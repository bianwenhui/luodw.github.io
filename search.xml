<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[kafka源码分析之概述]]></title>
      <url>http://luodw.cc/2017/04/24/kafka01/</url>
      <content type="html"><![CDATA[<p>最近帮实验室写了一个Spark+kafka实时处理日志的监控系统案例，大概流程为：</p>
<ol>
<li>用户购物日志发送给Kafka；</li>
<li>Spark实时从Kafka接收购物日志，利用Spark Streaming实时处理，最后将结果发送给Kafka；</li>
<li>用Flask构建一个web程序接收Kafka处理后的数据，用Flask-SocketIO实时将每秒的数据发送给客户端浏览器；</li>
<li>浏览器利用socket.io.js实时接收web发送来的数据，利用highcharts.js展示出来。
这个案例很好的展示了利用Spark+Kafka实时处理数据的开发模式。Spark在实时处理和批量处理都有很高的性能，Kafka消息队列在异步解耦，冗余处理和削峰等方面有很高的性能。</li>
</ol>
<p>Kafka在互联网各大公司都有很广泛的应用，主要在于Kakfa性能出众，又有很好的扩展性和稳定性。而之前看过NSQ消息队列，对消息队列的分布式架构都有一定的了解，所以想最近这段时间看看kafka源码，熟悉下Kafka的整体架构，以及学习Scala和Java是如何写基础组件的。</p>
<p>这篇文章先介绍下Kafka的整体架构，在通过一个简单的实例展示Python是如何操作Kafka消息队列，如下：</p>
<ol>
<li>Kafka整体架构；</li>
<li>Python操作Kafka；</li>
<li>总结；</li>
</ol>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2017/04/24/kafka01/#more">http://luodw.cc/2017/04/24/kafka01/#more</a></p>
<h1>Kafka整体架构</h1>
<hr>
<p>Kafka相对于NSQ架构更加的复杂，但也提供更丰富的功能，下面根据我的理解列出二者的不同点:</p>
<ol>
<li>NSQ消费者采用的是push模式，而Kafka消费者采用的是pull模式；</li>
<li>NSQ消息被消费之后，即被删除，而Kafka消费数据之后，并不删除数据，所以Kafka也可以看成是一个存储系统；</li>
<li>NSQ没提供消息副本功能，而Kafka提供分区多副本，当leader宕机之后，可以重新选组提供服务，具有高可用性；</li>
<li>NSQ各个nsqd之间不进行通信，而Kafka Server之间进行通信，毕竟要进行副本传输；</li>
<li>Kafka消费提供组的概念，不同组的消费者可以消费同一个topic下所有的数据；而对于同组消费者，各个消费者按某种算法一起消费同一个topic下不同分区的消息。虽然NSQ并没有挺供消费者组的概念，但是NSQ的channel则提供了相同的功能；不同的channel相当于不同消费者组，都能收到topic的所有消息，然后同一个channel所对应的所有消费者相当于Kafka同一个消费者组内的消费者。二者在这方面实现的功能是一样的。</li>
</ol>
<p>因此，我把NSQ看成是轻量级的消息队列，如果不需要消息副本，不需要提供消息冗余，只是简单消息的投递和消费我觉得可以使用NSQ，毕竟轻量，部署简单，也更容易深入理解源码。当然，如果需要很好的消息可靠性或者其他Kakfa其他特性，还是推荐Kafka。</p>
<p>下面先介绍下Kafka当中的专业术语:</p>
<ol>
<li>broker　一个Kafka集群有多个服务器，其中一台即称为一个broker；</li>
<li>Topic 我们可以把topic看成是消息的种类，我们发送的每条消息都属于某个topic；</li>
<li>Partition Partition是物理的概念，一个topic下面可以有多个Partition，这些Partition拥有等同的地位，主要是为了实现负载均衡；</li>
<li>Producer　复杂发布消息到Kafka Broker；</li>
<li>Consumer　向Kafka读取消息的客户端；</li>
<li>Consumer Group　消费者组，每个consumer都属于一个ConsumerGroup，我们可以指定组的名字，如果不指定，则属于默认的消费者组；</li>
</ol>
<p>下面同过一个简单的图示说明Kafka的拓扑结构以及与Producer和Consumer的关系
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-kafka.JPG" alt="Kafka简单的架构"></p>
<p>这里展示的是只是一个zookeeper（当然可以有多个）以及一个消费者组中的一个消费者（当然可以有多个消费者组和多个消费者），主要是为了简化分析。每个Kafka Server在启动时，都需要向zookeeper注册broker信息，路径为/brokers，可以通过zookeeper的ls /命令查看。等三个Kafka Server都启动之后，Producer与Consumer就可以连接投递和消费消息。这里假设有一个Topic，三个分区，每个分区只有一个副本，刚好对应图中的三个broker。对于多副本，等后续分析Kafka Server时再分析。</p>
<ol>
<li>Producer向某个topic发送消息时，需要先连接上与这个topic相关的一台或者多台broker，因为broker之间会相互通信，最后通过一台broker，就可以找到所有与该topic相关的broker。当Producer在发布消息时，根据消息提供的key进行分区（最简单的方式就是哈稀求余），因此一条消息并将属于一个分区；如果分区函数设计得当，所有消息将会被均衡的发送到所有分区，实现负载均衡。在早期版本的Producer，有同步和异步的方式，而在最新的版本中只提供异步的方式，即将所有消息先存入一个队列，然后开启一个后台线不断从队列读取消息并发送给Kafka Sever。</li>
<li>Consumer消费消息时，需要先连接zookeeper获取与topic相关的broker，然后再连接；等Consumer连上Kafka Server之后，然后发送FetchRequest请求，带上topic,partition和offset从相应的分区读取消息；</li>
</ol>
<p>下面通过官网提供的图，简单说明下消费者组模式
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-consumer-groups.png" alt="Kafka消费者组"></p>
<p>如图，假设有一个topic，四个partition；两个Kafka Server，每个Kafka Server分别有两个分区；有两个消费者组A和B。由图可知，ConsumerGroup A和ConsumerGroup B都可以消费同一个topic下的所有消息，而同一个消费者组内的消费者则消费topic下的不同分区；例如，ConsumerGroup A的C1消费分区0和3，而C2消费分区1和2。ConsumerGroup B下的四个Consumer则分别消费一个分区。</p>
<blockquote>
<p>消费者组主要是为了实现同一个topic下的消息的消息实现不同的处理，例如同一个topic下的消息，即可用于hadoop进行批处理，也可以用于Spark流计算，还可以直接进行持久化到磁盘等等。</p>
</blockquote>
<blockquote>
<p>消费者组内的多个消费者主要就是为了实现负载均衡。</p>
</blockquote>
<h1>Ｐython操作Kafka</h1>
<hr>
<p>这里用Python操作Kafka作为演示，只需要几行代码就可以实现生产者和消费者。生产者代码如下:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaProducer</div><div class="line"></div><div class="line">producer = KafkaProducer(bootstrap_servers=<span class="string">'localhost:9092'</span>)</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    producer.send(<span class="string">'test'</span>, <span class="string">"Hello World!"</span>.encode(<span class="string">'utf8'</span>))</div><div class="line">    time.sleep(<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>然后消费者代码如下:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</div><div class="line"></div><div class="line">consumer = KafkaConsumer(<span class="string">'test'</span>)</div><div class="line"><span class="keyword">for</span> msg <span class="keyword">in</span> consumer:</div><div class="line">    print((msg.value).decode(<span class="string">'utf8'</span>))</div></pre></td></tr></table></figure></p>
<p>我的测试环境只有一台Zookeeper和一台Kafka，生产者每隔3秒向test这个topic发送消息，消息内容为&quot;Hello World!&quot;。而消费者不断消费test的消息，PyCharm在consumer控制台下可以看到如下输出
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/home/charles/Envs/env1/bin/python /home/charles/PycharmProjects/kafka/consumer.py</div><div class="line">Hello World!</div><div class="line">Hello World!</div><div class="line">Hello World!</div><div class="line">Hello World!</div><div class="line">Hello World!</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>当然Kafka的Producer和Consumer都有很多配置，例如ack，是否自动commmitOffset等等，这也是我后续想看源码的原因，因为看了源码，可以更好的理解这些参数是什么意思，怎么做优化。</p>
<h1>总结</h1>
<hr>
<p>这篇文章简单的介绍了下Kafka，也算对Kafka有个较为深入的认识，也为后续深入看源码打下基础。Kafka代码量好多，需要耐心慢慢啃，我有大概看了下Kafka的代码，有很多优秀的设计可以学习，包括NIO，Selector，Java并发包等等。先到这吧。</p>
]]></content>
      
        <categories>
            
            <category> kafka </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nsqd执行解析]]></title>
      <url>http://luodw.cc/2017/04/14/nsqd/</url>
      <content type="html"><![CDATA[<p>这几天因为实验室原因，接触了kafka，又因为这个kafka，我就记起来早在去年看NSQ消息队列，而且之前也忘了写篇关于nsqd的原理介绍，因此这两天看了下nsqd代码，也就有了这篇文章。nsqd用golang语言编写，整体的框架以及代码都写得很棒，很好发挥了golang中goroutine和channel的结合使用，看nsq代码可以学习如何更优雅的使用golang，就如看redis可以学习原来c语言还可以写的那么优雅。</p>
<p>nsqd是NSQ中最重要的组件，接收生产者的消息以及给消费者发送消息都由nsqd完成。因此，这篇文章主要由下面三个部分：</p>
<ol>
<li>NSQ再介绍</li>
<li>生产者如何投递消息；</li>
<li>消费者如何接收消息；</li>
<li>总结；</li>
</ol>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2017/04/14/nsqd/#more">http://luodw.cc/2017/04/14/nsqd/#more</a></p>
<h1>NSQ再介绍</h1>
<hr>
<p>因为上篇关于NSQ的文章距离现在挺久远的，因此这里再次介绍下NSQ。先给出NSQ的拓扑图：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-3139862022.jpg" alt="NSQ拓扑"></p>
<p>在拓扑图中，NSQ主要由三个组件组成:</p>
<ol>
<li>nsqlookupd　该组件提供服务发现，消费者需要先连接nsqlookupd服务获取nsqd的地址，然后再连接nsqd。</li>
<li>nsqd　该组件是NSQ提供消息处理和转发的最核心组件。</li>
<li>nsqadmin　该组件是一个web服务器，提供查看NSQ整体信息的web ui界面。</li>
</ol>
<p>由拓扑图也可以看出，nsqd通过心态机制与nsqlookupd上报状态以及topic和channel信息。当向某个topic发布一个消息时，producer会同时连上所有的nsqd，然后随机选择一个nsqd发送消息；而consumer通过nsqlookupd获取到所有nsqd地址后，再向所有nsqd发起连接；当producer随机向某个nsqd发送消息时，该nsqd则将消息返回给consumer。</p>
<p>接下来看下单台nsqd是如何处理消息的，这里引用官网的一个动图：
<img src="https://f.cloud.github.com/assets/187441/1700696/f1434dc8-6029-11e3-8a66-18ca4ea10aca.gif" alt="nsqd消息处理"></p>
<p>当producer向nsqd某个topic发送一条消息时，该消息会被复制发送到该topic下的所有channel。当某个channel对应着多个client时，这时channel随机选择一个client，并由该client处理该消息。</p>
<p>由上述可以看出，为了提高性能，NSQ多两次使用负载均衡，例如producer发送消息时，随机选择一个nsqd服务接收消息以及channel在多个client中随机选择一个处理消息。</p>
<h1>生产者如何投递消息</h1>
<hr>
<p>通过对NSQ有了整体认识之后，接下来详细介绍下生产者如何把消息投递给client。nsqd的启动和nsqlookupd类似，也是通过开源框架</p>
<blockquote>
<p>&quot;github.com/judwhite/go-svc/svc&quot;</p>
</blockquote>
<p>优雅启动和退出，在nsqd的Main函数中开启了监听处理tcp和http两个服务的goroutine，与nsqlookupd不同的是，nsqd在Main函数中除了上述两个goroutine，还开启了其余三个goroutine</p>
<ol>
<li>lookupLoop　保持与nsqlookupd心跳连接，上报信息；</li>
<li>queueScanLoop　扫描和处理InFlightQueue和DeferredQueue；</li>
<li>statsdLoop　需要配置状态服务地址之后才开启；</li>
</ol>
<p>nsqd在开启之后，对于监听tcp的服务，每当有一个连接，tcp服务则开启一个goroutine处理该客户端，代码如下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TCPServer</span><span class="params">(listener net.Listener, handler TCPHandler, l app.Logger)</span></span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		clientConn, err := listener.Accept()</div><div class="line">	    <span class="comment">/* ....省略....*/</span></div><div class="line">		<span class="keyword">go</span> handler.Handle(clientConn)</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>而在Main函数中传递给这个函数的参数handler，为实现了Handle接口的结构体tcpServer，而在tcpServer.Handle函数中，最终调用protocol.IOLoop(clientConn)函数进行具体的处理，接下来看下这个函数
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">IOLoop</span><span class="params">(conn net.Conn)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">if</span> client.HeartbeatInterval &gt; <span class="number">0</span> &#123;</div><div class="line">			client.SetReadDeadline(time.Now().Add(client.HeartbeatInterval * <span class="number">2</span>))</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			client.SetReadDeadline(zeroTime)</div><div class="line">		&#125;</div><div class="line">        <span class="comment">/* .....省略......*/</span></div><div class="line">		line, err = client.Reader.ReadSlice(<span class="string">'\n'</span>)</div><div class="line">		<span class="comment">// trim the '\n'</span></div><div class="line">		line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</div><div class="line">		<span class="comment">// optionally trim the '\r'</span></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; line[<span class="built_in">len</span>(line)<span class="number">-1</span>] == <span class="string">'\r'</span> &#123;</div><div class="line">			line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</div><div class="line">		&#125;</div><div class="line">        <span class="comment">/* 解析出producer投递消息参数*/</span></div><div class="line">		params := bytes.Split(line, separatorBytes)</div><div class="line">        <span class="comment">/* .....省略......*/</span></div><div class="line">		<span class="keyword">var</span> response []<span class="keyword">byte</span></div><div class="line">        <span class="comment">/* 在p.Exec函数中根据命令执行具体函数*/</span></div><div class="line">		response, err = p.Exec(client, params)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> response != <span class="literal">nil</span> &#123;</div><div class="line">            <span class="comment">/* 将命令执行成功与否返回给用户 */</span></div><div class="line">			err = p.Send(client, frameTypeResponse, response)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				err = fmt.Errorf(<span class="string">"failed to send response - %s"</span>, err)</div><div class="line">				<span class="keyword">break</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">/* 客户端出问题或者退出，则上面循环也将退出 */</span></div><div class="line">	p.ctx.nsqd.logf(<span class="string">"PROTOCOL(V2): [%s] exiting ioloop"</span>, client)</div><div class="line">	conn.Close()</div><div class="line">	<span class="built_in">close</span>(client.ExitChan)</div><div class="line">	<span class="keyword">if</span> client.Channel != <span class="literal">nil</span> &#123;</div><div class="line">		client.Channel.RemoveClient(client.ID)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述IOLoop循环就是producer连接上nsqd之后，不断处理消息的代码段。对于producer，一个最简单的命令pub发送消息，先来看下p.Exec函数
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">Exec</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"IDENTIFY"</span>)) &#123;</div><div class="line">		<span class="keyword">return</span> p.IDENTIFY(client, params)</div><div class="line">	&#125;</div><div class="line">	err := enforceTLSPolicy(client, p, params[<span class="number">0</span>])</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">switch</span> &#123;</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"FIN"</span>)):</div><div class="line">		<span class="keyword">return</span> p.FIN(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"RDY"</span>)):</div><div class="line">		<span class="keyword">return</span> p.RDY(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"REQ"</span>)):</div><div class="line">		<span class="keyword">return</span> p.REQ(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"PUB"</span>)):</div><div class="line">		<span class="keyword">return</span> p.PUB(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"MPUB"</span>)):</div><div class="line">		<span class="keyword">return</span> p.MPUB(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"DPUB"</span>)):</div><div class="line">		<span class="keyword">return</span> p.DPUB(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"NOP"</span>)):</div><div class="line">		<span class="keyword">return</span> p.NOP(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"TOUCH"</span>)):</div><div class="line">		<span class="keyword">return</span> p.TOUCH(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"SUB"</span>)):</div><div class="line">		<span class="keyword">return</span> p.SUB(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"CLS"</span>)):</div><div class="line">		<span class="keyword">return</span> p.CLS(client, params)</div><div class="line">	<span class="keyword">case</span> bytes.Equal(params[<span class="number">0</span>], []<span class="keyword">byte</span>(<span class="string">"AUTH"</span>)):</div><div class="line">		<span class="keyword">return</span> p.AUTH(client, params)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, fmt.Sprintf(<span class="string">"invalid command %s"</span>, params[<span class="number">0</span>]))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由这个Exec函数可知，nsqd的tcp协议只支持上述12个命令，而大家最熟悉的莫过于PUB和SUB，即发布和订阅。对于producer，我么重点看下PUB这个命令：
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">PUB</span><span class="params">(client *clientV2, params [][]<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">    <span class="comment">/* 读取topic名称，即第二个参数　*/</span></div><div class="line">	topicName := <span class="keyword">string</span>(params[<span class="number">1</span>])</div><div class="line">	<span class="keyword">if</span> !protocol.IsValidTopicName(topicName) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_BAD_TOPIC"</span>,</div><div class="line">			fmt.Sprintf(<span class="string">"PUB topic name %q is not valid"</span>, topicName))</div><div class="line">	&#125;</div><div class="line">    <span class="comment">/* 读取消息体的长度*/</span></div><div class="line">	bodyLen, err := readLen(client.Reader, client.lenSlice)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(err, <span class="string">"E_BAD_MESSAGE"</span>, <span class="string">"PUB failed to read message body size"</span>)</div><div class="line">	&#125;</div><div class="line">    <span class="comment">/* 读取消息体 */</span></div><div class="line">	messageBody := <span class="built_in">make</span>([]<span class="keyword">byte</span>, bodyLen)</div><div class="line">	_, err = io.ReadFull(client.Reader, messageBody)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(err, <span class="string">"E_BAD_MESSAGE"</span>, <span class="string">"PUB failed to read message body"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> err := p.CheckAuth(client, <span class="string">"PUB"</span>, topicName, <span class="string">""</span>); err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">	&#125;</div><div class="line">    <span class="comment">/* 获取topic实例 */</span></div><div class="line">	topic := p.ctx.nsqd.GetTopic(topicName)</div><div class="line">	<span class="comment">/* 将消息体封装成message实例 */</span></div><div class="line">    msg := NewMessage(topic.GenerateID(), messageBody)</div><div class="line">	<span class="comment">/* 向目标topic投递消息 */</span></div><div class="line">    err = topic.PutMessage(msg)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(err, <span class="string">"E_PUB_FAILED"</span>, <span class="string">"PUB failed "</span>+err.Error())</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> okBytes, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于这个函数，由两点需要说明，</p>
<ol>
<li>
<p>首先关于NSQ的tcp协议，可以参考<a href="http://nsq.io/clients/tcp_protocol_spec.html" target="_blank" rel="external">NSQ官网</a>，这里给出PUB命令的协议如下:
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PUB <span class="xml"><span class="tag">&lt;<span class="name">topic_name</span>&gt;</span></span>\n (注:这个\n，其实是空格，这里表示这两行换行)</div><div class="line">[<span class="string"> 4-byte size in bytes </span>][<span class="symbol"> N-byte binary data </span>]</div><div class="line"></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">topic_name</span>&gt;</span></span> - a valid string (optionally having #ephemeral suffix)</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>对于上述GetTopic函数，如果topic实例已经存在，则直接获取，否则新建一个，这也就说明了NSQ的topic是在投递第一条消息时创建的，这个GetTopic函数后面再分析。</p>
</li>
</ol>
<p>ok，接下来继续分析向目标topic投递消息是如何完成的，即函数topic.PutMessage(msg)
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">PutMessage</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">/* ....省略.... */</span></div><div class="line">    err := t.put(m)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* ------------------------------------------- */</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> t.memoryMsgChan &lt;- m:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		b := bufferPoolGet()</div><div class="line">		err := writeMessageToBackend(b, m, t.backend)</div><div class="line">		bufferPoolPut(b)</div><div class="line">		t.ctx.nsqd.SetHealth(err)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			t.ctx.nsqd.logf(</div><div class="line">				<span class="string">"TOPIC(%s) ERROR: failed to write message to backend - %s"</span>,</div><div class="line">				t.name, err)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有Topic.put函数可以看出，nsqd优先把消息投递给内存channel（t.memoryMsgChan），当内存channel满了之后，则把消息append到磁盘文件中。而且这个t.memoryMsgChan可以通过参数mem-queue-size设置，默认为10000。而且从这个函数也可以看出，当把消息成功写入topic.memoryMsgChan或者追加到磁盘，消息投递成功。之后消息的处理，都交给了nsqd内部goroutine和channel之间的通信。那大家可能会好奇，消息写入topic.memoryMsgChan之后，在哪读取topic.memoryMsgChan处理消息了？下面要先来看下上述说的GetTopic函数:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NSQD)</span> <span class="title">GetTopic</span><span class="params">(topicName <span class="keyword">string</span>)</span> *<span class="title">Topic</span></span> &#123;</div><div class="line">	<span class="comment">// most likely, we already have this topic, so try read lock first.</span></div><div class="line">	n.RLock()</div><div class="line">	t, ok := n.topicMap[topicName]</div><div class="line">	n.RUnlock()</div><div class="line">	<span class="keyword">if</span> ok &#123;</div><div class="line">		<span class="keyword">return</span> t</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	n.Lock()</div><div class="line"></div><div class="line">	t, ok = n.topicMap[topicName]</div><div class="line">	<span class="keyword">if</span> ok &#123;</div><div class="line">		n.Unlock()</div><div class="line">		<span class="keyword">return</span> t</div><div class="line">	&#125;</div><div class="line">	deleteCallback := <span class="function"><span class="keyword">func</span><span class="params">(t *Topic)</span></span> &#123;</div><div class="line">		n.DeleteExistingTopic(t.name)</div><div class="line">	&#125;</div><div class="line">	t = NewTopic(topicName, &amp;context&#123;n&#125;, deleteCallback)</div><div class="line">	n.topicMap[topicName] = t</div><div class="line"></div><div class="line">	n.logf(<span class="string">"TOPIC(%s): created"</span>, t.name)</div><div class="line"></div><div class="line">	<span class="comment">// release our global nsqd lock, and switch to a more granular topic lock while we init our</span></div><div class="line">	<span class="comment">// channels from lookupd. This blocks concurrent PutMessages to this topic.</span></div><div class="line">	t.Lock()</div><div class="line">	n.Unlock()</div><div class="line">    <span class="comment">/* 下面省略从nsqlookupd获取topic信息代码，因为这个nsqd实例可能是新加的机器，所以需要执行nsqlookupd查询 */</span></div><div class="line">	<span class="keyword">return</span> t</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由代码可以验证，ＧetTopic函数是优先从已存在的topic中获取，如果请求的topic不存在，则新建一个topic。重点在哪个NewTopic函数，这个函数先代码如下：
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTopic</span><span class="params">(topicName <span class="keyword">string</span>, ctx *context, deleteCallback <span class="keyword">func</span>(*Topic)</span>) *<span class="title">Topic</span></span> &#123;</div><div class="line">	t := &amp;Topic&#123;</div><div class="line">		name:              topicName,</div><div class="line">		channelMap:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Channel),</div><div class="line">		memoryMsgChan:     <span class="built_in">make</span>(<span class="keyword">chan</span> *Message, ctx.nsqd.getOpts().MemQueueSize),</div><div class="line">		exitChan:          <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</div><div class="line">		channelUpdateChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</div><div class="line">		ctx:               ctx,</div><div class="line">		pauseChan:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</div><div class="line">		deleteCallback:    deleteCallback,</div><div class="line">		idFactory:         NewGUIDFactory(ctx.nsqd.getOpts().ID),</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> strings.HasSuffix(topicName, <span class="string">"#ephemeral"</span>) &#123;</div><div class="line">		t.ephemeral = <span class="literal">true</span></div><div class="line">		t.backend = newDummyBackendQueue()</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		t.backend = diskqueue.New(topicName,</div><div class="line">			ctx.nsqd.getOpts().DataPath,</div><div class="line">			ctx.nsqd.getOpts().MaxBytesPerFile,</div><div class="line">			<span class="keyword">int32</span>(minValidMsgLength),</div><div class="line">			<span class="keyword">int32</span>(ctx.nsqd.getOpts().MaxMsgSize)+minValidMsgLength,</div><div class="line">			ctx.nsqd.getOpts().SyncEvery,</div><div class="line">			ctx.nsqd.getOpts().SyncTimeout,</div><div class="line">			ctx.nsqd.getOpts().Logger)</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//最重要goroutine</span></div><div class="line">	t.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; t.messagePump() &#125;)</div><div class="line">	t.ctx.nsqd.Notify(t)</div><div class="line">	<span class="keyword">return</span> t</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个NewTopic函数先是实例化一个Topic实例，最后生成了一个goroutine来处理这个topic的消息，这个t.messagePump协程中执行了消息分发，代码如下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topic)</span> <span class="title">messagePump</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> msg *Message</div><div class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span></div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">var</span> chans []*Channel</div><div class="line">	<span class="keyword">var</span> memoryMsgChan <span class="keyword">chan</span> *Message</div><div class="line">	<span class="keyword">var</span> backendChan <span class="keyword">chan</span> []<span class="keyword">byte</span></div><div class="line"></div><div class="line">	t.RLock()</div><div class="line">    <span class="comment">//获取这个topic下的所有channel</span></div><div class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> t.channelMap &#123;</div><div class="line">		chans = <span class="built_in">append</span>(chans, c)</div><div class="line">	&#125;</div><div class="line">	t.RUnlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(chans) &gt; <span class="number">0</span> &#123;</div><div class="line">		memoryMsgChan = t.memoryMsgChan</div><div class="line">		backendChan = t.backend.ReadChan()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">        <span class="comment">/* 获取消息 */</span></div><div class="line">		<span class="keyword">case</span> msg = &lt;-memoryMsgChan:</div><div class="line">		<span class="keyword">case</span> buf = &lt;-backendChan:</div><div class="line">			msg, err = decodeMessage(buf)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				t.ctx.nsqd.logf(<span class="string">"ERROR: failed to decode message - %s"</span>, err)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">            <span class="comment">/* 省略一些特殊情况处理 */</span></div><div class="line">		<span class="keyword">for</span> i, channel := <span class="keyword">range</span> chans &#123;</div><div class="line">			chanMsg := msg</div><div class="line">			<span class="comment">/*</span></div><div class="line">            * 复制每个消息，并且分发给每个channel</div><div class="line">            */</div><div class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</div><div class="line">				chanMsg = NewMessage(msg.ID, msg.Body)</div><div class="line">				chanMsg.Timestamp = msg.Timestamp</div><div class="line">				chanMsg.deferred = msg.deferred</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> chanMsg.deferred != <span class="number">0</span> &#123;</div><div class="line">				channel.PutMessageDeferred(chanMsg, chanMsg.deferred)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			err := channel.PutMessage(chanMsg)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				t.ctx.nsqd.logf(</div><div class="line">					<span class="string">"TOPIC(%s) ERROR: failed to put msg(%s) to channel(%s) - %s"</span>,</div><div class="line">					t.name, msg.ID, channel.name, err)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">exit:</div><div class="line">	t.ctx.nsqd.logf(<span class="string">"TOPIC(%s): closing ... messagePump"</span>, t.name)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当创建出一个Topic之后，这个Topic的messagePump协程也随之创建，并且处于一个循环中，等待消息的到达。消息来源有两种，第一种就是之前在Topic.put函数中往t.memoryMsgChan写入的消息。还有一种是读取磁盘中消息。ok，当在messagePump函数中读取到消息之后，接着把消息分发到附属这个Topic的所有channel。</p>
<p>到这里，我们可以做个小结，</p>
<blockquote>
<p>当producer连上nsqd之后，向nsqd发送PUB命令投递消息；接着nsqd根据命令topic的名称在已经存在的topics中查找，如果查找到，则返回已存在的topic，如果不存在，则新建一个topic；然后把消息封装成Message写入Topic.memoryMsgChan；最后由Ｔopic.messagePump将消息分发给附属的channel。</p>
</blockquote>
<p>之前为消息如何投递到Ｔopic，后面将要介绍channel是如何把消息投递给client。</p>
<h1>消费者如何接收消息</h1>
<hr>
<p>这小节主要讲讲channel如何将消息发送给client，紧接着上述messagePump函数，将topic消息发送给channel的函数channel.PutMessage(chanMsg)，代码如下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">PutMessage</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</div><div class="line">	c.RLock()</div><div class="line">	<span class="keyword">defer</span> c.RUnlock()</div><div class="line">	<span class="keyword">if</span> c.Exiting() &#123;</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"exiting"</span>)</div><div class="line">	&#125;</div><div class="line">	err := c.put(m)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	atomic.AddUint64(&amp;c.messageCount, <span class="number">1</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* ------------------------------------------------------------------- */</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Channel)</span> <span class="title">put</span><span class="params">(m *Message)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">select</span> &#123;</div><div class="line">	<span class="keyword">case</span> c.memoryMsgChan &lt;- m:</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		b := bufferPoolGet()</div><div class="line">		err := writeMessageToBackend(b, m, c.backend)</div><div class="line">		bufferPoolPut(b)</div><div class="line">		c.ctx.nsqd.SetHealth(err)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			c.ctx.nsqd.logf(<span class="string">"CHANNEL(%s) ERROR: failed to write message to backend - %s"</span>,</div><div class="line">				c.name, err)</div><div class="line">			<span class="keyword">return</span> err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>channel的这两个函数和topic的一样，都是把消息优先发送给内存channel，当channel满了之后，把后续的消息append到磁盘文件。那么nsqd中在哪接收c.memoryMsgChan了？原先我以为和Topic一样，channel也会存在一个messagePump协程，用于接收c.memoryMsgChan的消息，而且早期的版本也是这么做的。但是不知道哪个版本之后，channel.messagePump取消了。所以最终是在哪接收c.memoryMsgChan的消息了？那要从consumer连上nsqd后说起。</p>
<p>consumer和producer连接nsqd的代码逻辑是一样的，最终consumer也是处于protocolV2.IOLoop函数中，
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">IOLoop</span><span class="params">(conn net.Conn)</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> err error</div><div class="line">	<span class="keyword">var</span> line []<span class="keyword">byte</span></div><div class="line">	<span class="keyword">var</span> zeroTime time.Time</div><div class="line"></div><div class="line">	clientID := atomic.AddInt64(&amp;p.ctx.nsqd.clientIDSequence, <span class="number">1</span>)</div><div class="line">	client := newClientV2(clientID, conn, p.ctx)</div><div class="line"></div><div class="line">	messagePumpStartedChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</div><div class="line">    <span class="comment">/* MessagePump协程是主要任务就是channel把消息投递给client */</span></div><div class="line">	<span class="keyword">go</span> p.messagePump(client, messagePumpStartedChan)</div><div class="line">	&lt;-messagePumpStartedChan</div><div class="line"></div><div class="line">    <span class="comment">/* 下面是consumer和nsqd交互的代码部分 */</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">if</span> client.HeartbeatInterval &gt; <span class="number">0</span> &#123;</div><div class="line">			client.SetReadDeadline(time.Now().Add(client.HeartbeatInterval * <span class="number">2</span>))</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			client.SetReadDeadline(zeroTime)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		line, err = client.Reader.ReadSlice(<span class="string">'\n'</span>)</div><div class="line"></div><div class="line">		<span class="comment">// trim the '\n'</span></div><div class="line">		line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</div><div class="line">		<span class="comment">// optionally trim the '\r'</span></div><div class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; line[<span class="built_in">len</span>(line)<span class="number">-1</span>] == <span class="string">'\r'</span> &#123;</div><div class="line">			line = line[:<span class="built_in">len</span>(line)<span class="number">-1</span>]</div><div class="line">		&#125;</div><div class="line">		params := bytes.Split(line, separatorBytes)</div><div class="line">		<span class="keyword">var</span> response []<span class="keyword">byte</span></div><div class="line">		response, err = p.Exec(client, params)</div><div class="line">		<span class="keyword">if</span> response != <span class="literal">nil</span> &#123;</div><div class="line">			err = p.Send(client, frameTypeResponse, response)</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	p.ctx.nsqd.logf(<span class="string">"PROTOCOL(V2): [%s] exiting ioloop"</span>, client)</div><div class="line">	conn.Close()</div><div class="line">	<span class="built_in">close</span>(client.ExitChan)</div><div class="line">	<span class="keyword">if</span> client.Channel != <span class="literal">nil</span> &#123;</div><div class="line">		client.Channel.RemoveClient(client.ID)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实之前producer也是有开启go p.messagePump(client, messagePumpStartedChan)协程，但是使用的不多，主要是consumer使用，因此在producer中就把代码删了。下面来看下这个协程:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *protocolV2)</span> <span class="title">messagePump</span><span class="params">(client *clientV2, startedChan <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">        memoryMsgChan = subChannel.memoryMsgChan</div><div class="line">        backendMsgChan = subChannel.backend.ReadChan()</div><div class="line">        flusherChan = outputBufferTicker.C</div><div class="line"></div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="comment">/* ....省略.... */</span></div><div class="line">		<span class="keyword">case</span> b := &lt;-backendMsgChan:</div><div class="line">			<span class="keyword">if</span> sampleRate &gt; <span class="number">0</span> &amp;&amp; rand.Int31n(<span class="number">100</span>) &gt; sampleRate &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			msg, err := decodeMessage(b)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				p.ctx.nsqd.logf(<span class="string">"ERROR: failed to decode message - %s"</span>, err)</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			msg.Attempts++</div><div class="line"></div><div class="line">            <span class="comment">/* 每次给client发送消息时，先把消息放到InFlightQueue */</span></div><div class="line">			subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</div><div class="line">            <span class="comment">/* 增加给该client发送消息的数量 */</span></div><div class="line">			client.SendingMessage()</div><div class="line">            <span class="comment">/* 真正发送消息的函数 */</span></div><div class="line">			err = p.SendMessage(client, msg, &amp;buf)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">goto</span> exit</div><div class="line">			&#125;</div><div class="line">			flushed = <span class="literal">false</span></div><div class="line">		<span class="keyword">case</span> msg := &lt;-memoryMsgChan:</div><div class="line">			<span class="keyword">if</span> sampleRate &gt; <span class="number">0</span> &amp;&amp; rand.Int31n(<span class="number">100</span>) &gt; sampleRate &#123;</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			msg.Attempts++</div><div class="line"></div><div class="line">			subChannel.StartInFlightTimeout(msg, client.ID, msgTimeout)</div><div class="line">			client.SendingMessage()</div><div class="line">			err = p.SendMessage(client, msg, &amp;buf)</div><div class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">				<span class="keyword">goto</span> exit</div><div class="line">			&#125;</div><div class="line">			flushed = <span class="literal">false</span></div><div class="line">		<span class="keyword">case</span> &lt;-client.ExitChan:</div><div class="line">			<span class="keyword">goto</span> exit</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>从代码可以看出，优先从磁盘获取消息发送给客户端，磁盘没消息，才发送内存channel中的消息。我的理解是这样的</p>
<blockquote>
<p>如果优先发送内存channel的消息，那么假设在某个时段，产生了大量消息，那么channel中在这个时段都是满的，则磁盘的消息被发送的时机会被延迟到这个时段结束，而如果这个时段很长，消息就会被延迟很久才能发送。而如果是优先发送磁盘，那么在channel满了之后，后续达到的消息都能被优先发送给客户端。当然可能导致channel内部的消息被延迟发送，所以这也是一种折中。</p>
</blockquote>
<p>为了保证消息的准确被处理，NSQ做了很多努力</p>
<ol>
<li>对于每给client发送一个消息，都会先把消息放到InFlightQueue，表示正处于发送的消息而且还没有收到确认。当consumer收到消息时，将回复给nsqd一个FIN命令＋message_id，表示该消息已经被处理，这时nsqd会将该message_id从InFlightQueue中删除。</li>
<li>如果客户端处理消息错误，则返回给nsqd一个REQ命令+message_id+timeout，这时nsqd则把消息放入DeferredQueue队列，等待超时再一次的发送。</li>
<li>如果客户端突然断线，则nsqd将不会收到client的回复，消息还是停留在InFlightQueue中。</li>
</ol>
<p>还记得之前有提到过，nsqd在Main函数中还单独开启一个goroutine，用于不断处理InFlightQueue和DeferredQueue中的消息，因此在上述两个队列的消息都是有机会发送给client，也就保证消息的正确投递。</p>
<p>这里还需要解释的就是如果一个channel对应多个client，那么channel会随机选择一个client投递消息。这个在代码中不容易看出来，而是利用了go channel的一个很重要的特性</p>
<blockquote>
<p>当往某个channel写入一个消息时，如果有多个goroutine在监听channel的读端，那么只有一个goroutine能接收到该消息。</p>
</blockquote>
<p>因此如果有多个client订阅同一个channel，那么这些client监听的是同一个channel.memoryMsgChan，当往某个channel写入消息时，则只有一个client能收到消息。</p>
<p>至于给client发送消息的具体细节，这里就不再详细介绍，代码很简单。</p>
<h1>总结</h1>
<hr>
<p>这篇主要介绍了nsqd是如何接收producer的消息以及如何把消息投递给client。NSQ消息队列架构比较简单，分布式架构也很好理解，结合golang的goroutine和channel实现了处理消息的高效以及代码的优雅，还有http模块中间件的封装，源码很值得阅读。</p>
]]></content>
      
        <categories>
            
            <category> nsq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nsqd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lua原来这么好用]]></title>
      <url>http://luodw.cc/2017/03/24/lua/</url>
      <content type="html"><![CDATA[<p>今天这篇文章就随意谈谈lua。最近在看nginx+lua，刚好学了lua，就被这门语言的简练给吸引了。lua语言可以大大减轻一个人的心智负担，除了变量，操作符，语句以及函数这些最基础的语言功能外，剩下最重要的就是数据结构table（数组本质上也是table的特例）了。不用去记那么多的语法以及黑魔法，简直大快人心。</p>
<p>我现在对Lua使用感兴趣部分就是nginx+lua和redis内嵌lua；特别是前者，nginx+lua+redis构建高性能应用。lua+nginx可以使nginx不需要重新编译的情况下添加功能，特别是，如果只是修改lua文件，nginx都不需要重新加载配置文件，极大便利了nginx开发；而redis内嵌lua，让redis服务器有了计算能力，而且减小带宽传输（多个命令）以及原子执行多个命令达到cas效果。</p>
<p>下面就说说最近的一些内容和心得，主要以下三部分：</p>
<ol>
<li>通过lua脚本操作redis；</li>
<li>nginx+lua示例；</li>
<li>lua面向对象实现；</li>
<li>总结；</li>
</ol>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2017/03/24/lua/#more">http://luodw.cc/2017/03/24/lua/#more</a></p>
<h1>通过lua脚本操作redis</h1>
<hr>
<p>之前在学习redis以及看源码时，由于不懂lua，所以redis内嵌Lua模块就跳过去了，如今学了Lua，因此想把这块知识补上。redis对Lua的支持，主要有以下以下７个命令，</p>
<ol>
<li>EVAL</li>
<li>EVALSHA</li>
<li>SCRIPT DEBUG</li>
<li>SCRIPT EXISTS</li>
<li>SCRIPT FLUSH</li>
<li>SCRIPT KILL</li>
<li>SCRIPT LOAD
具体这些命令怎么使用，以及实现原理如何，可以看链接<a href="http://redisbook.readthedocs.io/en/latest/feature/scripting.html" target="_blank" rel="external">Lua脚本-Redis设计与实现</a>和<a href="https://redis.io/commands/eval" target="_blank" rel="external">redis官网</a>。这里主要介绍下EVAL命令。</li>
</ol>
<p>EVAL命令格式为</p>
<blockquote>
<p>EVAL script numkeys key [key ...] arg [arg ...]</p>
</blockquote>
<p>这里的</p>
<ol>
<li>script即为lua脚本或lua脚本文件;</li>
<li>key一般指lua脚本操作的键，在lua脚本文件中，通过KEYS[i]获取;</li>
<li>arg指外部传递给lua脚本的参数，可以通过ARGV[i]获取；</li>
</ol>
<p>下面通过两个简单的示例展示eval命令的用法。首先是脚本语句，来自redis官网，如下
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt;  <span class="built_in">eval</span> <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> <span class="number">2</span> key1 key2 <span class="built_in">first</span> <span class="built_in">second</span></div><div class="line"><span class="number">1</span>) <span class="string">"key1"</span></div><div class="line"><span class="number">2</span>) <span class="string">"key2"</span></div><div class="line"><span class="number">3</span>) <span class="string">"first"</span></div><div class="line"><span class="number">4</span>) <span class="string">"second"</span></div></pre></td></tr></table></figure></p>
<p>这个示例中lua脚本为一个return语句，返回了lua一个数组，这个数组四个元素分别是通过外部传入lua脚本。因为redis内嵌了Lua虚拟机，因此redis接收到这个lua脚本之后，然后交给lua虚拟机执行。当lua虚拟机执行结束，即将执行结果返回给redis，redis将结果按自己的协议转换为返回给客户端的回复，最后再通过TCP将回复发回给客户端。</p>
<p>通过这个例子也可以看出，在lua脚本中可以通过KEYS[i]来获取外部传入的键值，通过ARGV[i]来获取外部传入的参数。</p>
<p>下面给出一个复杂点的lua脚本，在给出脚本之前，先看下redis中有哪些需要的数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; zrange people 0 3</div><div class="line">1) &quot;jom&quot;</div><div class="line">2) &quot;lily&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">127.0.0.1:6379&gt; hgetall jom</div><div class="line">1) &quot;sex&quot;</div><div class="line">2) &quot;boy&quot;</div><div class="line">3) &quot;age&quot;</div><div class="line">4) &quot;12&quot;</div><div class="line">127.0.0.1:6379&gt; hgetall lily</div><div class="line">1) &quot;age&quot;</div><div class="line">2) &quot;15&quot;</div><div class="line">3) &quot;sex&quot;</div><div class="line">4) &quot;girl&quot;</div><div class="line">127.0.0.1:6379&gt; hgetall tom</div><div class="line">1) &quot;sex&quot;</div><div class="line">2) &quot;boy&quot;</div><div class="line">3) &quot;girl&quot;</div><div class="line">4) &quot;13&quot;</div></pre></td></tr></table></figure></p>
<p>下面lua脚本的作用就是通过一次网络请求获取'jom'，'lily'，'tom'三个人的个人信息
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--[[</span></div><div class="line">--Keys[1] is the key</div><div class="line">--argv[1] is the offset</div><div class="line">--argv[2] is the limit</div><div class="line">--]]</div><div class="line"></div><div class="line"><span class="comment">-- 获取外部传入的命令</span></div><div class="line"><span class="keyword">local</span> key,offset,limit = KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], ARGV[<span class="number">2</span>]</div><div class="line"><span class="comment">-- 通过ZRANGE获取键为key的有序集合元素，偏移量为offset，个数为limit，即所有人名字</span></div><div class="line"><span class="keyword">local</span> names = redis.call(<span class="string">'ZRANGE'</span>, key, offset, limit)</div><div class="line"><span class="comment">-- infos存储所有个人信息</span></div><div class="line"><span class="keyword">local</span> infos = &#123;&#125;</div><div class="line"><span class="comment">-- 遍历所有名字</span></div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#names <span class="keyword">do</span></div><div class="line">	<span class="keyword">local</span> ck = names[i]</div><div class="line">    <span class="comment">-- 通过HGETALL命令获取每个人的个人信息</span></div><div class="line">	<span class="keyword">local</span> info = redis.call(<span class="string">'HGETALL'</span>,ck)</div><div class="line">    <span class="comment">-- 并且在个人信息中插入姓名</span></div><div class="line">	table.insert(info,<span class="string">'name'</span>)</div><div class="line">	table.insert(info,names[i])</div><div class="line"></div><div class="line">    <span class="comment">-- 插入infos中</span></div><div class="line">	infos[i] = info</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="comment">-- 将结果返回给redis</span></div><div class="line"><span class="keyword">return</span> infos</div></pre></td></tr></table></figure></p>
<p>在命令行上执行eval命令，即可以得到结果，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ ../redis/src/redis-cli --eval redlua.lua people , 0 2</div><div class="line">1) 1) &quot;sex&quot;</div><div class="line">   2) &quot;boy&quot;</div><div class="line">   3) &quot;age&quot;</div><div class="line">   4) &quot;12&quot;</div><div class="line">   5) &quot;name&quot;</div><div class="line">   6) &quot;jom&quot;</div><div class="line">2) 1) &quot;age&quot;</div><div class="line">   2) &quot;15&quot;</div><div class="line">   3) &quot;sex&quot;</div><div class="line">   4) &quot;girl&quot;</div><div class="line">   5) &quot;name&quot;</div><div class="line">   6) &quot;lily&quot;</div><div class="line">3) 1) &quot;sex&quot;</div><div class="line">   2) &quot;boy&quot;</div><div class="line">   3) &quot;girl&quot;</div><div class="line">   4) &quot;13&quot;</div><div class="line">   5) &quot;name&quot;</div><div class="line">   6) &quot;tom&quot;</div></pre></td></tr></table></figure></p>
<p>试想，如果没有使用lua脚本，那么上述功能需要在应用程序中先发送ZRANGE命令，获取所有姓名；获取到所有姓名之后，在遍历所有姓名，针对每个姓名访问redis获取给人信息，至少四次网络IO。而管道在这种场景上也派不上用场。由此可知，lua脚本在这种场景下提高redis性能是有多大的帮助了。</p>
<blockquote>
<p>需要特别注意的是people（键）后面的逗号左右都要留空格，不然会报错！</p>
</blockquote>
<h1>ngx+lua示例</h1>
<hr>
<p>ngx+lua是我最近非常感兴趣的一门技术，因为在带来高性能的同时，并没有提高编程的复杂性。如果是用c语言开发nginx第三方模块，需要了解nginx内部的数据结构以及接口，难度和心智上都有挑战。本小节也是通过简单的ngx+lua示例来展示在lua是如何在nginx中使用的。</p>
<p>开发环境可以通过<a href="http://wiki.jikexueyuan.com/project/nginx-lua/development-environment.html" target="_blank" rel="external">极客学院教程</a>安装。即安装OpenResty框架。安装的目录在/usr/servers，测试目录在/usr/example。</p>
<p>第一个示例展示如何获在lua脚本中获取http请求所有信息，这个示例来自<a href="http://jinnianshilongnian.iteye.com/blog/2186448" target="_blank" rel="external">开涛的博客</a>，可以很好理解在lua中如何获取nginx请求信息。在example.conf中添加如下路径映射
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location ~/lua_test/(\d+)/(\d+)$ &#123;</div><div class="line">   set $a $1;</div><div class="line">   set $b $host;</div><div class="line">   default_type &apos;text/html&apos;;</div><div class="line">   lua_code_cache on;</div><div class="line">   content_by_lua_file /usr/example/lua/lua_test.lua;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在/usr/example/lua/文件下新建lua_test.lua文件，复制如下代码
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- nginx变量</span></div><div class="line"><span class="keyword">local</span> var = ngx.var</div><div class="line">ngx.say(<span class="string">"ngx.var.a :"</span>,var.a,<span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"ngx.var.b :"</span>,var.b,<span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"ngx.var[2] :"</span>,var[<span class="number">2</span>],<span class="string">"&lt;br/&gt;"</span>)</div><div class="line"></div><div class="line"><span class="comment">-- 请求头</span></div><div class="line"><span class="keyword">local</span> headers = ngx.req.get_headers()</div><div class="line">ngx.say(<span class="string">"headers begin"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"Host : "</span>, headers[<span class="string">"Host"</span>], <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"user-agent : "</span>, headers[<span class="string">"user-agent"</span>], <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(headers) <span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></div><div class="line">                ngx.say(k, <span class="string">" : "</span>, table.concat(v, <span class="string">","</span>), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">else</span></div><div class="line">                        ngx.say(k, <span class="string">" : "</span>, v, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">ngx.say(<span class="string">"headers end"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"&lt;br/&gt;"</span>)</div><div class="line"></div><div class="line"><span class="comment">--get请求uri参数  </span></div><div class="line">ngx.say(<span class="string">"uri args begin"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</div><div class="line"></div><div class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(uri_args) <span class="keyword">do</span></div><div class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></div><div class="line">                ngx_say(k, <span class="string">" : "</span>, table.concat(v, <span class="string">". "</span>),<span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">else</span></div><div class="line">                ngx.say(k, <span class="string">": "</span>, v, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">--post请求参数  </span></div><div class="line">ngx.req.read_body()</div><div class="line">ngx.say(<span class="string">"post args begin"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="keyword">local</span> post_args = ngx.req.get_post_args()</div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(post_args) <span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></div><div class="line">                ngx.say(k, <span class="string">" : "</span>, table.concat(v, <span class="string">", "</span>), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">else</span></div><div class="line">                ngx.say(k, <span class="string">": "</span>, v, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">ngx.say(<span class="string">"post args end"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--请求的http协议版本  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.http_version : "</span>, ngx.req.http_version(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--请求方法  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.get_method : "</span>, ngx.req.get_method(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--原始的请求头内容  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.raw_header : "</span>,  ngx.req.raw_header(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--请求的body内容体  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.get_body_data() : "</span>, ngx.req.get_body_data(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"&lt;br/&gt;"</span>)</div></pre></td></tr></table></figure></p>
<p>由代码可以看出，lua脚本中主要信息来自于ngx.var和ngx.req这两个属性。在执行程序之前，先nginx需要先reload一次，最后我们就可以通过curl命令来访问nginx
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$curl -XPOST -d &apos;name=json&amp;age=26&apos; &apos;http://127.0.0.1:80/lua_test/1/2?token=ds43klk54fd&apos;</div><div class="line">ngx.var.a :1&lt;br/&gt;</div><div class="line">ngx.var.b :127.0.0.1&lt;br/&gt;</div><div class="line">ngx.var[2] :2&lt;br/&gt;</div><div class="line">headers begin&lt;br/&gt;</div><div class="line">Host : 127.0.0.1&lt;br/&gt;</div><div class="line">user-agent : curl/7.35.0&lt;br/&gt;</div><div class="line">host : 127.0.0.1&lt;br/&gt;</div><div class="line">content-type : application/x-www-form-urlencoded&lt;br/&gt;</div><div class="line">accept : */*&lt;br/&gt;</div><div class="line">content-length : 16&lt;br/&gt;</div><div class="line">user-agent : curl/7.35.0&lt;br/&gt;</div><div class="line">headers end&lt;br/&gt;</div><div class="line">&lt;br/&gt;</div><div class="line">uri args begin&lt;br/&gt;</div><div class="line">token: ds43klk54fd&lt;br/&gt;</div><div class="line">post args begin&lt;br/&gt;</div><div class="line">age: 26&lt;br/&gt;</div><div class="line">name: json&lt;br/&gt;</div><div class="line">post args end&lt;br/&gt;</div><div class="line">&lt;br/&gt;</div><div class="line">ngx.req.http_version : 1.1&lt;br/&gt;</div><div class="line">ngx.req.get_method : POST&lt;br/&gt;</div><div class="line">ngx.req.raw_header : POST /lua_test/1/2?token=ds43klk54fd HTTP/1.1</div><div class="line">User-Agent: curl/7.35.0</div><div class="line">Host: 127.0.0.1</div><div class="line">Accept: */*</div><div class="line">Content-Length: 16</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">&lt;br/&gt;</div><div class="line">ngx.req.get_body_data() : name=json&amp;age=26&lt;br/&gt;</div><div class="line">&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>通过代码和结果一一比对，可以看出已经正确获取请求信息。我觉得这是一个很好的入门示例，因为处理http请求，获取http请求头信息是非常有必要的，而上述例子则展示接口信息。</p>
<p>下面另一个示例是展示ngx+lua存取redis。同样在example.conf添加路径映射
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="attribute">location</span> ~/redis_test/(\d+)$ &#123;</div><div class="line">        <span class="attribute">default_type</span> <span class="string">'text/html'</span>;</div><div class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</div><div class="line">        <span class="attribute">lua_code_cache</span> <span class="literal">on</span>;</div><div class="line">        <span class="attribute">content_by_lua_file</span> /usr/example/lua/redis.lua;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在/usr/example/lua/文件夹下新建redis.lua，复制如下代码:
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> json = <span class="built_in">require</span>(<span class="string">"cjson"</span>)</div><div class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">"resty.redis"</span>)</div><div class="line"></div><div class="line"><span class="keyword">local</span> red = redis:new()</div><div class="line">red:set_timeout(<span class="number">1000</span>)</div><div class="line"></div><div class="line"><span class="keyword">local</span> ip = <span class="string">"127.0.0.1"</span></div><div class="line"><span class="keyword">local</span> port = <span class="number">6379</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> ok, err = red:connect(ip, port)</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></div><div class="line">        ngx.say(<span class="string">"connect to redis error : "</span>, err)</div><div class="line">        <span class="keyword">return</span> ngx.exit(<span class="number">500</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</div><div class="line"><span class="keyword">local</span> value = <span class="string">"value-"</span>..id</div><div class="line"></div><div class="line">red:set(id,value)</div><div class="line"></div><div class="line"><span class="keyword">local</span> resp, err = red:get(id)</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></div><div class="line">        ngx.say(<span class="string">"get from redis error : "</span>, err)</div><div class="line">        <span class="keyword">return</span> ngx.exit(<span class="number">500</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">red:<span class="built_in">close</span>()</div><div class="line"></div><div class="line">ngx.say(json.encode(&#123;content=resp&#125;))</div></pre></td></tr></table></figure></p>
<p>OpenResty将常用的lua包都已经打包好，包括redis客户端，memcache客户端，mysql客户端以及cjson等等，非常方便ngx+lua的开发。在执行程序之前，先reload一次配置文件，执行结果如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl http://127.0.0.1:80/redis_test/1</div><div class="line">&#123;&quot;content&quot;:&quot;value-1&quot;&#125;</div><div class="line">$ curl http://127.0.0.1:80/redis_test/2</div><div class="line">&#123;&quot;content&quot;:&quot;value-2&quot;&#125;</div><div class="line">$ curl http://127.0.0.1:80/redis_test/3</div><div class="line">&#123;&quot;content&quot;:&quot;value-3&quot;&#125;</div></pre></td></tr></table></figure></p>
<p>最后可以通过redis-cli客户端验证上述三个键值对是否插入成功。由这个例子可以展开讨论，如下</p>
<ol>
<li>因为OpenResty提供了redis，mysql以及模板渲染，因此利用ngx+lua可以直接部署一个小型网站；</li>
<li>可以在nginx本地搭一个redis缓存；当数据请求时，先访问本地的redis缓存，如果redis缓存需要的数据，直接直接在nginx层返回；如果redis没有缓存需要的数据，则转向web服务器。这样可以减轻后端服务器和数据库的压力，以及缩短请求时间。</li>
</ol>
<h1>lua面向对象实现</h1>
<hr>
<p>lua没有提供面像对象的实现，但是可以通过table来模拟。所以可知table在lua中是多么核心的数据结构。这里，我用redis客户端来说明lua是如何模拟面像对象的实现。
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">----引入table.new函数，兼容版本恩体</span></div><div class="line"><span class="keyword">local</span> ok, new_tab = <span class="built_in">pcall</span>(<span class="built_in">require</span>, <span class="string">"table.new"</span>)</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">or</span> <span class="built_in">type</span>(new_tab) ~= <span class="string">"function"</span> <span class="keyword">then</span></div><div class="line"><span class="comment">----如果还没有table.new接口，则自定义一个函数，返回一个空表格</span></div><div class="line">    new_tab = <span class="function"><span class="keyword">function</span> <span class="params">(narr, nrec)</span></span> <span class="keyword">return</span> &#123;&#125; <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="comment">-----------------------------------------------------</span></div><div class="line"><span class="comment">--新建一个表格</span></div><div class="line"> <span class="keyword">local</span> _M = new_tab(<span class="number">0</span>, <span class="number">155</span>)</div><div class="line"> _M.<span class="built_in">_VERSION</span> = <span class="string">'0.24'</span></div><div class="line"><span class="comment">-----------------------------------------------------</span></div><div class="line"><span class="keyword">local</span> mt = &#123; <span class="built_in">__index</span> = _M &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.new</span><span class="params">(self)</span></span></div><div class="line">    <span class="keyword">local</span> sock, err = tcp()</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sock <span class="keyword">then</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">--设置返回表的元表</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(&#123; sock = sock &#125;, mt)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>上述new方法即相当于类的构造函数，因此，我们可以通过如下方式新建一个对象
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-----此时require返回的redis即为模块中的_M</span></div><div class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">"resty.redis"</span>)</div><div class="line"><span class="keyword">local</span> red = redis:new()</div></pre></td></tr></table></figure></p>
<p>通过redis:new()方法返回一个{sock=sock}表格，然后设置这个表格的元表为resty.redis模块中的_M表格；__index元表格的意思就是当在red中访问一个不存在的属性时，则可以到元表中查询；因此当red调用下述函数时:
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">red:connect(<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</div><div class="line"><span class="comment">--------------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.connect</span><span class="params">(self, ...)</span></span></div><div class="line"><span class="comment">----如果是red调用改方法，则self即为red</span></div><div class="line">    <span class="keyword">local</span> sock = self.sock</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sock <span class="keyword">then</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">"not initialized"</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    self.subscribed = <span class="literal">nil</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> sock:connect(...)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>因为red中并不存在connect方法，因此red到它的_M中查找connect方法，并执行；其实_M和red在lua中是两个不同的对象，就是因为red的元表为_M，因此可以把_M当作是对象red的模板，也就是类的概念。</p>
<h1>总结</h1>
<hr>
<p>本文主要介绍了lua在redis和nginx的应用，以及lua面向对象的实现。多了解一些编程语言，可以更好对编程语言的理解。后面还是深入再看看ngx+lua的开发。</p>
]]></content>
      
        <categories>
            
            <category> lua </category>
            
        </categories>
        
        
        <tags>
            
            <tag> lua </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx是这么运行的]]></title>
      <url>http://luodw.cc/2017/03/17/nginx01/</url>
      <content type="html"><![CDATA[<p>很早之前就有看nginx的冲动，但是一直被一些事耽搁着，最近在繁忙之中，抽出点时间，看了下nginx代码，发现整体上并不是很难看懂，而且刚好想学习nginx+lua开发。nginx在互联网公司使用很广，最重要的功能当属反向代理和负载均衡了吧，当然还有缓存。所以有必要对nginx熟悉使用和深入了解。</p>
<p>记得我之前在很多文章有提到，后台组件框架主要有三种：redis单进程单线程，memcache单进程多线程，nginx多进程；等看了nginx之后，我也算集齐了；nginx以模块化方式开发，比如核心模块，event模块，http模块，然后为了支持多平台，event模块下又有对各大平台的封装支持，例如linux平台epoll，mac平台kqueue等等；然后http模块也被拆分成了很多子模块。</p>
<p>这篇文章算是我自己做的笔记吧，把之前研究的东西记录下。也许是之前看过redis和golang以及python的http框架，nginx整体框架比较容易就看懂了，当然很多细节还需后面慢慢看；这篇文章主要介绍nginx是如何开启，以及请求是怎么执行的，所以这篇文章主要就是以下两点：</p>
<ol>
<li>nginx开启流程;</li>
<li>重要回调函数设置；</li>
<li>nginx处理http请求；</li>
<li>总结</li>
</ol>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2017/03/17/nginx01/#more">http://luodw.cc/2017/03/17/nginx01/#more</a></p>
<h1>1. nginx开启流程</h1>
<hr>
<p>nginx体量很大，想要在较短时间内看完所有代码很难，而且我看得时间也不是很多，所以，这里主要站在宏观角度，对nginx做个整体剖析；其实如果直接从main函数直接开始看，其实也是可以看懂大部分，但是nginx回调函数太多了，看着看着，突然跑出一个回调函数，经常就懵逼了；因此，就需要用gdb来定点调试；</p>
<p>要使用gdb，首先需要在gcc编译时，加入-g选项，可以如下操作：</p>
<ol>
<li>打开nginx目录/auto/cc/conf文件，然后更改ngx_compile_opt=&quot;-c&quot;选项，添加-g，即为ngx_compile_opt=&quot;-c -g&quot;;</li>
<li>然后运行./configure和make即可编译生成可执行文件，在文件objs目录下;</li>
</ol>
<p>生成可执行文件nginx之后，直接在终端运行即可，nginx会加载默认配置文件，以daemon形式运行;</p>
<p>nginx运行之后，即可通过gdb来调试;按如下命令开启gdb
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gdb -<span class="selector-tag">q</span> -tui</div><div class="line"><span class="comment">// -q 安静模式，即不输出多余信息，-tui提供一个窗口显示代码</span></div></pre></td></tr></table></figure></p>
<p>然后，通过pidof命令获取nginx进程号，即可attach，如下：
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">shell pidof nginx</span></div></pre></td></tr></table></figure></p>
<p>nginx默认开启一个master进程和一个worker进程，因此上述命令会返回两个进程号，在我主机上8125和8126，较小是master进程，较大的是worker进程；接下来，先看下master进程，
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">attach</span> <span class="number">8125</span></div></pre></td></tr></table></figure></p>
<p>这样就可以直接调试nginx的worker进程，用命令bt可以查看master进程的函数栈
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="keyword">bt</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007efd445d9f76</span> <span class="keyword">in</span> do_sigsuspend (set=<span class="number">0x7ffe517ce5d0</span>) <span class="meta">at</span> ../sysdeps/unix/sysv/linux/sigsuspend.c:<span class="number">31</span></div><div class="line">#<span class="number">1</span>  __GI___sigsuspend (set=set@entry=<span class="number">0x7ffe517ce5d0</span>) <span class="meta">at</span> ../sysdeps/unix/sysv/linux/sigsuspend.c:<span class="number">41</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000042cc12</span> <span class="keyword">in</span> ngx_master_process_cycle (cycle=cycle@entry=<span class="number">0x181f110</span>) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">163</span></div><div class="line">#<span class="number">3</span>  <span class="number">0x000000000040c83d</span> <span class="keyword">in</span> main (argc=&lt;optimized <span class="keyword">out</span>&gt;, argv=&lt;optimized <span class="keyword">out</span>&gt;) <span class="meta">at</span> src/core/nginx.c:<span class="number">367</span></div></pre></td></tr></table></figure></p>
<p>nginx开启之后，首先启动的就是master进程，从main函数开始，</p>
<ol>
<li>main函数主要是做一些初始化操作，初始化启动参数，开启daemon，新建pid文件等等，然后调用ngx_master_process_cycle函数；</li>
<li>在ngx_master_process_cycle函数中最重要就是开启子进程，然后调用sigsuspend函数，master进程则阻塞在在信号中；</li>
</ol>
<p>因此，master进程任务就是开启子进程，然后管理子进程；怎么管理了？</p>
<p>信号，对，就是信号；当master进程收到一个信号之后，就把这个信号传递给worker进程，worker进程进而根据不同信号分别处理；那么问题又来了，master进程是如何把信号传递给worker进程的？</p>
<p>管道，对，就是管道；原理和memcache的master线程和worker线程通信机制一样；即每个worker进程有两个文件描述符fd[0]和fd[1]，一个读端，一个写端；worker进程将读端加入epoll事件监听，当master进程收到一个信号后，在每个worker进程写端写入一个flag，然后worker进程触发读事件，读取flag，并根据flag做相应操作。</p>
<p>因此nginx接收客户端请求以及处理客户端请求，主要是在worker进程，我们来看下，worker进程函数栈
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) attach <span class="number">8126</span></div><div class="line">(gdb) bt</div><div class="line">#<span class="number">0</span>  x00007efd4469d9f3 <span class="keyword">in</span> __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:<span class="number">81</span></div><div class="line">#<span class="number">1</span>  x000000000042dcae <span class="keyword">in</span> ngx_epoll_process_events (<span class="keyword">cycle</span>=x181f110, timer=<span class="number">18446744073709551615</span>, flags=<span class="number">1</span>) at src/event/modules/ngx_epoll_module.c:<span class="number">717</span></div><div class="line">#<span class="number">2</span>  x0000000000426225 <span class="keyword">in</span> ngx_process_events_and_timers (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110) at src/event/ngx_event.c:<span class="number">242</span></div><div class="line">#<span class="number">3</span>  x000000000042c15a <span class="keyword">in</span> ngx_worker_process_cycle (<span class="keyword">cycle</span>=x181f110, <span class="keyword">data</span>=&lt;optimized <span class="keyword">out</span>&gt;) at src/os/unix/ngx_process_cycle.c:<span class="number">753</span></div><div class="line">#<span class="number">4</span>  x000000000042ac46 <span class="keyword">in</span> ngx_spawn_process (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110, proc=proc@<span class="built_in">entry</span>=x42c0d9 &lt;ngx_worker_process_cycle&gt;, <span class="keyword">data</span>=<span class="keyword">data</span>@<span class="built_in">entry</span>=x0, </div><div class="line">    <span class="keyword">name</span>=<span class="keyword">name</span>@<span class="built_in">entry</span>=x47a4cf <span class="string">"worker process"</span>, respawn=respawn@<span class="built_in">entry</span>=-<span class="number">3</span>) at src/os/unix/ngx_process.c:<span class="number">198</span></div><div class="line">#<span class="number">5</span>  x000000000042c2b7 <span class="keyword">in</span> ngx_start_worker_processes (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110, n=<span class="number">1</span>, <span class="keyword">type</span>=<span class="keyword">type</span>@<span class="built_in">entry</span>=-<span class="number">3</span>) at src/os/unix/ngx_process_cycle.c:<span class="number">358</span></div><div class="line">#<span class="number">6</span>  x000000000042cb13 <span class="keyword">in</span> ngx_master_process_cycle (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110) at src/os/unix/ngx_process_cycle.c:<span class="number">130</span></div><div class="line">#<span class="number">7</span>  x000000000040c83d <span class="keyword">in</span> main (argc=&lt;optimized <span class="keyword">out</span>&gt;, argv=&lt;optimized <span class="keyword">out</span>&gt;) at src/core/nginx.c:<span class="number">367</span></div></pre></td></tr></table></figure></p>
<p>因为worker进程是由master进程fork出来，因此worker进程包含master进程的函数栈；我们直接从#5函数开始看，</p>
<ol>
<li>ngx_start_worker_processes 函数调用ngx_spawn_process开启子进程，并且设置master进程和worker进程通信的管道；</li>
<li>ngx_spawn_process函数主要是设置master进程和worker进程间通信管道，例如非阻塞等等，然后通过fork函数正式开启子进程；子进程调用通过参数传递进来的回调函数ngx_worker_process_cycle正式切入子进程部分，父进程则接着设置worker进程相关属性；</li>
<li>ngx_worker_process_cycle一开始调用ngx_worker_process_init函数对worker进程做些初始化设置，包括设置进程优先级，worker进程允许打开的最大文件描述符，对阻塞信号的设置，初始化所有模块，将master进程和worker进程间通信管道添加到监听可读事件等等；然后在一个无限循环中，函数ngx_worker_process_cycle接着调用ngx_process_events_and_timers，开启事件监听循环；</li>
<li>在ngx_process_events_and_timers函数中，先是获取锁，如果获取到锁，listenfd即可接收客户端，否则listenfd不可接收客户端事件；然后调用ngx_process_events函数，这个函数也就是ngx_epoll_process_events函数，开启开启事件监听；</li>
</ol>
<p>ok，worker进程此时已就绪，等待客户端连接以及请求数据；为了避免惊群现象以及实现worker进程负载均衡，每次有客户端连接时，所有worker进程会先争抢锁，如果某个worker进程获取到锁，即可执行接收客户端和客户端请求事件；如果worker进程没有争抢到锁，只执行客户端请求事件。</p>
<h1>2. 重要回调函数设置</h1>
<hr>
<p>当nginx的master进程和worker进程开启之后，客户端即可发送请求；接下来，就看看nginx是如何处理请求的；</p>
<p>当客户端发送请求之后，首先是通过tcp三次握手建立连接；当连接建立成功之后，即执行listenfd的回调函数，但是listenfd的回调函数是哪个了？这对于新手来说，其实是很难发现listenfd回调函数；下面分析下；</p>
<blockquote>
<p>像listenfd的回调函数以及模块间是如何拼凑在一起，这些几乎都是在模块初始化时完成的。对于listenfd的回调函数即是在event模块初始化时或者调用event模块一些设置函数时设置；客户端连接上服务器之后，服务器收到请求之后的回调函数也是在http模块初始化时或者调用模http模块一些设置函数时设置的。</p>
</blockquote>
<p>在event模块初始化时，调用的是ngx_event_process_init函数，下面列出这个函数最重要的代码:
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_event_process_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//.......</span></div><div class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; ngx_modules[m]; m++) &#123;</div><div class="line">        <span class="keyword">if</span> (ngx_modules[m]-&gt;type != NGX_EVENT_MODULE) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ngx_modules[m]-&gt;ctx_index != ecf-&gt;use) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">module</span> = ngx_modules[m]-&gt;ctx;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;actions.init(cycle, ngx_timer_resolution) != NGX_OK) &#123;</div><div class="line">            <span class="comment">/* fatal */</span></div><div class="line">            <span class="built_in">exit</span>(<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">   　 &#125;</div><div class="line">    <span class="comment">//..........</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</div><div class="line">        rev-&gt;handler = ngx_event_accept;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ngx_event_flags &amp; NGX_USE_RTSIG_EVENT) &#123;</div><div class="line">                <span class="keyword">if</span> (ngx_add_conn(c) == NGX_ERROR) &#123;</div><div class="line">                    <span class="keyword">return</span> NGX_ERROR;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="number">0</span>) == NGX_ERROR) &#123;</div><div class="line">                    <span class="keyword">return</span> NGX_ERROR;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在for循环中，迭代每个监听套接字，recv为listenfd连接对象的读事件，这里设置listenfd读事件的回调函数为ngx_event_accept函数，然后将每个listenfd添加到事件监听中，并设置为可读事件。</p>
<p>ok，当我们去看ngx_add_conn和ngx_add_event的定义时，如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_add_event        ngx_event_actions.add</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_add_conn         ngx_event_actions.add_conn</span></div></pre></td></tr></table></figure></p>
<p>说明ngx_add_conn和ngx_add_event都是结构体ngx_event_actions结构体中设置的函数指针；其实这个ngx_event_actions就是nginx跨平台的关键，因为不同平台使用的事件监听器是不一样的，导致ngx_event_actions也就不一样。例如linux使用的是epoll，因此ngx_event_actions结构体就是在epoll模块加载时设置，在上述代码前半部分。我们来看下epoll模块actions.init函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ngx_epoll_module.c</span></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_epoll_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_msec_t</span> timer)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    nevents = epcf-&gt;events;</div><div class="line">    ngx_io = ngx_os_io;</div><div class="line">    ngx_event_actions = ngx_epoll_module_ctx.actions;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码可以看出，ngx_event_actions被设置为ngx_epoll_module_ctx.actions，接着看下这个结构体:
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_event_module_t</span>  ngx_epoll_module_ctx = &#123;</div><div class="line">    &amp;epoll_name,</div><div class="line">    ngx_epoll_create_conf,               <span class="comment">/* create configuration */</span></div><div class="line">    ngx_epoll_init_conf,                 <span class="comment">/* init configuration */</span></div><div class="line"></div><div class="line">    &#123;<span class="comment">// actions</span></div><div class="line">        ngx_epoll_add_event,             <span class="comment">/* add an event */</span></div><div class="line">        ngx_epoll_del_event,             <span class="comment">/* delete an event */</span></div><div class="line">        ngx_epoll_add_event,             <span class="comment">/* enable an event */</span></div><div class="line">        ngx_epoll_del_event,             <span class="comment">/* disable an event */</span></div><div class="line">        ngx_epoll_add_connection,        <span class="comment">/* add an connection */</span></div><div class="line">        ngx_epoll_del_connection,        <span class="comment">/* delete an connection */</span></div><div class="line">        <span class="literal">NULL</span>,                            <span class="comment">/* process the changes */</span></div><div class="line">        ngx_epoll_process_events,        <span class="comment">/* process the events */</span></div><div class="line">        ngx_epoll_init,                  <span class="comment">/* init the events */</span></div><div class="line">        ngx_epoll_done,                  <span class="comment">/* done the events */</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>因此，当调用ngx_add_conn和ngx_add_event时，分别调用的是ngx_epoll_add_connection和ngx_epoll_add_event;如此一来，如果此时是mac平台，那么使用的事件监听器是kqueue，那么当调用ngx_add_event时，调用的就是ngx_kqueue_add_event。如果使用的poll监听器，那么调用将是ngx_poll_add_event等等。</p>
<p>接下来，再分析一个很重要的回调函数，即客户端连上客户端之后，发送请求时的回调函数，先来看下，listenfd回调函数
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">ngx_event_accept</span><span class="params">(<span class="keyword">ngx_event_t</span> *ev)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        socklen = NGX_SOCKADDRLEN;</div><div class="line">        <span class="comment">//......</span></div><div class="line">        s = accept(lc-&gt;fd, (<span class="keyword">struct</span> sockaddr *) sa, &amp;socklen);</div><div class="line">        <span class="comment">//.......</span></div><div class="line">         ngx_accept_disabled = ngx_cycle-&gt;connection_n / <span class="number">8</span></div><div class="line">                              - ngx_cycle-&gt;free_connection_n;</div><div class="line"></div><div class="line">        c = ngx_get_connection(s, ev-&gt;<span class="built_in">log</span>);</div><div class="line">        <span class="comment">//.......</span></div><div class="line">         <span class="keyword">if</span> (ngx_add_conn &amp;&amp; (ngx_event_flags &amp; NGX_USE_EPOLL_EVENT) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (ngx_add_conn(c) == NGX_ERROR) &#123;</div><div class="line">                ngx_close_accepted_connection(c);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">log</span>-&gt;data = <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">log</span>-&gt;handler = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        ls-&gt;handler(c);</div><div class="line">        <span class="comment">//.....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当客户端连接服务器时，首先listenfd回调函数先是调用accept函数接收客户端请求，然后从对象池中获取一个封装客户端socket连接对象，如果目前使用的是epoll事件监听器，则调用ngx_add_conn(c)放入事件监听，最后调用ngx_listening_t的回调函数，对客户端连接进一步操作；ok，这个ls-&gt;handler(c)是个啥？我在第一次看代码时，一脸懵逼！！！还记得之前说的吗？模块之间的衔接，几乎都是在模块初始化或者调用模块一些设置函数时设置的，因此接下来，就来看看http模块初始化时做了什么。http模块并没有在模块初始化函数中设置ls-&gt;handler(c)，而是在当读取到&quot;http&quot;命令时，执行命令函数ngx_http_block中设置；
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *</span></div><div class="line"><span class="title">ngx_http_block</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    <span class="keyword">if</span> (ngx_http_optimize_servers(cf, cmcf, cmcf-&gt;ports) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_CONF_ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//......</span></div><div class="line">&#125;</div><div class="line">------------------------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_optimize_servers</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_http_core_main_conf_t</span> *cmcf,</span></div><div class="line">    <span class="keyword">ngx_array_t</span> *ports)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//........</span></div><div class="line">     <span class="keyword">if</span> (ngx_http_init_listening(cf, &amp;port[p]) != NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">&#125;</div><div class="line">--------------------------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_init_listening</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_http_conf_port_t</span> *port)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">      ls = ngx_http_add_listening(cf, &amp;addr[i]);</div><div class="line">        <span class="keyword">if</span> (ls == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">&#125;</div><div class="line">------------------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_listening_t *</span></div><div class="line"><span class="title">ngx_http_add_listening</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_http_conf_addr_t</span> *addr)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//........................</span></div><div class="line">     ls-&gt;handler = ngx_http_init_connection;</div><div class="line">     <span class="comment">//.........................</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>真是藏的够深，经历了四个函数，终于看到ls-handler设置函数了，即为ngx_http_init_connection函数，而这个函数在http模块，为客户端http请求处理的入口函数；到此为止，我们可以知道服务器在接收到客户端之后，首先将客户端封装成ngx_connection_t结构体，然后交给http模块执行http请求。</p>
<h1>3. nginx处理http请求</h1>
<hr>
<p>nginx处理http的请求是nginx最重要的职能，也是最复杂的一部分。可以大概说下执行流程：</p>
<ol>
<li>读取解析请求行；</li>
<li>读取解析请求头；</li>
<li>开始最重要的部分，即多阶段处理；nginx把请求处理划分成了11个阶段，也就是说当nginx读取了请求行和请求头之后，将请求封装了结构体ngx_http_request_t，然后每个阶段的handler都会根据这个ngx_http_request_t，对请求进行处理，例如重写uri，权限控制，路径查找，生成内容以及记录日志等等；</li>
<li>将结果返回给客户端；</li>
</ol>
<p>多阶段处理是nginx模块最重要的部分，因为第三方模块也是注册在这；例如有人写了一个利用nginx和memcache做页面缓存的第三方模块，也可以把memcache换成redis集群等等；而且nginx多阶段处理有点类似python和golang　web框架的中间件，后者主要是用装饰器模式，对handler一层一层封装，而nginx是用数组（链表）形式组合多阶段handler，然后按handler链表执行即可；</p>
<p>因为多阶段这块内容还没完全看懂，所以跟着网上教程，写了个最简单的第三方模块，用于设置定点调试，观察http阶段函数执行过程，步骤如下：</p>
<ol>
<li>在nginx目录下新建一个目录thm（third mudole），在新建一个foo目录（foo模块），然后在foo目录下新建ngx_http_foo_module.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_http.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_foo_init</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_foo_handler</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span> ngx_http_foo_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* preconfiguration */</span></div><div class="line">    ngx_http_foo_init,                 <span class="comment">/* postconfiguration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* merge server configuration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* create location configuration */</span></div><div class="line">    <span class="literal">NULL</span>                               <span class="comment">/* merge location configuration */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">ngx_module_t</span>  ngx_http_foo_module = &#123;</div><div class="line">    NGX_MODULE_V1,</div><div class="line">    &amp;ngx_http_foo_module_ctx,                      <span class="comment">/* module context */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* module directives */</span></div><div class="line">    NGX_HTTP_MODULE,                               <span class="comment">/* module type */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init master */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init module */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init process */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init thread */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* exit thread */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* exit process */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* exit master */</span></div><div class="line">    NGX_MODULE_V1_PADDING</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_foo_handler</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></div><div class="line">&#123;</div><div class="line">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">            <span class="string">"#### hello, this FOO module"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_DECLINED;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_foo_init</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf)</span></div><div class="line">&#123;</div><div class="line">    ngx_http_handler_pt               *h;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_http_core_main_conf_t</span>         *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</div><div class="line"></div><div class="line">    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</div><div class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *h = ngx_http_foo_handler;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>然后同样是在foo目录下新建一个配置文件config
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">ngx_addon_name</span>=ngx_http_foo_module</div><div class="line"><span class="attr">HTTP_MODULES</span>=<span class="string">"$HTTP_MODULES ngx_http_foo_module"</span></div><div class="line"><span class="attr">NGX_ADDON_SRCS</span>=<span class="string">"$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_foo_module.c"</span></div></pre></td></tr></table></figure></p>
<p>这样，一个最简单的第三方模块就编写完成，上述两个函数很好理解，一个是初始化函数，将这个模块的handler注册到某个阶段中，这个例子是在阶段NGX_HTTP_CONTENT_PHASE，然后当程序执行到上述阶段时，即可执行foo模块；最后重新编译生成可执行文件即可。</p>
<p>接下来，利用gdb来看下http执行过程，把定点设置在
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(gdb) b ngx_http_foo_handler</div><div class="line">Breakpoint <span class="number">1</span> <span class="meta">at</span> <span class="number">0x47617e</span>: file ./thm/foo/ngx_http_foo_module.c, line <span class="number">41</span>.</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line"></div><div class="line">Breakpoint <span class="number">1</span>, ngx_http_foo_handler (r=<span class="number">0x175bf70</span>) <span class="meta">at</span> ./thm/foo/ngx_http_foo_module.c:<span class="number">41</span></div><div class="line"><span class="number">41</span>	    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, <span class="number">0</span>,</div><div class="line">(gdb) <span class="keyword">bt</span></div><div class="line">#<span class="number">0</span>  ngx_http_foo_handler (r=<span class="number">0x175bf70</span>) <span class="meta">at</span> ./thm/foo/ngx_http_foo_module.c:<span class="number">41</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x0000000000435f76</span> <span class="keyword">in</span> ngx_http_core_content_phase (r=<span class="number">0x175bf70</span>, ph=<span class="number">0x176f408</span>) <span class="meta">at</span> src/http/ngx_http_core_module.c:<span class="number">1377</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x0000000000430f43</span> <span class="keyword">in</span> ngx_http_core_run_phases (r=r@entry=<span class="number">0x175bf70</span>) <span class="meta">at</span> src/http/ngx_http_core_module.c:<span class="number">847</span></div><div class="line">#<span class="number">3</span>  <span class="number">0x000000000043105c</span> <span class="keyword">in</span> ngx_http_handler (r=r@entry=<span class="number">0x175bf70</span>) <span class="meta">at</span> src/http/ngx_http_core_module.c:<span class="number">830</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x0000000000438d66</span> <span class="keyword">in</span> ngx_http_process_request (r=r@entry=<span class="number">0x175bf70</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">1910</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x000000000043add5</span> <span class="keyword">in</span> ngx_http_process_request_headers (rev=rev@entry=<span class="number">0x1776590</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">1342</span></div><div class="line">#<span class="number">6</span>  <span class="number">0x000000000043b083</span> <span class="keyword">in</span> ngx_http_process_request_line (rev=rev@entry=<span class="number">0x1776590</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">1022</span></div><div class="line">#<span class="number">7</span>  <span class="number">0x000000000043b767</span> <span class="keyword">in</span> ngx_http_wait_request_handler (rev=<span class="number">0x1776590</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">499</span></div><div class="line">#<span class="number">8</span>  <span class="number">0x000000000042de5c</span> <span class="keyword">in</span> ngx_epoll_process_events (cycle=&lt;optimized <span class="keyword">out</span>&gt;, timer=&lt;optimized <span class="keyword">out</span>&gt;, flags=&lt;optimized <span class="keyword">out</span>&gt;)</div><div class="line">    <span class="meta">at</span> src/event/modules/ngx_epoll_module.c:<span class="number">822</span></div><div class="line">#<span class="number">9</span>  <span class="number">0x0000000000426225</span> <span class="keyword">in</span> ngx_process_events_and_timers (cycle=cycle@entry=<span class="number">0x1751110</span>) <span class="meta">at</span> src/event/ngx_event.c:<span class="number">242</span></div><div class="line">#<span class="number">10</span> <span class="number">0x000000000042c15a</span> <span class="keyword">in</span> ngx_worker_process_cycle (cycle=<span class="number">0x1751110</span>, data=&lt;optimized <span class="keyword">out</span>&gt;) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">753</span></div><div class="line">#<span class="number">11</span> <span class="number">0x000000000042ac46</span> <span class="keyword">in</span> ngx_spawn_process (cycle=cycle@entry=<span class="number">0x1751110</span>, proc=proc@entry=<span class="number">0x42c0d9</span> &lt;ngx_worker_process_cycle&gt;, data=data@entry=<span class="number">0x0</span>, </div><div class="line">    name=name@entry=<span class="number">0x47a4cf</span> <span class="string">"worker process"</span>, respawn=respawn@entry=-<span class="number">3</span>) <span class="meta">at</span> src/os/unix/ngx_process.c:<span class="number">198</span></div><div class="line">#<span class="number">12</span> <span class="number">0x000000000042c2b7</span> <span class="keyword">in</span> ngx_start_worker_processes (cycle=cycle@entry=<span class="number">0x1751110</span>, n=<span class="number">1</span>, type=type@entry=-<span class="number">3</span>) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">358</span></div><div class="line">#<span class="number">13</span> <span class="number">0x000000000042cb13</span> <span class="keyword">in</span> ngx_master_process_cycle (cycle=cycle@entry=<span class="number">0x1751110</span>) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">130</span></div><div class="line">#<span class="number">14</span> <span class="number">0x000000000040c83d</span> <span class="keyword">in</span> main (argc=&lt;optimized <span class="keyword">out</span>&gt;, argv=&lt;optimized <span class="keyword">out</span>&gt;) <span class="meta">at</span> src/core/nginx.c:<span class="number">367</span></div></pre></td></tr></table></figure></p>
<p>简要说明下上述函数，我阅读的版本和运行版本不一样，因此上述仅供参考:</p>
<ol>
<li>当有客户端发送tcp连接请求时，ngx_epoll_process_events返回listenfd可读事件，调用ngx_event_accept函数接收客户端请求，然后将请求封装成ngx_connection_t结构体，最后调用ngx_http_init_connection函数进入http处理；</li>
<li>在新版nginx中，并没有看到ngx_http_wait_request_handler,而是改成了ngx_http_init_connection(ngx_connection_t *c)函数，然后在这个函数内部调用ngx_http_init_request函数初始化请求结构体ngx_http_request_t以及调用ngx_http_process_request_line函数；</li>
<li>ngx_http_process_request_line函数内部先是调用ngx_http_read_request_header函数将请求行读取到缓存中，然后调用ngx_http_parse_request_line函数解析出请求行信息，最后调用ngx_http_process_request_header处理请求头；</li>
<li>在函数ngx_http_process_request_header内部先是调用函数ngx_http_read_request_header读取请求头，然后调用ngx_http_parse_header_line函数解析出请求头，接着调用ngx_http_process_request_header函数对请求头进行必要的验证，最后调用ngx_http_process_request函数处理请求；</li>
<li>在ngx_http_process_request函数内部调用ngx_http_handler(ngx_http_request_t *r)函数，而在ngx_http_handler(ngx_http_request_t *r)函数内部调用
函数ngx_http_core_run_phases进行多阶段处理；</li>
<li>我们来看下多阶段处理函数ngx_http_core_run_phases
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">ngx_http_core_run_phases</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_int_t</span>                   rc;</div><div class="line">    <span class="keyword">ngx_http_phase_handler_t</span>   *ph;</div><div class="line">    <span class="keyword">ngx_http_core_main_conf_t</span>  *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);</div><div class="line"></div><div class="line">    ph = cmcf-&gt;phase_engine.handlers;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ph[r-&gt;phase_handler].checker) &#123;</div><div class="line"></div><div class="line">        rc = ph[r-&gt;phase_handler].checker(r, &amp;ph[r-&gt;phase_handler]);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rc == NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>http多阶段处理，每个阶段可能对应一个handler，也可能对应多个handler，而每个阶段对应同一个checker，因此上述while循环中，迭代所有http模块handler，然后在handler函数中根据请求结构体ngx_http_request_t做出相应的处理；上述gdb调试结果，可以看出NGX_HTTP_CONTENT_PHASE阶段的checker函数为ngx_http_core_content_phase，然后再在这个checker函数内部执行foo模块的handler（ngx_http_foo_handler）。</p>
<p>等到多阶段处理结束之后，最后再将response返回给客户端。</p>
<h1>4. 总结</h1>
<p>这篇文章主要就是宏观分析下nginx整体运行流程，因为第一次看nginx时，有很多看不懂的地方，所以这篇文章也算是做笔记吧。后续还需认真看多阶段处理，因为第三方开发模块也是注册在多阶段过程，以及熟悉ngx+lua模块开发。</p>
]]></content>
      
        <categories>
            
            <category> nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《人类简史》和《未来简史》--赫拉利]]></title>
      <url>http://luodw.cc/2017/02/18/mankind/</url>
      <content type="html"><![CDATA[<p>最近在业余时间，看了以色列历史学家赫拉利两本著作《人类简史》和《未来简史》，这两本书也是受到各大科技大佬，作家以及报社推荐，全球20多个国家争相购得版权热销；我在看完《人类简史》之后，真心佩服赫拉利的学识渊博以及脑洞大；后来，《未来简史》一出版，我也是第一时间购买，并且大概花一个星期就看完了，完全可以说是情不自禁；</p>
<p>这两本书分别叙述了我们人类是如何从动物一步一步走向万物之灵，地球主宰；以及我们人类在未来将会面对可能的未来；通过这两本书，我也更加认清我们生活的这个世界，什么是人文主义教条，什么是资本主义教条等等；《人类简史》和《未来简史》可以说是历史哲学书籍，因为赫拉利在书中并不仅仅是叙述事实，而且辩证地阐述了事实的由来；</p>
<p>再看这两本书之前，我自己的感受是最好对世界史有个认识，可以看看“二混子”历史系列以及《大国崛起》记录片；对于《未来简史》我觉得有大数据思维会更好理解数据主义，可以看看《大数据时代》或者《智能时代》；</p>
<p>下面就跟着赫拉利介绍下这两本书的观点；</p>
<ol>
<li>《人类简史》</li>
<li>《未来简史》</li>
<li>感悟</li>
</ol>
<h1>《人类简史》</h1>
<hr>
<p>《人类简史》这本书的副标题为“从动物到上帝”，我觉得很切合书本提到的观点；我们人类最原始其实和普通的动物一样，过着采集狩猎的生活；后面经历了认知革命，农业革命以及科学革命才一步一步主宰地球，过着现在的生活；下面，分别从上述三大革命来阐述赫拉利观点；</p>
<h2>认知革命</h2>
<p>认知革命可以说是智人(人类祖先)从普通动物到万物之灵最为重要的一次革命，因为这次革命，智人绕过基因组演变的宿命，从动物到人类的演变；下面先给出一些重要时间：</p>
<ul>
<li>135亿年 宇宙大爆炸</li>
<li>38亿年 形成有机生物，生物学开始</li>
<li>250 万年 非洲人属开始演化，出现最早的石器</li>
<li>200万年 人类由非洲传播到欧亚大陆，演化为不同的人种</li>
<li>30万年 开始日常用火</li>
<li>20万年 智人在东非演化</li>
<li>7万年 认知革命 出现能描述故事的语言</li>
<li>1.2万年 农业革命 驯化动植物，出现永久聚落</li>
<li>500年 科学革命 人类承认自己的无知，开始取得前所未有的能力；欧洲人开始在政府美洲和各大洋，整个地球形成单一历史场域，资本主义兴起</li>
<li>200年 工业革命生产力大幅度提高，动植物大规模灭绝</li>
</ul>
<p>从这个时间，我们可以知道人这个物种其实大概存活了250万年，我们智人存活的历史有20万年；在智人出现的时候，其实智人和其他动物一样，过着采集狩猎的生活；在个人能力上，不如尼安德特人或者一些大型的动物；因此那时智人也是弱势群体，经常只能在远处看着大型动物吃猎物，然后再吃剩下的肉；当时的智人，也和动物一样，四海为家，哪有食物，就在哪定居；而且由于每天可能吃到的食物不一样，因此智人能获取的必需的营养成分；智人就上述生活到了距今7万年，智人开始了第一次革命：认知革命。</p>
<p>在认知革命之前，智人的认知和其他动物一样，只能叙述某个事实，例如，河边有头狮子；而在认知革命之后，智人产生了可以叙述故事的语言，这些故事也可以说是想象的实体，例如上帝，国家，企业等等，而正是这些想象的实体，智人才打败其他人种和动物，登上食物链顶端；因为就算是大批互相不认识的人，只要同样相信某个故事，就能共同协作；</p>
<p>原来动物或其他人种可能只有几个人的小团伙协作，但是认知革命之后，智人通过故事可以让大批的人聚集在一起协作；因此如果是单打独斗，智人肯定是打不过狮子或者尼安德特人，但是智人可以聚集大量的智人一起协作对抗其他人种和动物，可以说这时的智人已经在地球上再也没有对手了，主宰折地球；</p>
<p>在距今7万年到1万年期间，智人开始从非洲开始走向世界，每到一个地方，靠着团队协作，打败了各种人种以及动物，甚至导致大量物种灭绝；就这样，智人成为地球上唯一的人种，智人主宰地球每个角落；</p>
<p>也有学者提出，认知革命是怎么产生的？书本提到说是基因突变，纯粹的偶然，毕竟历史就是由偶然的事件串起来的；正是因为这次基因突变，智人就绕开了基因演化的宿命，踏上文化演化的快车道；我们现在的人类的基因和认知革命前的基因相差不是很大，但是现在人类的生活已经和认知革命前智人的生活可以说完全不同；</p>
<h2>农业革命</h2>
<p>大约在距今1.2万年，此时的智人已经在地球的每个角落，并且靠着采集狩猎生活；在这之后，智人进行了第二次革命：农业革命；农业革命一直延续到距今500年前，也就是说公元前1万年到公园1500年，我们祖先开始过上了农民的生活，种植农作物和饲养动物；</p>
<p>农业革命之后，因为人类开始饲养动植物，所以人类也就没有过着四海为家采集狩猎的生活，而是在某个地方定居下来，过着日出而作，日落而息的生活；随着人类的聚集以及认知革命产生叙述故事的能力，开始出现城镇，王国，宗教，帝国等大型的想象的实体；后面的历史进入了人类文明史，智人开始生活在客观和主观，以及人类社会三个现实中，而动物还是生活在主观和客观现实中；</p>
<p>也有人说，农业革命是最大的骗局；对于智人整体而言，农业革命是历史的进步；但是对于智人个体而言却是退步；</p>
<ol>
<li>因为人类的定居，因此人类更容易遭受洪涝灾害的影响；而采集狩猎时期的智人，因为四海为家，这边没食物，可以到其他地方觅食；</li>
<li>其次智人的食物单一，营养还不如采集狩猎时期的营养丰富，采集狩猎时期，智人食物多样化；</li>
<li>其次是疾病的传播；因为人类聚居在一起，使得疾病更加容易传播；</li>
</ol>
<p>农业革命还有一个重大的成就，就是文字的发明；当时的帝国要记录交易和税收，军用物资和商品的库存量，但是人的大脑存储有限，而且人类总难免一死以及人类的大脑只存储特定类型的信息；因此就导致了文字的产生；公元前3000年左右，苏美尔人产生了最早的文字；</p>
<p>正是想象构建的秩序和文字的发明，弥补了我们基因的不足，人类社会就这样继续前行着；</p>
<h2>人类融合</h2>
<p>农业革命后，人类从一开始各个独立生活在自己的小区域慢慢走向了融合；赫拉利提到，促成人类走向融合的有三大因素：金钱，帝国和宗教；</p>
<p>在原始社会，人与人之间的交换主要是物物交换；例如，10个苹果换区一双鞋；但是有些时候，鞋匠不一定需要10个苹果，因此这时买鞋的人就无法与鞋匠进行交换；后来演化为用一个特定的以物易物系统，分别从不同专业农夫和制造商取得物品，然后再分配到需要人手里；后来又发明了金钱的概念，不一定是硬币或钞票，因为金钱也是人的想象出来，只要大家相信，任何东西都可以代表其他物品交换；一开始用贝壳，后来用银金属，最后才到纸币电子货币；</p>
<p>帝国主要有两个因素，一个是多民族，一个是领土可以灵活调整；历史上出现较大的帝国有古希腊帝国，古罗马帝国，奥斯特土耳其帝国等等；帝国将不同的民族收为统一管理，使各个民族的生活习惯，语言，文化等等趋于统一，人类更加融合；</p>
<p>一开始，采集狩猎时期，学者普遍认可泛神论；后来演进成了多神论，二元论，一神论以及现在的人文主义宗教；在科学革命之前，人类信仰上帝，而科学革命之后，人文主义兴起，人类相信自己的感觉；</p>
<h2>科学革命</h2>
<p>在距今500面前，智人进行了第三次革命：科学革命；科学革命最主要的成就可以说有两方面，一个是人文主义的兴起，一个是工业革命；人文主义的兴起，人类从信仰上帝转变为相信自己的感觉；人类的生活的意义不再是为了上帝某个计划而活，而是凭着自己的感觉而活；而工业革命大大提高了人类的力量，促进人类经济，政治各方面的极大提高；</p>
<p>对于科学革命，赫拉利在书本中提到，促成科学革命的两股力量主要是帝国和资本；</p>
<p>《大国崛起》讲述的就是16世纪以来，也就是科学革命以来9个世界大国的崛起；最开始，葡萄牙由于领土的狭小，资源短缺，当时国力也不是西班牙的对手，因此为了经济的发展，只能往航海新航线探索，这也开始了欧洲帝国殖民全球的历史；在殖民的过程中，列强往往会带着各行业的人才，生物学，地质学，地理学等等，在殖民地进行考察收集数据；这也是当时科学能快速发展的一方面原因；</p>
<p>另一个原因就是资本主义的兴起；帝国在殖民过程中，需要消耗大量的金钱，如果每次都是向国民收税，国民早就民不聊生，暴乱四起；荷兰最早兴起资本主义；当荷兰在殖民东南亚时，除了向国民征税外，还建立了东印度公司；东印度公司向社会筹集战争资金，然后通过殖民获取财富，再反馈给股东，这样就建立一个正向反馈；也正是相信战争能获取财富，因此欧洲国家才投资发展热兵器，如枪，大炮以及各种技术的研究；</p>
<p>资本主义也是主要依赖于人的信任，信赖未来会获得财富，所以才会有人投资；这个概念现在也适用；当今，风投公司将资本投向创业公司，也是因为相信所投创业公司可以上市盈利，而所投创业公司最后上市之后，风投公司就可以分红或者股票套现，获取财富；</p>
<p>科学革命最后一部分还提到，人文主义为现代社会提供了意义，而科学为现代社会提供力量；人们就这样快乐的生活着了吗？然而随机生命科学与信息技术的发展，人类社会遭遇了第二次认知革命，这些将会在《未来简史》中介绍；</p>
<h1>《未来简史》</h1>
<hr>
<p>如果看过《人类简史》，《未来简史》会比较好看懂，因为《未来简史》大部分还是在说历史，为未来做铺垫，只有最后一部分，预测未来的发展方向；</p>
<p>《未来简史》最主要的论断就是生物也是算法，碳基或者叫做有机算法，而计算机属于硅基算法或者叫做无机算法；既然二者同属算法，那么生物和计算是可以相互交流，通过基因改造技术或者植入芯片的方式，使智人上升为超人类；或者通过人工智能方式，产生比人类更智能的物种，新物种接管人类；这也导致产生新的宗教：科技人文主义和数据主义；</p>
<h2>人类的新议题</h2>
<p>这一章节，赫拉利通过大量的例子证明了自科学革命以来，人类战胜了饥荒，瘟疫和战争；而在第三个千年之际，人类开始了追求新的三个议题：长生不死，快乐和神性；</p>
<p>这三个方面可以很好理解，人类在战胜了饥荒，瘟疫和战争之后，在人文主义宗教之下，因为没了突如其来的死亡，但是终将寿终正寝，因此人类就开始了永生的追求；而人类永生，漫漫人生，肯定不想充满痛苦，因此开始对快乐的追求；而人类的贪然，希望把生活的大部分甚至是外太空纳到自己的控制之下，必定追求更高的力量；</p>
<p>这一章节还通过绿色草坪的例子，说明研究历史的意义：不是为了预测未来，而是要将会自己从过去中释放出来，想象是否有另一种可能；而这本书的标题《未来简史》主要是基于过去300的未来，因此赫拉利提到，为了题解未来，我们需要再回头，了解智人是怎样的生物，人文主义如何成为主导世界的宗教以及为什么实现人文主义的梦想反而导致人文主义的崩塌；</p>
<h2>智人征服世界</h2>
<p>这部分主要讲了三点：</p>
<ol>
<li>人类与其他动物有什么不同？</li>
<li>人类如何征服世界？</li>
<li>智人究竟是以高等的生命形式，还是欺凌其他物种的地痞流氓？</li>
</ol>
<p>生物也是算法，人类99%的决定，包括关于配偶，事业和住处的选择，都是由各种进化而成的算法来处理，我们把这些算法称为感觉，情感和欲望；</p>
<p>现代科学和工业的兴起，带来了人和动物关系的第二次革命；农业革命中，人类让泛灵论只剩下人类和神的对话；而到了科学革命，连神也去掉了，人类成了整个世界的独角兽；</p>
<p>人类与其他动物到底有什么不同？其实人类和其他物种并没有特别之处，人类的情感欲望动物也有，真正让人类统治地球，就是虚构故事的能力，人类洒下的意义之网；</p>
<h2>智人为世界赋予意义</h2>
<p>这一章节还是在说明人类的为世界赋予的意义，包括神，城市，国家，文字，公司以及各种品牌等；</p>
<p>同时提到现代科学和宗教的关系；在科学革命之前，人类有意义(宗教)，却没力量；而科学革命之后，人类有了科技，力量得到大幅度提升，而人类也不相信上帝的存在，为什么人类社会没有崩塌(宗教的意义就在于维护人类秩序)？原因就在于新的宗教－人文主义的兴起；科学提供力量，人文主义提供意义和秩序；</p>
<p>人文主义就是说人类生活意义不在是某个超人类的计划，而是相信自己的感觉，自由意志才是最高的权威；书上提到以下小点人文主义：</p>
<ol>
<li>人文主义政治：选民能做出最好的选择</li>
<li>人文主义经济：顾客永远是对的</li>
<li>人文主义美学：看的人觉得美，就是美</li>
<li>人文主义伦理：感觉对了，就去做吧(同性恋)</li>
<li>人文主义教育：为自己想</li>
</ol>
<p>人文主义兴起之后，更加注重人的感觉；在科学革命之前，书上对战争的描述主要描述战争这件事实；而人文主义兴起之后，书上对战争的描述主要是考虑士兵个体的感受；</p>
<p>人文主义在发展过程中，产生了三个分支：进化人文主义，自由人文主义，社会人文主义；</p>
<ul>
<li>进化人文主义　最为代表就是德国纳粹激进民族主义；觉得自己民族是最优民族，灭绝把次等民族，防止次等民族污染优等民族的基因；</li>
<li>自由人文主义　认为每个人都是独特的个体，拥有独一无二的内在声音；</li>
<li>社会人文主义　考虑更多的集体的感受，而不是个人的利益；
目前，世界上的国家主要是自由人文主义和社会主义，例如俄罗斯和中国就是社会主义，发展社会主义经济；而美国和欧洲国家就是自由人文主义，发展资本主义经济；</li>
</ul>
<h2>智人失去控制权</h2>
<p>这章节才是开始预测未来可能发生的趋势；首先提出生命科学的发展，戳破了人文主义的想法，自由个人也是一个虚构的故事，人只是生化算法的组合；既然人是生化算法的组合，那么有机算法和无机算法都有智能，有机算法只是比无机算法多了一个意识，但是无机算法会比人类更加智能；但是在大多数情况下下，人们只需要智能而不要意识，例如谷歌和特斯拉的无人驾驶汽车，如果同是把人运输到目的地，那么这需要智能即可，对于意识可有可无；因此未来很多职业会被算法代替，会产生很多无用阶级；</p>
<p>由《智能时代》我们知道，当数据量大到一定程度时，算法可能会比我们自己更加了解自己；而且生物也是算法，那么由于无机算法比有机算法更加智能，权威将会从个人转移到算法；人将被无机算法淘汰，就向其他动物被人类淘汰一样；人将更加信赖算法，这就导致人文主义的崩塌；</p>
<p>科技人文主义：通过基因工程，纳米技术和脑机界面升级智人，智人将上升为神人，拥有超人类的力量，例如更强大的记忆力，更加智慧的大脑，更加庞大的心理频谱等；</p>
<p>数据主义：人类和人类社会就是一个数据处理系统，当数据量大到人类大脑不能处理时，就需要借助于更加强大电子算法；而且电子算法比我们自己将更加了解自己；</p>
<p>最后把《未来简史》提出三项未来发展列出：</p>
<ol>
<li>生命科学指出所有生物都是算法，而生命是进行数据处理；</li>
<li>智能正在和意识脱钩；</li>
<li>无意识但具备高度智能的算法，可能很快就会比我们更了解自己；</li>
</ol>
<h1>感悟</h1>
<hr>
<p>《人类简史》和《未来简史》是我读到书里面，使我世界观大为改变的两本书(当然，我读书不多，哈哈)，强烈推荐阅读；从人类诞生之初到现代社会，由从现代社会预测未来的可能性，而且这种预测是完全有可能实现，对我们做好未来的准备也很有参考意义。</p>
]]></content>
      
        <categories>
            
            <category> reading </category>
            
        </categories>
        
        
        <tags>
            
            <tag> reading </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SeaweedFS概述]]></title>
      <url>http://luodw.cc/2017/01/05/weedfs/</url>
      <content type="html"><![CDATA[<p>文件系统在后端开发中，是非常重要的组件，当有存储图片或者视频的时候，文件系统就派上用场了；例如阿里为淘宝上的大量图片存储开发了分布式文件系统TFS和FastDFS，有些直播软件上视频也是存储在文件系统上等等；因此如果是从事后端开发或者分布式存储开发，也必须好好学习研究下文件系统；seaweedfs文件系统实现了Facebook's Haystack文件系统设计论文，它并不支持Linux操作系统中POSIX文件系统语义，而是选择实现了key-&gt;file存储形式，类似于NoSQL，我们也可以称呼为NoFS；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-a123.JPG" alt="100篇博客，上本人照片"></p>
<p>这篇博客，不会深入分析seaweedfs文件系统原理，这里只是简单的介绍，作为之前一段时间的总结；所以这篇文章包括下面３小点:</p>
<ol>
<li>seaweedfs文件系统架构;</li>
<li>seaweedfs操作例子;</li>
<li>总结;</li>
</ol>
<h1>SeaweedFS文件系统架构</h1>
<hr>
<p>分布式文件系统的拓扑结构大体都类似，分为NameNode和DataNode，NameNode负责管理数据节点拓扑结构以及元数据，DataNode负责真实数据存储；在seaweedfs文件系统中，NameNode称为Master，DataNode称为VolumeServer；我们先来看下seaweedfs文件系统整体的拓扑结构:</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_07861.JPG" alt="seaweedfs文件系统拓扑结构"></p>
<p>由架构图可以看出，</p>
<ul>
<li>Master负责管理集群的拓扑结构，分为主从结构，并采用raft实现主从复制和高可用，以此消除单点问题；TFS中的NameNode为了消除单点问题，采取的是虚拟IP配上lvs；</li>
<li>DataNode负责存储具体数据，并与M-Master保持心跳，上报自己的存储信息；</li>
</ul>
<p>当客户端需要存储数据时，</p>
<ol>
<li>需要先给M-Master发送请求，获取该文件存储的DataNode地址，文件存储的VolumeID以及文件fid;</li>
<li>然后客户端接着将文件发送至从Master获取到的DataNode，DataNode会根据VolumeID找到相应的Volume，并将文件存储到该Volume;</li>
</ol>
<blockquote>
<p>分布式文件系统数据节点存储数据时，会创建出若干个大文件(可以想象为磁盘)，用于存储小文件，例如文件，短视频等等；在seaweedfs中，大文件就称为Volume；</p>
</blockquote>
<p>ok，上述是正常情况下seaweedfs运行时的整体架构图，但是机器的东西，说不准哪天就挂了，特别是Master，因为Master挂了，整个文件系统就不可用了；在seaweedfs是通过raft实现高可用，即使M-Master挂了，会通过选举算法，在S-Master选举出新的M-Master，然后所有DataNode则将自己的信息上报给新的M-Master；结构图如下:</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_07871.JPG" alt="选举新M-Master"></p>
<p>图中可以看出，当M-Master挂了之后，剩余两个S-Master会进行选举，产生新的M-Master，此时所有的DataNode将会连接到新的M-Master，并上报自己的存储信息；而客户端下次需要存储文件时，会先到选举产生的新M-Master获取DataNode信息，然后再将文件存储到具体DataNode；</p>
<p>这里，client是如何连接到新的M-Master的，我不是很清楚，因此没有在实际生产环境中部署使用过，但是我觉得可以通过客户端轮询来实现;</p>
<p>接下来，我们来看下Master拓扑结构，如下图:</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_07881.JPG" alt="Master拓扑结构"></p>
<p>seaweedfs拓扑结构主要有三个概念，数据中心(DataCenter)，机架(Rack)，数据节点(DataNode)；这样可以很灵活配置不同数据中心，同一个数据中心下不同机架，同一机架下不同的数据节点；数据都是存储在DataNode中；</p>
<p>最后再来看下DataNode存储节点Volumn布局；如下:
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="code">+-------------+</span></div><div class="line"><span class="section">| SuperBlock  |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle1     |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle2     |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle3     |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle...   |</span></div><div class="line">+-------------+</div></pre></td></tr></table></figure></p>
<p>一般情况下，一个DataNode会配置多个Volume，这样可以避免多个客户端对同一个Volume读写争抢；每个Volume由一个SuperBlock和若干个Needle组成；每个Needle则代表一个小文件，例如图片和短视频；</p>
<h1>SeaweedFS操作例子</h1>
<hr>
<p>客户端访问seaweedfs，主要是通过http协议，我们通过以下例子来说明；首先开启一个Master以及两个DataNode
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./weed master</div><div class="line">./weed <span class="keyword">volume</span><span class="bash"> -dir=<span class="string">"/tmp/1"</span> -max=5  -mserver=<span class="string">"localhost:9333"</span> -port=8080</span></div><div class="line">./weed <span class="keyword">volume</span><span class="bash"> -dir=<span class="string">"/tmp/2"</span> -max=5  -mserver=<span class="string">"localhost:9333"</span> -port=8081</span></div></pre></td></tr></table></figure></p>
<p>-dir表示该DataNode数据存储的目录，-max表示volume个数最大值，-mserver表示Master地址，-port该DataNode监听的端口；</p>
<p>首先从Master获取一个fid:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; curl -X POST http://localhost:9333/dir/assign</div><div class="line">&#123;<span class="string">"fid"</span>:<span class="string">"3,017ebf0b02"</span>,<span class="string">"url"</span>:<span class="string">"127.0.0.1:8081"</span>,<span class="string">"publicUrl"</span>:<span class="string">"127.0.0.1:8081"</span>,<span class="string">"count"</span>:1&#125;</div></pre></td></tr></table></figure></p>
<p>这里fid中，3表示volumeid，01表示文件的序号，7ebf0b02表示cookie</p>
<p>然后，我们访问127.0.0.1:8081，并传入fid以及文件存储，如下:
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; curl -X PUT -F <span class="keyword">file</span>=@<span class="regexp">/home/</span>charles<span class="regexp">/myphoto.jpg http:/</span><span class="regexp">/127.0.0.1:8081/</span><span class="number">3</span>,<span class="number">017</span>ebf0b02</div><div class="line">&#123;<span class="string">"name"</span>:<span class="string">"myphoto.jpg"</span>,<span class="string">"size"</span>:<span class="number">61188</span>&#125;</div></pre></td></tr></table></figure></p>
<p>这样，图片就已经存储到127.0.0.1:8081DataNode上第3个volume上了；我们可以在浏览器通过链接http://127.0.0.1:8081/3,017ebf0b02访问到刚才存储的图片；</p>
<h1>总结</h1>
<hr>
<p>这篇文章只是简单的介绍seaweedfs的架构以及原理，同时通过简单的上传图片展示如何使用seaweedfs，算是学习记录，也希望给看者入门材料；之前在实习时，看了TFS，了解文件系统大体架构，因此看快就熟悉了seaweedfs的架构；但是seaweedfs使用的是http协议，而TFS使用的是自己设置的协议并且是C++编写，seaweedfs会比TFS简单易懂，而且自带系统后台，方便查看集群信息；</p>
]]></content>
      
        <categories>
            
            <category> weedfs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSQ源码分析之nsqlookupd]]></title>
      <url>http://luodw.cc/2016/12/13/nsqlookupd/</url>
      <content type="html"><![CDATA[<p>上篇文章介绍了NSQ整体概述以及拓扑结构；这篇文章开始分析下NSQ源码；NSQ主要由三个部分nsqd,nsqlookupd,nsqadmin以及一些工具组成，我们从简单的nsqlookupd开始分析源码；nsqlookupd是nsq管理集群拓扑信息以及用于注册和发现nsqd服务；所以，也可以把nsqlookupd理解为注册发现服务；当nsq集群中有多个nsqlookupd服务时，因为每个nsqd都会向所有的nsqlookupd上报本地信息，因此nsqlookupd具有最终一致性；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_0718.JPG" alt="厦门狮山"></p>
<p>这篇文章主要从以下几个方面来分析下nsqlookupd源码：</p>
<ol>
<li>nsqlookupd运行过程；</li>
<li>nsqlookupd优秀设计；</li>
<li>总结；</li>
</ol>
<h1>nsqlookupd运行过程</h1>
<hr>
<h2>NSQ目录结构</h2>
<p>在看nsqlookupd源码之前，先来看下NSQ的目录结构；NSQ目录结构设计也很清晰，从目录就可以看出各个模块什么意思；</p>
<ol>
<li>apps　目录存放了nsqd, nsqlookupd, nsqadmin和一些工具的main函数文件；</li>
<li>internal　目录存放了NSQ内部使用的一些函数，例如三大组件通用函数；</li>
<li>nsqadmin　目录存放了关于nsqadmin源码；</li>
<li>nsqd　目录存放了关于nsqd源码；</li>
<li>nsqlookupd　目录存放了　nsqlookupd的源码；</li>
</ol>
<p>因此如果看nsqlookupd源码的话，我们首先需要看apps/nsqlookupd目录下的nsqlookupd.go文件；</p>
<h2>nsqlookupd启动函数</h2>
<p>NSQ的nsqd和nsqlookupd组件都使用了开源组件</p>
<blockquote>
<p>&quot;github.com/judwhite/go-svc/svc&quot;</p>
</blockquote>
<p>来管理进程的初始化，启动和关闭；我们先来看下main函数
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> program <span class="keyword">struct</span> &#123;</div><div class="line">	nsqlookupd *nsqlookupd.NSQLookupd</div><div class="line">&#125;<span class="comment">//nsqlookupd启动服务实例</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	prg := &amp;program&#123;&#125;</div><div class="line">	<span class="keyword">if</span> err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>svc.run方法接收一个实现了init,start和stop方法的服务实例，以及若干信号；信号用于控制该服务的优雅终止，而服务实例用于开启nsqlookupd服务；</p>
<p>我们来看下program的start方法；
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *program)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	flagSet.Parse(os.Args[<span class="number">1</span>:])</div><div class="line"></div><div class="line">	<span class="keyword">if</span> *showVersion &#123;</div><div class="line">		fmt.Println(version.String(<span class="string">"nsqlookupd"</span>))</div><div class="line">		os.Exit(<span class="number">0</span>)</div><div class="line">	&#125;<span class="comment">//如果只是查看版本号，则显示版本号并退出</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> cfg <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</div><div class="line">	<span class="keyword">if</span> *config != <span class="string">""</span> &#123;</div><div class="line">		_, err := toml.DecodeFile(*config, &amp;cfg)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Fatalf(<span class="string">"ERROR: failed to load config file %s - %s"</span>, *config, err.Error())</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="comment">//从配置文件解析配置信息</span></div><div class="line"></div><div class="line">	opts := nsqlookupd.NewOptions()</div><div class="line">	options.Resolve(opts, flagSet, cfg)</div><div class="line">	<span class="comment">//实例化一个nsqlookupd实例</span></div><div class="line">	daemon := nsqlookupd.New(opts)</div><div class="line">	<span class="comment">//调用nsqlookupd的Main方法</span></div><div class="line">	daemon.Main()</div><div class="line">	p.nsqlookupd = daemon</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数用于调用nsqlookupd的Main函数，而Main函数才是nsqlookupd模块启动的主体函数；当这个Start函数返回之后，整个程序阻塞在svc.Run方法内部的信号channel上；当我们向这个程序发送SIGINT和SIGTERM信号时，svc.Run函数调用program.Stop方法终止nsqlookupd进程。</p>
<h2>nsqlookupd模块之Main函数</h2>
<p>之前的分析都还是在apps/nsqlookupd目录下，通过之前调用nsqlookupd.Main方法，将代码切换到了nsqlookupd目录下；ok，我们直接找到nsqlookupd/nsqlookupd.Main方法；
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *NSQLookupd)</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">//整个nsqlookupd模块上下文</span></div><div class="line">	ctx := &amp;Context&#123;l&#125;</div><div class="line"></div><div class="line">	tcpListener, err := net.Listen(<span class="string">"tcp"</span>, l.opts.TCPAddress)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		l.logf(<span class="string">"FATAL: listen (%s) failed - %s"</span>, l.opts.TCPAddress, err)</div><div class="line">		os.Exit(<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">	l.Lock()</div><div class="line">	l.tcpListener = tcpListener</div><div class="line">	l.Unlock()</div><div class="line">	tcpServer := &amp;tcpServer&#123;ctx: ctx&#125;</div><div class="line">	<span class="comment">//开启nsqlookupd的tcp服务</span></div><div class="line">	l.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		protocol.TCPServer(tcpListener, tcpServer, l.opts.Logger)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	httpListener, err := net.Listen(<span class="string">"tcp"</span>, l.opts.HTTPAddress)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		l.logf(<span class="string">"FATAL: listen (%s) failed - %s"</span>, l.opts.HTTPAddress, err)</div><div class="line">		os.Exit(<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">	l.Lock()</div><div class="line">	l.httpListener = httpListener</div><div class="line">	l.Unlock()</div><div class="line">	httpServer := newHTTPServer(ctx)</div><div class="line">	<span class="comment">//开启nsqlookupd的http服务</span></div><div class="line">	l.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		http_api.Serve(httpListener, httpServer, <span class="string">"HTTP"</span>, l.opts.Logger)</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，l.waitGroup是sync.WaitGroup的子类，该类的Wrap方法用于在新的goroutine调用参数func函数；因此在执行Main方法之后，此时nsqlookupd进程就另外开启了两个goroutine，一个用于执行tcp服务，一个用于执行http服务；我们分别来看下；</p>
<h2>nsqlookupd之tcp服务；</h2>
<p>上篇文章有说道，nsqlookupd的tcp服务是用于处理nsqd上报信息的；我们顺着之前的Main方法，找到开启tcp服务的代码internal/protocol/tcp_server.go，如下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TCPHandler <span class="keyword">interface</span> &#123;</div><div class="line">	Handle(net.Conn)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TCPServer</span><span class="params">(listener net.Listener, handler TCPHandler, l app.Logger)</span></span> &#123;</div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"TCP: listening on %s"</span>, listener.Addr()))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		clientConn, err := listener.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</div><div class="line">				l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"NOTICE: temporary Accept() failure - %s"</span>, err))</div><div class="line">				runtime.Gosched()</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// theres no direct way to detect this error because it is not exposed</span></div><div class="line">			<span class="keyword">if</span> !strings.Contains(err.Error(), <span class="string">"use of closed network connection"</span>) &#123;</div><div class="line">				l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"ERROR: listener.Accept() - %s"</span>, err))</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">go</span> handler.Handle(clientConn)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"TCP: closing %s"</span>, listener.Addr()))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个TCPServer函数是公共函数部分，因此这个函数也用于nsqd的tcp服务；这个函数和平时见到的golang网络编程模型一样，在一个for循环中，接收一个客户端，并开启一个新的goroutine来处理这个客户端；</p>
<p>接下来，看下这个TCPHandler，这是个接口，这个接口包含Handle(net.Conn)方法，从Main方法可以看出，传入的TCPHandler是类tcpServer；我们接下来看下，在文件nsqlookupd/tcp.go:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> tcpServer <span class="keyword">struct</span> &#123;</div><div class="line">	ctx *context</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tcpServer)</span> <span class="title">Handle</span><span class="params">(clientConn net.Conn)</span></span> &#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">var</span> prot protocol.Protocol</div><div class="line">	<span class="keyword">switch</span> protocolMagic &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"  V1"</span>:</div><div class="line">		prot = &amp;LookupProtocolV1&#123;ctx: p.ctx&#125;</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		protocol.SendResponse(clientConn, []<span class="keyword">byte</span>(<span class="string">"E_BAD_PROTOCOL"</span>))</div><div class="line">		clientConn.Close()</div><div class="line">		p.ctx.nsqlookupd.logf(<span class="string">"ERROR: client(%s) bad protocol magic '%s'"</span>,</div><div class="line">			clientConn.RemoteAddr(), protocolMagic)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = prot.IOLoop(clientConn)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		p.ctx.nsqlookupd.logf(<span class="string">"ERROR: client(%s) - %s"</span>, clientConn.RemoteAddr(), err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	......</div></pre></td></tr></table></figure></p>
<p>这个tcpServer只有一个成员ctx，之前在Main函数有看到，这个context只有一个成员，即这个nsqlookupd实例的地址；这个context其实主要作用就是在各模块间传递nsqlookupd这个实例，便于访问nsqlookupd地址；nsq协议有默认(其实就是v0)和v1，因此代码有根据协议的版本执行不同的代码；我们以协议v1为例；这个Handle方法最后调用了LookupProtocolV1.IOLoop方法；由名字可以看出这个IOLoop函数是一个循环，我们来看下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">...........<span class="comment">//省去一些代码</span></div><div class="line">client := NewClientV1(conn)</div><div class="line">reader := bufio.NewReader(client)</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">	<span class="comment">//读取用户的请求命令</span></div><div class="line">	line, err = reader.ReadString(<span class="string">'\n'</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">break</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	line = strings.TrimSpace(line)</div><div class="line">	<span class="comment">//按空格切割用户请求，params存储的就是用户请求命令以及参数</span></div><div class="line">	params := strings.Split(line, <span class="string">" "</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> response []<span class="keyword">byte</span></div><div class="line">	<span class="comment">//执行请求并返回结果</span></div><div class="line">	response, err = p.Exec(client, reader, params)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		ctx := <span class="string">""</span></div><div class="line">		<span class="keyword">if</span> parentErr := err.(protocol.ChildErr).Parent(); parentErr != <span class="literal">nil</span> &#123;</div><div class="line">			ctx = <span class="string">" - "</span> + parentErr.Error()</div><div class="line">		&#125;</div><div class="line">		p.ctx.nsqlookupd.logf(<span class="string">"ERROR: [%s] - %s%s"</span>, client, err, ctx)</div><div class="line"></div><div class="line">		_, sendErr := protocol.SendResponse(client, []<span class="keyword">byte</span>(err.Error()))</div><div class="line">		<span class="keyword">if</span> sendErr != <span class="literal">nil</span> &#123;</div><div class="line">			p.ctx.nsqlookupd.logf(<span class="string">"ERROR: [%s] - %s%s"</span>, client, sendErr, ctx)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// errors of type FatalClientErr should forceably close the connection</span></div><div class="line">		<span class="keyword">if</span> _, ok := err.(*protocol.FatalClientErr); ok &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">continue</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> response != <span class="literal">nil</span> &#123;</div><div class="line">		_, err = protocol.SendResponse(client, response)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后这个客户端的goroutine就在这个循环中不断执行用户(其实就是nsqd服务)请求；过程如下:</p>
<ol>
<li>读取用户请求；</li>
<li>将用户请求字符串按空格切割成字符串数组；</li>
<li>调用LookupProtocolV1.Exec方法，执行具体请求；</li>
</ol>
<p>最后来看下LookupProtocolV1.Exec方法;
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *LookupProtocolV1)</span> <span class="title">Exec</span><span class="params">(client *ClientV1, reader *bufio.Reader, params []<span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">switch</span> params[<span class="number">0</span>] &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"PING"</span>:</div><div class="line">		<span class="keyword">return</span> p.PING(client, params)</div><div class="line">	<span class="keyword">case</span> <span class="string">"IDENTIFY"</span>:</div><div class="line">		<span class="keyword">return</span> p.IDENTIFY(client, reader, params[<span class="number">1</span>:])</div><div class="line">	<span class="keyword">case</span> <span class="string">"REGISTER"</span>:</div><div class="line">		<span class="keyword">return</span> p.REGISTER(client, reader, params[<span class="number">1</span>:])</div><div class="line">	<span class="keyword">case</span> <span class="string">"UNREGISTER"</span>:</div><div class="line">		<span class="keyword">return</span> p.UNREGISTER(client, reader, params[<span class="number">1</span>:])</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, fmt.Sprintf(<span class="string">"invalid command %s"</span>, params[<span class="number">0</span>]))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个函数可以看出，nsqd向nsqlookupd发送的信息只有上述四个命令，我分别说明下:</p>
<ol>
<li>PING nsqd每隔一段时间都会向nsqlookupd发送心跳，表明自己还活着；</li>
<li>IDENTITY 当nsqd第一次连接nsqlookupd时，发送IDENTITY，验证自己身份；</li>
<li>REGISTER 当nsqd创建一个topic或者channel时，向nsqlookupd发送REGISTER请求，在nsqlookupd上更新当前nsqd的topic或者channel信息；</li>
<li>UNREGISTER 当nsqd删除一个topic或者channel时，向nsqlookupd发送UNREGISTER请求，在nsqlookupd上更新当前nsqd的topic或者channel信息；
具体各个命令怎么执行，这里就不去分析了；需要提一点是，nsqd的信息是保存在registration_db这样的实例里面的；</li>
</ol>
<p>我们来总结下nsqlookupd的tcp执行流程:</p>
<ol>
<li>首先在Main函数开启一个goroutine来开启一个tcp循环，接收nsqd连接请求；</li>
<li>当接收到一个nsqd接请求时，开启一个goroutine来处理这个nsqd；</li>
<li>这个nsqd先是经历tcpServer.Handle函数，然后到LookupProtocolV1.IOLoop函数，并阻塞在此函数中；</li>
<li>当nsqd发送请求时，LookupProtocolV1.IOLoop函数先是读取该请求，并调用LookupProtocolV1.Exec函数执行具体请求；</li>
</ol>
<h2>nsqlookupd之http服务</h2>
<p>nsqlookupd的http服务是用于向nsqadmin提供查询接口的，本质上，就是一个web服务器，提供http查询接口；我们顺着Main函数，来看下http是怎么运行的，在文件internel/http_api/http_server.go中
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(listener net.Listener, handler http.Handler, proto <span class="keyword">string</span>, l app.Logger)</span></span> &#123;</div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"%s: listening on %s"</span>, proto, listener.Addr()))</div><div class="line"></div><div class="line">	server := &amp;http.Server&#123;</div><div class="line">		Handler:  handler,</div><div class="line">		ErrorLog: log.New(logWriter&#123;l&#125;, <span class="string">""</span>, <span class="number">0</span>),</div><div class="line">	&#125;</div><div class="line">	err := server.Serve(listener)</div><div class="line">	<span class="comment">// theres no direct way to detect this error because it is not exposed</span></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !strings.Contains(err.Error(), <span class="string">"use of closed network connection"</span>) &#123;</div><div class="line">		l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"ERROR: http.Serve() - %s"</span>, err))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"%s: closing %s"</span>, proto, listener.Addr()))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数也很简单，实例化http.Server模块，然后调用server.Server(listner)函数开启http服务；如果之前有看过golang的http模块，应该知道http模块最重要的就是http.Handler，因为http.Handler提供了路由查询，视图函数执行功能；在Main函数看到传入的http.Handler是newHTTPServer这个类，我们来看下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> httpServer <span class="keyword">struct</span> &#123;</div><div class="line">	ctx    *Context</div><div class="line">	router http.Handler</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHTTPServer</span><span class="params">(ctx *Context)</span> *<span class="title">httpServer</span></span> &#123;</div><div class="line">	log := http_api.Log(ctx.nsqlookupd.opts.Logger)</div><div class="line">	<span class="comment">//实例化一个httprouter</span></div><div class="line">	router := httprouter.New()</div><div class="line">	router.HandleMethodNotAllowed = <span class="literal">true</span></div><div class="line">	<span class="comment">//设置panic时的处理函数</span></div><div class="line">	router.PanicHandler = http_api.LogPanicHandler(ctx.nsqlookupd.opts.Logger)</div><div class="line">	<span class="comment">//设置not found处理函数</span></div><div class="line">	router.NotFound = http_api.LogNotFoundHandler(ctx.nsqlookupd.opts.Logger)</div><div class="line">	<span class="comment">//当请求方法不支持时的处理函数</span></div><div class="line">	router.MethodNotAllowed = http_api.LogMethodNotAllowedHandler(ctx.nsqlookupd.opts.Logger)</div><div class="line">	s := &amp;httpServer&#123;</div><div class="line">		ctx:    ctx,</div><div class="line">		router: router,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	router.Handle(<span class="string">"GET"</span>, <span class="string">"/ping"</span>, http_api.Decorate(s.pingHandler, log, http_api.PlainText))</div><div class="line">	<span class="comment">//省略后续路由定义</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *httpServer)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">	s.router.ServeHTTP(w, req)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>nsqlookupd的http服务路由使用的是开源框架httprouter；httprouter路由使用radix树来存储路由信息，路由查找上效率高，同时提供一些其他优秀特性，因此很受欢迎，gin web框架使用的就是httprouter路由；</p>
<p>这个httpServer有两个成员属性，一个是context，用于传递nsqlookupd地址，一个是httprouter实例，用于定义路由以及提供路由查找入口；这个httpServer.ServerHTTP函数内部调用httprouter.ServerHTTP来处理http请求；</p>
<p>针对这个函数，我们最后再来看下路由定义中的http_api.Decorate函数，在文件internal/http_api/api_response.go
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decorate</span><span class="params">(f APIHandler, ds ...Decorator)</span> <span class="title">httprouter</span>.<span class="title">Handle</span></span> &#123;</div><div class="line">	decorated := f</div><div class="line">	<span class="keyword">for</span> _, decorate := <span class="keyword">range</span> ds &#123;</div><div class="line">		decorated = decorate(decorated)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">		decorated(w, req, ps)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数其实就是一个装饰器，第一个参数为需要被装饰的视图函数，从第二参数开始，都是装饰函数，最后返回装饰好的视图函数；http模块比较简单，和其他的web服务一样，很容易看懂；每个路由以及对应的视图函数比较多，这里就不一一解释了；</p>
<h1>nsqlookupd优秀设计</h1>
<hr>
<p>上部分主要分析了nsqlookupd执行过程，主要有两个方面，一个是tcp，另一个是http；这部分，我将根据自己的理解，写下我认为nsqlookupd优秀设计；学习开源框架，除了使用和了解原理外，我觉得学习开源框架优秀设计以及代码技巧也是非常有意义的一件事；</p>
<h2>优雅的代码启动方式和退出方式</h2>
<p>nsqlookupd模块使用开源框架svc来开启进程以及控制进程的退出；本人也一直很喜欢使用信号的方式来退出进程，这样可以在进程收到信号时，可以做一些扫尾操作；虽然svc也是用信号来控制进程退出，但是使用svc，使代码看起来更简介优雅；</p>
<h2>context的使用</h2>
<p>nsqlookupd服务使用context来保存上下文(nsqlookupd实例地址)，这样在每个模块就可以很方便地访问nsqdlookupd实例；这有点类似与golang1.7正式引入的context；</p>
<h2>代码复用</h2>
<p>接口的使用，使代码复用更加容易；而且golang的继承是非浸入式的，即不需要显示声明某结构体继承自某个接口，只要该结构体实现了接口定义的函数即可；例如internal/protocol/tcp_server.go
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">TCPHandler</span> interface &#123;</div><div class="line">	<span class="type">Handle</span>(net.<span class="type">Conn</span>)</div><div class="line">&#125;</div><div class="line"><span class="title">func</span> <span class="type">TCPServer</span>(listener net.<span class="type">Listener</span>, handler <span class="type">TCPHandler</span>, l app.<span class="type">Logger</span>)</div></pre></td></tr></table></figure></p>
<p>这个函数是用于开启tcp服务，nsqd和nsqlookupd都有使用，这里的TCPHandler就是一个接口，nsqd和nsqlookupd服务分别有相应的结构体实现了TCPHandler，然后传入这个函数中；</p>
<h2>视图函数封装</h2>
<p>在web开发过程中，每个路由都有对应的视图函数，当我们在执行一个视图函数时，我们有打印日志(例如请求执行时间)或者判断权限等需求；如果在写每个视图函数时，都手动添加日志打印，第一是麻烦，第二是代码冗余；如果用装饰器模式将会非常方便；nsqlookupd的http服务针对每个视图函数都进行了装饰；如果所有视图函数的装饰函数是一样，那么我们可以直接装饰在http.handler上，这样可以简化代码；python的bottle也提供了类似功能，但是bottle是以插件的形式引入装饰器；</p>
<h1>总结</h1>
<p>这篇文章分析了nsqlookupd服务执行过程以及分享了我自认为一些好的代码设计；nsqlookupd对golang主要特性channel使用比较少，我们将会在nsqd中看到NSQ是如何优雅使用goroutine和channel.</p>
]]></content>
      
        <categories>
            
            <category> nsq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nsq </tag>
            
            <tag> nsqlookupd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NSQ源码分析之概述]]></title>
      <url>http://luodw.cc/2016/12/08/nsq01/</url>
      <content type="html"><![CDATA[<p>消息队列在互联网公司使用非常普遍，因此也促使我去学习研究消息队列的原理以及细节问题；之前也有接触过消息队列，最主要就是在异步处理方面，当然消息队列还解耦，流量削峰等功能；目前消息队列产品也比较多，例如kafka，ActiveMQ，RabbitMQ，NSQ等等；之前原本打算看kafka，但是处于学习成本(kafka是scala编写，之前scala接触的比较少)，所以就先不看kafka，选择了NSQ；NSQ主要是golang编写，本人刚好非常喜欢golang这门语言，因此在学习NSQ的同时，也可以学习NSQ是如何优雅地使用golang;</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1802933924.jpg" alt="厦门飞机场"></p>
<p>目前，看了nsqlookupd的代码，写的真的很精美，我觉得代码可以和redis相媲美，这等后续分析代码时再详说；关于NSQ的特性，可以查看<a href="http://nsq.io/overview/features_and_guarantees.html" target="_blank" rel="external">NSQ官网</a>；这篇文章主要分析以下几点:</p>
<ol>
<li>NSQ概述;</li>
<li>python操作NSQ;</li>
<li>总结;</li>
</ol>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2016/12/08/nsq01/#more">http://luodw.cc/2016/12/08/nsq01/#more</a></p>
<h1>NSQ概述</h1>
<hr>
<p>NSQ提供了三大组件以及一些工具，三大组件为:</p>
<ol>
<li>nqsd NSQ主要组件，用于存储消息以及分发消息；</li>
<li>nsqlookupd 用于管理nsqd集群拓扑，提供查询nsqd主机地址的服务以及服务最终一致性；</li>
<li>nsqadmin 用于管理以及查看集群中的topic,channel,node等等；</li>
</ol>
<p>对于单机版，只需要用到nsqd就够了，但是单机会出现单点问题以及没有监控，因此如果是线上环境，都会部署nsqlookupd,nsqadmin以及nsqd集群；这里先给出我手绘的NSQ拓扑图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-3139862022.jpg" alt="NSQ拓扑"></p>
<p>NSQ的拓扑结构和文件系统的拓扑结构类似，有一个中心节点来管理集群节点；我们从图中可以看出:</p>
<ol>
<li>nsqlookupd服务同时开启tcp和http两个监听服务，nsqd会作为客户端，连上nsqlookupd的tcp服务，并上报自己的topic和channel信息，以及通过心跳机制判断nsqd状态；还有个http服务提供给nsqadmin获取集群信息；</li>
<li>nsqadmin只开启http服务，其实就是一个web服务，提供给客户端查询集群信息；</li>
<li>nsqd也会同时开启tcp和http服务，两个服务都可以提供给生产者和消费者，http服务还提供给nsqadmin获取该nsqd本地topic和channel信息；</li>
</ol>
<p>以上就是NSQ集群服务整体拓扑信息，下面来看下客户端方面；NSQ提供了多种语言的支持，比如go-nsq for golang，pynsq for python等；上述拓扑信息，我也是看了pynsq才弄懂了客户端是如何和nsq集群连接的；我们来看下:</p>
<ol>
<li>生产者会同时连上NSQ集群中所有nsqd节点，当然这些节点的地址是在Writer初始化时，通过外界传递进去；当发布消息时，writer会随机选择一个nsqd节点发布某个topic的消息；</li>
<li>消费者也会同时连上NSQ集群中所有nsqd节点，reader首先会连上nsqlookupd，获取集群中topic的所有producer，然后通过tcp连上所有producer节点，并在本地用tornado轮询每个连接，当某个连接有可读事件时，即有消息达到，处理即可；</li>
</ol>
<p>根据我自己的理解，说说NSQ优点:</p>
<ul>
<li>高可用(无单点问题) writer和reader是直接连上各个nsqd节点，因此即使nsqlookupd挂了，也不影响线上正常使用；即使某个nsqd节点挂了，writer发布消息时，发现节点挂了，可以选择其他节点(当然，这是客户端负责的)，单个节点挂了对reader无影响；</li>
<li>高性能 writer在发布消息时，是随机发布到集群中nsqd节点，因此在一定程序上达到负载均衡；reader同时监听着集群中所有nsqd节点，无论哪个节点有消息，都会投递到reader上；</li>
<li>高可扩展 当向集群中添加节点时，首先reader会通过nsqlookupd发现新的节点加入，并i自动连接；因为writer连接的nsqd节点的地址是初始化时设置的，因此增加节点时，只需要在初始化writer时，添加新节点的地址即可；</li>
</ul>
<p>ok，分析了NSQ集群整体的拓扑结构之后，我们来看下单个nsqd节点是如何处理消息的，下面给出官网提供的动图:
<img src="https://f.cloud.github.com/assets/187441/1700696/f1434dc8-6029-11e3-8a66-18ca4ea10aca.gif" alt="nsqd消息处理"></p>
<p>当向某个topic发布一个消息时，该消息会被复制到所有的channel，如果channel只有一个客户端，那么channel就将消息投递给这个客户端；如果channel的客户端不止一个，那么channel将把消息随机投递给任何一个客户端，这也可以看做是客户端的负载均衡；</p>
<h1>python操作nsq</h1>
<hr>
<p>NSQ官网上已经有NSQ快速入门操作，这里就不去讲述了，我们来看下python是如何操作nsq；首先要下载pynsq包，可以用
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install pynsq</div></pre></td></tr></table></figure></p>
<p>然后需要在三个终端分别开启nsqd，nsqlookupd和nsqadmin服务
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./nsqlookupd</div><div class="line">./nsqd --lookupd-tcp-address=127.0.0.1:4160</div><div class="line">./nsqadmin --lookupd-http-address=127.0.0.1:4161</div></pre></td></tr></table></figure></p>
<p>三个服务开启之后，我们就可以编写生产者和消费者；生产者代码如下：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> nsq</div><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub_message</span><span class="params">()</span>:</span></div><div class="line">    writer.pub(<span class="string">'test'</span>, time.strftime(<span class="string">'%H:%M:%S'</span>).encode(<span class="string">'utf-8'</span>), finish_pub)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish_pub</span><span class="params">(conn, data)</span>:</span></div><div class="line">    print(data)</div><div class="line"></div><div class="line">writer = nsq.Writer([<span class="string">'127.0.0.1:4150'</span>])</div><div class="line">tornado.ioloop.PeriodicCallback(pub_message, <span class="number">5000</span>).start()</div><div class="line">nsq.run()</div></pre></td></tr></table></figure></p>
<p>消费者代码如下：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> nsq</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(message)</span>:</span></div><div class="line">    print(message.body)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line">r = nsq.Reader(message_handler=handler,</div><div class="line">        nsqd_tcp_addresses=[<span class="string">'127.0.0.1:4150'</span>],</div><div class="line">        topic=<span class="string">'test'</span>, channel=<span class="string">'test'</span>, lookupd_poll_interval=<span class="number">15</span>)</div><div class="line">nsq.run()</div></pre></td></tr></table></figure></p>
<p>这里消费者，暂时连接到具体的nsqd实例，因为连接到nsqlookupd会报错，根据出错提示，应该是pynsq包对nsqlookupd返回的结果处理出错；</p>
<p>这里的生产者每隔5秒向'test' topic发送时间字符串，消费者可以得到这个时间字符串，我们可以看下上述生产者和消费的输出；
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生产者输出，返回ok，表示消息投递成功</span></div><div class="line">charles@charles-Aspire<span class="number">-4741</span>:~/mydir/pydir$ python3 nsq_producer.py </div><div class="line">b<span class="string">'OK'</span></div><div class="line">b<span class="string">'OK'</span></div><div class="line">b<span class="string">'OK'</span></div><div class="line">b<span class="string">'OK'</span></div><div class="line">.....</div><div class="line"><span class="comment">//消费者输出</span></div><div class="line">charles@charles-Aspire<span class="number">-4741</span>:~/mydir/pydir$ python3 nsq_consume.py </div><div class="line">b<span class="string">'19:36:11'</span></div><div class="line">b<span class="string">'19:36:16'</span></div><div class="line">b<span class="string">'19:36:21'</span></div><div class="line">b<span class="string">'19:36:26'</span></div><div class="line">b<span class="string">'19:36:31'</span></div><div class="line">.....</div></pre></td></tr></table></figure></p>
<p>上述就是python操作nsq最简单的示例程序；</p>
<h2>总结</h2>
<hr>
<p>这篇文章分析了nsq的架构设计，并通过一个简单的例子说明了nsq如何使用；当然nsq还有很多配置参数，例如每隔消息队列的长度，以及内存使用上限等等；后续文章，将继续分析nsqlookupd和nsqd的源码。</p>
]]></content>
      
        <categories>
            
            <category> nsq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nsq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python之wsgiref模块]]></title>
      <url>http://luodw.cc/2016/11/12/python-wsgi/</url>
      <content type="html"><![CDATA[<p>之前写了python的http原生模块，分析了原生http模块的实现原理以及不足;而实际使用过程中，用的比较多的是python的wsgi server和wsgi application; 关于什么是wsgi协议，简单的来说，就是wsgi server调用wsgi application接口的约定，即当有个请求到达wsgi server时，wsgi server通过调用wsgi application提供的接口来处理这个请求;其实，看过python wsgiref模块，也就能理解什么是wsgi模块。</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1970767937.jpg" alt="圆明园遗址(时光相册制作)"></p>
<p>现在比较流行的wsgi application有bottle, flask,django等，比较流行的wsgi server有werkzeug,gunicorn,gevent等;今天这篇文章主要分析下python自带的wsgiref模块，以这个为模板，可以理解下wsgi协议；</p>
<p>这篇文章主要有以下两部分：</p>
<ol>
<li>wsgiref简单示例</li>
<li>wsgiref实现原理</li>
<li>原理解释示例程序</li>
<li>总结</li>
</ol>
<h2>wsgiref简单示例</h2>
<hr>
<p>这里先给出wsgiref模块的简单示例，有个感性的认识，后续在分析实现原理；代码如下:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</div><div class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    httpd = make_server(<span class="string">''</span>, <span class="number">9999</span>, application)</div><div class="line">    print(<span class="string">"Serving HTTP on port 9999..."</span>)</div><div class="line">    httpd.serve_forever()</div></pre></td></tr></table></figure></p>
<p>这个示例程序很简单，创建一个httpd服务器，并监听9999端口，当有客户端请求时，在浏览器显示Hello, web字符串；</p>
<p>上述例子中的application就是wsgiref application，当然也可以一个类，平时常见的也是类，例如flask,bottle等，这些类实现__call__方法，并且该方法参数为environ, start_response即可，environ为一个字典，保存系统变量以及请求相关属性，例如请求路径，请求参数，请求方法等等；start_response为函数，设置response的状态码和header，然后application函数的返回值为response的body；因此上述例子程序，设置response状态码为200，表示请求成功，在headers添加返回数据类型为text/html，以及返回的response body为[b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']</p>
<h2>wsgiref实现原理</h2>
<hr>
<p>wsgiref模块也是由server和handler组成，server用于监听端口，接收请求；handler用于处理请求；先来看下server
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIServer</span><span class="params">(HTTPServer)</span>:</span></div><div class="line"></div><div class="line">    <span class="string">"""BaseHTTPServer that implements the Python WSGI protocol"""</span></div><div class="line"></div><div class="line">    application = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_bind</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Override server_bind to store the server name."""</span></div><div class="line">        HTTPServer.server_bind(self)</div><div class="line">        self.setup_environ()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_environ</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Set up base environment</span></div><div class="line">        env = self.base_environ = &#123;&#125;</div><div class="line">        env[<span class="string">'SERVER_NAME'</span>] = self.server_name</div><div class="line">        env[<span class="string">'GATEWAY_INTERFACE'</span>] = <span class="string">'CGI/1.1'</span></div><div class="line">        env[<span class="string">'SERVER_PORT'</span>] = str(self.server_port)</div><div class="line">        env[<span class="string">'REMOTE_HOST'</span>]=<span class="string">''</span></div><div class="line">        env[<span class="string">'CONTENT_LENGTH'</span>]=<span class="string">''</span></div><div class="line">        env[<span class="string">'SCRIPT_NAME'</span>] = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_app</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.application</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_app</span><span class="params">(self,application)</span>:</span></div><div class="line">        self.application = application</div></pre></td></tr></table></figure></p>
<p>WSGIServer继承自HTTPServer，并重载来server_bind方法，同时提供注册和获取server application的接口；其中set_environ函数设置了该web应用程序的环境变量，例如服务器名称，服务器端口等等；</p>
<p>ok，了解来WSGIServer之后，来看下handler是如何实现；WSGIRequestHandler类继承自BaseHTTPRequestHandler，并且重载handle方法，即处理请求的方法；</p>
<p>我们来看下WSGIRequestHandler的handle方法：
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="string">""</span><span class="string">"Handle a single HTTP request"</span><span class="string">""</span></div><div class="line">	<span class="comment"># 读取客户端发送的请求行</span></div><div class="line">        <span class="keyword">self</span>.raw_requestline = <span class="keyword">self</span>.rfile.readline(<span class="number">65537</span>)</div><div class="line">        <span class="keyword">if</span> len(<span class="keyword">self</span>.raw_requestline) &gt; <span class="number">65536</span>:</div><div class="line">            <span class="keyword">self</span>.requestline = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.request_version = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.command = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.send_error(<span class="number">414</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">	<span class="comment"># 解析客户端的请求行和请求头</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.parse_request(): <span class="comment"># An error code has been sent, just exit</span></div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="comment"># Avoid passing the raw file object wfile, which can do partial</span></div><div class="line">        <span class="comment"># writes (Issue 24291)</span></div><div class="line">        stdout = BufferedWriter(<span class="keyword">self</span>.wfile)</div><div class="line">        <span class="symbol">try:</span></div><div class="line">	　　<span class="comment"># 用于调用wsgi application的handler</span></div><div class="line">            handler = ServerHandler(</div><div class="line">                <span class="keyword">self</span>.rfile, stdout, <span class="keyword">self</span>.get_stderr(), <span class="keyword">self</span>.get_environ()</div><div class="line">            )</div><div class="line">            handler.request_handler = <span class="keyword">self</span>      <span class="comment"># backpointer for logging</span></div><div class="line">            handler.run(<span class="keyword">self</span>.server.get_app())</div><div class="line">        <span class="symbol">finally:</span></div><div class="line">            stdout.detach()</div></pre></td></tr></table></figure></p>
<p>handle函数首先解析请求行和请求头，然后实例化ServerHandler类，用该类来调用wsgi application；</p>
<p>ServerHandler类接受参数为socket读端，输出端，错误输出端以及一个包含请求信息的字典；self.get_environ()函数返回包含web应用程序的环境变量和请求的环境变量的字典；</p>
<p>最后再来看下ServerHandler;ServerHandler继承自SimpleHandler,SimpleHandler继承自BaseHandler；我们直接看下ServerHandler的run方法；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>, application)</span></span>:</div><div class="line">	<span class="symbol">try:</span></div><div class="line">            <span class="keyword">self</span>.setup_environ()</div><div class="line">            <span class="keyword">self</span>.result = application(<span class="keyword">self</span>.environ, <span class="keyword">self</span>.start_response)</div><div class="line">            <span class="keyword">self</span>.finish_response()</div><div class="line">        <span class="symbol">except:</span></div><div class="line">            <span class="symbol">try:</span></div><div class="line">                <span class="keyword">self</span>.handle_error()</div><div class="line">            <span class="symbol">except:</span></div><div class="line">                <span class="comment"># If we get an error handling an error, just give up already!</span></div><div class="line">                <span class="keyword">self</span>.close()</div><div class="line">                raise   <span class="comment"># ...and let the actual server figure it out.</span></div></pre></td></tr></table></figure></p>
<ol>
<li>self.setup_environ函数用于建立每次请求的相关信息，并存储在self.environ；</li>
<li>self.start_response为该handler函数，用于设置response的状态码和header；</li>
<li>self.result为response body；</li>
<li>self.finish_response用于将response返回给客户端；</li>
</ol>
<p>这个handler类就不一一分析了，详情可以看wsgiref/handlers.py模块；</p>
<h2>原理解释示例程序</h2>
<hr>
<p>了解了wsgiref模块之后．从原理层面来解释上述例子程序；再次粘帖程序代码如下:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</div><div class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    httpd = make_server(<span class="string">''</span>, <span class="number">9999</span>, application)</div><div class="line">    print(<span class="string">"Serving HTTP on port 9999..."</span>)</div><div class="line">    httpd.serve_forever()</div></pre></td></tr></table></figure></p>
<p>示例程序先是调用wsgiref模块的make_server方法，可以看下该方法如下：
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def make<span class="number">_</span>server(</div><div class="line">    host, port, app, server<span class="number">_</span><span class="keyword">class</span>=WSGIServer, handler<span class="number">_</span><span class="keyword">class</span>=WSGIRequestHandler</div><div class="line">):</div><div class="line">    <span class="string">"""Create a new WSGI server listening on `host` and `port` for `app`"""</span></div><div class="line">    server = server<span class="number">_</span><span class="keyword">class</span>((host, port), handler<span class="number">_</span><span class="keyword">class</span>)</div><div class="line">    server.set<span class="number">_</span>app(app)</div><div class="line">    <span class="keyword">return</span> server</div></pre></td></tr></table></figure></p>
<p>可以看到wsgiref默认的server_class为WSGIServer，handler_class为WSGIRequestHandler；先是实例化一个WSGIServer，然后注册application，最后返回该server实例；</p>
<p>在示例程序中，最后调用httpd.server_forever()方法开启事件监听循环；</p>
<p>当某个请求到来之后，先是实例化一个WSGIRequestHandler，并在该WSGIRequestHandler的handle方法内部解析请求参数，以及实例化一个ServerHandler，以及调用ServerHandler的run方法来处理请求；</p>
<p>在ServerHandler的run方法内部先是建立环境变量字典environ，然后调用wsgi application设置resopnse的状态码和headers，以及返回response body；最后调用finish_response()方法将response返回给客户端；</p>
<p>上述即为一次请求全过程；</p>
<h2>总结</h2>
<hr>
<p>这篇文章分析了python的wsgiref模块，解释了wsgiref模块一次请求的过程；当然实际应用中，wsgi application可不是示例程序中那么简单的返回一个字符串，因为一个web应用程序需要根据路由来调用相应的view函数以及一些其他特性，这等到分析bottle时再来分析；</p>
<p>wsgi server和wsgi application分离的设计，使python web的开发非常灵活，在部署python web应用程序时，可以根据性能的需求，选择合适的wsgi server；例如flask自带的wsgi server不适合在正式工业环境中使用，因此flask经常的搭配是nginx+gunicorn+flask，而不是用自带的werkzeug；</p>
<p>不同的wsgi server，区别主要是在并发模型的选择上，有单线程，多进程，多线程，协程；而wsgi application主要功能相近，无非就是根据请求路由，执行相应的view函数，当然有一些特性上的不同；</p>
<p>今天就先写到这，下篇文章分析bottle的实现；</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> wsgiref </tag>
            
            <tag> wsgi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python之HTTP模块]]></title>
      <url>http://luodw.cc/2016/11/05/python-http/</url>
      <content type="html"><![CDATA[<p>挺久没写博客了，因为博主开始了今年另一段美好的实习经历，学习加做项目，时间已排满；很感谢今年这两段经历，让我接触了golang和python，学习不同语言，可以跳出之前学习c/c++思维的限制，学习golang和python的优秀特性以及了解在不同的场景，适用不同的语言；而之前学习linux和c/c++，也使我很快就上手golang和python;</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/IMG_0361.JPG" alt="杭州清河坊"></p>
<p>我学习的习惯，除了学习如何使用，还喜欢研究源码，学习运行机制，这样用起来才会得心应手或者说，使用这些语言或框架，就和平时吃饭睡觉一样，非常自然；因为最近有接触到bottle和flask  web框架，所以想看下这两个的源码，但是这两个框架是基于python自带的http，因此就有了这篇文章；</p>
<p>这篇主要从以下几个方面来解析python之http模块:</p>
<ol>
<li>一个python http简单的例子</li>
<li>http之server;</li>
<li>http之handler;</li>
</ol>
<h1>python http简单例子</h1>
<hr>
<p>python http框架主要有server和handler组成，server主要是用于建立网络模型，例如利用epoll监听socket；handler用于处理各个就绪的socket；先来看下python http简单的使用：
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">from http.server import HTTPServer,SimpleHTTPRequestHandler</div><div class="line"></div><div class="line">ServerClass = HTTPServer</div><div class="line">HandlerClass = SimpleHTTPRequestHandler</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    port = <span class="keyword">int</span>(sys.<span class="built_in">argv</span>[<span class="number">2</span>])</div><div class="line">    server_address = (sys.<span class="built_in">argv</span>[<span class="number">1</span>],port)</div><div class="line">    httpd = ServerClass(server_address,HandlerClass)</div><div class="line"></div><div class="line">    <span class="keyword">sa</span>=httpd.socket.getsockname()</div><div class="line">    <span class="keyword">print</span>(<span class="string">"Serving HTTP on"</span>, <span class="keyword">sa</span>[<span class="number">0</span>], <span class="string">"port"</span>, <span class="keyword">sa</span>[<span class="number">1</span>], <span class="string">"..."</span>)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        httpd.serve_forever()</div><div class="line">    except KeyboardInterrup<span class="variable">t:</span></div><div class="line">        <span class="keyword">print</span>(<span class="string">"\nKeyboard interrupt received, exiting."</span>)</div><div class="line">        httpd.server_close()</div><div class="line">        sys.<span class="keyword">exit</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>运行上述例子，可以得到如下：</p>
<blockquote>
<p>python3 myhttp.py 127.0.0.1 9999</p>
</blockquote>
<p>此时如果在当前文件夹新建一个index.html文件，就可以通过<a href="http://127.0.0.1:9999/index.html" target="_blank" rel="external">http://127.0.0.1:9999/index.html</a>访问了index.html页面了。</p>
<p>这个例子的server类用的是HTTPServer，handler类是SimpleHTTPRequestHandler，因此当HTTPServer监听到有request到来时，就把这个request丢给SimpleHTTPRequestHandler类求处理；ok，了解这些之后，我们开始分别分析下server和handler.</p>
<h1>http之server</h1>
<hr>
<p>http模块的设计充分利用了面向对象的继承多态，因为之前有看了会tfs文件系统的代码，所以再看python http时，没那么大的压力；先给出server的继承关系
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="code">                       +------------------+</span></div><div class="line"><span class="code">+------------+</span>         | tcpserver基类    |</div><div class="line">| BaseServer +--------&gt;| 开启事件循环监听 |</div><div class="line"><span class="code">+-----+</span>------+         | 处理客户端请求   |</div><div class="line"><span class="code">      |                +------------------+</span></div><div class="line"><span class="code">      v                +-----------------+</span></div><div class="line"><span class="code">+------------+</span>         | httpserver基类  |</div><div class="line">| TCPServer  <span class="code">+--------&gt;+</span>  设置监听socket |</div><div class="line"><span class="code">+-----+</span>------+         | 开启监听        |</div><div class="line"><span class="code">      |                +-----------------+</span></div><div class="line"><span class="section">      v</span></div><div class="line">+------------+</div><div class="line"><span class="section">| HTTPServer |           </span></div><div class="line">+------------+</div></pre></td></tr></table></figure></p>
<p>继承关系如上图所示，其中BaseServer和TCPServer在文件socketserver.py，HTTPServer在http/server.py；我们先看下来BaseServer；</p>
<h2>BaseServer</h2>
<hr>
<p>因为BaseServer是所有server的基类，因此BaseServer尽可能抽象出所有server的共性，例如开启事件监听循环，这就是每个server的共性，因此这也是BaseServer主要做的使;我们来看下BaseServer主要代码部分
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def serve_forever(<span class="keyword">self</span>, poll_interval=<span class="number">0.5</span>):</div><div class="line">        <span class="keyword">self</span>.__is_shut_down.clear()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">with</span> _ServerSelector() <span class="keyword">as</span> <span class="keyword">selector</span>:</div><div class="line">                <span class="keyword">selector</span>.register(<span class="keyword">self</span>, selectors.EVENT_READ)</div><div class="line"></div><div class="line">                <span class="keyword">while</span> <span class="keyword">not</span> <span class="keyword">self</span>.__shutdown_request:</div><div class="line">                    ready = <span class="keyword">selector</span>.select(poll_interval)</div><div class="line">                    <span class="keyword">if</span> ready:</div><div class="line">                        <span class="keyword">self</span>._handle_request_noblock()</div><div class="line"></div><div class="line">                    <span class="keyword">self</span>.service_actions()</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            <span class="keyword">self</span>.__shutdown_request = <span class="keyword">False</span></div><div class="line">            <span class="keyword">self</span>.__is_shut_down.set()</div></pre></td></tr></table></figure></p>
<p>代码中的selector其实就是封装了select,poll,epoll等的io多路复用，然后将服务自身监听的socket注册到io多路复用，开启事件监听，当有客户端连接时，此时会调用self._handle_request_noblock()来处理请求；接下来看下这个处理函数做了啥；
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def _handle_request_noblock(<span class="keyword">self</span>):</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            request, client_address = <span class="keyword">self</span>.get_request()</div><div class="line">        <span class="keyword">except</span> OSError:</div><div class="line">            return</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.verify_request(request, client_address):</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="keyword">self</span>.process_request(request, client_address)</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">self</span>.handle_error(request, client_address)</div><div class="line">                <span class="keyword">self</span>.shutdown_request(request)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">self</span>.shutdown_request(request)</div></pre></td></tr></table></figure></p>
<p>_handle_request_noblock函数是一个内部函数，首先是接收客户端连接请求，底层其实是封装了系统调用accept函数，然后验证请求，最后调用process_request来处理请求；其中get_request是属于子类的方法，因为tcp和udp接收客户端请求是不一样的(tcp有连接，udp无连接)</p>
<p>我们接下来再看下process_request具体做了什么；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(<span class="keyword">self</span>, request, client_address)</span></span>:</div><div class="line">       <span class="keyword">self</span>.finish_request(request, client_address)</div><div class="line">       <span class="keyword">self</span>.shutdown_request(request)</div><div class="line"><span class="comment"># -------------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish_request</span><span class="params">(<span class="keyword">self</span>, request, client_address)</span></span>:</div><div class="line">        <span class="keyword">self</span>.RequestHandlerClass(request, client_address, <span class="keyword">self</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown_request</span><span class="params">(<span class="keyword">self</span>, request)</span></span>:</div><div class="line">    <span class="keyword">self</span>.close_request(request)</div></pre></td></tr></table></figure></p>
<p>process_request函数先是调用了finish_request来处理一个连接，处理结束之后，调用shutdown_request函数来关闭这个连接；而finish_request函数内部实例化了一个handler类，并把客户端的socket和地址传了进去，说明，handler类在初始化结束的时候，就完成了请求处理，这个等后续分析handler时再细看；</p>
<p>以上就是BaseServer所做的事，这个BaseServer不能直接使用，因为有些函数还没实现，只是作为tcp/udp的抽象层；总结下：</p>
<ol>
<li>先是调用serve_forever开启事件监听；</li>
<li>然后当有客户端请求到来时，将请求交给handler处理；</li>
</ol>
<h2>TCPServer</h2>
<hr>
<p>由上述BaseServer抽象出的功能，我们可以知道TCPServer或UDPServer应该完成的功能有，初始化监听套接字，并绑定监听，最后当有客户端请求时，接收这个客户端；我们来看下代码
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BaseServer==&gt;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, server_address, RequestHandlerClass)</span></span>:</div><div class="line">        <span class="string">""</span><span class="string">"Constructor.  May be extended, do not override."</span><span class="string">""</span></div><div class="line">        <span class="keyword">self</span>.server_address = server_address</div><div class="line">        <span class="keyword">self</span>.RequestHandlerClass = RequestHandlerClass</div><div class="line">        <span class="keyword">self</span>.__is_shut_down = threading.Event()</div><div class="line">        <span class="keyword">self</span>.__shutdown_request = False</div><div class="line"><span class="comment">#--------------------------------------------------------------------------------</span></div><div class="line">TCPServer==&gt;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, server_address, RequestHandlerClass, bind_and_activate=True)</span></span>:</div><div class="line">       BaseServer.__init_<span class="number">_</span>(<span class="keyword">self</span>, server_address, RequestHandlerClass)</div><div class="line">       <span class="keyword">self</span>.socket = socket.socket(<span class="keyword">self</span>.address_family,</div><div class="line">                                   <span class="keyword">self</span>.socket_type)</div><div class="line">       <span class="keyword">if</span> <span class="symbol">bind_and_activate:</span></div><div class="line">           <span class="symbol">try:</span></div><div class="line">               <span class="keyword">self</span>.server_bind()</div><div class="line">               <span class="keyword">self</span>.server_activate()</div><div class="line">           <span class="symbol">except:</span></div><div class="line">               <span class="keyword">self</span>.server_close()</div><div class="line">               raise</div></pre></td></tr></table></figure></p>
<p>TCPServer初始化时先是调用基类BaseServer的初始化函数，初始化服务器地址，handler类等，然后初始化自身的监听套接字，最后调用server_bind绑定套接字，server_activate监听套接字
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_bind</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">allow_reuse_address:</span></div><div class="line">        <span class="keyword">self</span>.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">    <span class="keyword">self</span>.socket.bind(<span class="keyword">self</span>.server_address)</div><div class="line">    <span class="keyword">self</span>.server_address = <span class="keyword">self</span>.socket.getsockname()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_activate</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">    <span class="keyword">self</span>.socket.listen(<span class="keyword">self</span>.request_queue_size)</div></pre></td></tr></table></figure></p>
<p>TCPServer还实现了另一个函数，那就是接收客户端请求，
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.socket.accept()</div></pre></td></tr></table></figure></p>
<p>之前如果有学过linux编程，那么看这些代码应该会觉得很熟悉，因为函数名和Linux提供的系统调用名一模一样，这里也不多说了；</p>
<p>TCPServer其实已经把基于tcp的服务器主体框架搭起来了，因此HTTPServer在继承TCPServer基础上，只是重载了server_bind函数，设置reuse_address等；</p>
<p>ok，这里分析下上述例子程序的开启过程；</p>
<ol>
<li>httpd = ServerClass(server_address,HandlerClass)这行代码在初始化HTTPServer时，主要是调用基类TCPServer的初始化方法，初始化了监听的套接字，并绑定和监听；</li>
<li>httpd.serve_forever()这行代码调用的是基类BaseServer的serve_forever方法，开启监听循环，等待客户端的连接；</li>
</ol>
<p>如果有看过redis或者一些后台组件的源码，对这种并发模型应该很熟悉；ok，分析了server之后，接下来看下handler是如何处理客户端请求的。</p>
<h1>http之handler</h1>
<hr>
<p>handler类主要分析tcp层的handler和http应用层的handler,tcp层的handler是不能使用的，因为tcp层只负责传输字节，但是并不知对于接收到的字节要如何解析，如何处理等；因此应用层协议如该要使用TCP协议，必须继承TCP handler，然后实现handle函数即可;例如，http层的handler实现handle函数，解析http协议，处理业务请求以及结果返回给客户端；先来看下tcp层的handler</p>
<h2>tcp层handler</h2>
<hr>
<p>tcp层handler主要有BaseRequestHandler和StreamRequestHandler(都在socketserver.py文件)，先看下BaseRequestHandler代码，
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequestHandler</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, request, client_address, server)</span></span>:</div><div class="line">        <span class="keyword">self</span>.request = request</div><div class="line">        <span class="keyword">self</span>.client_address = client_address</div><div class="line">        <span class="keyword">self</span>.server = server</div><div class="line">        <span class="keyword">self</span>.setup()</div><div class="line">        <span class="symbol">try:</span></div><div class="line">            <span class="keyword">self</span>.handle()</div><div class="line">        <span class="symbol">finally:</span></div><div class="line">            <span class="keyword">self</span>.finish()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        pass</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        pass</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        pass</div></pre></td></tr></table></figure></p>
<p>之前在看server时，知道处理客户端请求就是在handler类的初始化函数中完成；由这个基类初始化函数，我们知道处理请求大概经历三个过程：</p>
<ol>
<li>setup对客户端的socket做一些设置；</li>
<li>handle真正处理请求的函数；</li>
<li>finish关闭socket读写请求；</li>
</ol>
<p>这个BaseRequestHandler是handler top level 基类，只是抽象出handler整体框架，并没有实际的处理；我们看下tcp handler，
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamRequestHandler</span>(<span class="title">BaseRequestHandler</span>):</span></div><div class="line">    timeout = None</div><div class="line">    disable_nagle_algorithm = False</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">self</span>.connection = <span class="keyword">self</span>.request</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.timeout is <span class="keyword">not</span> <span class="symbol">None:</span></div><div class="line">            <span class="keyword">self</span>.connection.settimeout(<span class="keyword">self</span>.timeout)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">disable_nagle_algorithm:</span></div><div class="line">            <span class="keyword">self</span>.connection.setsockopt(socket.IPPROTO_TCP,</div><div class="line">                                       socket.TCP_NODELAY, True)</div><div class="line">        <span class="keyword">self</span>.rfile = <span class="keyword">self</span>.connection.makefile(<span class="string">'rb'</span>, <span class="keyword">self</span>.rbufsize)</div><div class="line">        <span class="keyword">self</span>.wfile = <span class="keyword">self</span>.connection.makefile(<span class="string">'wb'</span>, <span class="keyword">self</span>.wbufsize)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.wfile.<span class="symbol">closed:</span></div><div class="line">            <span class="symbol">try:</span></div><div class="line">                <span class="keyword">self</span>.wfile.flush()</div><div class="line">            except socket.<span class="symbol">error:</span></div><div class="line">                pass</div><div class="line">        <span class="keyword">self</span>.wfile.close()</div><div class="line">        <span class="keyword">self</span>.rfile.close()</div></pre></td></tr></table></figure></p>
<p>tcp handler实现了setup和finish函数，setup函数设置超时时间，开启nagle算法以及设置socket读写缓存；finish函数关闭socket读写；</p>
<p>由上述两个tcp层的handler可知，要实现一个基于http的服务器handler，只需要继承StreamRequestHandler类，并实现handle函数即可；因此这也是http层handler主要做的事；</p>
<h2>http层handler</h2>
<hr>
<p>由之前tcp层handler的介绍，我们知道http层handler在继承tcp层handler基础上，主要是实现了handle函数处理客户端的请求；还是直接看代码吧；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">self</span>.close_connection = True</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.handle_one_request()</div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">close_connection:</span></div><div class="line">            <span class="keyword">self</span>.handle_one_request()</div></pre></td></tr></table></figure></p>
<p>这就是BaseHTTPRequestHandler的handle函数，在handle函数会调用handle_one_request函数处理一次请求；默认情况下是短链接，因此在执行了一次请求之后，就不会进入while循环在同一个连接上处理下一个请求，但是在handle_one_request函数内部会进行判断，如果请求头中的connection为keep_alive或者http版本大于等于1.1，则可以保持长链接；接下来看下handle_one_request函数是如何处理；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_one_request</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">    <span class="symbol">try:</span></div><div class="line">        <span class="keyword">self</span>.raw_requestline = <span class="keyword">self</span>.rfile.readline(<span class="number">65537</span>)</div><div class="line">        <span class="keyword">if</span> len(<span class="keyword">self</span>.raw_requestline) &gt; <span class="number">65536</span>:</div><div class="line">            <span class="keyword">self</span>.requestline = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.request_version = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.command = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">raw_requestline:</span></div><div class="line">            <span class="keyword">self</span>.close_connection = True</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.parse_request():</div><div class="line">            <span class="keyword">return</span></div><div class="line">        mname = <span class="string">'do_'</span> + <span class="keyword">self</span>.command</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(<span class="keyword">self</span>, mname):</div><div class="line">            <span class="keyword">self</span>.send_error(</div><div class="line">                HTTPStatus.NOT_IMPLEMENTED,</div><div class="line">                <span class="string">"Unsupported method (%r)"</span> % <span class="keyword">self</span>.command)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        method = getattr(<span class="keyword">self</span>, mname)</div><div class="line">        method()</div><div class="line">        <span class="keyword">self</span>.wfile.flush()</div><div class="line">    except socket.timeout as <span class="symbol">e:</span></div><div class="line">        <span class="keyword">self</span>.log_error(<span class="string">"Request timed out: %r"</span>, e)</div><div class="line">        <span class="keyword">self</span>.close_connection = True</div><div class="line">        <span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>这个handle_one_request执行过程如下：</p>
<ol>
<li>先是调用parse_request解析客户端http请求内容</li>
<li>通过&quot;do_&quot;+command构造出请求所对于的函数method</li>
<li>调用method函数，处理业务并将response返回给客户端</li>
</ol>
<p>这个BaseHTTPRequestHandler是http handler基类，因此也是无法直接使用，因为它没有定义请求处理函数，即method函数；好在python为我们提供了一个简单的SimpleHTTPRequestHandler，该类继承了BaseHTTPRequestHandler，并实现了请求函数；我们看下get函数：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># SimpleHTTPRequestHandler</span></div><div class="line"><span class="comment"># ---------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="string">"""Serve a GET request."""</span></div><div class="line">      f = self.send_head()</div><div class="line">      <span class="keyword">if</span> f:</div><div class="line">          <span class="keyword">try</span>:</div><div class="line">              self.copyfile(f, self.wfile)</div><div class="line">          <span class="keyword">finally</span>:</div><div class="line">              f.close()</div></pre></td></tr></table></figure></p>
<p>这个get函数先是调用do_GET函数给客户端返回response头部，并返回请求的文件，最后调用copyfile函数将请求文件通过连接返回给客户端；</p>
<p>以上就是http模块最基础的内容，最后，总结下例子程序handler部分：</p>
<ol>
<li>server把请求传给SimpleHTTPRequestHandler初始化函数；</li>
<li>SimpleHTTPRequestHandler在初始化部分，对这个客户端connection进行一些设置；</li>
<li>接着调用handle函数处理请求；</li>
<li>在handle函数接着调用handle_one_request处理请求；</li>
<li>在handle_one_request函数内部，解析请求，找到请求处理函数；</li>
<li>我之前的访问属于get访问，因此直接调用do_GET函数将index.html文件返回给客户端；</li>
</ol>
<p>python http模块到此已经分析结束；不知道大家有没发现，python自带的http模块使用起来不是很方便，因为它是通过请求方法来调用请求函数，这样当同一方法调用次数非常多时，例如get和post方法，会导致这个请求函数异常庞大，代码不好编写，各种情况判断；当然SimpleHTTPRequestHandler只是python提供的一个简单例子而已；</p>
<p>当然，python官方提供了针对http更好用的框架，即wsgi server和wsgi application；接下来文章先分析python自带的wsgiref模块以及bottle，后面再分析flask;</p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从汇编角度理解golang多值返回和闭包]]></title>
      <url>http://luodw.cc/2016/09/04/golang03/</url>
      <content type="html"><![CDATA[<p>今天聊两个轻松的话题，golang相比与之前学习的C/C++，有很多新颖的特性，不知道大家的使用的时候，有没想过，这些特性是如何实现的？当然你可能会说，不了解这些特性好像也不影响自己使用golang；对，你说的也有道理；但是，多了解底层的实现原理，对于在使用golang时的眼界是完全不一样的，就类似于看过http的实现之后，再来使用http框架，和未看过http框架时的眼界是不一样的，当然，你如果是一名it爱好者，求知欲自然会引导你去学习；知其然而不知其所以然，是很可怕的；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-0033033999475765_b.jpg" alt="厦门世贸中心"></p>
<p>相对于C/C++，golang有很多新颖的特性，例如goroutine,channel,defer,reflect,interface{}等等；这些特性其实从golang源码是可以理解其实现的原理；今天这篇文章主要来分析下golang多值返回以及闭包的实现，因为这两个实现golang源码中并不存在，我们必须从汇编的角度来窥探二者的实现；</p>
<p>这篇文章主要就分析两点:</p>
<ol>
<li>golang多值返回的实现;</li>
<li>golang闭包的实现;</li>
<li>总结;</li>
</ol>
<h1>golang多值返回的实现</h1>
<hr>
<p>我们在学C/C++时，很多人应该有了解过C/C++函数调用过程，参数是通过寄存器di和si(假设就两个参数)传递给被调用的函数，被调用函数的返回结果只能是通过eax寄存器返回给调用函数，因此C/C++函数只能返回一个值，那么我们是不是可以想象，golang的多值返回是否可以通过多个寄存器来实现的，正如用多个寄存器来传参一样？</p>
<p>这也是一种办法，但是golang并没有采用；我的理解是引入多个寄存器来存储返回值，会引起多个寄存器用途的重新约定，这无疑增加了复杂度；可以这么说，golang的ABI与C/C++非常不一样；</p>
<p>在从汇编角度分析golang多值返回之前，需要先熟悉golang汇编代码的一些约定，<a href="https://golang.org/doc/asm" target="_blank" rel="external">golang官网</a>有说明，这里重点说明四个symbols，需要注意的是这里的寄存器是伪寄存器：</p>
<ol>
<li>FP　栈底寄存器，指向一个函数栈的顶部；</li>
<li>PC  程序计数器，指向下一条执行指令;</li>
<li>SB　指向静态数据的基指针，全局符号;</li>
<li>SP　栈顶寄存器;</li>
</ol>
<p>这里面最重要的就是FP和SP，FP寄存器主要用于取参数以及存返回值，golang函数调用的实现很大程度上都是依赖这两个寄存器，这里先给出结果，</p>
<p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">                </div><div class="line">+-----------+---\</div><div class="line">|<span class="string">  返回值2  </span>|<span class="string">    \</span></div><div class="line">+-----------+     \</div><div class="line">|<span class="string">  返回值1  </span>|<span class="string">      \</span></div><div class="line">+---------+-+      </div><div class="line">|<span class="string">  参数2    </span>|<span class="string">      这些在调用函数中</span></div><div class="line">+-----------+       </div><div class="line">|<span class="string">  参数1    </span>|<span class="string">   　 /</span></div><div class="line">+-----------+     /</div><div class="line">|<span class="string">  返回地址 </span>|<span class="string">    /</span></div><div class="line">+-----------+--\/-----fp值</div><div class="line">|<span class="string">  局部变量 </span>|<span class="string">   \</span></div><div class="line">|<span class="string">    ...    </span>|<span class="string">   被调用数栈祯</span></div><div class="line">|<span class="string">           </span>|<span class="string">   /</span></div><div class="line">+-----------+--/+---sp值</div></pre></td></tr></table></figure></p>
<p>这个就是golang的一个函数栈，也是说函数传参是通过fp+offset来实现的，而多个返回值也是通过fp+offset存储在调用函数的栈帧中；下面通过一个例子来分析
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import <span class="string">"fmt"</span></div><div class="line"></div><div class="line">func test(<span class="selector-tag">i</span>, j int) (int, int) &#123;</div><div class="line">	<span class="selector-tag">a</span> := <span class="selector-tag">i</span> + j</div><div class="line">	<span class="selector-tag">b</span> := <span class="selector-tag">i</span> - j</div><div class="line">	return <span class="selector-tag">a</span>, <span class="selector-tag">b</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	<span class="selector-tag">a</span>, <span class="selector-tag">b</span> := test(<span class="number">2</span>, <span class="number">1</span>)</div><div class="line">	fmt.Println(<span class="selector-tag">a</span>, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子很简单，主要是为了说明golang多值返回的过程；我们通过下面命令编译该程序</p>
<blockquote>
<p>go tool compile -S test.go &gt; test.s</p>
</blockquote>
<p>然后，就可以打开test.s，来看下这个小程序的汇编代码。首先来看下test函数的汇编代码</p>
<p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span>.test t=<span class="number">1</span> size=<span class="number">32</span> value=<span class="number">0</span> args=<span class="number">0x20</span> locals=<span class="number">0x0</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        TEXT    <span class="string">""</span>.test(SB), <span class="number">$0</span>-<span class="number">32</span>//栈大小为<span class="number">32</span>字节</div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">NOP</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">NOP</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.i+<span class="number">8</span>(FP), <span class="built_in">CX</span>//取第一个参数i</div><div class="line">        <span class="number">0x0005</span> <span class="number">00005</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.j+<span class="number">16</span>(FP), <span class="built_in">AX</span>//取第二个参数j</div><div class="line">        <span class="number">0x000a</span> <span class="number">00010</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$0</span>, gclocals·a8eabfc4a4514ed6b3b0c61e9680e440(SB)</div><div class="line">        <span class="number">0x000a</span> <span class="number">00010</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</div><div class="line">        <span class="number">0x000a</span> <span class="number">00010</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="built_in">BX</span>//将i放入<span class="built_in">bx</span></div><div class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        ADDQ    <span class="built_in">AX</span>, <span class="built_in">CX</span>//i+j放入<span class="built_in">cx</span></div><div class="line">        <span class="number">0x0010</span> <span class="number">00016</span> (<span class="keyword">test</span>.go:<span class="number">7</span>)        SUBQ    <span class="built_in">AX</span>, <span class="built_in">BX</span>//i-j放入<span class="built_in">bx</span></div><div class="line">						//将返回结果存入调用函数栈帧</div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">8</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.~<span class="built_in">r2</span>+<span class="number">24</span>(FP)</div><div class="line">						//将返回结果存入调用函数栈帧</div><div class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (<span class="keyword">test</span>.go:<span class="number">8</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BX</span>, <span class="string">""</span>.~<span class="built_in">r3</span>+<span class="number">32</span>(FP)</div><div class="line">        <span class="number">0x001d</span> <span class="number">00029</span> (<span class="keyword">test</span>.go:<span class="number">8</span>)        <span class="keyword">RET</span></div></pre></td></tr></table></figure></p>
<p>由这个汇编代码可以看出来，在test函数内部，是通过fp+8取第一个参数，fp+16取第二个参数；然后将返回的第一个值存入fp+24,返回的第二个值存入fp+32，和我上述所说完全一致；golang函数调用过程，是通过fp+offset来实现传参和返回值，而不像C/C++都是通过寄存器实现传参和返回值；</p>
<p>但是，这里有个问题，我的变量都是int类型，为啥分配的都是8字节，这有待考证；</p>
<p>本来想通过查看main函数的栈帧来验证之前的结论，但是golang对小函数自动转为内联函数，因此你们可以自己编译出来看看，main函数内部是没有调用test函数的，而是将test函数的汇编代码直接拷贝进main函数执行了；</p>
<h1>golang闭包的实现</h1>
<hr>
<p>之前有去看了下C++11的lambda函数的实现，其实实现原理就是仿函数；编译器在编译lambda函数时，会生成一个匿名的仿函数类，然后执行这个lambda函数时，会调用编译生成的匿名仿函数类重载函数调用方法，这个方法也就是lambda函数中定义的方法；其实golang闭包的实现和这个类似，我们通过例子来说明
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">		a = a + i</div><div class="line">		<span class="keyword">return</span> a</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	f := test(<span class="number">1</span>)</div><div class="line">	a := f(<span class="number">2</span>)</div><div class="line">	fmt.Println(a)</div><div class="line">	b := f(<span class="number">3</span>)</div><div class="line">	fmt.Println(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子程序很简单，test函数传入一个整型参数a，返回一个函数类型；这个函数类型传入一个整型参数以及返回一个整型值；main函数调用test函数，返回一个闭包函数；ok，来看下test函数的汇编代码:</p>
<p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span>.test t=<span class="number">1</span> size=<span class="number">160</span> value=<span class="number">0</span> args=<span class="number">0x10</span> locals=<span class="number">0x20</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        TEXT    <span class="string">""</span>.test(SB), <span class="number">$32</span>-<span class="number">16</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    (TLS), <span class="built_in">CX</span></div><div class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        CMPQ    <span class="built_in">SP</span>, <span class="number">16</span>(<span class="built_in">CX</span>)</div><div class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        JLS     <span class="number">142</span></div><div class="line">        <span class="number">0x000f</span> <span class="number">00015</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        SUBQ    <span class="number">$32</span>, <span class="built_in">SP</span></div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$0</span>, gclocals·8edb5632446ada37b0a930d010725cc5(SB)</div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$1</span>, gclocals·008e235a1392cc90d1ed9ad2f7e76d87(SB)</div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        LEAQ    type.int(SB), <span class="built_in">BX</span></div><div class="line">        <span class="number">0x001a</span> <span class="number">00026</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BX</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x001e</span> <span class="number">00030</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        PCDATA  <span class="number">$0</span>, <span class="number">$0</span></div><div class="line">					//生成一个<span class="keyword">int</span>型对象，即a</div><div class="line">        <span class="number">0x001e</span> <span class="number">00030</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">CALL</span>    runtime.newobject(SB)</div><div class="line">					//<span class="number">8</span>(<span class="built_in">sp</span>)即生成的a的地址，放入<span class="built_in">AX</span></div><div class="line">        <span class="number">0x0023</span> <span class="number">00035</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></div><div class="line">					//将a的地址存入<span class="built_in">sp</span>+<span class="number">24</span>的位置</div><div class="line">        <span class="number">0x0028</span> <span class="number">00040</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.&amp;a+<span class="number">24</span>(<span class="built_in">SP</span>)</div><div class="line">					//取出main函数传入的第一个参数，即a</div><div class="line">        <span class="number">0x002d</span> <span class="number">00045</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.a+<span class="number">40</span>(FP), <span class="built_in">BP</span></div><div class="line">					//将a放入(<span class="built_in">AX</span>)指向的内存，即上述新生成的<span class="keyword">int</span>型对象</div><div class="line">        <span class="number">0x0032</span> <span class="number">00050</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BP</span>, (<span class="built_in">AX</span>)</div><div class="line">        <span class="number">0x0035</span> <span class="number">00053</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        LEAQ    type.struct &#123; F uintptr<span class="comment">; a *int &#125;(SB), BX</span></div><div class="line">        <span class="number">0x003c</span> <span class="number">00060</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BX</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0040</span> <span class="number">00064</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        PCDATA  <span class="number">$0</span>, <span class="number">$1</span></div><div class="line">        <span class="number">0x0040</span> <span class="number">00064</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">CALL</span>    runtime.newobject(SB)</div><div class="line">					//<span class="number">8</span>(<span class="built_in">sp</span>)这就是上述生成的struct对象地址</div><div class="line">        <span class="number">0x0045</span> <span class="number">00069</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></div><div class="line">        <span class="number">0x004a</span> <span class="number">00074</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">NOP</span></div><div class="line">					//<span class="keyword">test</span>内部匿名函数地址存入<span class="built_in">BP</span></div><div class="line">        <span class="number">0x004a</span> <span class="number">00074</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        LEAQ    <span class="string">""</span>.test.func1(SB), <span class="built_in">BP</span></div><div class="line">					//将匿名函数地址放入(<span class="built_in">AX</span>)指向的地址，即给上述</div><div class="line">					//F uintptr赋值</div><div class="line">        <span class="number">0x0051</span> <span class="number">00081</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BP</span>, (<span class="built_in">AX</span>)</div><div class="line">        <span class="number">0x0054</span> <span class="number">00084</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.autotmp_0001+<span class="number">16</span>(<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0059</span> <span class="number">00089</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">NOP</span>	</div><div class="line">					//将上述生成的整型对象a的地址存入<span class="built_in">BP</span></div><div class="line">        <span class="number">0x0059</span> <span class="number">00089</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.&amp;a+<span class="number">24</span>(<span class="built_in">SP</span>), <span class="built_in">BP</span></div><div class="line">        <span class="number">0x005e</span> <span class="number">00094</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        CMPB    runtime.writeBarrier(SB), <span class="number">$0</span></div><div class="line">        <span class="number">0x0065</span> <span class="number">00101</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">JNE</span>     <span class="number">$0</span>, <span class="number">117</span></div><div class="line">					//将a地址存入<span class="built_in">AX</span>指向内存+<span class="number">8</span>，</div><div class="line">					//即为上述结构体a *<span class="keyword">int</span>赋值</div><div class="line">        <span class="number">0x0067</span> <span class="number">00103</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BP</span>, <span class="number">8</span>(<span class="built_in">AX</span>)</div><div class="line">					//将上述结构体的地址存入main函数栈帧中；</div><div class="line">        <span class="number">0x006b</span> <span class="number">00107</span> (<span class="keyword">test</span>.go:<span class="number">9</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.~<span class="built_in">r1</span>+<span class="number">48</span>(FP)</div><div class="line">        <span class="number">0x0070</span> <span class="number">00112</span> (<span class="keyword">test</span>.go:<span class="number">9</span>)        ADDQ    <span class="number">$32</span>, <span class="built_in">SP</span></div><div class="line">        <span class="number">0x0074</span> <span class="number">00116</span> (<span class="keyword">test</span>.go:<span class="number">9</span>)        <span class="keyword">RET</span></div></pre></td></tr></table></figure></p>
<p>之前有看到一句话，很形象地描述了闭包</p>
<blockquote>
<p>类是有行为的数据，而闭包是有数据的行为；</p>
</blockquote>
<p>也就是说闭包是有上下文的，我们以测试例子为例，通过test函数生成的闭包函数，都有各自的a，这个a就是闭包的上下文数据，而且这个a一直伴随着他的闭包函数，每调用一次，a都会发生变化；</p>
<p>我们分析了上述汇编代码，来看下闭包实现原理；在这个测试例子中，由于a是闭包的上下文数据，因此a必须在堆上分配，如果在栈上分配，函数结束，a也被回收了；然后会定义出一个匿名结构体:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>.<span class="keyword">struct</span> &#123; </div><div class="line">	F <span class="keyword">uintptr</span><span class="comment">//这个就是闭包调用的函数指针 </span></div><div class="line">	a *<span class="keyword">int</span> <span class="comment">//这就是闭包的上下文数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着生成一个该对象，并将之前在堆上分配的整型对象a的地址赋值给结构体中的a指针，接下来将闭包调用的func函数地址赋值给结构体中F指针；这样，每生成一个闭包函数，其实就是生成一个上述结构体对象，每个闭包对象也就有自己的数据a和调用函数F；最后将这个结构体的地址返回给main函数；</p>
<p>ok，来看下main函数获取闭包的过程；</p>
<p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span>.main t=<span class="number">1</span> size=<span class="number">528</span> value=<span class="number">0</span> args=<span class="number">0x0</span> locals=<span class="number">0x88</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       TEXT    <span class="string">""</span>.main(SB), <span class="number">$136</span>-<span class="number">0</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       <span class="keyword">MOVQ</span>    (TLS), <span class="built_in">CX</span></div><div class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       LEAQ    -<span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></div><div class="line">        <span class="number">0x000e</span> <span class="number">00014</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       CMPQ    <span class="built_in">AX</span>, <span class="number">16</span>(<span class="built_in">CX</span>)</div><div class="line">        <span class="number">0x0012</span> <span class="number">00018</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       JLS     <span class="number">506</span></div><div class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       SUBQ    <span class="number">$136</span>, <span class="built_in">SP</span></div><div class="line">        <span class="number">0x001f</span> <span class="number">00031</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       FUNCDATA        <span class="number">$0</span>, gclocals·f5be5308b59e045b7c5b33ee8908cfb7(SB)</div><div class="line">        <span class="number">0x001f</span> <span class="number">00031</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       FUNCDATA        <span class="number">$1</span>, gclocals·9d868b227cedd8dd4b1bec8682560fff(SB)</div><div class="line">       					//将参数<span class="number">1</span>(f:=<span class="keyword">test</span>(<span class="number">1</span>))放入main函数栈顶</div><div class="line">	<span class="number">0x001f</span> <span class="number">00031</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       <span class="keyword">MOVQ</span>    <span class="number">$1</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0027</span> <span class="number">00039</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       PCDATA  <span class="number">$0</span>, <span class="number">$0</span></div><div class="line">					//调用main函数生成闭包对象</div><div class="line">        <span class="number">0x0027</span> <span class="number">00039</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       <span class="keyword">CALL</span>    <span class="string">""</span>.test(SB)</div><div class="line">					//将闭包对象的地址放入<span class="built_in">DX</span></div><div class="line">        <span class="number">0x002c</span> <span class="number">00044</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">DX</span></div><div class="line">       					//将参数<span class="number">2</span>(a:=f(<span class="number">2</span>))放入栈顶</div><div class="line">	<span class="number">0x0031</span> <span class="number">00049</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    <span class="number">$2</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0039</span> <span class="number">00057</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    <span class="built_in">DX</span>, <span class="string">""</span>.f+<span class="number">56</span>(<span class="built_in">SP</span>)</div><div class="line">					//将闭包对象的函数指针赋值给<span class="built_in">BX</span></div><div class="line">        <span class="number">0x003e</span> <span class="number">00062</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    (<span class="built_in">DX</span>), <span class="built_in">BX</span></div><div class="line">        <span class="number">0x0041</span> <span class="number">00065</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       PCDATA  <span class="number">$0</span>, <span class="number">$1</span></div><div class="line">					//这里调用闭包函数，并且将闭包对象的地址也传进</div><div class="line">					//闭包函数，为了修改a嘛</div><div class="line">        <span class="number">0x0041</span> <span class="number">00065</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">CALL</span>    <span class="built_in">DX</span>, <span class="built_in">BX</span></div><div class="line">        <span class="number">0x0043</span> <span class="number">00067</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">BX</span></div></pre></td></tr></table></figure></p>
<p>很明显，main函数调用test函数获取的是闭包对象的地址，通过这个闭包对象地址找到闭包函数，然后执行这个闭包函数，并且把闭包对象的地址传进函数，这点和C++传this指针原理一样，为了修改成员变量a；</p>
<p>最后看下test内部的匿名函数(闭包函数实现):</p>
<p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span><span class="selector-class">.test</span><span class="selector-class">.func1</span> t=<span class="number">1</span> size=<span class="number">32</span> value=<span class="number">0</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x0</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        TEXT    <span class="string">""</span><span class="selector-class">.test</span><span class="selector-class">.func1</span>(SB), $<span class="number">0</span>-<span class="number">16</span></div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        NOP</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        NOP</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        FUNCDATA        $<span class="number">0</span>, gclocals·<span class="number">23</span>e8278e2b69a3a75fa59b23c49ed6ad(SB)</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        FUNCDATA        $<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</div><div class="line">   					<span class="comment">//DX是闭包对象的地址，+8即a的地址</span></div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        MOVQ    <span class="number">8</span>(DX), AX</div><div class="line">					<span class="comment">//AX为a的地址，(AX)即为a的值</span></div><div class="line">        <span class="number">0</span>x0004 <span class="number">00004</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        MOVQ    (AX), BP</div><div class="line">					<span class="comment">//将参数i存入R8</span></div><div class="line">        <span class="number">0</span>x0007 <span class="number">00007</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        MOVQ    <span class="string">""</span>.i+<span class="number">8</span>(FP), R8</div><div class="line">					<span class="comment">//a+i的值存入BP</span></div><div class="line">        <span class="number">0</span>x000c <span class="number">00012</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        ADDQ    R8, BP</div><div class="line">					<span class="comment">//将a+i存入a的地址</span></div><div class="line">        <span class="number">0</span>x000f <span class="number">00015</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        MOVQ    BP, (AX)</div><div class="line">					<span class="comment">//将a地址最新数据存入BP</span></div><div class="line">        <span class="number">0</span>x0012 <span class="number">00018</span> (test<span class="selector-class">.go</span>:<span class="number">8</span>)        MOVQ    (AX), BP</div><div class="line">					<span class="comment">//将a最新值作为返回值放入main函数栈中</span></div><div class="line">        <span class="number">0</span>x0015 <span class="number">00021</span> (test<span class="selector-class">.go</span>:<span class="number">8</span>)        MOVQ    BP, <span class="string">""</span>.~r1+<span class="number">16</span>(FP)</div><div class="line">        <span class="number">0</span>x001a <span class="number">00026</span> (test<span class="selector-class">.go</span>:<span class="number">8</span>)        RET</div></pre></td></tr></table></figure></p>
<p>闭包函数的调用过程:</p>
<ol>
<li>通过闭包对象地址获取闭包上下文数据a的地址;</li>
<li>接着通过a的地址获取到a的值，并与参数i相加；</li>
<li>将a+i作为最新值存入a的地址；</li>
<li>将a最新值返回给main函数；</li>
</ol>
<h1>总结</h1>
<hr>
<p>这篇文章简单地从汇编角度分析了golang多值返回和闭包的实现；</p>
<ul>
<li>多值返回主要是通过fp寄存器+offset获取参数以及存入返回值实现；</li>
<li>闭包主要是通过在编译时生成包含闭包函数和闭包上下文数据的结构体实现；</li>
</ul>
<p>有什么不对的地方，希望各位能指出来，谢谢~</p>
]]></content>
      
        <categories>
            
            <category> golang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> golang </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang之database/sql与go-sql-driver]]></title>
      <url>http://luodw.cc/2016/08/28/golang02/</url>
      <content type="html"><![CDATA[<p>上篇文章也有说道，golang的http,rpc,以及第三方的redigo,go-sql-driver是开发一个服务常见的四大组件，因此我是很推荐有时间可以看下上述四大组件，而且golang自带的http和rpc框架本身就是http和rpc很好的教程，而且第三方框架miekg/dns也是采用http框架的形式，所以看懂http，对快速看懂miekg/dns是很有帮助的；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1612992717.jpg" alt="厦大美景"></p>
<p>redigo相对较小，看起来比较容易，但是必须好好学习下redis的网络传输协议；http协议看懂整体流程相对较简单，但是要完全看懂，需要一定时日，毕竟内容较多；而golang的rpc框架可以基于tcp和http，也是比较好看懂，主要是反射比较多，rpc关键用了http自带的gob数解析格式，可以顺便学习下gob是如何使用的；而数据库操作之前用的就是挺迷糊的，明明有两个包database/sql和go-sql-driver为什么就只调用了database/sql里面的接口，因此在看了database/sql和go-sql-driver代码之后，就恍然大悟，也写篇博客记录下；</p>
<h1>前言</h1>
<hr>
<p>这里先给出简单例子，说明下如何使用database/sql；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	<span class="string">"database/sql"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	<span class="keyword">db</span>, <span class="keyword">err</span> := sql.<span class="keyword">Open</span>(<span class="string">"mysql"</span>, <span class="string">"root:root@/test"</span>)</div><div class="line">	checkErr(<span class="keyword">err</span>)</div><div class="line">	rows, <span class="keyword">err</span> := <span class="keyword">db</span>.<span class="keyword">Query</span>(<span class="string">"select * from test"</span>)</div><div class="line">	checkErr(<span class="keyword">err</span>)</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		id   uint64</div><div class="line">		name <span class="built_in">string</span></div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> rows.Next() &#123;</div><div class="line">		<span class="keyword">err</span> = rows.Scan(&amp;id, &amp;name)</div><div class="line">		checkErr(<span class="keyword">err</span>)</div><div class="line">		fmt.Println(id, <span class="string">"-&gt;"</span>, name)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func checkErr(<span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		panic(<span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子很简单，先实例化一个数据库实例，然后通过db实例的query方法查询test数据库中的数据；大家可以看到，并没有用到go-sql-driver这个驱动程序，这是为什么了？</p>
<p>首先给出两个结论:</p>
<ol>
<li>database/sql是golang提供操作数据库的接口，但是有些内部方法需要调用驱动程序的接口；</li>
<li>go-sql-driver是符合database/sql接口的一套驱动程序，因此，真正进行数据库操作的接口是在go-sql-driver中实现的；</li>
</ol>
<p>好，接下来，我们看下database/sql是如何调用go-sql-driver的接口的；</p>
<h1>database/sql与go-sql-driver</h1>
<hr>
<p>我们先来看下，database/sql是如何注册驱动程序的，这个有点类似于linux虚拟文件系统，注册不同的文件系统，最后调用的就是相应文件系统的接口；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//database/sql/sql.go</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	driversMu sync.Mutex</div><div class="line">	drivers   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]driver.Driver)</div><div class="line">)</div><div class="line"><span class="comment">/*-------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, driver driver.Driver)</span></span> &#123;</div><div class="line">	driversMu.Lock()</div><div class="line">	<span class="keyword">defer</span> driversMu.Unlock()</div><div class="line">	<span class="keyword">if</span> driver == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sql: Register driver is nil"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> _, dup := drivers[name]; dup &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sql: Register called twice for driver "</span> + name)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将驱动放入map中</span></div><div class="line">	drivers[name] = driver</div><div class="line">&#125;</div><div class="line"><span class="comment">/*--------------------------------------------------------*/</span></div><div class="line"><span class="comment">//go-sql-driver/mysql/driver.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	sql.Register(<span class="string">"mysql"</span>, &amp;MySQLDriver&#123;&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个代码可以看出，向database/sql注册驱动，其实就是将驱动程序存入database/sql内部定义的一个map中；而init()函数是在包引入时首先执行的函数，因此我们在使用go-sql-driver时，就不用显式注册驱动，因为包引入时，就已经注册好；我们接下来看下如何获得一个数据库；</p>
<h2>获取一个数据库</h2>
<p>由上述例子程序可以看出，要操作数据库，必须先获取一个数据库实例db，代码如下:
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//database/sql/sql.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span> &#123;</div><div class="line">	driversMu.Lock()</div><div class="line">	driveri, ok := drivers[driverName]</div><div class="line">	driversMu.Unlock()</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"sql: unknown driver %q (forgotten import?)"</span>, driverName)</div><div class="line">	&#125;</div><div class="line">	db := &amp;DB&#123;</div><div class="line">		driver:   driveri,</div><div class="line">		dsn:      dataSourceName,</div><div class="line">		openerCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, connectionRequestQueueSize),</div><div class="line">		lastPut:  <span class="built_in">make</span>(<span class="keyword">map</span>[*driverConn]<span class="keyword">string</span>),</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> db.connectionOpener()</div><div class="line">	<span class="keyword">return</span> db, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由这段代码，根据driverName获取驱动程序实例，然后封装成一个db实例返回，此时并没有一个连接存在；而是开启了一个goroutine来生产连接；我们来看下这个goroutine是怎么生产连接的；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) connectionOpener() &#123;</div><div class="line">	<span class="comment">//这个channel的缓冲区大小为1000000</span></div><div class="line">	<span class="keyword">for</span> <span class="keyword">range</span> <span class="keyword">db</span>.openerCh &#123;</div><div class="line">		<span class="keyword">db</span>.openNewConnection()</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Open one new connection</span></div><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) openNewConnection() &#123;</div><div class="line">	<span class="comment">//这是database/sql第一次调用驱动的接口，获取一个真实的连接</span></div><div class="line">	<span class="keyword">ci</span>, <span class="keyword">err</span> := <span class="keyword">db</span>.driver.<span class="keyword">Open</span>(<span class="keyword">db</span>.dsn)</div><div class="line">	<span class="keyword">db</span>.mu.Lock()</div><div class="line">	defer <span class="keyword">db</span>.mu.Unlock()</div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.closed &#123;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> == nil &#123;</div><div class="line">			<span class="keyword">ci</span>.<span class="keyword">Close</span>()</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">db</span>.pendingOpens--</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">db</span>.putConnDBLocked(nil, <span class="keyword">err</span>)</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将从驱动获取的连接封装成driverConn</span></div><div class="line">	dc := &amp;driverConn&#123;</div><div class="line">		<span class="keyword">db</span>: <span class="keyword">db</span>,</div><div class="line">		<span class="keyword">ci</span>: <span class="keyword">ci</span>,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将新生成的driverConn放入空闲数组中</span></div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.putConnDBLocked(dc, <span class="keyword">err</span>) &#123;</div><div class="line">		<span class="keyword">db</span>.addDepLocked(dc, dc)</div><div class="line">		<span class="keyword">db</span>.numOpen++</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">ci</span>.<span class="keyword">Close</span>()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此，在获取一个db实例的时候，同时也生成了一个生产连接的goroutine，这个goroutine阻塞在channel中，当需要连接的时候，直接向这个channel发送数据即可；那么什么时候会产生连接了？有以下两种情况:</p>
<ol>
<li>第一次调用ping函数的时候，会产生一个连接；</li>
<li>当调用db.Exec或者db.Query等方法时，如果空闲数组中有连接，则直接获取，如果空闲数组中没有可用的连接，则会产生一个新的连接；</li>
</ol>
<h2>ping函数</h2>
<p>这里用ping函数来演示，如何通过向上述的goroutine发送数据，并产生一个连接，来，看下ping函数:
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Ping</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">//获取一个连接</span></div><div class="line">	dc, err := db.conn(cachedOrNewConn)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将连接放入空闲数组中</span></div><div class="line">	db.putConn(dc, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ping这个函数很简单，调用db.conn获取一个连接，参数表示获取策略，可以是</p>
<ol>
<li>cachedOrNewConn从空闲数组获取或者新新生成一个连接</li>
<li>alwaysNewConn总是从新生成一个连接</li>
</ol>
<p>接下来，看下db.conn函数:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">func (db *DB) conn(strategy connReuseStrategy) (*driverConn, error) &#123;</div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Lock</span>()</div><div class="line">	<span class="keyword">if</span> db<span class="selector-class">.closed</span> &#123;</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		return nil, errDBClosed</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果策略可以从空闲连接数组中获取，且空闲连接大于0,则直接从空闲数组获取连接返回；</span></div><div class="line">	numFree := len(db.freeConn)</div><div class="line">	<span class="keyword">if</span> strategy == cachedOrNewConn &amp;&amp; numFree &gt; <span class="number">0</span> &#123;</div><div class="line">		conn := db<span class="selector-class">.freeConn</span>[<span class="number">0</span>]</div><div class="line">		copy(db<span class="selector-class">.freeConn</span>, db<span class="selector-class">.freeConn</span>[<span class="number">1</span>:])</div><div class="line">		db<span class="selector-class">.freeConn</span> = db<span class="selector-class">.freeConn</span>[:numFree-<span class="number">1</span>]</div><div class="line">		conn<span class="selector-class">.inUse</span> = true</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		return conn, nil</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果当前打开的连接数大于设定的最大连接数，则阻塞在connQequest这个channel上，</span></div><div class="line">	<span class="comment">//下文再揭晓什么时候往这个channel写数据</span></div><div class="line">	<span class="keyword">if</span> db<span class="selector-class">.maxOpen</span> &gt; <span class="number">0</span> &amp;&amp; db<span class="selector-class">.numOpen</span> &gt;= db<span class="selector-class">.maxOpen</span> &#123;</div><div class="line">		req := make(chan connRequest, <span class="number">1</span>)</div><div class="line">		db<span class="selector-class">.connRequests</span> = append(db<span class="selector-class">.connRequests</span>, req)</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		ret := &lt;-req</div><div class="line">		return ret<span class="selector-class">.conn</span>, ret<span class="selector-class">.err</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果空闲连接数组中没有可用连接，且当前打开连接数还没达到最大值，则直接生成一个连接；</span></div><div class="line">	db.numOpen++ </div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">	ci, err := db<span class="selector-class">.driver</span><span class="selector-class">.Open</span>(db.dsn)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Lock</span>()</div><div class="line">		db<span class="selector-class">.numOpen--</span> <span class="comment">// 获取失败，则当前连接数减一</span></div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Lock</span>()</div><div class="line">	<span class="comment">//封装成driverConn</span></div><div class="line">	dc := &amp;driverConn&#123;</div><div class="line">		db: db,</div><div class="line">		ci: ci,</div><div class="line">	&#125;</div><div class="line">	db.addDepLocked(dc, dc)</div><div class="line">	dc<span class="selector-class">.inUse</span> = true</div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">	return dc, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个函数可以看出，并不是所有连接都是从之前提到的那个goroutine产生，这个db.conn也会直接调用driver.Open函数产生连接；接下来看下ping函数内部是如何把连接放入空闲连接数组中的；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) putConn(dc *driverConn, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">db</span>.mu.Lock()</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> == driver.ErrBadConn &#123;</div><div class="line">		<span class="keyword">db</span>.maybeOpenNewConnections()</div><div class="line">		<span class="keyword">db</span>.mu.Unlock()</div><div class="line">		dc.<span class="keyword">Close</span>()</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	added := <span class="keyword">db</span>.putConnDBLocked(dc, nil)</div><div class="line">	<span class="keyword">db</span>.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !added &#123;</div><div class="line">		dc.<span class="keyword">Close</span>()</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数内部，如果传进来的err为driver.ErrBadConn，那么之前在调用db.conn时获取的是一个无效的连接，因此这里需要调用db.maybeOpenNewConnections()来产生新连接；这个函数后面分析，先来看下added := db.putConnDBLocked(dc, nil)
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) putConnDBLocked(dc *driverConn, <span class="keyword">err</span> <span class="keyword">error</span>) bool &#123;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.maxOpen &gt; 0 &amp;&amp; <span class="keyword">db</span>.numOpen &gt; <span class="keyword">db</span>.maxOpen &#123;</div><div class="line">		<span class="keyword">return</span> false</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果有goroutine阻塞在获取连接上，则将这个本应该放回空闲连接数组的连接</span></div><div class="line">	<span class="comment">//返回给那个goroutine</span></div><div class="line">	<span class="keyword">if</span> c := len(<span class="keyword">db</span>.connRequests); c &gt; 0 &#123;</div><div class="line">		req := <span class="keyword">db</span>.connRequests[0]</div><div class="line">		<span class="keyword">copy</span>(<span class="keyword">db</span>.connRequests, <span class="keyword">db</span>.connRequests[1:])</div><div class="line">		<span class="keyword">db</span>.connRequests = <span class="keyword">db</span>.connRequests[:c-1]</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> == nil &#123;</div><div class="line">			dc.inUse = true</div><div class="line">		&#125;</div><div class="line">		req &lt;- connRequest&#123;</div><div class="line">			conn: dc,</div><div class="line">			<span class="keyword">err</span>:  <span class="keyword">err</span>,</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> true</div><div class="line">	<span class="comment">//否则将这个连接放入空闲数组中</span></div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">err</span> == nil &amp;&amp; !<span class="keyword">db</span>.closed &amp;&amp; <span class="keyword">db</span>.maxIdleConnsLocked() &gt; len(<span class="keyword">db</span>.freeConn) &#123;</div><div class="line">		<span class="keyword">db</span>.freeConn = <span class="keyword">append</span>(<span class="keyword">db</span>.freeConn, dc)</div><div class="line">		<span class="keyword">return</span> true</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ok，到这里，可以做个小结</p>
<ul>
<li>当某个goroutine需要一个连接的时候，首先查看空闲连接数组中是否有可用连接，如果有，则直接从空闲数组中获取；如果空闲数组中没有可用的连接，则需要判断当前打开的连接数是否超出设定的最大值，如果是，则当前goroutine阻塞；如果当前打开的连接数并没有大于设定的最大值，则直接生产一个连接返回；</li>
<li>当某个goroutine结束数据库操作时，将当前使用的连接放入空闲连接数组中，这时需要进行判断，是否有某个goroutine阻塞在获取连接上，如果有，则将当前的连接直接返回给阻塞的goroutine，如果没有goroutine阻塞在获取连接上，则可以直接放入空闲连接数组即可；</li>
</ul>
<p>之前还提到一个问题，就是当在putConn函数中，如果传入的是一个badConn，那么这时可能要生成新的连接；道理也很简单，因为如果某个goroutine阻塞在获取连接上，那么可能因为这个连接未及时调用putConn而阻塞更久；</p>
<p>我们来看下这个db.maybeOpenNewConnections()函数
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) maybeOpenNewConnections() &#123;</div><div class="line">	<span class="comment">//需要产生新的连接数量，db.pendingOpens是正在生成连接的数量</span></div><div class="line">	numRequests := len(<span class="keyword">db</span>.connRequests) - <span class="keyword">db</span>.pendingOpens</div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.maxOpen &gt; 0 &#123;</div><div class="line">		numCanOpen := <span class="keyword">db</span>.maxOpen - (<span class="keyword">db</span>.numOpen + <span class="keyword">db</span>.pendingOpens)</div><div class="line">		<span class="keyword">if</span> numRequests &gt; numCanOpen &#123;</div><div class="line">			numRequests = numCanOpen</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> numRequests &gt; 0 &#123;</div><div class="line">		<span class="keyword">db</span>.pendingOpens++</div><div class="line">		numRequests--</div><div class="line">		<span class="comment">//向db.openerCh发送数据，connectionOpener便会产生一个新连接</span></div><div class="line">		<span class="keyword">db</span>.openerCh &lt;- struct&#123;&#125;&#123;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，才知道，原来一开始产生db的时候，新建的goroutine是在当连接出错时，用来生产连接的；</p>
<h2>db.Query方法</h2>
<p>之前已经知道如何获取一个连接，接着我们可以用db.Query是方法是如何实现的；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) <span class="keyword">Query</span>(<span class="keyword">query</span> string, <span class="keyword">args</span> ...interface&#123;&#125;) (*Rows, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">var</span> rows *Rows</div><div class="line">	<span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span></div><div class="line">	<span class="keyword">for</span> i := 0; i &lt; maxBadConnRetries; i++ &#123;</div><div class="line">		rows, <span class="keyword">err</span> = <span class="keyword">db</span>.<span class="keyword">query</span>(<span class="keyword">query</span>, <span class="keyword">args</span>, cachedOrNewConn)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != driver.ErrBadConn &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> == driver.ErrBadConn &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">db</span>.<span class="keyword">query</span>(<span class="keyword">query</span>, <span class="keyword">args</span>, alwaysNewConn)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> rows, <span class="keyword">err</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数，最终调用的是db.query()函数
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//database/sql/sql.go</span></div><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) <span class="keyword">query</span>(<span class="keyword">query</span> string, <span class="keyword">args</span> []interface&#123;&#125;, strategy connReuseStrategy) (*Rows, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="comment">//调用db.conn获取连接，如果出错，则回到Query方法的for循环中</span></div><div class="line">	<span class="keyword">ci</span>, <span class="keyword">err</span> := <span class="keyword">db</span>.conn(strategy)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">db</span>.queryConn(<span class="keyword">ci</span>, <span class="keyword">ci</span>.releaseConn, <span class="keyword">query</span>, <span class="keyword">args</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">/*-------------------------------------------------------------*/</span></div><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) queryConn(dc *driverConn, releaseConn func(<span class="keyword">error</span>), <span class="keyword">query</span> string, <span class="keyword">args</span> []interface&#123;&#125;) (*Rows, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="comment">//driver.Queryer是一个接口，只有query方法；从驱动中获取的</span></div><div class="line">	<span class="comment">//连接必须实现Query方法，</span></div><div class="line">	<span class="keyword">if</span> queryer, ok := dc.<span class="keyword">ci</span>.(driver.Queryer); ok &#123;</div><div class="line">		dargs, <span class="keyword">err</span> := driverArgs(nil, <span class="keyword">args</span>)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">			releaseConn(<span class="keyword">err</span>)</div><div class="line">			<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">		&#125;</div><div class="line">		dc.Lock()</div><div class="line">		<span class="comment">//调用go-sql-driver中连接的Query方法</span></div><div class="line">		rowsi, <span class="keyword">err</span> := queryer.<span class="keyword">Query</span>(<span class="keyword">query</span>, dargs)</div><div class="line">		dc.Unlock()</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != driver.ErrSkip &#123;</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">				releaseConn(<span class="keyword">err</span>)</div><div class="line">				<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 将结果封装成Rows</span></div><div class="line">			rows := &amp;Rows&#123;</div><div class="line">				dc:          dc,</div><div class="line">				releaseConn: releaseConn,</div><div class="line">				rowsi:       rowsi,</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> rows, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	...省去一些代码...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从queryConn函数可以看出，db.Query方法最终调用go-sql-driver驱动中mysqlConn.Query方法，最后将结果封装成Rows，返回给客户端；最后看下go-sql-driver的mysqlConn.Query方法
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *mysqlConn)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args []driver.Value)</span> <span class="params">(driver.Rows, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> mc.netConn == <span class="literal">nil</span> &#123;</div><div class="line">		errLog.Print(ErrInvalidConn)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, driver.ErrBadConn</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 发送sql语句请求，comQuery是查询类型</span></div><div class="line">	err := mc.writeCommandPacketStr(comQuery, query)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// 读取结果</span></div><div class="line">		<span class="keyword">var</span> resLen <span class="keyword">int</span></div><div class="line">		resLen, err = mc.readResultSetHeaderPacket()</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			rows := <span class="built_in">new</span>(textRows)</div><div class="line">			rows.mc = mc</div><div class="line"></div><div class="line">			<span class="keyword">if</span> resLen == <span class="number">0</span> &#123;</div><div class="line">				<span class="comment">// no columns, no more data</span></div><div class="line">				<span class="keyword">return</span> emptyRows&#123;&#125;, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Columns</span></div><div class="line">			rows.columns, err = mc.readColumns(resLen)</div><div class="line">			<span class="keyword">return</span> rows, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，对于实现database/sql接口的驱动，操作的是真实的数据库，然后将结果返回给database/sql中的方法；其他方法类似，这里不一一分析；</p>
<h1>总结</h1>
<p>这篇文章主要分析了golang的database/sql模块是如何调用驱动中定义的方法；了解这些之后，对于使用database/sql将会更加得心应手，以及在驱动出现错误时，可以更快速的定位到错误；</p>
<p>之前看到很多地方都有用到protobuf，因此决定好好研究下这个框架，下次理解透之后，在发出来.</p>
]]></content>
      
        <categories>
            
            <category> golang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> golang </tag>
            
            <tag> database/sql </tag>
            
            <tag> go-sql-driver </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang语言之groupcache]]></title>
      <url>http://luodw.cc/2016/08/23/golang01/</url>
      <content type="html"><![CDATA[<p>实习期间一直在用golang，今天想写篇博客，聊聊我对golang的一些思考，以及分析下groupcache的实现；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/1356594941.jpg" alt="厦大美景"></p>
<p>在没接触golang之前，在我的印象里，服务器开发就是常见的nginx多进程，memcache多线程，redis单线程；后来，golang这种多协程，一个连接对应一个协程的模式深深吸引了我，相比进程，线程，协程粒度相对较小，协程切换代价与进程和线程相比是非常小的，因此一个连接对应一个协程才得以行得通；</p>
<p>golang很适合写服务，首先是语言层面支持高并发，其次是对http和rpc接口封装，用户在写c/s架构服务器时，既可以用基于http的rest api接口实现客户端和服务器端的通信，同时还可以用rpc实现客户端和服务器端的通信，而且支持多种数据格式传输，例如xml,json,gob等等；最后就是部署简单，生成可执行文件，直接运行；</p>
<p>学习golang，首先是学习基础语法，这个网上有很多教程，有一本《Go语言编程》很适合入门；其次就需要学习go语言层面底层的一些东西，例如协程切换，socket编程原理以及gc等等；这是非常有必要的，因为了解这些，对golang的使用会更加得心应手；例如golang网络编程，是怎么通知某个描述符有事件到达的?协程一开始阻塞在read调用中，当有数据达到之后，是怎么被唤醒的?等；我推荐两本gitbook，一个适合入门，一个适合深入:</p>
<ul>
<li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/index.html" target="_blank" rel="external">深入理解Go</a></li>
<li><a href="https://tracymacding.gitbooks.io/implementation-of-golang/content/" target="_blank" rel="external">Implemention of golang</a></li>
</ul>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2016/08/23/golang01/">http://luodw.cc/2016/08/23/golang01/</a></p>
<p>在了解基础于语法以及一些底层原理之后，我觉得可以看看golang自带的框架，写的非常棒，很适合学习，特别是http和rpc，因为学习这两个框架可以了解到一次http请求是如何实现的，以及一次rpc过程是怎么实现的；当然还有一些第三方开源框架也写得很好；</p>
<p>ok，下面就来看看缓存库groupcache是怎么实现的。</p>
<h1>groupcache</h1>
<hr>
<p>groupcache存储的是kv结构，同是memcache作者出品，官方github上说明如下：</p>
<blockquote>
<p>groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases.</p>
</blockquote>
<p>也就是说groupcache是一个kv缓存，用于在某些方面替代memcache，但是我在学习了这个框架之后，我发现这个框架的适用场景并不多，因为groupcache只能get，不能update和delete，也不能设置过期时间，只能通过lru淘汰最近最少访问的数据；有些数据如果长时间不更改，那么可以用groupcache作为缓存；groupcache已经在dl.Google.com、Blogger、Google Code、Google Fiber、Google生产监视系统等项目中投入使用。</p>
<p>但是groupcache还是有它的优点的，groupcache既是服务器，也是客户端，当在本地groupcache缓存中没有查找的数据时，通过一致性哈希，查找到该key所对应的peer服务器，在通过http协议，从该peer服务器上获取所需要的数据；还有一点就是当多个客户端同时访问memcache中不存在的键时，会导致多个客户端从mysql获取数据并同时插入memcache中，而在相同情况下，groupcache只会有一个客户端从mysql获取数据，其他客户端阻塞，直到第一个客户端获取到数据之后，再返回给多个客户端；</p>
<p>groupcache是一个缓存库，也就是说不是一个完整的软件，需要自己实现main函数。可以自己写个测试程序，跑跑groupcache，我看了有些博客是直接引用<a href="http://capotej.com/blog/2013/07/28/playing-with-groupcache/" target="_blank" rel="external">Playing With Groupcache</a>这篇博客的测试程序，这个测试程序，客户端和groupcache通过rpc进行通信，而groupcache peer之间通过http协议进行通信；这是比较好的做法，因为如果客户端与服务器通信和groupcache之间通信采用的是同一个端口，那么在并发量上去的时候，会严重影响性能；下图是这个测试程序的架构图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-topology.png" alt="groupcache结构图"></p>
<p>这个原理就是如果客户端用的是set或get命令时，这时直接操作的是数据源(数据库或文件)，如果调用的是cget命令，则从groupcache中查找数据；</p>
<p>groupcache内部实现了lru和一致性哈希，我觉得大家可以看看，学习golang是如何实现lru和一致性哈希。下面简单分析groupcache Get函数的实现以及peer之间的通信；</p>
<h2>groupcache Get函数实现</h2>
<p>当客户端连上groupcache时，能做的只有get获取数据，如果本地有所需要的数据，则直接返回，如果没有，则通过一致性哈希函数判断这个key所对应的peer，然后通过http从这个peer上获取数据；如果这个peer上有需要的数据，则通过http回复给之前的那个groupcache；groupcache收到之后，保存在本地hotCache中，并返回给客户端；如果peer上也没有所需要的数据，则groupcache从数据源(数据库或者文件)获取数据，并将数据保存在本地mainCache，并返回给客户端；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Get</span><span class="params">(ctx Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="title">error</span></span> &#123;</div><div class="line">	g.peersOnce.Do(g.initPeers)</div><div class="line">	g.Stats.Gets.Add(<span class="number">1</span>)<span class="comment">//这是groupcache状态数据，即Get的次数+1</span></div><div class="line">	<span class="keyword">if</span> dest == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"groupcache: nil dest Sink"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//查找本地缓存，包括mainCache和hotCache</span></div><div class="line">	value, cacheHit := g.lookupCache(key)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> cacheHit &#123;</div><div class="line">		<span class="comment">//如果命中，直接返回</span></div><div class="line">		g.Stats.CacheHits.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> setSinkView(dest, value)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 如果本地没有命中，则从peer获取</span></div><div class="line">	destPopulated := <span class="literal">false</span></div><div class="line">	value, destPopulated, err := g.load(ctx, key, dest)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> destPopulated &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将value赋值给dest返回</span></div><div class="line">	<span class="keyword">return</span> setSinkView(dest, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个Get函数很简单，先检查本地cache是否存在，存在即返回，不存在则向peer获取，接下来看下load函数是如何实现的；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(ctx Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="params">(value ByteView, destPopulated <span class="keyword">bool</span>, err error)</span></span> &#123;</div><div class="line">	g.Stats.Loads.Add(<span class="number">1</span>)</div><div class="line">	<span class="comment">//下面这个loadGroup是保证当数据不存在时，只有一个客户端从peer或者数据源获取数据，</span></div><div class="line">	<span class="comment">//其他客户端阻塞，直到第一个客户端数据之后，所有客户端再返回；这个主要是通过sync.WaitGroup实现</span></div><div class="line">	viewi, err := g.loadGroup.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> value, cacheHit := g.lookupCache(key); cacheHit &#123;</div><div class="line">			g.Stats.CacheHits.Add(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		g.Stats.LoadsDeduped.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">var</span> value ByteView</div><div class="line">		<span class="keyword">var</span> err error</div><div class="line">		<span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</div><div class="line">			<span class="comment">//从peer获取数据</span></div><div class="line">			value, err = g.getFromPeer(ctx, peer, key)</div><div class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">				g.Stats.PeerLoads.Add(<span class="number">1</span>)</div><div class="line">				<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			g.Stats.PeerErrors.Add(<span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//从数据源获取数据</span></div><div class="line">		value, err = g.getLocally(ctx, key, dest)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			g.Stats.LocalLoadErrs.Add(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		g.Stats.LocalLoads.Add(<span class="number">1</span>)</div><div class="line">		destPopulated = <span class="literal">true</span> </div><div class="line">		<span class="comment">//将数据源获取的数据存储在本地mainCache中</span></div><div class="line">		g.populateCache(key, value, &amp;g.mainCache)</div><div class="line">		<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		value = viewi.(ByteView)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个load函数先是从peer获取数据，如果peer没有数据，则直接从数据源(数据库或文件)获取数据；ok，先看下groupcache是如何从数据源获取数据，然后再分析下如果从peer中获取数据；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getLocally</span><span class="params">(ctx Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="params">(ByteView, error)</span></span> &#123;</div><div class="line">	err := g.getter.Get(ctx, key, dest)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dest.view()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getLocallly函数主要是利用NewGroup创建Group时传进去的Getter，在调用这个Getter的Get函数从数据源获取数据。
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(name <span class="keyword">string</span>, cacheBytes <span class="keyword">int64</span>, getter Getter)</span> *<span class="title">Group</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> newGroup(name, cacheBytes, getter, <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说当groupcache以及peer不存在所需数据时，用户可以自己定义从哪获取数据以及如何获取数据，即定义Getter的实例即可；</p>
<h2>从peer获取数据</h2>
<p>当本地groupcache中不存在数据时，会先从peer处获取数据，我们来看下getFromPeer函数实现
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(ctx Context, peer ProtoGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</div><div class="line">	<span class="comment">//为了减少传输数据量，在peer之间，通过pb来传输数据</span></div><div class="line">	req := &amp;pb.GetRequest&#123;</div><div class="line">		Group: &amp;g.name,</div><div class="line">		Key:   &amp;key,</div><div class="line">	&#125;</div><div class="line">	res := &amp;pb.GetResponse&#123;&#125;</div><div class="line">	err := peer.Get(ctx, req, res)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	value := ByteView&#123;b: res.Value&#125;</div><div class="line">	<span class="keyword">if</span> rand.Intn(<span class="number">10</span>) == <span class="number">0</span> &#123;<span class="comment">//10%的概率将从peer获取的数据存储在本地hotCache</span></div><div class="line">		g.populateCache(key, value, &amp;g.hotCache)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个ProtoGetter是个接口，httpGetter结构体实现了这个接口，而上述传进getFromPeer函数的peer就是httpGetter,因此，我们可以来看下httpGet这个结构体的Get函数
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">func (h *httpGetter) Get(context Context, <span class="keyword">in</span> *pb<span class="selector-class">.GetRequest</span>, out *pb.GetResponse) error &#123;</div><div class="line">	u := fmt.Sprintf(</div><div class="line">		<span class="string">"%v%v/%v"</span>,</div><div class="line">		h<span class="selector-class">.baseURL</span>,</div><div class="line">		url.QueryEscape(<span class="keyword">in</span>.GetGroup()),</div><div class="line">		url.QueryEscape(<span class="keyword">in</span>.GetKey()),</div><div class="line">	)</div><div class="line">	req, err := http.NewRequest(<span class="string">"GET"</span>, u, nil)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	<span class="selector-tag">tr</span> := http<span class="selector-class">.DefaultTransport</span></div><div class="line">	<span class="keyword">if</span> h<span class="selector-class">.transport</span> != nil &#123;</div><div class="line">		<span class="selector-tag">tr</span> = h.transport(context)</div><div class="line">	&#125;</div><div class="line">	res, err := <span class="selector-tag">tr</span>.RoundTrip(req)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	defer res<span class="selector-class">.Body</span><span class="selector-class">.Close</span>()</div><div class="line">	<span class="keyword">if</span> res<span class="selector-class">.StatusCode</span> != http<span class="selector-class">.StatusOK</span> &#123;</div><div class="line">		return fmt.Errorf(<span class="string">"server returned: %v"</span>, res.Status)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//bufferPool是bytes.Buffer类型的对象池</span></div><div class="line">	<span class="selector-tag">b</span> := bufferPool.Get().(*bytes.Buffer)</div><div class="line">	<span class="selector-tag">b</span>.Reset()</div><div class="line">	defer bufferPool.Put(b)</div><div class="line">	_, err = io.Copy(<span class="selector-tag">b</span>, res.Body)<span class="comment">//将获取的数据copy给b</span></div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return fmt.Errorf(<span class="string">"reading response body: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	err = proto.Unmarshal(<span class="selector-tag">b</span>.Bytes(), out)<span class="comment">//将数据存在out中</span></div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return fmt.Errorf(<span class="string">"decoding response body: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数首先向peer发起一个http请求，然后将请求得到的封装在out *pb.GetResponse，返回给getFromPeer,并最终返回给客户端；</p>
<h1>总结</h1>
<p>这篇文章主要是聊聊我对学习golang的一些看法，以及分析下groupcache的实现原理，分析的不是很细，主要是对这个框架进行了分析，对groupcache有了整体的认识之后，再去看细节部分，会简单很多。</p>
<p>这几天再看sqlmock开源框架，这个主要作用就是，在单元测试时用来模拟数据库操作；主要原理就是实现一个驱动程序。在看这个sqlmock过程中，首先必须把database/sql以及go-sql-driver看懂，知道这两个是如何一起运作的，这样才能了解sqlmock的实现；过几天再把database/sql以及go-sql-driver的实现原理发出来。</p>
]]></content>
      
        <categories>
            
            <category> golang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> golang </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux内存分配与回收]]></title>
      <url>http://luodw.cc/2016/08/13/linux-cache/</url>
      <content type="html"><![CDATA[<p>之前在实习时，听了OOM的分享之后，就对linux内核内存管理充满兴趣；但是这块知识非常庞大，没有一定积累，不敢写下，担心误人子弟；所以经过一个一段时间的积累，对内核内存有一定了解之后，今天才写下这篇博客，记录以及分享；</p>
<p>之前也有写过linux内存管理，那篇文章主要是<a href="http://luodw.cc/2016/02/17/linux-memory/">linux内存管理</a>，这篇文章主要是分析了单个进程空间的内存布局与分配，今天这篇博客主要是从全局的视角分析下内核对内存的管理;
<img src="http://7xjnip.com1.z0.glb.clouddn.com/29381f30e924b899045823b46e061d950b7bf6d2.jpg" alt="厦大白城"></p>
<p>下面主要从以下方面介绍linux内存管理:</p>
<ul>
<li>进程的内存申请与分配</li>
<li>内存耗尽之后OOM</li>
<li>申请的内存都在哪？</li>
<li>系统回收内存</li>
</ul>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2016/08/13/linux-cache/">http://luodw.cc/2016/08/13/linux-cache/</a></p>
<h1>进程的内存申请与分配</h1>
<hr>
<p>之前有篇文章介绍hello world程序是如何载入内存以及是如何申请内存的；我在这，再次说明下；同样，还是先给出进程的地址空间，我觉得对于任何开发人员这张图是必须记住的，还有一张就是操作disk,memory以及cpu cache的时间图；
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_015.png" alt="进程的地址空间"></p>
<p>当我们在终端启动一个程序时，终端进程调用exec函数将可执行文件载入内存，此时代码段，数据段，bbs段，stack段都通过mmap函数映射到内存空间，堆则要根据是否有在堆上申请内存来决定是否映射；exec执行之后，此时并未真正开始执行进程，而是将cpu控制权交给了动态链接库装载器，由它来将该进程需要的动态链接库装载进内存；之后才开始进程的执行；这个过程可以通过strace命令跟踪进程调用的系统函数来分析，
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">charles@charles-Aspire-4741:~$ strace ./toUpper</div><div class="line">execve(<span class="string">"./toUpper"</span>, [<span class="string">"./toUpper"</span>], [/* 72 vars */]) = 0</div><div class="line">brk(NULL)                               = 0x1bef000</div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f30be5d8000</div><div class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=116232, ...&#125;) = 0</div><div class="line">mmap(NULL, 116232, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f30be5bb000</div><div class="line">close(3)                                = 0</div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = 3</div><div class="line"><span class="built_in">read</span>(3, <span class="string">"\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0"</span>..., 832) = 832</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1864888, ...&#125;) =: 0</div><div class="line">mmap(NULL, 3967488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f30bdfec000</div><div class="line">mprotect(0x7f30be1ac000, 2093056, PROT_NONE) = 0</div><div class="line">mmap(0x7f30be3ab000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bf000) = 0x7f30be3ab000</div><div class="line">mmap(0x7f30be3b1000, 14848, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f30be3b1000</div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>这是我上篇博客认识pipe中的程序，从这个输出过程，可以看出和我上述描述的一致；</p>
<p>当第一次调用malloc申请内存时，通过系统调用brk嵌入到内核，首先会进行一次判断，是否有关于堆的vma，如果没有，则通过mmap匿名映射一块内存给堆，并建立vma结构，挂到mm_struct描述符上的红黑树和链表上；然后回到用户态，通过内存分配器(ptmaloc,tcmalloc,jemalloc)算法将分配到的内存进行管理，返回给用户所需要的内存；</p>
<p>如果用户态申请大内存时，是直接调用mmap分配内存，此时返回给用户态的内存还是虚拟内存，直到第一次访问返回的内存时，才真正进行内存的分配；其实通过brk返回的也是虚拟内存，但是经过内存分配器进行切割分配之后(切割就必须访问内存)，全都分配到了物理内存</p>
<p>当进程在用户态通过调用free释放内存时，如果这块内存是通过mmap分配，则调用munmap直接返回给系统；否则内存是先返回给内存分配器，然后由内存分配器统一返还给系统，这就是为什么当我们调用free回收内存之后，再次访问这块内存时，可能不会报错的原因；</p>
<p>当然，当整个进程退出之后，这个进程占用的内存都会归还给系统；</p>
<h1>内存耗尽之后OOM</h1>
<hr>
<p>在实习期间，有一台测试机上的mysql实例经常被oom杀死；oom(out of memory)即为系统在内存耗尽时的自我拯救措施，他会选择一个进程，将其杀死，释放出内存；很明显，哪个进程占用的内存最多，即最可能被杀死，但事实是这样的吗？</p>
<p>今天早上去上班，刚好碰到了一起OOM，突然发现，oom一次，世界都安静下来了，哈哈；测试机上的redis被杀死了；
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Out of memory: <span class="keyword">Kill</span> process <span class="number">12312</span> (redis-<span class="keyword">server</span>) score <span class="number">9</span> <span class="keyword">or</span> sacrifice <span class="keyword">child</span></div><div class="line">Killed process <span class="number">12312</span>, UID <span class="number">501</span>, (redis-<span class="keyword">server</span>) total-vm:<span class="number">186660</span>kB, anon-rss:<span class="number">9388</span>kB, <span class="keyword">file</span>-rss:<span class="number">4</span>kB</div></pre></td></tr></table></figure></p>
<p>OOM关键文件oom_kill.c，里面介绍了当内存不够时，系统如何选择最应该被杀死的进程；选择因素有挺多的，除了进程占用的内存外，还有进程运行的时间，进程的优先级，是否为root用户进程，子进程个数和占用内存以及用户控制参数oom_adj都相关；</p>
<p>当产生oom之后，函数select_bad_process会遍历所有进程，通过之前提到的那些因素，每个进程都会得到一个oom_score分数，分数最高，则被选为杀死的进程；</p>
<p>我们可以通过设置/proc/&lt;pid&gt;/oom_adj分数来干预系统选择杀死的进程；
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * /proc/&lt;pid&gt;/oom_adj set to -17 protects from the oom killer for legacy</div><div class="line"> * purposes.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_DISABLE (-17)</span></div><div class="line"><span class="comment">/* inclusive */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_ADJUST_MIN (-16)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_ADJUST_MAX 15</span></div></pre></td></tr></table></figure></p>
<p>这是内核关于这个oom_adj调整值的定义；最大可以调整为15,最小为-16，如果为-17，则该进程就像买了vip会员一样，不会被系统驱逐杀死了；因此，如果在一台机器上有跑很多服务器，且你不希望自己的服务被杀死的话，就可以设置自己服务的oom_adj为-17；</p>
<p>当然，说到这，就必须提到另一个参数/proc/sys/vm/overcommit_memory，man proc说明如下:
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0: heuristic overcommit (this is the default)</div><div class="line">1: always overcommit, never<span class="built_in"> check</span></div><div class="line">2: always check, never overcommit</div></pre></td></tr></table></figure></p>
<p>意思就是当overcommit_memory为0时，则为启发式oom，即当申请的虚拟内存不是很夸张的大于物理内存，则系统允许申请；但是当进程申请的虚拟内存很夸张的大于物理内存，则就会产生OOM，例如只有8g的物理内存，然后redis虚拟内存占用了24G，物理内存占用3g,如果这时执行bgsave，子进程和父进程共享物理内存，但是虚拟内存是自己的，即子进程会申请24g的虚拟内存，这很夸张大于物理内存，就会产生一次OOM；</p>
<p>当overcommit_memory为1时，则永远都允许overmemory内存申请；即不管你多大的虚拟内存申请都允许，但是当系统内存耗尽时，这时就会产生oom；即上述的redis例子，在overcommit_memory=1时，是不会产生oom的，因为物理内存足够；</p>
<p>当overcommit_memory为2时，永远都不能超出某个限定额的内存申请，这个限定额为swap+RAM*系数（/proc/sys/vm/overcmmit_ratio，默认50%，可以自己调整），如果这么多资源已经用光，那么后面任何尝试申请内存的行为都会返回错误，这通常意味着此时没法运行任何新程序</p>
<p>以上就是oom的内容，了解原理，以及如何根据自己的应用，合理的设置OOM；</p>
<h1>系统申请的内存都在哪？</h1>
<hr>
<p>我们了解了一个进程的地址空间之后，是否会好奇，申请到的物理内存都存在哪了？可能很多人觉得，不就是物理内存吗？我这里说申请的内存在哪，是因为物理内存有分为cache和普通物理内存，可以通过free命令查看；而且物理内存还有分DMA,NORMAL,HIGH三个区，这里主要分析cache和普通内存；</p>
<p>通过第一部分，我们知道一个进程的地址空间几乎都是mmap函数申请，有文件映射和匿名映射两种；</p>
<h2>共享文件映射</h2>
<p>我们先来看下代码段和动态链接库映射段，这两个都是属于共享文件映射，也就是说由同一个可执行文件启动的两个进程是共享这两个段，都是映射到同一块物理内存；那么这块内存在哪了？我写了个程序测试如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">struct</span> stat sb;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">  	<span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;</div><div class="line">    	perror(<span class="string">"open"</span>);</div><div class="line">	&#125;  </div><div class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"fstat"</span>);  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,sb.st_size, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_SHARED , fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">    	perror(<span class="string">"mmap"</span>);  </div><div class="line">	 &#125;</div><div class="line">	<span class="comment">//必须执行下面memset函数，否则系统不会分配真实内存</span></div><div class="line">	<span class="built_in">memset</span>(p,<span class="string">'c'</span>,sb.st_size);</div><div class="line">	sleep(<span class="number">100</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先看下当前系统的内存使用情况:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           5828        1596        3612          47         620        3913</div><div class="line">Swap:          3904           4        3900</div></pre></td></tr></table></figure></p>
<p>当我在本地新建一个1G的文件</p>
<blockquote>
<p>dd if=/dev/zero of=fileblock bs=M count=1024</p>
</blockquote>
<p>然后调用上述程序，进行共享文件映射,此时内存使用情况为：
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> ./hello fileblock</div><div class="line">/*---------------------*/</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1679 </span>      <span class="number"> 2491 </span>        <span class="number"> 47 </span>      <span class="number"> 1656 </span>       3824</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div></pre></td></tr></table></figure></p>
<p>我们可以发现，buff/cache增长了大概1G，因此我们可以得出结论，代码段和动态链接库段是映射到内核cache中，也就是说当执行共享文件映射时，文件是先被读取到cache中，然后再映射到用户进程空间中；</p>
<h2>私有文件映射段</h2>
<p>对于进程空间中的数据段，其必须是私有文件映射；因为如果是共享文件映射，那么同一个可执行文件启动的两个进程，任何一个进程修改数据段，都将影响另一个进程了；我将上述测试程序改写成匿名文件映射：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">struct</span> stat sb;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">        <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        perror(<span class="string">"open"</span>);</div><div class="line">        &#125;  </div><div class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"fstat"</span>);  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,sb.st_size, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_PRIVATE , fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"mmap"</span>);  </div><div class="line">         &#125;</div><div class="line">        <span class="comment">//必须执行下面memset函数，否则系统不会分配真实内存</span></div><div class="line">        <span class="built_in">memset</span>(p,<span class="string">'c'</span>,sb.st_size);</div><div class="line">        sleep(<span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在执行程序执行，需要先将之前的cache释放掉，否则会影响结果</p>
<blockquote>
<p>echo 1 &gt;&gt; /proc/sys/vm/drop_caches</p>
</blockquote>
<p>接着执行程序，看下内存使用情况:
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//没执行程序之前的内存使用情况</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1679 </span>      <span class="number"> 3681 </span>        <span class="number"> 47 </span>       <span class="number"> 467 </span>       3840</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div><div class="line">/*------------------------------------------*/</div><div class="line">./hello fileblock</div><div class="line">/*-----------------------------------------*/</div><div class="line">//调用程序之后内存使用情况</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 2713 </span>      <span class="number"> 1584 </span>        <span class="number"> 47 </span>      <span class="number"> 1530 </span>       2806</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div></pre></td></tr></table></figure></p>
<p>从使用前和使用后对比，可以发现used和buff/cache分别增长了1G，说明当进行私有文件映射时，首先是将文件映射到cache中，然后如果某个文件对这个文件进行修改，则会从其他内存中分配一块内存先将文件数据拷贝至新分配的内存，然后再在新分配的内存上进行修改，这也就是写时复制；</p>
<p>这也很好理解，因为如果同一个可执行文件开启多个实例，那么内核先将这个可执行的数据段映射到cache，然后每个实例如果有修改数据段，则都将分配一个一块内存存储数据段，毕竟数据段也是一个进程私有的；</p>
<p>通过上述分析，可以得出结论，如果是文件映射，则都是将文件映射到cache中，然后根据共享还是私有进行不同的操作；</p>
<h2>私有匿名映射</h2>
<p>像bbs段，堆，栈这些都是匿名映射，因为可执行文件中没有相应的段；而且必须是私有映射，否则如果当前进程fork出一个子进程，那么父子进程将会共享这些段，一个修改都会影响到彼此，这是不合理的;</p>
<p>ok，现在我把上述测试程序改成私有匿名映射
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,SIZE, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">    	perror(<span class="string">"mmap"</span>);  </div><div class="line">	 &#125;</div><div class="line">	<span class="built_in">memset</span>(p,<span class="string">'c'</span>,SIZE);</div><div class="line">	sleep(<span class="number">100</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时再来看下内存的使用情况
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//程序执行前</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1698 </span>      <span class="number"> 3646 </span>        <span class="number"> 47 </span>       <span class="number"> 483 </span>       3821</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div><div class="line">/*------------------------------------------*/</div><div class="line">./hello</div><div class="line">/*------------------------------------------*/</div><div class="line">//测试程序执行之后</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 2749 </span>      <span class="number"> 2582 </span>        <span class="number"> 47 </span>       <span class="number"> 496 </span>       2771</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div></pre></td></tr></table></figure></p>
<p>我们可以看到，只有used增加了1G，而buff/cache并没有增长；说明，在进行匿名私有映射时，并没有占用cache，其实这也是有道理，因为就只有当前进程在使用这块这块内存，没有必要占用宝贵的cache;</p>
<h2>共享匿名映射</h2>
<p>当我们需要在父子进程共享内存时，就可以用到mmap共享匿名映射；那么共享匿名映射的内存是存放在哪了？我继续改写上述测试程序为共享匿名映射
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,SIZE, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"mmap"</span>);  </div><div class="line">         &#125;</div><div class="line">        <span class="built_in">memset</span>(p,<span class="string">'c'</span>,SIZE);</div><div class="line">        sleep(<span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时来看下内存的使用情况：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/测试程序执行前：</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           5828        1667        3661          47         499        3852</div><div class="line">Swap:          3904           4        3900</div><div class="line">/*-----------------------------------------*/</div><div class="line">./hello</div><div class="line">/*-----------------------------------------*/</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           5828        1694        2602        1071        1531        2801</div><div class="line">Swap:          3904           4        3900</div></pre></td></tr></table></figure></p>
<p>从上述结果，我们可以看出，只有buff/cache增长了1G，即当进行共享匿名映射时，这时是从cache中申请内存；道理也很明显，因为父子进程共享这块内存，共享匿名映射存在于cache，然后每个进程再映射到彼此的虚存空间，这样即可操作的是同一块内存，</p>
<h1>系统回收内存</h1>
<hr>
<p>当系统内存不足时，有两种方式进行内存释放，一种是手动的方式，另一种是系统自己触发的内存回收；先来看下手动触发方式；</p>
<h2>手动回收内存</h2>
<p>手动回收内存，之前也有演示过，即</p>
<blockquote>
<p>echo 1 &gt;&gt; /proc/sys/vm/drop_caches</p>
</blockquote>
<p>我们可以在man proc下面看到关于这个的简介
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">To free pagecache, use:</div><div class="line">	echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches<span class="title"></span></div><div class="line"></div><div class="line">To free<span class="title"> dentries</span> and<span class="title"> inodes,</span> use:<span class="title"></span></div><div class="line"></div><div class="line">	echo 2 &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches<span class="title"></span></div><div class="line"></div><div class="line">To free<span class="title"> pagecache,</span> dentries<span class="title"> and</span> inodes,<span class="title"> use:</span></div><div class="line"><span class="title"></span></div><div class="line">	echo 3 &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches<span class="title"></span></div><div class="line"> Because writing<span class="title"> to</span> this<span class="title"> file</span> is<span class="title"> a</span> nondestructive<span class="title">  operation</span> <span class="title"> and</span> <span class="title"> </span></div><div class="line">dirty <span class="title"> objects</span> <span class="title"> are</span> <span class="title"> not</span> <span class="title"> freeable,</span> <span class="title"> the</span> user<span class="title"> should</span> run<span class="title"> sync(1)</span> first.</div></pre></td></tr></table></figure></p>
<p>从这个介绍可以看出，当drop_caches文件为1时，这时将释放pagecache中可释放的部分(有些cache是不能通过这个释放的)；当drop_caches为2时，这时将释放dentries和inodes缓存；当drop_caches为3时，这同时释放上述两项；</p>
<p>关键还有最后一句，意思是说如果pagecache中有脏数据时，操作drop_caches是不能释放的，必须通过sync命令将脏数据刷新到磁盘，才能通过操作drop_caches释放pagecache；</p>
<p>ok，之前有提到有些pagecache是不能通过drop_caches释放的，那么除了上述提文件映射和共享匿名映射外，还有有哪些东西是存在pagecache了？</p>
<h3>tmpfs</h3>
<p>我们先来看下tmpfs; tmpfs和procfs,sysfs以及ramfs一样，都是基于内存的文件系统；tmpfs和ramfs的区别就是ramfs的文件基于纯内存的，和tmpfs除了纯内存外，还会使用swap交换空间，以及ramfs可能会把内存耗尽，而tmpfs可以限定使用内存大小；可以用命令df -T -h查看系统一些文件系统，其中就有一些是tmpfs，比较出名的是目录/dev/shm</p>
<p>tmpfs文件系统源文件在内核源码mm/shmem.c，tmpfs实现很复杂，之前有介绍虚拟文件系统，基于tmpfs文件系统创建文件和其他基于磁盘的文件系统一样，也会有inode,super_block,identry,file等结构，区别主要是在读写上，因为读写才涉及到文件的载体是内存还是磁盘；</p>
<p>而tmpfs文件的读函数shmem_file_read，过程主要为通过inode结构找到address_space地址空间，其实就是磁盘文件的pagecache；然后通过读偏移定位cache页以及页内偏移，这时就可以直接从这个pagecache通过函数__copy_to_user将缓存页内数据拷贝到用户空间；当我们要读物的数据不pagecache中时，这时要判断是否在swap中，如果在则先将内存页swap in，再读取；</p>
<p>tmpfs文件的写函数shmem_file_write，过程主要为先判断要写的页是否在内存中，如果在，则直接将用户态数据通过函数__copy_from_user拷贝至内核pagecache中覆盖老数据，并标为dirty；如果要写的数据不再内存中，则判断是否在swap中，如果在，则先读取出来，用新数据覆盖老数据并标为脏；如果即不在内存也不在磁盘，则新生成一个pagecache存储用户数据；</p>
<p>由上面分析，我们知道基于tmpfs的文件也是使用cache的，我们可以在/dev/shm上创建一个文件来检测下:
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有创建文件前内存使用情况</span></div><div class="line">charles<span class="meta">@charles</span>-Aspire<span class="number">-4741</span>:<span class="regexp">/dev/</span>shm$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line"><span class="string">Mem:</span>           <span class="number">5828</span>        <span class="number">1401</span>        <span class="number">2223</span>          <span class="number">42</span>        <span class="number">2204</span>        <span class="number">4058</span></div><div class="line"><span class="string">Swap:</span>          <span class="number">3904</span>           <span class="number">0</span>        <span class="number">3904</span></div><div class="line"><span class="comment">/*-----------------------------------------*/</span></div><div class="line">dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>zero of=fileblock bs=<span class="number">1</span>G count=<span class="number">1</span></div><div class="line"><span class="comment">/*-----------------------------------------*/</span></div><div class="line"><span class="comment">//在/dev/shm上创建一个1G的文件</span></div><div class="line">charles<span class="meta">@charles</span>-Aspire<span class="number">-4741</span>:<span class="regexp">/dev/</span>shm$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line"><span class="string">Mem:</span>           <span class="number">5828</span>        <span class="number">1400</span>        <span class="number">1197</span>        <span class="number">1066</span>        <span class="number">3229</span>        <span class="number">3035</span></div><div class="line"><span class="string">Swap:</span>          <span class="number">3904</span>           <span class="number">0</span>        <span class="number">3904</span></div></pre></td></tr></table></figure></p>
<p>看到了吧，cache增长了1G，验证了tmpfs的确使用的cache内存；</p>
<p>其实mmap匿名映射原理也是用了tmpfs，在mm/mmap.c-&gt;do_mmap_pgoff函数内部，有判断如果file结构为空以及为SHARED映射，则调用shmem_zero_setup(vma)函数在tmpfs上用新建一个文件
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int shmem_zero_setup(<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span> *vma)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *file;</div><div class="line">	loff_t size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">	file = shmem_file_setup(<span class="string">"dev/zero"</span>, size, vma-&gt;vm_flags);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(file))</div><div class="line">		<span class="keyword">return</span> PTR_ERR(file);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (vma-&gt;vm_file)</div><div class="line">		fput(vma-&gt;vm_file);</div><div class="line">	vma-&gt;vm_file = file;</div><div class="line">	vma-&gt;vm_ops = &amp;shmem_vm_ops;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就解释了为什么共享匿名映射内存初始化为0了；但是我们知道用mmap分配的内存初始化为0，就是说mmap私有匿名映射也为0,那么体现在哪了？</p>
<p>这个在do_mmap_pgoff函数内部可没有体现出来，而是在缺页异常，然后分配一种特殊的初始化为0的页；</p>
<p>那么这个tmpfs占有的内存页可以回收吗？
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//创建文件前</div><div class="line">free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1240 </span>      <span class="number"> 4040 </span>        <span class="number"> 41 </span>       <span class="number"> 547 </span>       4245</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 0 </span>       3904</div><div class="line">//创建文件之后</div><div class="line">root@charles-Aspire-4741:/dev/shm<span class="comment"># free -m</span></div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1243 </span>      <span class="number"> 3011 </span>      <span class="number"> 1065 </span>      <span class="number"> 1573 </span>       3217</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 0 </span>       3904</div><div class="line">/*------------------------------------------*/</div><div class="line">root@charles-Aspire-4741:/dev/shm<span class="comment"># echo 1 &gt;&gt; /proc/sys/vm/drop_caches</span></div><div class="line">/*-------------------------------------------*/</div><div class="line"> free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1243 </span>      <span class="number"> 3012 </span>      <span class="number"> 1065 </span>      <span class="number"> 1572 </span>       3217</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 0 </span>       3904</div></pre></td></tr></table></figure></p>
<p>也就是说tmpfs文件占有的pagecache是不能回收的；道理也很明显，因为有文件引用这些页，就不能回收；</p>
<h3>共享内存</h3>
<p>posix共享内存其实和mmap共享映射是同一个道理，都是利用在tmpfs文件系统上新建一个文件，然后再映射到用户态；最后两个进程操作同一个物理内存；那么System V共享内存是否也是利用tmpfs文件系统了？</p>
<p>我们可以跟踪到下述函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newseg</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_params *params)</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">//........</span></div><div class="line"><span class="built_in">sprintf</span>(name, <span class="string">"SYSV%08x"</span>, key);</div><div class="line"><span class="keyword">if</span>  ((shmflg &amp; SHM_NORESERVE) &amp;&amp;sysctl_overcommit_memory != OVERCOMMIT_NEVER)</div><div class="line">	acctflag = VM_NORESERVE;</div><div class="line">file = shmem_kernel_file_setup(name, size, acctflag);</div><div class="line"><span class="comment">//........</span></div></pre></td></tr></table></figure></p>
<p>这个函数就是新建一个共享内存段，其中函数</p>
<blockquote>
<p>shmem_kernel_file_setup</p>
</blockquote>
<p>就是在tmpfs文件系统上创建一个文件；然后通过这个内存文件实现进程通信；这我就不写测试程序了；而且这也是不能回收的，因为共享内存ipc机制生命周期是随内核的，也就是说你创建共享内存之后，如果不显示删除的话，进程退出之后，共享内存还是存在的；</p>
<p>之前看了一些技术博客，说到Poxic和System V两套ipc机制(消息队列，信号量以及共享内存)都是使用tmpfs文件系统，也就是说最终内存使用的都是pagecache，但是我在源码中看出了两个共享内存是基于tmpfs文件系统，其他信号量和消息队列还没看出来(有待后续考究)；</p>
<p>posix消息队列的实现有点类似与pipe的实现，也是自己一套mqueue文件系统，然后在inode上的i_private上挂上关于消息队列属性mqueue_inode_info，在这个属性上，内核2.6时，是用一个数组存储消息，而到了4.6则用红黑树了存储消息(我下载了这两个版本，具体什么时候开始用红黑树，没深究)；然后两个进程每次操作都是操作这个mqueue_inode_info中的消息数组或者红黑树，实现进程通信；和这个mqueue_inode_info类似的还有tmpfs文件系统属性shmem_inode_info和为epoll服务的文件系统eventloop,也有一个特殊属性struct eventpoll，这个是挂在file结构的private_data等等；</p>
<blockquote>
<p>说到这，可以小结下，进程空间中代码段，数据段，动态链接库(共享文件映射)，mmap共享匿名映射都存在于cache中，但是这些内存页都有被进程引用，所以是不能释放的；基于tmpfs的ipc进程间通信机制的生命周期是随内核，因此也是不能通过drop_caches释放；</p>
</blockquote>
<p>虽然上述提及的cache不能释放，但是后面有提到，当内存不足时，这些内存是可以swap out的；</p>
<p><strong>因此drop_caches能释放的就是当从磁盘读取文件时的缓存页以及某个进程将某个文件映射到内存之后，进程退出，这时映射文件的的缓存页如果没有被引用，也是可以被释放的;</strong></p>
<h2>内存自动释放方式</h2>
<p>当系统内存不够时，操作系统有一套自我整理内存，并尽可能的释放内存机制；如果这套机制不能释放足够多的内存，那么只能OOM了；</p>
<p>之前在提及oom时，说道redis因为oom被杀死，如下:
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Out of memory: <span class="keyword">Kill</span> process <span class="number">12312</span> (redis-<span class="keyword">server</span>) score <span class="number">9</span> <span class="keyword">or</span> sacrifice <span class="keyword">child</span></div><div class="line">Killed process <span class="number">12312</span>, UID <span class="number">501</span>, (redis-<span class="keyword">server</span>) total-vm:<span class="number">186660</span>kB, anon-rss:<span class="number">9388</span>kB, <span class="keyword">file</span>-rss:<span class="number">4</span>kB</div></pre></td></tr></table></figure></p>
<p>第二句后半部分，</p>
<blockquote>
<p>total-vm:186660kB, anon-rss:9388kB, file-rss:4kB</p>
</blockquote>
<p>把一个进程内存使用情况，用三个属性进行了说明，即所有虚拟内存，常驻内存匿名映射页以及常驻内存文件映射页；</p>
<p>其实从上述的分析，我们也可以知道一个进程其实就是文件映射和匿名映射；</p>
<ul>
<li>文件映射:代码段，数据段，动态链接库共享存储段以及用户程序的文件映射段；</li>
<li>匿名映射：bbs段，堆，以及当malloc用mmap分配的内存，还有mmap共享内存段；</li>
</ul>
<p>其实内核回收内存就是根据文件映射和匿名映射来进行的；在mmzone.h有如下定义:
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define LRU_BASE 0</span></div><div class="line"><span class="comment">#define LRU_ACTIVE 1</span></div><div class="line"><span class="comment">#define LRU_FILE 2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> &#123;</span></div><div class="line">	LRU_INACTIVE_ANON = LRU_BASE,<span class="regexp">//</span>不活跃匿名映射页lru</div><div class="line">	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,<span class="regexp">//</span>活跃匿名映射页lru</div><div class="line">	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,<span class="regexp">//</span>不活跃文件映射页lru</div><div class="line">	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,<span class="regexp">//</span>活跃文件映射页lru</div><div class="line">	LRU_UNEVICTABLE,</div><div class="line">	NR_LRU_LISTS</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>LRU_UNEVICTABLE即为不可驱逐页lru，我的理解就是当调用mlock锁住内存，不让系统swap out出去的页列表；</p>
<p>简单说下linux内核自动回收内存原理；内核有一个kswapd会周期性的检查内存使用情况，如果发现空闲内存定于pages_low，则kswapd会对lru_list前四个lru队列进行扫描，在活跃链表中查找不活跃的页，并添加不活跃链表；然后再遍历不活跃链表，逐个进行回收释放出32个页，知道free page数量达到pages_high；针对不同的页，回收方式也不一样；</p>
<p>当然，当内存水平低于某个极限阈值时，会直接发出内存回收，原理和kswapd一样，但是这次回收力度更大，需要回收更多的内存；</p>
<p>文件页：</p>
<ol>
<li>如果是脏页，则直接回写进磁盘，再回收内存；</li>
<li>如果不是脏页，则直接释放回收；因为如果是io读缓存，直接释放掉，下次读时，缺页异常，直接到磁盘读回来即可；如果是文件映射页，直接释放掉，下次访问时，也是产生两个缺页异常，一次将文件内容读取进磁盘，另一次与进程虚拟内存关联；</li>
</ol>
<p>匿名页：
因为匿名页没有回写的地方，如果释放掉，那么就找不到数据了，所以匿名页的回收是采取swap out到磁盘；并在页表项做个标记，下次缺页异常在从磁盘swap in进内存；</p>
<p>swap换进换出其实是很占用系统IO的，如果系统内存需求突然间迅速增长，那么cpu将被io占用，系统会卡死，导致不能对外提供服务；因此系统提供一个参数，用于设置当进行内存回收时，执行回收cache和swap匿名页的，这个参数为:
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/<span class="keyword">proc</span>/sys/vm/swappiness<span class="title"></span></div><div class="line">     The value<span class="title"> in</span> this<span class="title"> file</span> controls<span class="title"> how</span> aggressively<span class="title"> the</span> kernel<span class="title"> will</span></div><div class="line"><span class="title">     swap</span> memory<span class="title"> pages.</span> <span class="title"> Higher</span> values<span class="title"> increase</span> aggressiveness,<span class="title"> lower</span></div><div class="line"><span class="title">     values</span> decrease<span class="title"> aggressiveness.</span> <span class="title"> The</span> default<span class="title"> value</span> is 60.</div></pre></td></tr></table></figure></p>
<p>意思就是说这个值越高，越可能使用swap的方式回收内存；最大值为100；如果设为0，则尽可能使用回收cache的方式释放内存；</p>
<h1>总结</h1>
<p>这篇博客主要是写了linux内存管理相关的东西；首先是回顾了进程地址空间；其次当进程消耗大量内存而导致内存不足时，我们可以有两种方式，第一是手动回收cache；另一种是系统后台线程swapd执行内存回收工作；最后当申请的内存大于系统剩余的内存时，这时就只会产生oom，杀死进程，释放内存；从这个过程，可以看出系统为了腾出足够的内存，是多么的努力啊！！！</p>
<p>后记</p>
<blockquote>
<p>一开始决定在写最后一部分内存回收时，打算列出源码进行分析，但是发现linux内存回收比文件系统难看多了；所以暂时以分析原理为主，后面有时间，慢慢再看这块代码；</p>
</blockquote>
<blockquote>
<p>我一直很支持学计算机的朋友学习linux和c/c++，因为现在服务器几乎都是linux系统，而且经典高性能服务器软件大部分是c/c++(nginx,redis,mysql,redis,leveldb等等)写的，且跑在linux系统上；其次就是，linux暴露给外界进入的入口就是系统调用，其他语言如果想嵌入内核，就必须封装系统调用接口；而C++主要是锻炼oop思想还有泛型思想；因此，学好了linux和c/c++，再学其他软件或语言，都会轻松很多；<strong>这也就是我一直喜欢linux和c/c++的原因</strong></p>
</blockquote>
<blockquote>
<p>像这次实习接触golang语言；如果有c/c++基础，golang语法层面是很快熟悉的；然后如果了解linux系统系统调用以及内核原理，那么golang执行与系统相关的函数也会很好理解；像平时使用的网络编程，golang没有提供epoll接口，但是其实内部是有用这个epoll进行轮询的；后面要好好写写博客，聊聊golang</p>
</blockquote>
<p>还是那句话，如果有什么出错的地方，希望大家能指出来，感谢～</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> memory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从内核源码聊聊pipe实现]]></title>
      <url>http://luodw.cc/2016/08/01/pipeof/</url>
      <content type="html"><![CDATA[<p>用linux也有两年多了，从命令，系统调用，到内核原理一路学过来，我发现我是深深喜欢上这个系统；使用起来就是一个字“爽”；当初在看linux内核原理时，对linux内核源码有种敬畏的心理，不敢涉入，主要是看不懂，直到最近实习的时候，在某次分享会上，某位老师分享了OOM机制，我很感兴趣，就去看内核代码，发现，原来我能看懂了；所以想写篇博客，分享下从内核代码分析pipe的实现；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-39310_2010129_676673.jpg" alt="厦大上弦场"></p>
<p>这部分内容说简单也很简单，说难也难，其实就是需要了解linux内核一些原理，例如系统调用嵌入内核，虚拟文件系统等等；</p>
<p>接下来，我会从以下小点介绍管道</p>
<ul>
<li>用户态管道的使用；</li>
<li>虚拟文件系统</li>
<li>内核态管道的实现原理；</li>
<li>fifo命名管道实现</li>
<li>总结；</li>
</ul>
<h1>管道的使用</h1>
<hr>
<p>一开始接触linux，相信很多人都是从命令开始；当一个命令的输出，需要作为另一个命令的输入时，我们就会使用管道来实现这个功能；例如，我们经常需要在某个文档中查找是否存在某个单词，我们就可以用如下方式:</p>
<blockquote>
<p>cat test.txt | grep 'hello'</p>
</blockquote>
<p>这行命令表示在test.txt文件中查找包含单词'hello'的句子。我们先解释下这行命令是怎么实现的；</p>
<p>我们知道终端也是一个进程，当我们输入一个命令执行时，其实是终端程序调用fork和exec产生一个子进程执行命令程序；当终端在执行这行命令时，会先解析输入的参数，当发现输入的命令行中有‘|’符号时，就会知道在命令行中包含了管道，因此，在终端程序中，</p>
<ul>
<li>会先fork出一个子进程，并执行exec将cat载入内存；</li>
<li>接着在cat程序中，用函数pipe定义出管道;</li>
<li>在定义出管道之后，再调用fork，生成一个子进程；</li>
<li>在父进程cat中关闭管道读端，将cat进程的标准输出重定向到管道的写端；</li>
<li>在子进程中将管道的写端关闭，将标准输入重定向到管道的读端，再调用exec将grep进程载入内存；</li>
<li>最后，cat的输出就可以最为grep的输入了；</li>
</ul>
<p>这里需要说明的是，父进程cat对管道的操作必须在fork之前，否则父进程cat对管道的操作会继承到子进程，这样会导致子进程无法读取父进程的数据；我们可以用一个简单的程序来模拟上述过程，为了简单起见，例子简单地将字符串从小写转为大写；程序如下:
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;stdio.h&gt;</span></div><div class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></div><div class="line"><span class="comment">#include&lt;unistd.h&gt;</span></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  int fd[<span class="number">2</span>];</div><div class="line">  int ret=pipe(fd);<span class="regexp">//</span>创建管道</div><div class="line">  <span class="keyword">if</span> (ret==-<span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"pipe error!"</span>);</div><div class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  int pid=fork();</div><div class="line">  <span class="keyword">if</span> (pid&lt;<span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"fork error!"</span>);</div><div class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="regexp">//</span>在子进程中</div><div class="line">      close(fd[<span class="number">1</span>]);</div><div class="line">      dup2(fd[<span class="number">0</span>],STDIN_FILENO);<span class="regexp">//</span>将子进程的标准输入重定向到fd[<span class="number">0</span>]</div><div class="line">      ret=execl(<span class="string">"./toUpper"</span>,<span class="string">"toUpper"</span>, <span class="string">""</span>,NULL);<span class="regexp">//</span>执行子进程</div><div class="line">      <span class="keyword">if</span>(ret==-<span class="number">1</span>)&#123;</div><div class="line">        fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"execl error!"</span>);</div><div class="line">        <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="regexp">//</span> 以下是父进程</div><div class="line">  close(fd[<span class="number">0</span>]);</div><div class="line">  dup2(fd[<span class="number">1</span>],STDOUT_FILENO);<span class="regexp">//</span> 将父进程的标准输出重定向到fd[<span class="number">1</span>]</div><div class="line">  char buf[<span class="number">1024</span>];</div><div class="line">  int n=read(STDIN_FILENO,buf,<span class="number">1024</span>);<span class="regexp">//</span> 从标准输入读取数据</div><div class="line">  <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;</div><div class="line">    fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"read error!"</span>);</div><div class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">  &#125;<span class="regexp">//</span> 将数据写入管道缓冲区中</div><div class="line">  write(STDOUT_FILENO, buf,n);</div><div class="line">  sleep(<span class="number">1</span>);</div><div class="line">  return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述为主程序；在主程序中通过fork函数创建出一个子进程；在父进程中关闭管道读端，将标准输出重定向到管道写端；当在父进程有数据输出到标准输出时，就可以输出到管道的缓冲区；在子进程中，关闭管道写端，将标准输入重定向到管道读端，这样子进程从标准输入读取时，就可以从管道缓冲区读取；
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">chartoUp</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (ch&gt;<span class="string">'a'</span> &amp;&amp; ch &lt;<span class="string">'z'</span>) &#123;</div><div class="line">    ch = ch - <span class="number">32</span>;</div><div class="line">  &#125;<span class="keyword">else</span> &#123;</div><div class="line">    ch = ch;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> buf[BUFSIZE];</div><div class="line">  <span class="comment">// 从标准输入读取数据，其实就是从管道缓冲区读取数据</span></div><div class="line">  <span class="keyword">int</span> n=read(STDIN_FILENO,buf,BUFSIZE);</div><div class="line">  <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, <span class="string">"read error!"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (;i&lt;n;i++)</div><div class="line">  &#123;</div><div class="line">      buf[i]=toUp(buf[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述程序为父进程调用的子程序，先从管道缓冲区读取数据，然后将每个字母转换为大写字母，最后输出到标准输出；例子很简单，当然，也可以使用C语言io库封装好的popen函数来实现上述功能;</p>
<h1>虚拟文件系统</h1>
<hr>
<p>在讲管道之前，必须先介绍下linux虚拟文件系统，否则很难说清楚在这里；虚拟文件系统是linux内核四大模块之一，我们知道linux下面everything is file。例如磁盘文件，管道，套接字，设备等等；我们都可以通过read和write函数来读取上述文件的数据；为了支持这一特性，linux引入虚拟文件系统，就是通过一层文件系统虚拟层，屏蔽不同文件系统的差异，实现相同的函数接口操作；linux支持非常多的文件系统，我们可以通过查看</p>
<blockquote>
<p>cat /proc/filesystems</p>
</blockquote>
<p>包括基于磁盘的文件ext4,ext3等，基于内存的文件系统proc,pipefs,sysfs,ramf以及tmpfs,和套接字文件系统sockfs;</p>
<p>当我们在用户态调用read函数读取一个文件描述符时，主要过程如下:</p>
<ol>
<li>首先通过软中断嵌入内核，调用系统相应服务例程sys_read,sys_read函数如下:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">asmlinkage ssize_t sys_read(unsigned int fd, <span class="keyword">char</span> __user * buf, size_t <span class="keyword">count</span>)</div><div class="line">&#123;</div><div class="line">    struct <span class="keyword">file</span> *<span class="keyword">file</span>;</div><div class="line">    ssize_t <span class="keyword">ret</span> = -EBADF;</div><div class="line">    int fput_needed;</div><div class="line">    <span class="comment">// fget_light函数从当前进程的文件描述符表中，通过文件描述符，</span></div><div class="line">    <span class="comment">//　获取file结构体</span></div><div class="line">    <span class="keyword">file</span> = fget_light(fd, &amp;fput_needed);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">file</span>) &#123;</div><div class="line">    	loff_t pos = file_pos_read(<span class="keyword">file</span>);<span class="comment">//获取读取文件的偏移量</span></div><div class="line">        <span class="keyword">ret</span> = vfs_read(<span class="keyword">file</span>, buf, <span class="keyword">count</span>, &amp;pos);<span class="comment">//调用虚拟文件系统调用层</span></div><div class="line">    	file_pos_write(<span class="keyword">file</span>, pos);<span class="comment">//　更新当前文件的偏移量</span></div><div class="line">    	fput_light(<span class="keyword">file</span>, fput_needed);<span class="comment">//　更新文件的引用计数</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">ret</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>我们可以看到sys_read服务例程的参数和系统调用read的参数是一样的，首先通过fd从当前的文件数组中获取file实例，接着获取当前的读偏移量，然后进入虚拟文件系统vfs_read调用;</p>
<ol start="2">
<li>接下来看看vf_read虚拟层调用的过程:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ssize_t vfs_read(struct <span class="keyword">file</span> *<span class="keyword">file</span>, <span class="keyword">char</span> __user *buf, size_t <span class="keyword">count</span>, loff_t *pos)</div><div class="line">&#123;</div><div class="line">	struct inode *inode = <span class="keyword">file</span>-&gt;f_dentry-&gt;d_inode;</div><div class="line">	ssize_t <span class="keyword">ret</span>;</div><div class="line"> 	<span class="keyword">if</span> (!(<span class="keyword">file</span>-&gt;f_mode &amp; FMODE_READ))</div><div class="line">    		<span class="keyword">return</span> -EBADF;</div><div class="line">  	<span class="keyword">if</span> (!<span class="keyword">file</span>-&gt;f_op || (!<span class="keyword">file</span>-&gt;f_op-&gt;<span class="keyword">read</span> &amp;&amp; !<span class="keyword">file</span>-&gt;f_op-&gt;aio_read))</div><div class="line">    		<span class="keyword">return</span> -EINVAL;</div><div class="line">  	<span class="keyword">ret</span> = locks_verify_area(FLOCK_VERIFY_READ, inode, <span class="keyword">file</span>, *pos, <span class="keyword">count</span>);</div><div class="line">  	<span class="keyword">if</span> (!<span class="keyword">ret</span>) &#123;</div><div class="line">    		<span class="keyword">ret</span> = security_file_permission (<span class="keyword">file</span>, MAY_READ);</div><div class="line">    	<span class="keyword">if</span> (!<span class="keyword">ret</span>) &#123;</div><div class="line">      		<span class="keyword">if</span> (<span class="keyword">file</span>-&gt;f_op-&gt;<span class="keyword">read</span>)</div><div class="line">        		<span class="comment">// 进入具体文件系统</span></div><div class="line">        		<span class="keyword">ret</span> = <span class="keyword">file</span>-&gt;f_op-&gt;<span class="keyword">read</span>(<span class="keyword">file</span>, buf, <span class="keyword">count</span>, pos);</div><div class="line">      		<span class="keyword">else</span></div><div class="line">        		<span class="keyword">ret</span> = do_sync_read(<span class="keyword">file</span>, buf, <span class="keyword">count</span>, pos);</div><div class="line">        	<span class="keyword">if</span> (<span class="keyword">ret</span> &gt; 0)</div><div class="line">			 dnotify_parent(<span class="keyword">file</span>-&gt;f_dentry, DN_ACCESS);</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">ret</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>在这个函数中，一开始先属性检查以及安全性检查，然后通过下面代码进入具体的文件系统</p>
<blockquote>
<p>ret = file-&gt;f_op-&gt;read(file, buf, count, pos);</p>
</blockquote>
<p>每种文件系统的file-&gt;f_op-&gt;read是不一样的，像基于磁盘的文件系统，file-&gt;f_op-&gt;read函数是先到缓存缓存获取数据，如果缓存没有数据，则到磁盘获取；基于内存的文件系统，file-&gt;f_op-&gt;read则是直接在内核缓存获取数据，而不会到磁盘获取数据;</p>
<p>所以虚拟文件系统类似于面向对象多态的实现，首先设计好接口，不同的文件系统分别实现这些接口，这样就可以调用相同的接口，实现不同的操作;</p>
<p>而这个file-&gt;f_op主要是从inode-&gt;i_fop中获得，因此对于不同的文件系统，inode也结构也是有区别的．当创建一个inode时，针对不同的文件系统需要设置不同的属性，最主要就是各种操作函数指针结构体，例如inode-&gt;i_op和inode-&gt;i_fop；这样不同的文件系统，就可以在f-&gt;f_op-&gt;read调用中，实现不同的操作.</p>
<h1>内核管道的实现</h1>
<hr>
<p>上面给出了管道简单的操作以及稍微介绍了虚拟文件系统，pipefs主要的系统调用就是pipe，read和write. 下面来分析内核是怎么实现管道的；linux下的进程的用户态地址空间都是相互独立的，因此两个进程在用户态是没法直接通信的，因为找不到彼此的存在；而内核是进程间共享的，因此进程间想通信只能通过内核作为中间人，来传达信息. 下图显示了两个进程间通过内核缓存进行通信的过程:</p>
<p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                写 |<span class="string"> 入         +-------+</span></div><div class="line">    +--------------+------------&lt;       |</div><div class="line">    |<span class="string">              </span>|<span class="string">            </span>|<span class="string"> 进程1 </span>|</div><div class="line">+---v----+         |<span class="string">            </span>|<span class="string">       </span>|</div><div class="line">|<span class="string">        </span>|<span class="string">         </span>|<span class="string">            +-------+</span></div><div class="line">|<span class="string"> 缓 存  </span>|<span class="string">     内  </span>|<span class="string">  用</span></div><div class="line">|<span class="string"> (page) </span>|<span class="string">     核  </span>|<span class="string">  户</span></div><div class="line">|<span class="string">        </span>|<span class="string">         </span>|<span class="string">  态</span></div><div class="line">+---v----+         |<span class="string">            +-------+</span></div><div class="line">    |<span class="string">              </span>|<span class="string">            </span>|<span class="string">       </span>|</div><div class="line">    |<span class="string">              </span>|<span class="string">            </span>|<span class="string"> 进程2 </span>|</div><div class="line">    +--------------+------------&gt;       |<span class="string"></span></div><div class="line">                读 |<span class="string"> 取         +-------+</span></div><div class="line">                   |</div></pre></td></tr></table></figure></p>
<p>pipe的实现就是和上述图示一样，在pipefs文件系统的inode中有一个属性</p>
<blockquote>
<p>struct pipe_inode_info	*i_pipe;</p>
</blockquote>
<p>这个结构体定义如下:</p>
<p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//pipe_fs_i.h</div><div class="line">struct pipe_inode_info &#123;</div><div class="line">    wait_queue_head_t wait<span class="comment">;</span></div><div class="line">    char *base<span class="comment">;//指向管道缓存首地址</span></div><div class="line">    unsignedint len<span class="comment">;//管道缓存使用的长度</span></div><div class="line">    unsignedint start<span class="comment">;//读缓存开始的位置</span></div><div class="line">    unsignedint readers<span class="comment">;</span></div><div class="line">    unsignedint writers<span class="comment">;</span></div><div class="line">    unsignedint waiting_writers<span class="comment">;</span></div><div class="line">    unsignedint r_counter<span class="comment">;</span></div><div class="line">    unsignedint w_counter<span class="comment">;</span></div><div class="line">    struct fasync_struct *fasync_readers<span class="comment">;</span></div><div class="line">    struct fasync_struct *fasync_writers<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个结构体定义了管道的缓存，由base指向，缓存大小为一个内存页，有如下定义</p>
<blockquote>
<p>#define PIPE_SIZE		PAGE_SIZE</p>
</blockquote>
<p>其实到现在我们大概可以猜得到管道的是实现原理，在一个进程中，向管道中写入数据时，其实就是写入这个缓存中；然后在另一个进程读取管道时，其实就是从这个缓存读取，实现进程的通信．</p>
<p>这个缓存也可以解释为什么管道是单通道的：</p>
<blockquote>
<p>因为只有一个缓存，如果是双通道，那么两个进程同时向这块缓存写数据时，这样会导致数据覆盖，即一个进程的数据被另一个进程的数据覆盖．而向套接字有读写缓存，因此套接字是双通道的．</p>
</blockquote>
<p>ok，接下来，从pipe函数开始，看看内核是如何创建管道的．pipe系统调用在内核对应的服务例程为sys_pipe，在sys_pipe函数中，接着调用do_pipe创建两个管道描述符，一个用于写，另一个用于读；我们来看下do_pipe都做了什么．</p>
<h2>do_pipe函数</h2>
<p>一开始先获得两个空file实例，一个对应管道读描述符，另一个对应管道写描述符</p>
<p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">error </span>= -ENFILE;</div><div class="line">f1 = get_empty_filp();</div><div class="line">if (!f1)</div><div class="line">	goto no_files;</div><div class="line">f2 = get_empty_filp();</div><div class="line">if (!f2)</div><div class="line">	goto close_f1;</div></pre></td></tr></table></figure></p>
<p>接着通过调用get_pipe_inode来实例化一个带有pipe属性的inode</p>
<p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">structinode* pipe_new(structinode* inode)</div><div class="line">&#123;</div><div class="line">	unsigned long <span class="built_in">page</span>;</div><div class="line">	<span class="comment">// 申请一个内存页，作为pipe的缓存</span></div><div class="line">	<span class="built_in">page</span> = __get_free_page(GFP_USER);</div><div class="line">	<span class="keyword">if</span> (!<span class="built_in">page</span>)</div><div class="line">		return NULL;</div><div class="line">	<span class="comment">// 为pipe_inode_info结构体分配内存</span></div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i\_pipe = kmalloc(sizeof(structpipe_inode\_info), GFP_KERNEL);</div><div class="line">	<span class="function"><span class="title">if</span> (!inode-&gt;</span>i_pipe)</div><div class="line">		goto fail_page;	</div><div class="line">	<span class="comment">// 初始化pipe_inode_info属性</span></div><div class="line">	init_waitqueue_head(PIPE_WAIT(*inode));</div><div class="line">	PIPE_BASE(*inode) = (char*) <span class="built_in">page</span>;</div><div class="line">	PIPE_START(*inode) = PIPE_LEN(*inode) = <span class="number">0</span>;</div><div class="line">	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = <span class="number">0</span>;</div><div class="line">	PIPE_WAITING_WRITERS(*inode) = <span class="number">0</span>;</div><div class="line">	PIPE_RCOUNTER(*inode) = PIPE_WCOUNTER(*inode) = <span class="number">1</span>;</div><div class="line">	*PIPE_FASYNC_READERS(*inode) = *PIPE_FASYNC_WRITERS(*inode) = NULL;</div><div class="line">	return inode;</div><div class="line">	fail_page:</div><div class="line">		free_page(<span class="built_in">page</span>);</div><div class="line">	return NULL;</div><div class="line">&#125;</div><div class="line"><span class="comment">//----------------------------------------------------------------</span></div><div class="line">static struct inode * get_pipe_inode(void)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//　从pipefs超级块中分配一个inode</span></div><div class="line">	<span class="function"><span class="title">struct</span>	inode *inode = new_inode(pipe_mnt-&gt;</span>mnt_sb);</div><div class="line">	<span class="keyword">if</span> (!inode)</div><div class="line">		goto fail_inode;</div><div class="line">	<span class="comment">// pipe_new函数主要用来为这个inode初始化pipe属性，就是pipe_inode_info结构体</span></div><div class="line">	<span class="keyword">if</span>(!pipe_new(inode))</div><div class="line">		goto fail_iput;</div><div class="line">	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = <span class="number">1</span>;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_fop = &amp;rdwr_pipe_fops;<span class="comment">//设置pipefs的inode操作函数集合，rdwr_pipe_fops</span></div><div class="line">	<span class="comment">// 为结构体，包含读写管道所有操作</span></div><div class="line"></div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_state = I_DIRTY;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_mode = S_IFIFO | S_IRUSR | S_IWUSR;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span><span class="function"><span class="title">i_uid</span> = current-&gt;</span>fsuid;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span><span class="function"><span class="title">i_gid</span> = current-&gt;</span>fsgid;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span><span class="function"><span class="title">i_atime</span> = inode-&gt;</span><span class="function"><span class="title">i_mtime</span> = inode-&gt;</span>i_ctime = CURRENT_TIME;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_blksize = PAGE_SIZE</div><div class="line">	return inode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，在当前进程的files_struct结构中获取两个空的文件描述符，分别存储在i和j</p>
<p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">error </span>= get_unused_fd();</div><div class="line">if (error &lt; 0)</div><div class="line">	goto close_f12_inode;</div><div class="line">i = error;</div><div class="line"><span class="keyword">error </span>= get_unused_fd();</div><div class="line">if (error &lt; 0)</div><div class="line">	goto close_f12_inode_i;</div><div class="line">j = error;</div></pre></td></tr></table></figure></p>
<p>下一步就是为这个inode分配dentry目录项，dentry主要用于将file和inode连接起来,以及设置f1和f2的vfsmnt,dentry,mapping属性</p>
<p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sprintf</span>(<span class="keyword">name</span>, "[%lu]", inode-&gt;</span>i_ino);</div><div class="line">this.<span class="keyword">name</span> = <span class="keyword">name</span>;</div><div class="line">this.len = strlen(<span class="keyword">name</span>);</div><div class="line"><span class="function"><span class="title">this</span>.hash = inode-&gt;</span>i_ino; <span class="comment">/* will go */</span></div><div class="line"><span class="function"><span class="title">dentry</span> = d_alloc(pipe_mnt-&gt;</span><span class="function"><span class="title">mnt_sb</span>-&gt;</span>s_root, &amp;this);</div><div class="line"><span class="keyword">if</span> (!dentry)</div><div class="line">	goto close_f12_inode_i_j;</div><div class="line"><span class="function"><span class="title">dentry</span>-&gt;</span>d\_op = &amp;pipefs_dentry_operations;</div><div class="line">d_add(dentry, inode);</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_vfsmnt = f2-&gt;</span>f\_vfsmnt = mntget(mntget(pipe_mnt));</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_dentry = f2-&gt;</span>f_dentry = dget(dentry);</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_mapping = f2-&gt;</span><span class="function"><span class="title">f</span>\_mapping = inode-&gt;</span>i_mapping;</div></pre></td></tr></table></figure></p>
<p>最后，针对读写file实例设置不同的属性，并且将两个fd和两个file实例关联起来</p>
<p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* read file */</span></div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_pos = f2-&gt;</span>f_pos = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f\_flags = O_RDONLY;<span class="comment">//f1这个file实例只可读</span></div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f\_op = &amp;read_pipe_fops;<span class="comment">//这是这个可读file的操作函数集合结构体</span></div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f\_mode = FMODE_READ;</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f_version = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/* write file */</span></div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_flags = O_WRONLY;<span class="comment">//f2这个file实例只可写</span></div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_op = &amp;write_pipe_fops;<span class="comment">//这是这个只可写的file操作函数集合结构体</span></div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_mode = FMODE_WRITE;</div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_version = <span class="number">0</span>;</div><div class="line"></div><div class="line">fd_install(i, f1);<span class="comment">//将i(fd)和f1(file)关联起来</span></div><div class="line">fd_install(j, f2);<span class="comment">// 将j(fd)和f2(file)关联起来</span></div><div class="line">fd[<span class="number">0</span>] = i;</div><div class="line">fd[<span class="number">1</span>] = j;</div><div class="line">return <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>到这里，do_pipe函数就算结束了，并且用i和j文件描述符填充了fd[2]数组，最后在sys_pipe函数中通过copy_to_user将fd[2]数组返回给用户程序；</p>
<p>总结下do_pipe函数的执行过程:</p>
<ol>
<li>实例化两个空file结构体；</li>
<li>创建带有pipe属性的inode结构；</li>
<li>在当前进程文件描述符表中找出两个未使用的文件描述符;</li>
<li>为这个inode分配dentry结构体，关联file和inode;</li>
<li>针对可读和可写file结构，分别设置相应属性，主要是操作函数集合属性；</li>
<li>关联文件描述符和file结构</li>
<li>将两个文件描述符返回给用户;</li>
</ol>
<h2>pipe读操作</h2>
<p>当通过pipe函数获取到两个文件描述符，即可使用read和write函数分别对这两个描述符进行读写;我们先来看下read操作;</p>
<p>有之前虚拟文件系统知道，当用户态调用read函数时，对应于内核态sys_read，然后在sys_read函数中调用vfs_read函数，在vfs_read函数中调用file-&gt;f_op-&gt;read，由上述do_pipe函数可以知道，pipefs的read(file)实例对应的file-&gt;f_op为read_pipe_fpos，这个read_pipe_fpos结构体定义如下:</p>
<p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct file_operations read_pipe_fops = &#123;</div><div class="line">	<span class="selector-class">.llseek</span>		= no_llseek,</div><div class="line">	<span class="selector-class">.read</span>		= pipe_read,</div><div class="line">	<span class="selector-class">.readv</span>		= pipe_readv,</div><div class="line">	<span class="selector-class">.write</span>		= bad_pipe_w,</div><div class="line">	<span class="selector-class">.poll</span>		= pipe_poll,</div><div class="line">	<span class="selector-class">.ioctl</span>		= pipe_ioctl,</div><div class="line">	<span class="selector-class">.open</span>		= pipe_read_open,</div><div class="line">	<span class="selector-class">.release</span>	= pipe_read_release,</div><div class="line">	<span class="selector-class">.fasync</span>		= pipe_read_fasync,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此，在vfs_read函数中调用的(pipe)file-&gt;f_op-&gt;read即为pipe_read函数，这个函数定义在fs/pipe.c文件中,</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t</span></div><div class="line"><span class="title">pipe_read</span><span class="params">(structfile *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></div><div class="line">&#123;</div><div class="line">  structiovec iov = &amp;#<span class="number">123</span>; .iov\_base = buf, .iov_len = count &amp;#<span class="number">125</span>;;</div><div class="line">  <span class="keyword">return</span> pipe_readv(filp, &amp;iov, <span class="number">1</span>, ppos);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>pipe_read函数将用户程序的接收数据缓冲区和大小转换为iovec结构，然后调用pipe_readv函数从缓冲区获取数据;在pipe_readv函数中，最主要部分如下:</p>
<p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">intsize = PIPE_LEN(*inode);</div><div class="line"><span class="built_in">if</span> (<span class="built_in">size</span>) &#123;</div><div class="line">  <span class="comment">// 获取管道缓冲区读首地址</span></div><div class="line">  <span class="keyword">char</span> *pipebuf = PIPE_BASE(*inode) + PIPE_START(*inode);</div><div class="line">  <span class="comment">// 缓冲区可读最大值=PIPE\_SIZE - PIPE\_START(inode)</span></div><div class="line">  ssize_t chars = PIPE_MAX_RCHUNK(*inode);</div><div class="line"></div><div class="line">  <span class="comment">// 下面两个if语句用于比较缓冲区可读最大值，缓冲区数据长度以及</span></div><div class="line">  <span class="comment">// 用户态缓冲区的长度，取最小值</span></div><div class="line">  <span class="built_in">if</span> (chars &gt; total_len)</div><div class="line">  	chars = total_len;</div><div class="line">  <span class="built_in">if</span> (chars &gt; <span class="built_in">size</span>)</div><div class="line">  	chars = <span class="built_in">size</span>;</div><div class="line">  <span class="comment">// 调用如下函数把数据拷贝到用户态</span></div><div class="line">  <span class="built_in">if</span> (pipe_iov_copy_to_user(iov, pipebuf, chars)) &#123;</div><div class="line">    <span class="built_in">if</span> (!ret) ret = -EFAULT;</div><div class="line">      <span class="built_in">break</span>;</div><div class="line">  &#125;</div><div class="line">  ret += chars;</div><div class="line">  <span class="comment">// 更新缓冲区读首地址</span></div><div class="line">  PIPE_START(*inode) += chars;</div><div class="line">  <span class="comment">// 对缓冲区长度取模</span></div><div class="line">  PIPE_START(*inode) &amp;= (PIPE_SIZE - <span class="number">1</span>);</div><div class="line">  <span class="comment">// 更新缓冲区数据长度</span></div><div class="line">  PIPE_LEN(*inode) -= chars;</div><div class="line">  <span class="comment">// 更新用户态缓冲区长度</span></div><div class="line">  total_len -= chars;</div><div class="line">  do_wakeup = <span class="number">1</span>;</div><div class="line">  <span class="built_in">if</span> (!total_len)</div><div class="line">    <span class="built_in">break</span>;	<span class="comment">/* 如果用户态缓冲区已满，则读取成功 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码是在一个循环中，直到用户态缓冲区已满，或者管道缓冲区全部数据读取完毕；当然这还涉及到如果缓冲区为空，则当前进程阻塞(切换到其他进程)等等；我们来看下pipe_iov_copy_to_user函数</p>
<p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static inline int</div><div class="line">pipe_iov_copy_to_user(struct iovec *iov, constvoid *<span class="keyword">from</span>, unsignedlong len)</div><div class="line">&#123;</div><div class="line">    unsignedlongcopy;</div><div class="line"></div><div class="line">    while (len &gt; <span class="number">0</span>) &#123;</div><div class="line">      while (!iov-&gt;iov_len)</div><div class="line">      	iov++;</div><div class="line">      <span class="keyword">copy</span><span class="bash"> = min_t(unsignedlong, len, iov-&gt;iov_len);</span></div><div class="line"></div><div class="line">      if (copy_to_user(iov-&gt;iov_base, <span class="keyword">from</span>, <span class="keyword">copy</span><span class="bash">))</span></div><div class="line">          return -EFAULT;</div><div class="line">      <span class="keyword">from</span> += <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">      len -= <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">      iov-&gt;iov_base += <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">      iov-&gt;iov_len -= <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">    &#125;</div><div class="line">    return0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数很简单，其实就是在一个循环中，将缓冲区中数据通过copy_to_user函数写到用户态空间缓冲区中。最后在用户态read函数返回之后，即可在缓冲区中读取到管道中数据。</p>
<p>pipe的写过程其实就是和read的过程相反，首先也是通过系统调用嵌入内核write-&gt;sys_write-&gt;vfs_write,在vfs_write函数中调用file-&gt;f_op-&gt;write函数，而这个函数对应管道写file实例的pipe_write函数。后面的过程就是将用户态缓冲区的数据拷贝到内核管道缓冲区，不再叙述；</p>
<h1>fifo命名管道的实现</h1>
<hr>
<p>因为pipe只能用在两个有亲缘关系的进程上，例如父子进程；如果要在两个没有关系的进程上用管道通信时，这时pipe就派不上用场了。我们可以思考一个问题，如何让两个不相干的进程找到带有pipe属性的inode了？我们自然就想到利用磁盘文件。因为linux下两个进程访问同一个文件时，虽然各自的file是不一样的，但是都是指向同一个inode节点。所以将pipe和磁盘文件结合，就产生了fifo命名管道；</p>
<p>fifo的实现原理和pipe一样，我们可以看下fifo和pipe的read函数操作集合:</p>
<p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//read_fifo_fpos</span></div><div class="line">struct file_operations read_fifo_fops = &#123;</div><div class="line">	<span class="selector-class">.read</span>		= pipe_read,</div><div class="line">	<span class="selector-class">.readv</span>		= pipe_readv,</div><div class="line">	<span class="selector-class">.write</span>		= bad_pipe_w,</div><div class="line">	<span class="selector-class">.poll</span>		= fifo_poll,</div><div class="line">	<span class="selector-class">.ioctl</span>		= pipe_ioctl,</div><div class="line">	<span class="selector-class">.open</span>		= pipe_read_open,</div><div class="line">	<span class="selector-class">.release</span>	= pipe_read_release,</div><div class="line">	<span class="selector-class">.fasync</span>		= pipe_read_fasync,</div><div class="line">&#125;</div><div class="line"><span class="comment">// read_pipe_fops</span></div><div class="line">struct file_operations read_pipe_fops = &#123;</div><div class="line">	<span class="selector-class">.llseek</span>		= no_llseek,</div><div class="line">	<span class="selector-class">.read</span>		= pipe_read,</div><div class="line">	<span class="selector-class">.readv</span>		= pipe_readv,</div><div class="line">	<span class="selector-class">.write</span>		= bad_pipe_w,</div><div class="line">	<span class="selector-class">.poll</span>		= pipe_poll,</div><div class="line">	<span class="selector-class">.ioctl</span>		= pipe_ioctl,</div><div class="line">	<span class="selector-class">.open</span>		= pipe_read_open,</div><div class="line">	<span class="selector-class">.release</span>	= pipe_read_release,</div><div class="line">	<span class="selector-class">.fasync</span>		= pipe_read_fasync,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出来，二者操作函数一样，说明对fifo的读写操作也是对管道缓冲区进行读写；唯一不同点是轮询函数，其实fifo_poll和pipe_poll也是一样的</p>
<blockquote>
<p>#define fifo_poll pipe_poll</p>
</blockquote>
<p>而fifo创建的文件只是让读写进程能找到相同的inode，进而操作相同的pipe缓冲区。</p>
<h1>总结</h1>
<hr>
<p>这篇文章，主要从内核代码介绍了pipe的实现，总结一点就是两个进程对同一块内存的操作，和进程内部多个线程操作同一个块内存类似。我这只是简单的说明pipe的实现原理，当然，实际上还有许多内容，例如管道阻塞和非阻塞，管道轮询等等。此外还介绍了fifo命名管道的实现原理。</p>
<p>在准备写这篇文章时，我也看了些关于文件系统的资料以及内核其他文件系统的代码，我加深了对linux虚拟文件系统的实现机理。</p>
<p>接下来文章，要开始分析了golang的底层实现了，因为在使用过程中，发现golang是一门非常好用的系统级语言，越来越多的公司引入了golang语言进行项目开发，知其然而不知所以然是一件很痛苦的事。</p>
]]></content>
      
        <categories>
            
            <category> pipe </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pipe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不忘初心，重新认识hello world]]></title>
      <url>http://luodw.cc/2016/07/02/helloworld/</url>
      <content type="html"><![CDATA[<p>对于程序员来说，hello world的含义，可能并不只是一句简单的打招呼，更多的是学习一门编程语言的第一个示例．和编程接触了这么多年，如果要学习一门编程语言，我也会情不自禁地敲下hello world程序，看下程序的的输出．如今回过头的来重新看hello world，就会发现hello world背后隐藏的许多秘密；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-fpic1574.jpg" alt="首页显示"></p>
<p>路走的远了，就需要不断回头审视自己来时的路，以及眺望未来之路，不忘初心，重新(心)出发．所以才有了这篇文章，好好窥探hello world的秘密；</p>
<p>这篇文章主要分为以下几块，</p>
<ol>
<li>什么是程序？</li>
<li>代码如何转换为二进制?</li>
<li>程序是怎么装载进内存？</li>
<li>进程是怎么执行的?</li>
<li>进程怎么退出?</li>
</ol>
<p>【版权声明】博客内容由罗道文的私房菜拥有版权，允许转载，但请标明原文链接<a href="http://luodw.cc/2016/07/02/helloworld/">http://luodw.cc/2016/07/02/helloworld/</a></p>
<p>其实就是hello world的一生；都是我自己的理解，有误的地方，希望看者能提出来，互相进步；这里就是做个引子，介绍下，希望可以帮助大家更好的理解进程的运行,如果想深入学习，需要看相关书籍；</p>
<h1>什么是程序</h1>
<hr>
<p>很多时候，人们会把程序和进程的概念弄混了，其实可以这么理解，程序是一堆无生命的二进制代码，而这些二进制代码被读取进内存，跑起来之后，就是进程了；也就是说，程序是躺在磁盘里无生命活力的二进制代码，而进程是在内存中有生命活力的二进制代码；ok，我写个hello world程序hello.c，作为例子:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这剪短的代码，有没很熟悉？如果有种很熟悉的感觉，那恭喜你，你肯定也是个程序员(不用回头，没错，就是你!!!)． 这段代码很简单，就是简单的输出一句&quot;hello world&quot;就退出了．按我的理解，这其实还不能算是程序，可以称呼为代码；我理解的是程序应该是能被操作系统认识理解，运行的代码．而操作系统只能认识二进制的东西，所以像我们编写的C/C++,JAVA,GO等等代码，最后都要被转换为二进制的代码，才能够执行；</p>
<h1>代码如何转换为二进制</h1>
<hr>
<p>紧接着上述的话题，当我们写好一段代码之后，如果将其转换为二进制了?这就是我们默默无闻的编译器了．为什么说默默无闻了?因为编译器做着非常重要的工作，但是又有多少人真正打开编译器的心扉，好好认识编译器？(当然包括我，羞愧低下了头!!!)．编译C代码分为几个步奏，有技术背景应该听过，预处理，编译，汇编，链接；</p>
<p>预处理阶段为:</p>
<blockquote>
<p>gcc -E hello.c -o hello.i</p>
</blockquote>
<p>我们可以打开hello.i看看，里面的头文件stdio.h已经被展开了，包括一些类型定义函数定义等等，截取片段如下:
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __socklen_t;</div><div class="line"><span class="meta"># 36 <span class="meta-string">"/usr/include/stdio.h"</span> 2 3 4</span></div><div class="line"><span class="meta"># 44 <span class="meta-string">"/usr/include/stdio.h"</span> 3 4</span></div><div class="line"><span class="keyword">struct</span> _IO_FILE;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IO_FILE FILE;</div></pre></td></tr></table></figure></p>
<p>从这个片段，我们可以看出来了，我们平时引用的stdio.h文件存在与/usr/include/stdio.h，所以想研究stdio.h的朋友，可以打开看看；这个代码片段很重要的还有FILE的定义，这就是我们用c语言打开一个文件返回的句柄结构，所以想理解C语言中缓冲流是怎么实现的，可以先看看_IO_FILE结构体中io流缓冲区的定义，再结合代码即可理解；</p>
<p>预处理之后，接下来，就需要将这些代码编译成汇编代码:</p>
<blockquote>
<p>gcc -S hello.i -o hello.s</p>
</blockquote>
<p>这个过程，就是将上述的代码转换为汇编代码，其实就是一条条汇编指令，这个过程是c代码转换为二进制最为重要的过程，也是最复杂的过程；我们可以打开hello.s看看内部的东东
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line"><span class="symbol">.LFB0:</span></div><div class="line"><span class="meta">        .cfi_startproc</span></div><div class="line">        pushq   %rbp</div><div class="line"><span class="meta">        .cfi_def_cfa_offset</span> <span class="number">16</span></div><div class="line"><span class="meta">        .cfi_offset</span> <span class="number">6</span>, -<span class="number">16</span></div><div class="line">        <span class="keyword">movq</span>    %rsp, %rbp</div><div class="line"><span class="meta">        .cfi_def_cfa_register</span> <span class="number">6</span></div><div class="line">        movl    $.LC0, %edi</div><div class="line">        <span class="keyword">call</span>    puts</div></pre></td></tr></table></figure></p>
<p>这就是汇编指令，但是直接打开hello.s看，显示不是很友好，我们可以用objdump或者gdb的反汇编指令打开obj文件，如下:
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~$ objdump -d hello.o</div><div class="line"></div><div class="line">hello.o：     文件格式 elf64-x86-<span class="number">64</span></div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</div><div class="line">   <span class="number">0</span>:	<span class="number">55</span>                   	<span class="keyword">push</span>   %rbp</div><div class="line">   <span class="number">1</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</div><div class="line">   <span class="number">4</span>:	bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $0<span class="keyword">x</span><span class="number">0</span>,%edi</div><div class="line">   <span class="number">9</span>:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  e &lt;main+<span class="number">0xe</span>&gt;</div><div class="line">   e:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $0<span class="keyword">x</span><span class="number">0</span>,%eax</div><div class="line">  <span class="number">13</span>:	<span class="number">5</span>d                   	<span class="keyword">pop</span>    %rbp</div><div class="line">  <span class="number">14</span>:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>这样看是不是好很多了．学习汇编，重要的不是说还让你去写汇编代码(当然有些C代码是有嵌入汇编的，例如内存屏障),而是让我们能看懂汇编代码．那有人又会问，看懂汇编代码有什么用？我最深的体会就是可以从汇编代码看懂函数栈的调用过程，我很早也有写过<a href="http://luodw.cc/2015/10/07/gdb/">用gdb反汇编理解c函数栈调用过程</a>，还有就是理解底层ABI的一些东西，例如系统调用嵌入内核时，参数是存在哪些寄存器，然后从内核内核返回用户态时，返回值是存在哪个寄存器(rax)等等；如果你还有问知道这些有什么用，我只能问你，为什么来学计算机？</p>
<p>ok，编译结束之后，接下来就是将汇编代码转换为目标文件：</p>
<blockquote>
<p>gcc -c hello.s -o hello.o</p>
</blockquote>
<p>目标文件已经是二进制代码了，这个hello.o也是之前用objdump打开查看汇编代码的文件；二进制代码是不能用文本编辑器打开查看的，可以试着用vim打开hello.o，可以看到一对乱码，可能会有几个看得懂的字符；我们可以用od -c　hello.o命令看二进制所对应的每个字符．
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~$ od -c hello.o</div><div class="line"><span class="number">0000000</span> <span class="number">177</span>   E   L   F <span class="number">002</span> <span class="number">001</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000020</span> <span class="number">001</span>  <span class="string">\0</span>   &gt;  <span class="string">\0</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000040</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   <span class="number">0</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000060</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   @  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   @  <span class="string">\0</span>  <span class="string">\r</span>  <span class="string">\0</span>  <span class="string">\n</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000100</span>   U   H <span class="number">211</span> <span class="number">345</span> <span class="number">277</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">350</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">270</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000120</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   ] <span class="number">303</span>   h   e   l   l   o       w   o   r   l   d</div><div class="line"><span class="number">0000140</span>   !  <span class="string">\0</span>  <span class="string">\0</span>   G   C   C   :       (   U   b   u   n   t   u    </div><div class="line"><span class="number">0000160</span>   <span class="number">4</span>   .   <span class="number">8</span>   .   <span class="number">4</span>   -   <span class="number">2</span>   u   b   u   n   t   u   <span class="number">1</span>   ~   <span class="number">1</span></div><div class="line"><span class="number">0000200</span>   <span class="number">4</span>   .   <span class="number">0</span>   <span class="number">4</span>   .   <span class="number">3</span>   )       <span class="number">4</span>   .   <span class="number">8</span>   .   <span class="number">4</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000220</span> <span class="number">024</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">001</span>   z   R  <span class="string">\0</span> <span class="number">001</span>   x <span class="number">020</span> <span class="number">001</span></div><div class="line"><span class="number">0000240</span> <span class="number">033</span>  <span class="string">\f</span>  <span class="string">\a</span>  <span class="string">\b</span> <span class="number">220</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">034</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">034</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div></pre></td></tr></table></figure></p>
<p>编译成目标文件之后，最后一步就是链接，生成可执行的目标文件．二进制代码文件有分为可重定向文件，可执行文件和可共享文件．一般情况下，hello.o是可重定向文件，多个.o文件链接在一起，就可以生成可执行文件；静态链接库和动态链接库为可共享的二进制代码．</p>
<p>在这个例子中，只有一个文件，所以就直接生成可执行文件就好了</p>
<blockquote>
<p>gcc hello.o -o hello</p>
</blockquote>
<p>此时就生成了可执行的程序；在linux下，可执行的程序属于ELF文件，可以使用file命令查看文件类型．这时还没有进程，还只是程序而已；之前看到有些问题，如&quot;进程的的静态区是什么时候分配的，有些回答是编译时&quot;．我当时就醉了，编译的时候还没进程，哪来的内存；正确是编译时决定内存的如何分配，但是真正分配还是在进程跑起来之后．</p>
<h1>程序是如何装载进内存</h1>
<hr>
<p>ok，到这为止，一个程序就已经准备好了，我们很习惯就会输出以下命令执行程序</p>
<blockquote>
<p>./hello</p>
</blockquote>
<p>就这么简短的一个运行命令，里面就有非常多的学问，涉及到程序的装载，操作系统内存分配，进程调度；在接下去讲进程装载时，有必要介绍下hello这个可执行文件的布局；很多人应该有听过进程的代码段，数据段，bbs，堆，栈等；相应的，在可执行文件中，也有代码段，数据段，bbs；而堆和栈在elf文件中没有相应的项，他俩属于匿名映射；当然elf文件不止之前说的三个段，还有很多，我们可以用readelf命令来查看elf文件中含有的sections:
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~$ readelf -S hello</div><div class="line">共有<span class="number"> 30 </span>个节头，从偏移量 0x1178 开始：</div><div class="line"></div><div class="line">节头：</div><div class="line">  [Nr] Name              Type             Address           Offset</div><div class="line">       Size              EntSize          Flags  Link  Info  Align</div><div class="line">  [ 0]                   NULL            <span class="number"> 0000000000000000 </span> 00000000</div><div class="line">      <span class="number"> 0000000000000000 </span><span class="number"> 0000000000000000 </span>         <span class="number"> 0 </span>   <span class="number"> 0 </span>    0</div><div class="line">  [ 1] .interp           PROGBITS        <span class="number"> 0000000000400238 </span> 00000238</div><div class="line">       000000000000001c <span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    1</div><div class="line">  [ 2] .note.ABI-tag     NOTE            <span class="number"> 0000000000400254 </span> 00000254</div><div class="line">      <span class="number"> 0000000000000020 </span><span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    4</div><div class="line">  [ 3] .note.gnu.build-i NOTE            <span class="number"> 0000000000400274 </span> 00000274</div><div class="line">      <span class="number"> 0000000000000024 </span><span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    4</div><div class="line">  [ 4] .gnu.hash         GNU_HASH        <span class="number"> 0000000000400298 </span> 00000298</div><div class="line">       000000000000001c <span class="number"> 0000000000000000 </span>  A      <span class="number"> 5 </span>   <span class="number"> 0 </span>    8</div><div class="line">  [ 5] .dynsym           DYNSYM           00000000004002b8  000002b8</div><div class="line">      <span class="number"> 0000000000000060 </span><span class="number"> 0000000000000018 </span>  A      <span class="number"> 6 </span>   <span class="number"> 1 </span>    8</div><div class="line">  [ 6] .dynstr           STRTAB          <span class="number"> 0000000000400318 </span> 00000318</div><div class="line">       000000000000003d <span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    1</div><div class="line">  [ 7] .gnu.version      VERSYM          <span class="number"> 0000000000400356 </span> 00000356</div><div class="line">      <span class="number"> 0000000000000008 </span><span class="number"> 0000000000000002 </span>  A      <span class="number"> 5 </span>   <span class="number"> 0 </span>    2</div><div class="line">  [ 8] .gnu.version_r    VERNEED         <span class="number"> 0000000000400360 </span> 00000360</div><div class="line">      <span class="number"> 0000000000000020 </span><span class="number"> 0000000000000000 </span>  A      <span class="number"> 6 </span>   <span class="number"> 1 </span>    8</div></pre></td></tr></table></figure></p>
<p>太长了，我就截取这部分sections．在这么多sections，很多我们并不知道他们有什么用，但是有几个setcion我们是必须了解的，因为在理解静态链接库和动态链接库时，需要他们；例如header,.symtab,.rel.text,.rel.data,.dynamic等等；rela.txt和rela.data一般是在可重定向文件才会有，链接生成的可执行文件一般是没有的；但是因为很多section的读写权限是一样的，所以在装载进内存时，这些sections会合并成一个segment，例如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-linux_process_address_space_03.png" alt="进程地址空间和elf文件的映射"></p>
<p>图片取自,<strong>程序员的自我修养</strong>从这幅图可以看出，进程的地址空间的一个段，就相当于elf文件中多个sections；所以我们看到的代码段，并不只是代码，还有可能是字符串常量或者一些常量，因为这些都是可读不可写的，所以可以合并在代码段中．</p>
<p>ok，理解上面所说之后，接着可以说说进程是如何被载入内存了．因为终端也是一个程序，所以当我们在终端输入</p>
<blockquote>
<p>./hello</p>
</blockquote>
<p>这时，终端会调用fork创建一个子进程，fork函数是一个系统调用，这时会嵌入内核，调用的是clone函数，这个clone函数接着会调用do_fork函数，这个函数做了大部分创建工作，例如创建task_struct，内核栈，thread_info等结构，因为fork函数是采用写时复制技术，因此此时子进程task_struct大部分的属性还是和父进程task_struct一样，主要就是没有为子进程开辟内存空间；当子进程内核结构创建好之后，这时进程调度系统会优先调度子进程，因为一般情况下，子进程会直接调用exec函数避免写时拷贝开销．</p>
<blockquote>
<p>这里提下，一次fork调用为什么会返回两个值；因为当fork在内核调用成功，要返回用户态时，如果此时调度子进程执行，那么会把0放入rax寄存器中，等fork返回用户态执行子进程时，从rax得到的就是0；当内核调度的是父进程时，这时会把子进程的id号放入rax寄存器中，等返回到用户态执行父进程时，此时从rax获得的就是子进程的id号；</p>
</blockquote>
<p>到这里，还是只是创建了子进程内核的一些结构，接下来，在终端fork的子进程中，会调用exec系列函数</p>
<blockquote>
<p>execl(&quot;./hello&quot;,&quot;hello&quot;,&quot;&quot;,NULL);</p>
</blockquote>
<p>这个函数会会为子进程hello单独开辟一块内存(之前是和父进程共用内存空间)，其实最主要就是为mm_struct结构以及页表重新赋值；具体怎么做了，最主要是调用mmap函数；我们可以把上述图的左边看成是躺在磁盘中的可执行文件，右边对应的是进程在内存中布局；当内核要将可执行文件的代码段映射到进程空间时，内核会先把code segment读取进内核的cache中，然后给hello进程的code段分配一块vma虚拟内存，并把这块虚拟内存映射到在cache中code segment，并把这块vma放入mm_struct的红黑树和链表中．链表适合当需要遍历所有vma内存区域时，而红黑树适合快速获取某个特定内存区域；我们经常查看/proc/&lt;pid&gt;/maps某个进程的内存布局，其实就是便利这个进程的vma链表即可．</p>
<p>数据段也是采用同样的方式载入．但是堆和栈不是采用这种方式，因为他俩在elf文件中没有相应的栈，所以他俩是通过mmap匿名映射的方式分配内存，同时也加入到mm_struct中vma链表和红黑树结构中．</p>
<p>下面这张图更好说明了用户进程空间:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_015.png" alt="进程用户态控空间"></p>
<p>到目前为止，内核已经为hello这个子进程创建了内核task_struct结构，内核栈，thread_info以及用户空间内存结构．按理说应该开始执行程序了吧，但是并没有；在真正执行hello程序之前，首先会把权限交给动态链接器，也就是我们在输出/proc/&lt;pid&gt;/maps的时候，看到的</p>
<blockquote>
<p>/lib/x86_64-linux-gnu/ld-2.19.so</p>
</blockquote>
<p>这个链接器会把hello这个程序中用到的动态链接库载入用户空间的共享存储区，采用的方法也是内存映射，也会为这些动态链接库生成一个vma结构，放入mm_struct中vma链表和红黑树中．hello这个进程用的最主要就是C运行时库，</p>
<blockquote>
<p>/lib/x86_64-linux-gnu/libc-2.19.so</p>
</blockquote>
<p>我还是输出hello这个进程的内存结构吧
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">root@charles-<span class="symbol">Lenovo:</span>/home/charles<span class="comment"># cat /proc/1658/maps</span></div><div class="line"><span class="number">00400000</span>-<span class="number">00401000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">09</span> <span class="number">130893</span>                             /home/charles/hello</div><div class="line"><span class="number">00600000</span>-<span class="number">00601000</span> r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">09</span> <span class="number">130893</span>                             /home/charles/hello</div><div class="line"><span class="number">00601000</span>-<span class="number">00602000</span> rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">09</span> <span class="number">130893</span>                             /home/charles/hello</div><div class="line"><span class="number">7</span>f1a47bc6000-<span class="number">7</span>f1a47d80000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47d80000-<span class="number">7</span>f1a47f80000 ---p <span class="number">001</span>ba000 <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47f80000-<span class="number">7</span>f1a47f84000 r--p <span class="number">001</span>ba000 <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47f84000-<span class="number">7</span>f1a47f86000 rw-p <span class="number">001</span>be000 <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47f86000-<span class="number">7</span>f1a47f8b000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>f1a47f8b000-<span class="number">7</span>f1a47fae000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28893</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">ld</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a4818d000-<span class="number">7</span>f1a48190000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>f1a481aa000-<span class="number">7</span>f1a481ad000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>f1a481ad000-<span class="number">7</span>f1a481ae000 r--p <span class="number">00022000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28893</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">ld</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a481ae000-<span class="number">7</span>f1a481af000 rw-p <span class="number">00023000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28893</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">ld</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a481af000-<span class="number">7</span>f1a481b0000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>fff82079000-<span class="number">7</span>fff8209a000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [stack]</div><div class="line"><span class="number">7</span>fff820ed000-<span class="number">7</span>fff820ef000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</div><div class="line"><span class="number">7</span>fff820ef000-<span class="number">7</span>fff820f1000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vvar]</div><div class="line">ffffffffff600000-ffffffffff601000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</div></pre></td></tr></table></figure></p>
<p>这些vma段和上述图片是一样的，图片看得更形象；hello这个进程没有堆结构，因为进程运行过程中，并没有申请堆内存．ok，当动态链接库也转载进内存之后，就把控制权交给hello进程执行．</p>
<h1>进程是如何执行的?</h1>
<hr>
<p>进程的执行其实就是cpu获取指令以及数据，并进行计算，这里cpu各个寄存器的使用和虚拟内存与物理内存转换等等；而hello这个进程非常简单，就是调用C库函数printf输出一句话．但是其中涉及的过程还是相当复杂的．</p>
<p>首先当执行到printf时，因为hello.c中没有定义这个函数，所以进程会去C库的动态链接库查找，当找到printf之后，进程会跳转到printf函数执行；在printf函数内部，会执行系统调用</p>
<blockquote>
<p>write(1, &quot;hello world!\n&quot;, 13)</p>
</blockquote>
<p>其中1是STDOUT_FILENO表示标准输，对应的就是输出到显示器；到这里，我们可以聊聊系统调用；当执行这个write函数时，因为write是个系统调用，在执行这个write之前，会将参数放入寄存器中，例如1放在rdi,＂hello world!\n&quot;字符串指针放入rsi,13放入rdx寄存器中．linux在执行系统调用时，会触发一次int80软中断，并把系统调用号放入rax寄存器中；这时cpu切换到内核软中断处理函数中，怎么找到这个软中断函数？这个说起来，话又很多了(IDTR寄存器和中断描述符表)．在中断函数中，找到rax寄存器对应的系统调用，write对应的是sys_write函数，开始执行sys_write函数．在sys_write函数中，会通过fd找到file结构，inode结构等等，最后输出到显示器．</p>
<h1>进程是如何退出的</h1>
<hr>
<p>当进程执行结束之后，会调用exit函数，而这个函数调用的系统调用函数_exit()会嵌入内核，进行清除工作．例如释放进程打开的文件，释放进程mm_struct对应的内存(如果没有共享内存)等等，最后只剩下task_struct,内核栈和thread_info三个结构．子进程会给父进程发送一个SIGCHLD信号，表示进程退出；父进程在收到这个信号之后，会调用wait或waitpid函数回收子进程的资源，task_struct,内核栈以及thread_info．到这里，hello进程的生命就算走完了．</p>
<h1>总结</h1>
<hr>
<p>这篇文章主要就是介绍linux下面，一个进程的生命过程，从诞生到终结．涉及到非常多的知识，也希望能给大家对进程的一个比较清晰的认识；我并没有写得很深入，因为那样的话，会非常长，大部分人会看不懂．我自己发现有些知识点还需要好好巩固，因为有时候，我并不能非常熟练的表达出来，还需要多研究．</p>
<p>还是那句话，如果有什么出错的地方，还希望各位能够指出来，共同进步．</p>
]]></content>
      
        <categories>
            
            <category> hello world </category>
            
        </categories>
        
        
        <tags>
            
            <tag> helloworld </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[libtask之channel实现机制]]></title>
      <url>http://luodw.cc/2016/06/26/libtask01/</url>
      <content type="html"><![CDATA[<p>用过golang语言，都知道golang最吸引人的特性就是goroutine和channel．goroutine可以称呼为go程，其实就是go语言协程；channel即为通道，用于goroutine之间进行通信；比较直观的理解，channel实现可以认为生产者和消费者模型，即一个goroutine写入消息，另一个协程读取消息；当然，具体如何实现，可以看libtask的channel实现，即可略知一二．</p>
<p>libtask的channel模块，理解起来没有task模块轻松，逻辑比较复杂，我在计划写这篇博客时，还是很担心不能够写明白libtask的channel是如何运行的；这篇博客主要是以例子以及解析源码的形式来分析channel的实现；</p>
<p>go  channel分为有有缓存和无缓存，对应于libtask也是如此，我们先来看下无缓存是如何实现的；</p>
<h2>无缓存channel实现</h2>
<hr>
<p>下面是一个简单的例子，用于说明libtask中channel的实现
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;task.h&gt;</span></span></div><div class="line"></div><div class="line">Channel *c=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">counttask1</span><span class="params">(<span class="keyword">void</span> *arg)</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test3-----\n"</span> );</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> x = chanrecvul(c);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,x );</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test4-----\n"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">    c = chancreate(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>),<span class="number">0</span>);</div><div class="line">    taskcreate(counttask1, <span class="literal">NULL</span>, <span class="number">32768</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test1-----\n"</span> );</div><div class="line">    chansendul(c, <span class="number">1</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test2-----\n"</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译程序</p>
<blockquote>
<p>gcc -g mytest.c -o mytest -ltask</p>
</blockquote>
<p>最后得到结果如下:
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test1<span class="comment">-----</span></div><div class="line">test3<span class="comment">-----</span></div><div class="line"><span class="number">1</span></div><div class="line">test4<span class="comment">-----</span></div><div class="line">test2<span class="comment">-----</span></div></pre></td></tr></table></figure></p>
<p>先来分析下结果，当然如果你熟悉golang，这结果是很明显的．</p>
<ol>
<li>一开始任务队列中只有taskmain任务，所以调度器直接调度taskmain任务；</li>
<li>在taskmain任务中，创建了counttask1任务，然后输出&quot;test1------&quot;，接着向管道中写入一个无符号长整形1，由于是无缓存的channel，所以taskmain任务阻塞并切换到调度器;</li>
<li>此时任务队列只有counttask1，调度器调度counttask1任务执行;</li>
<li>在counttask1任务中，从channel中读取一个元素，因为channel中已经有一个元素，所以直接返回channel中的数值，最后输出&quot;test4----&quot;;</li>
<li>调度器切回taskmain执行，最后结束任务队列为空，退出整个程序；</li>
</ol>
<h2>源码实现</h2>
<hr>
<p>libtask中关于channel的源码实现主要是在文件channel.c中，我在初次看channel的实现时，就三个字＂看不懂＂；主要逻辑在chanalt和altexec函数中，这两个函数最晦涩难懂；最后只能祭出上古神器gdb；跟着gdb，设断点，一步一步跟踪程序，最后终于把channel搞懂了；所以建议从代码字面看不懂的同学，可以和我一样，利用gdb；</p>
<p>好了，不多说，来开始代码之旅；</p>
<h3>向channel发送数据代码逻辑</h3>
<p>测试例子程序中，我们先看下创建channel的代码逻辑
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function">Channel*</span></div><div class="line"><span class="title">chancreate</span><span class="params">(<span class="keyword">int</span> elemsize, <span class="keyword">int</span> bufsize)</span></div><div class="line">&#123;</div><div class="line">	Channel *c;</div><div class="line">	<span class="comment">// 为channel分配内存</span></div><div class="line">	c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *c+bufsize*elemsize);</div><div class="line">	<span class="keyword">if</span>(c == nil)&#123;</div><div class="line">		fprint(<span class="number">2</span>, <span class="string">"chancreate malloc: %r"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> *c);</div><div class="line">	c-&gt;elemsize = elemsize;<span class="comment">// channel中每个元素的大小</span></div><div class="line">	c-&gt;bufsize = bufsize;</div><div class="line">	c-&gt;nbuf = <span class="number">0</span>;<span class="comment">//缓存已使用量</span></div><div class="line">	c-&gt;buf = (uchar*)(c+<span class="number">1</span>);<span class="comment">//指向缓存首地址</span></div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"><span class="comment">//--------------------------------------------------------</span></div><div class="line"><span class="keyword">struct</span> Channel</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	bufsize;<span class="comment">//缓存大小，即缓存元素个数</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	elemsize;<span class="comment">//channel每个元素的大小</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	*buf;<span class="comment">//指向缓存的指针</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	nbuf;<span class="comment">//缓存已使用量</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	off;<span class="comment">//当前读取的元素个数</span></div><div class="line">	Altarray	asend;<span class="comment">//发送队列</span></div><div class="line">	Altarray	arecv;<span class="comment">//接收队列</span></div><div class="line">	<span class="keyword">char</span>		*name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从这段代码，我们可以看出来参数elemsize表示channel中每个元素的大小，bufsize表示缓存可以容纳多少个元素，即缓存的size；因此有无缓存，主要是看bufsize的值，如果为0，则无缓存，如果不为0，则有缓存；</p>
<p>创建好channel之后，接下来看下chansendul(c, 1)函数的代码逻辑，这个函数直接调用_chanop函数
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">_chanop(Channel *c, <span class="keyword">int</span> op, <span class="keyword">void</span> *p, <span class="keyword">int</span> canblock)</div><div class="line">&#123;</div><div class="line">	Alt a[<span class="number">2</span>];</div><div class="line"></div><div class="line">	a[<span class="number">0</span>].c = c;</div><div class="line">	a[<span class="number">0</span>].op = op;</div><div class="line">	a[<span class="number">0</span>].v = p;</div><div class="line">	a[<span class="number">1</span>].op = canblock ? CHANEND : CHANNOBLK;</div><div class="line">	<span class="keyword">if</span>(chanalt(a) &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一次看代码的时候，会被这个alt数组给弄混淆了，代码中可以看出其实就是第一个alt存储数据，第二个并没有存储数据；看到后面之后，才会发现其实第二个alt就是用于一些条件的判断；</p>
<p>ok，接下来，到最重要的函数chanalt，省去一些无关紧要的代码,
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">chanalt(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">	<span class="comment">/* 省去一些代码 */</span></div><div class="line">	<span class="comment">/* 此时n=1 */</span></div><div class="line">	ncan = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">		<span class="built_in">c</span> = a[i].<span class="built_in">c</span>;</div><div class="line">		<span class="keyword">if</span>(altcanexec(&amp;a[i]))&#123;</div><div class="line">				ncan++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/* ......  */</span></div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">		<span class="keyword">if</span>(a[i].op != <span class="type">CHANNOP</span>)</div><div class="line">			altqueue(&amp;a[i]);</div><div class="line">	&#125;</div><div class="line">	taskswitch();</div><div class="line"><span class="comment">//------------------------------------------------</span></div><div class="line"><span class="keyword">static</span> int</div><div class="line">altcanexec(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">	<span class="type">Altarray</span> *ar;</div><div class="line">	<span class="type">Channel</span> *<span class="built_in">c</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(a-&gt;op == <span class="type">CHANNOP</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="built_in">c</span> = a-&gt;<span class="built_in">c</span>;</div><div class="line">	<span class="keyword">if</span>(<span class="built_in">c</span>-&gt;bufsize == <span class="number">0</span>)&#123;</div><div class="line">		ar = chanarray(<span class="built_in">c</span>, otherop(a-&gt;op));</div><div class="line">		<span class="keyword">return</span> ar &amp;&amp; ar-&gt;n;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		...............</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在chanalt函数中，首先是判断这个alt是否可执行；在判断函数altcanexec内部，因为此时是无缓存版本，因此代码逻辑就在if语句内部；</p>
<blockquote>
<p>otherop(a-&gt;op)函数返回当前操作的相反队列；例如如果此时是一个发送操作，那么这个otherop函数返回的是接收队列</p>
</blockquote>
<blockquote>
<p>chanarray函数返回通道c(channel)中，otherop(a-&gt;op)类型的队列，此时返回的是接收队列，因为ar-&gt;n为当前通道队列中元素的个数，此时接收队列为空，所以此时为ar-&gt;n为0</p>
</blockquote>
<p>因此这个判断函数altcanexec返回false，代码就直接来到了altqueue函数中，这个alt加入队列函数很简单，就是简单的将alt放入相应队列中，此时alt加入的是发送队列;</p>
<p>最后执行taskswitch函数，执行任务调度，切换到调度器；要注意的是，此时taskmain是没有放入任务队列的(调用taskyield函数才是让出当前CPU，并把自身放入任务队列末尾)，因此后面需要有个函数将这个taskmain放入队列中，等待调度，那这个函数是谁了?后面再揭晓</p>
<h3>从channel接收代码逻辑</h3>
<p>taskmain任务切换到调度器之后，此时任务队列中只有counttask1任务，因此调度器切换counttask1任务执行，我们直接看函数chanrecvul(c)逻辑，这个函数也是调用_chanop函数，最后到达chanalt函数;在chanalt函数中，代码逻辑主要是下面这些:
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">chanalt(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">	<span class="comment">/* ...... */</span></div><div class="line">	ncan = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">		<span class="built_in">c</span> = a[i].<span class="built_in">c</span>;</div><div class="line">		<span class="keyword">if</span>(altcanexec(&amp;a[i]))&#123;</div><div class="line">				ncan++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ncan)&#123;</div><div class="line">		j = rand()%ncan;</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(altcanexec(&amp;a[i]))&#123;</div><div class="line">				<span class="keyword">if</span>(j-- == <span class="number">0</span>)&#123;</div><div class="line">					altexec(&amp;a[i]);</div><div class="line">					<span class="keyword">return</span> i;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/* ....... */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//------------------------------------------------</span></div><div class="line"><span class="keyword">static</span> int</div><div class="line">altcanexec(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">        <span class="type">Altarray</span> *ar;</div><div class="line">        <span class="type">Channel</span> *<span class="built_in">c</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(a-&gt;op == <span class="type">CHANNOP</span>)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="built_in">c</span> = a-&gt;<span class="built_in">c</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">c</span>-&gt;bufsize == <span class="number">0</span>)&#123;</div><div class="line">                ar = chanarray(<span class="built_in">c</span>, otherop(a-&gt;op));</div><div class="line">                <span class="keyword">return</span> ar &amp;&amp; ar-&gt;n;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">                ...............</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在判断函数altcanexec函数内部，因为a-&gt;op为接收，所以ar为发送队列，因为之前已经存入一个元素，因此ar-&gt;n不为0，所以判断为真，此时ncan加1；转入执行下面if语句，最后执行altexec函数；
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">altexec(Alt *a)</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	Altarray *ar;</div><div class="line">	Alt *other;</div><div class="line">	Channel *c;</div><div class="line"></div><div class="line">	<span class="function"><span class="title">c</span> = a-&gt;</span>c;</div><div class="line">	<span class="function"><span class="title">ar</span> = chanarray(c, otherop(a-&gt;</span>op));<span class="comment">//取出channel中的发送队列</span></div><div class="line">	<span class="function"><span class="title">if</span>(ar &amp;&amp; ar-&gt;</span>n)&#123;</div><div class="line">		<span class="function"><span class="title">i</span> = rand()%ar-&gt;</span>n;<span class="comment">//i=0</span></div><div class="line">		<span class="function"><span class="title">other</span> = ar-&gt;</span>a[i];<span class="comment">//取出发送队列第一个alt</span></div><div class="line">		altcopy(a, other);<span class="comment">//将发送队列第一个alt中携带的数据拷贝到a</span></div><div class="line">		<span class="function"><span class="title">altalldequeue</span>(other-&gt;</span>xalt);<span class="comment">//删除发送队列第一个alt</span></div><div class="line">		<span class="function"><span class="title">other</span>-&gt;</span>xalt[<span class="number">0</span>].xalt = other;</div><div class="line">		<span class="function"><span class="title">taskready</span>(other-&gt;</span>task);<span class="comment">// 将other的宿主任务放入调度队列中</span></div><div class="line">	&#125;<span class="keyword">else</span></div><div class="line">		altcopy(a, <span class="literal">nil</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数很重要，可以说是理解channel接收逻辑的重点；解释如下</p>
<ol>
<li>一开始，取出发送队列第一个alt；</li>
<li>将发送队列第一个alt的数据拷贝至接收alt中；</li>
<li>删除发送队列中的第一个alt，因为已经被处理了;</li>
<li>调用taskready将taskmain任务放入任务队列中，等待调度；</li>
</ol>
<p>最后在chanrecvul函数中，将val，即接收alt-&gt;v中存储的值，返回给用户；</p>
<p>当counttask1任务结束时，调度器调度taskmain执行，taskmain输出一句&quot;test2----&quot;，也结束运行</p>
<p>最后，调度任务队列为空，调度循环退出，整个进程也就退出了</p>
<p>因此到目前为止，channel的发送接收逻辑已经很清楚了</p>
<blockquote>
<p>taskmain任务向channel发送数据时，将alt放入channel的发送队列；阻塞切换；然后counttask1任务从channel接收数据时，将发送队列第一个alt携带数据拷贝至接收队列的alt中，并将taskmain放入任务队列末尾，等待调度；在chanrecvul将数据返回给用户</p>
</blockquote>
<p>libtask无缓存的channel暂时分析到这；对于有缓存的的channel，代码逻辑和这下相似，只是用到了buf，我相信看懂无缓存channel的代码逻辑之后，再跟着gdb单步调试肯定也能看懂有缓存channel逻辑；</p>
<p>有时间在分析有缓存channel逻辑吧．</p>
]]></content>
      
        <categories>
            
            <category> libtask </category>
            
        </categories>
        
        
        <tags>
            
            <tag> libtask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[聊聊golang的前身libtask]]></title>
      <url>http://luodw.cc/2016/06/21/libtask/</url>
      <content type="html"><![CDATA[<p>在实习期间，由于项目需要，接触了golang这门语言；经过一段时间的学习使用，我发现golang语言语法简单，有C/C++基础的同学，一个星期即可上手，当然要深入理解golang，还是要多使用，多学习底层机制；goroutine的引入，使得golang非常适合并发程序的开发；而我了，在学习一门语言或技术的时候，是一定要理解底层的实现原理，否则我会用的很盲目或者说难受．所以有了这篇文章．</p>
<p>之前，在没接触golang时，在我的认知范围内，服务器开发架构大体就是类似redis的单线程，memcache多线程，ngnix多进程；在接触golang之后，我认识了协程这么一个概念，可以说这是我知识体系非常大的补充，因为服务器开发还可以采用协程实现；接下来，先简要介绍下协程的概念，然后在介绍golang前身libtask的实现原理；</p>
<h1>协程是什么</h1>
<p>协程，其实就是轻量级线程，粒度比线程还小，通俗点说就是用户态的一个函数块；一个进程或线程如果内存够大，就可以创建足够多的协程，但是在在内核层面，还是只有一个进程描述符，也就是说内核并不知道协程的存在，所以协程的调度执行完全需要用户态调度器来调度执行；协程有也有自己的栈，也有自己的上下文，所以协程可以在执行到一半的时候让出cpu，同时保存上下文，切换到其他协程，待其他协程执行结束之后，再切回来继续执行；</p>
<p>对于Linux，</p>
<ol>
<li>进程切换是个耗时的工作，因为首先要程序要先嵌入到内核，保存当前进程的上下文到任务段，然后进程调度算法选择一个就绪进程，将这个就绪进程任务段保存的寄存器值恢复到CPU，切换页表，切换堆栈，刷新cpu中TLB和Cache缓存等；</li>
<li>线程就是轻量级的进程，因为线程在内核里面也有进程描述符，也有内核堆栈；所以线程的切换，也需要嵌入内核，执行上下文切换以及堆栈切换等，但是同个进程中的线程切换不需要切换页表，不要刷新TLB，所以在一定程度上，线程切换代价是小于进程切换；</li>
<li>协程的切换比进程，线程切换代价都小；linux下面，CPU调度最小的单位是线程(因为内核调度需要task_struct嘛)，所以对于一个进程或线程上的所有协程只能在同一个CPU上调度执行，而且只能一个协程执行结束之后再执行其他线程，除非某个协程显式让出CPU；因此，协程的调度不需要内核调度，而是由用户态调度器调度，而且只需要切换CPU硬件上下文，代价相对于进程线程是非常低的．</li>
</ol>
<p>当前，支持协程的语言越来越多，主流的有lua,golang,python,Erlang等；当然在远古时代，那时没有语言支持协程，有些大佬就用C语言自己封装实现用户态任务调度库，比较有代表性的就是golang的前身libtask，所以学习golang，libtask一定要看看，对于理解golang有很大的帮助．</p>
<h1>说说libtask</h1>
<p>libtask是一套用c语言编写的任务调度库，实现很简单，将创建的任务存入一个队列中，然后main函数主线程在一个for循环中，不断从队列头部开始调度任务，直到任务队列为空，直到所有任务调度完毕，进程退出；</p>
<h2>libtask简单例子程序</h2>
<p>这里先给个例子简单说明下libtask使用:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;task.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">counttask1</span><span class="params">(<span class="keyword">void</span> *arg)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"task1: %d\n"</span>, i);</div><div class="line">        taskyield();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">counttask2</span><span class="params">(<span class="keyword">void</span> *arg)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"task2: %d\n"</span>, i);</div><div class="line">        taskyield();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">    taskcreate(counttask1, <span class="literal">NULL</span>, <span class="number">32768</span>);</div><div class="line">    taskcreate(counttask2, <span class="literal">NULL</span>, <span class="number">32768</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译这段代码时，需要加入动态链接库</p>
<blockquote>
<p>gcc example.c -o example -ltask</p>
</blockquote>
<p>最后执行结果如下:
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">charles<span class="meta">@charles</span>-<span class="string">Lenovo:</span>~/libtask$ gcc example.c -o example -ltask</div><div class="line">charles<span class="meta">@charles</span>-<span class="string">Lenovo:</span><span class="regexp">~/libtask$ ./</span>example</div><div class="line"><span class="string">task1:</span> <span class="number">0</span></div><div class="line"><span class="string">task2:</span> <span class="number">5</span></div><div class="line"><span class="string">task1:</span> <span class="number">1</span></div><div class="line"><span class="string">task2:</span> <span class="number">6</span></div><div class="line"><span class="string">task1:</span> <span class="number">2</span></div><div class="line"><span class="string">task2:</span> <span class="number">7</span></div><div class="line"><span class="string">task1:</span> <span class="number">3</span></div><div class="line"><span class="string">task2:</span> <span class="number">8</span></div><div class="line"><span class="string">task1:</span> <span class="number">4</span></div><div class="line"><span class="string">task2:</span> <span class="number">9</span></div></pre></td></tr></table></figure></p>
<p>这个例子很简单，通过在taskmain函数中调用taskcreate创建两个任务，然后taskmain任务退出，开始执行counttask1和counttask2两个任务，并通过taskyield函数实现任务切换，主要就是让出CPU，实现交替执行，最终打印如上结果．</p>
<p>可能有小伙伴会有疑问，怎么这段小程序没有main函数？因为开始学编程的时候，老师就说main函数是程序入口．带着疑问，查看源码发现，main函数已经集成在libtask库，在task.c文件中；我刚开始看时，也有疑惑，为什么不把main函数交给用户？通过查看源码，我的理解是，因为在main函数中，需要实现任务调度功能，如果把main函数交个用户，那就需要再提供一个接口给用户注册调度模块，这就无疑增加代码难度以及暴露太多的内部细节，例如任务队列以及任务结构等等；所以libtask库干脆封装main函数，并在main函数中实现调度器，这样只需提供创建任务的接口即可，内部实现细节全都隐藏了．</p>
<h2>libtask实现原理</h2>
<p>这里先给出如下图示说明libtask的执行过程，我以上述example.c为例
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line">              <span class="comment">|</span>  <span class="comment">Scheduler</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">主线程</span></div><div class="line">              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line">              <span class="comment">/</span>      <span class="comment">|</span>     <span class="comment">\</span></div><div class="line">             <span class="comment">/</span>       <span class="comment">|</span>      <span class="comment">\</span></div><div class="line">            <span class="comment">/</span>        <span class="comment">|</span>       <span class="comment">\</span></div><div class="line">           <span class="comment">/</span>         <span class="comment">|</span>        <span class="comment">\</span></div><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>     <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>    <span class="literal">+</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line"><span class="comment">|</span> <span class="comment">taskmain</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">task1</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">task2</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span></div><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>     <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>    <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div></pre></td></tr></table></figure></p>
<ol>
<li>在task.c文件main函数中，首先会创建taskmain任务，并放入任务队列中；</li>
<li>接着mian函数主程序进入任务调度循环中，不断迭代并执行任务队列中的任务，直到任务队列为空；一开始只有taskmain任务，因此执行taskmain任务函数；</li>
<li>一般情况下，我们会在taskmain任务函数中创建其他任务，并放入任务中；此时tasmain任务结束退出；</li>
<li>此时任务队列中只有task1和task2，task1在队首，所以先执行，当遇到taskyield函数时，此时task1自愿放弃cpu，把自身放入任务队列末尾；执行任务切换，切换到调度器；</li>
<li>此时调度器取出位于队首的task2执行，同样，遇到taskyield，放弃cpu,自身存入任务队列末尾，切换到调度器；</li>
<li>调度器执行task1...</li>
</ol>
<p>以上就是例子example.c的执行过程，从中我们可以知道，libtask把真正的main函数隐藏了，也就是说调度器对用户是透明的，但是给用户提供了另一个main函数taskmain；因此我们在使用libtask时只需要把taskmain当做main函数即可，在libtask的真正main函数中会为这个taskmain创建一个任务并调度执行；所以除了调度器外，taskmain永远是第一个任务，后面的任务需要从taskmain任务创建衍生．</p>
<h2>libtask源码解析</h2>
<p>要实现任务切换，就必须能够保存当前任务的上下文，这样再次切回当前任务时，可以继续执行当前任务；在linux平台下面，主要用的就是ucontext.h，提供的getcontext,setcontext,swapcontext和makecontext函数，具体的上下文有结构体ucontext_t指定，包括任务的栈的大小，栈顶指针以及cpu内寄存器信息；简要介绍下四个函数，具体如何使用可以谷歌之．</p>
<ol>
<li>int getcontext(ucontext_t *ucp);函数用于获取当前任务的上下文，并存入ucp中；</li>
<li>int setcontext(const ucontext_t *ucp);用于实现任务切换，即设置当前执行的上下文；</li>
<li>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);用于创建一个上下文，存入ucp中，当执行这个上下文时，会跳转到func函数中执行；</li>
<li>int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);这个函数可以看成是setcontext好绕getcontext函数的合成，先保存当前上下文在oucp，然后跳转到ucp指定的上下文；当ucp任务执行结束之后，会回到swapcontext函数的下一行代码继续执行(实现可以思考uc_link)．</li>
</ol>
<p>接下来，从main函数开始，源码解析(省去一些不影响分析的代码)
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> taskargc;<span class="comment">//为了将用户输入的参数传进taskmain函数中</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> **taskargv<span class="comment">//所以设置了这两个变量</span></div><div class="line"><span class="keyword">int</span> mainstacksize;<span class="comment">// taskmain任务栈的大小</span></div><div class="line"></div><div class="line"><span class="comment">// taskmain主协程</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">taskmainstart</span><span class="params">(<span class="keyword">void</span> *v)</span></div><div class="line">&#123;</div><div class="line">	taskname(<span class="string">"taskmain"</span>);</div><div class="line">	taskmain(taskargc, taskargv);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	  省去对信号处理函数</div><div class="line">	*/</div><div class="line">	argv0 = argv[<span class="number">0</span>];</div><div class="line">	taskargc = argc;</div><div class="line">	taskargv = argv;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(mainstacksize == <span class="number">0</span>)</div><div class="line">		mainstacksize = <span class="number">256</span>*<span class="number">1024</span>;<span class="comment">//设置taskmain栈大小</span></div><div class="line"></div><div class="line">    　　<span class="comment">/* 创建taskmain协程 */</span></div><div class="line">	taskcreate(taskmainstart, nil, mainstacksize);</div><div class="line">        <span class="comment">/* 进入协程调度 */</span></div><div class="line">	taskscheduler();</div><div class="line">	fprint(<span class="number">2</span>, <span class="string">"taskscheduler returned in main!\n"</span>);</div><div class="line">	<span class="built_in">abort</span>();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>libtask代码写的很清晰，主程序主要是执行taskmain任务创建，接着进入任务调度模块；接下来先看下任务创建函数taskcreate
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">nt</div><div class="line">taskcreate(<span class="keyword">void</span> (*fn)(<span class="keyword">void</span>*), <span class="keyword">void</span> *arg, uint stack)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> <span class="keyword">id</span>;</div><div class="line">	Task *t;</div><div class="line">	<span class="comment">/*　taskalloc函数主要执行任务结构体Task内存分配以及创建，初始化</span></div><div class="line">	　　任务栈信息，创建任务上下文　*/</div><div class="line">	t = taskalloc(fn, arg, stack);</div><div class="line">	taskcount++;</div><div class="line">	<span class="keyword">id</span> = t-&gt;<span class="keyword">id</span>;</div><div class="line">	<span class="keyword">if</span>(nalltask%<span class="number">64</span> == <span class="number">0</span>)&#123;<span class="comment">//nalltask变量标识所有任务的个数，如果任务超出64个</span></div><div class="line">				<span class="comment">//则需要重新分配内存，把任务数组大小增加64</span></div><div class="line">		alltask = realloc(alltask, (nalltask+<span class="number">64</span>)*<span class="keyword">sizeof</span>(alltask[<span class="number">0</span>]));</div><div class="line">		<span class="keyword">if</span>(alltask == <span class="literal">nil</span>)&#123;</div><div class="line">			fprint(<span class="number">2</span>, <span class="string">"out of memory\n"</span>);</div><div class="line">			abort();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	t-&gt;alltaskslot = nalltask;</div><div class="line">	alltask[nalltask++] = t;</div><div class="line">	taskready(t);<span class="comment">//taskready将任务t标为就绪状态，并加入任务队列中</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">id</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//----------------------------------------------------------------------</span></div><div class="line"><span class="keyword">void</span></div><div class="line">taskready(Task *t)</div><div class="line">&#123;</div><div class="line">	t-&gt;ready = <span class="number">1</span>;</div><div class="line">	addtask(&amp;taskrunqueue, t);<span class="comment">//将任务t加入taskrunqueue队列中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过taskcreate函数创建maintask任务，并且放入任务队列taskrunqueue队列中之后，接下来，程序进入taskscheduler()调度函数中，我们直接看任务调度循环部分
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(;;)&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(taskcount == <span class="number">0</span>)</div><div class="line">		<span class="keyword">exit</span>(taskexitval);</div><div class="line">	<span class="regexp">/* 取出队首的任务 */</span></div><div class="line">	t = taskrunqueue.head;</div><div class="line">	<span class="keyword">if</span>(t == nil)&#123;</div><div class="line">		fprint(<span class="number">2</span>, <span class="string">"no runnable tasks! %d tasks stalled\n"</span>, taskcount);</div><div class="line">		<span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="regexp">/* 从任务队列中删除该任务 */</span></div><div class="line">	deltask(&amp;taskrunqueue, t);</div><div class="line">	t-&gt;ready = <span class="number">0</span>;</div><div class="line">	taskrunning = t;<span class="regexp">/* 设置全局任务运行变量为当前执行任务t */</span></div><div class="line">	tasknswitch++; <span class="regexp">/* 任务切换次数+1 */</span></div><div class="line">	taskdebug(<span class="string">"run %d (%s)"</span>, t-&gt;id, t-&gt;name);</div><div class="line">	<span class="regexp">/* 执行任务切换 */</span></div><div class="line">	contextswitch(&amp;taskschedcontext, &amp;t-&gt;context);</div><div class="line">	taskrunning = nil;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(t-&gt;exiting)&#123;<span class="regexp">//</span>如果任务t执行完毕，即可在全局任务数组中删除</div><div class="line">		<span class="keyword">if</span>(!t-&gt;system)</div><div class="line">			taskcount--;</div><div class="line"></div><div class="line">		i = t-&gt;alltaskslot;</div><div class="line">		alltask[i] = alltask[--nalltask];</div><div class="line">		alltask[i]-&gt;alltaskslot = i;</div><div class="line">		free(t);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在contextswitch函数中，执行swapcontext函数进行任务切换；在上述example.c例子中，由于一开始任务队列中只有taskmain任务，因此执行contextswitch之后，切换到taskmain任务执行；在taskmain函数中，创建两个任务task1和task2，并加入到taskrunqueue队列中，taskmain即运行结束，在任务启动函数taskstart函数的结尾，有个退出函数taskexit(0)，这个函数执行如下操作:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskexit</span><span class="params">(<span class="keyword">int</span> val)</span></div><div class="line">&#123;</div><div class="line">	taskexitval = val;</div><div class="line">	taskrunning-&gt;exiting = <span class="number">1</span>;</div><div class="line">	taskswitch();</div><div class="line">&#125;</div><div class="line"><span class="comment">// -----------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskswitch</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	needstack(<span class="number">0</span>);</div><div class="line">	contextswitch(&amp;taskrunning-&gt;context, &amp;taskschedcontext);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这两个函数，我们可以看出在某个任务退出之后，会进行任务切换，将控制权交给任务调度器，然后由调度器调度队列中的下一个任务；因此，到目前为止，libtask的架构更加清晰明了，</p>
<blockquote>
<p>由调度器调度队首任务，并从任务队列中删除队首任务；队首任务执行结束之后，会切回调度器，接着由调度器调度新的队首任务，直到任务队列为空．</p>
</blockquote>
<blockquote>
<p>当然有一种情况是遇到taskyield函数，这时当前任务会让出cpu，切换到调度器，并将自身放入任务队列末尾，等待调度器的再次调度．调度器即执行新的队首任务．</p>
</blockquote>
<p>这篇文章主要是分析了golang的前身libtask的实现原理，多多少少都有着golang的影子，当然听说golang改进了libtask任务调度机制，因为libtask每次某个任务执行结束都需要切换到调度器，再由调度器调度新的任务，显然，切换到调度器这过程是多余了；具体golang怎么实现，待我后续研究...</p>
<p>下篇文章分析下libtask的channel的实现．</p>
]]></content>
      
        <categories>
            
            <category> libtask </category>
            
        </categories>
        
        
        <tags>
            
            <tag> libtask </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TFS之DataServer启动执行过程]]></title>
      <url>http://luodw.cc/2016/05/20/tfs01/</url>
      <content type="html"><![CDATA[<p>最近在实习,接触了tfs文件系统,刚好之前有决定往数据存储方向发展,因此很认真的看了tfs安装部署,以及源码.不得不说,tfs源码真心不是很容易看懂的,因为用了C++很多继承多态,回调机制,地处底层封装等等,我也是花了大概好几天天的时间才把DataServer整体部分看懂了;因此必须写篇博客记录下...</p>
<h1>文件系统</h1>
<hr>
<p>学过计算机的朋友 ，都有听说过文件系统，简要地说，文件系统就是操作系统组织磁盘文件的一种方式，因为磁盘就是一个物理设备，只知道存储二进制的比特位，但是并不知道存储的是文件还是目录，因此操作系统要规划好如何将文件存入磁盘以及如何从磁盘取文件等等，这就是文件系统做的事；关于文件系统的介绍，《linux鸟哥的私房菜》前几章有很好的介绍。</p>
<p>当然对于linux来说，一切都是文件，因为在linux下面，文件系统的概念更广，有传统的基于磁盘的ext4,ext3...，有基于网络的sockfs，有基于内存的pipefs和procfs等等。通过一层虚拟文件系统vfs，屏蔽各个文件系统的差异，为用户提供统一的访问接口open,write,read,close等等；</p>
<p>分布式文件系统是属于用户态的文件系统，最终利用的还是操作系统内核的文件系统的存储功能；tfs将磁盘分成若干个块（其实就是大文件），一个块一般较大，可以存储较多的小文件；tfs就是将小文件存储在某个块中，也是从块中取小文件；我的理解就是操作系统文件系统单个文件为单位存储单个文件的数据，而分布式文件系统以块为单位存储各个小文件的数据。常见的分布式文件系统有GFS,HDFS,GridFS,TFS,FastFS等等；</p>
<h1>TFS简要概述</h1>
<hr>
<p>最近两个星期都在看TFS文件系统dataserver部分源码，感受最深的就是快吐了，由于是C++写的，代码里面充斥太多的继承多态，回调，以及各种底层封装，反正就是一个字“乱”，也可能正如林老湿所说，“是时候换个姿势了”。经过我的坚持和林老湿的指导，最终还是把整个dataserver的执行过程看懂了，因此今天写篇博客总结下。</p>
<p>TFS（Taobao !FileSystem）是一个高可扩展、高可用、高性能、面向互联网服务的分布式文件系统，主要针对海量的非结构化数据，它构筑在普通的Linux机器集群上，关于tfs的介绍可以看<a href="%22http://code.taobao.org/p/tfs/wiki/intro/%22">官方文档</a></p>
<p>先给出TFS整体框架图<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-tfs01.png" alt="TFS整体框架">
正如图所示，NameServer负责管理各个block和dataserver之间的对应关系，并不存储实际数据，而DataServer用于存储具体的数据，当应用程序要存储一个文件时，</p>
<ol>
<li>首先在客户端根据文件名解析出文件该文件所对应的block_id和file_id，接着访问NameServer，NameServer向客户端返回这个block_id对应块所在的dataserver地址链表（有一个是primary_ds,其他为了冗余存储），</li>
<li>客户端接着访问primary_ds，请求在block_id块存储file_id文件，把文件写入block_id对应块中；</li>
<li>primary_ds将数据写入块之后，再给其他slave数据服务器发送在block_id块存储file_id的消息，实现同步；slave服务器成功写入返回之后，primary_ds通过心跳机制给ns报告块的使用情况；</li>
<li>primary_ds给客户端回复数据成功写入；</li>
</ol>
<p>当客户端需要读取文件时，</p>
<ol>
<li>首先在客户端根据文件名解析出文件所对应的block_id和file_id，然后访问NameServer获取这个block所对应的dataserver地址链表；</li>
<li>接着客户端访问primary_ds读取数据；</li>
</ol>
<p>以上就客户端存储和读取数据的简要过程，之后会深入介绍文件存储和读取，本篇文章主要是介绍DataServer执行过程；</p>
<h1>DataServer启动过程</h1>
<hr>
<p>首先来看下DataServer启动过程，稍后再分析DataServer处理业务过程。</p>
<ol>
<li>服务器要开启，首先要找到main函数，DataServer的main函数在/dataserver/service.cpp下面
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">  tfs::dataserver::DataService service;</div><div class="line">  <span class="keyword">return</span> service.main(argc, argv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>从代码可以看出先是实例化一个DataService类，然后调用DataService这个类的main函数，接着我们自然而然的会去DataService中查找main函数，接着会发现并没有！这里要先介绍类的继承关系：
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">DataService</span>继承自/<span class="meta">common</span>/<span class="keyword">BaseService</span></div><div class="line"><span class="keyword">BaseService继承自/common/BaseMain</span></div></pre></td></tr></table></figure></p>
<p>因此我们向上查找，在BaseMain类中找到了main方法，在main方法中，主要处理的是运行程序时，跟在程序后面的参数，最后在main方法中调用start方法
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">iret</span> = start(argc , argv, daemonize);</div></pre></td></tr></table></figure></p>
<p>start方法也是在/common/base_main.cpp文件中，主要做的任务就是处理服务器配置文件以及初始化工作目录，pid目录以及日志目录，最后调用run函数
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iret = <span class="keyword">run</span><span class="bash">(argc, argv);</span></div></pre></td></tr></table></figure></p>
<ol start="2">
<li>而这个run函数在/common/base_service.cpp的BaseService类中，run函数主要任务就是首先通过调用函数
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int32_t iret = initialize_network(<span class="name">argv</span>[<span class="number">0</span>])<span class="comment">;</span></div></pre></td></tr></table></figure></li>
</ol>
<p>开启网络模块tbnet两个线程，一个是eventloop线程，负责事件监听，另一个是timeoutLoop线程，负责监控各个客户端连接的情况。在run函数中，接着开启4工作线程，工作线程个数可配置,以及一个时间监控线程（我暂时不知道有啥用），最后调用initialize函数，到达具体服务的初始化操作；</p>
<ol start="3">
<li>之前是tfs为各个服务抽象出来的公共部分，通过initialize函数达到初始化具体服务的目的；在/dataserver/dataservice.cpp/DataService类中找到了initialize函数,这个函数主要就是初始化dataserver具体信息，比如初始化dataserver的私有目录，设置NameServer的地址，核对网络设备以及自身地址，同时再监听本dataserver端口+1的端口，也就是说一个dataserver监听着两个端口，假如第一个是8200，那么还有端口是8201。在initialize函数中，最后步骤就是开启了2个心跳线程，1个校对线程，1个压缩线程，1个复制线程（可配置）。</li>
</ol>
<p>至此，dataserver就启动完毕，等待客户端的连接，请求数据。</p>
<p>dataserver默认是有13个线程，我们可以通过pstack或者gdb info thread打印出来，而且除了main主线程，其他线程是根据开启时间，从上至下排列；
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">[root@meitu_6 luodw]# pstack <span class="number">3875</span></div><div class="line">Thread <span class="number">13</span> (Thread <span class="number">0x7f2ea1b96700</span> (LWP <span class="number">3876</span>)):<span class="comment">//tbnet的事件监听线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e96163</span> <span class="keyword">in</span> epoll_wait () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a61a9</span> <span class="keyword">in</span> tbnet::EPollSocketEvent::getEvents(int, tbnet::IOEvent*, int) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a2c29</span> <span class="keyword">in</span> tbnet::Transport::eventLoop(tbnet::SocketEvent*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">12</span> (Thread <span class="number">0x7f2ea1195700</span> (LWP <span class="number">3877</span>)):<span class="comment">// tbnet客户端监控超时监控事件</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e8ee54</span> <span class="keyword">in</span> usleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a396a</span> <span class="keyword">in</span> tbnet::Transport::timeoutLoop() ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">11</span> (Thread <span class="number">0x7f2e9bfff700</span> (LWP <span class="number">3881</span>)):<span class="comment">// 工作线程1</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">10</span> (Thread <span class="number">0x7f2e9b5fe700</span> (LWP <span class="number">3883</span>)):<span class="comment">// 工作线程2</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">9</span> (Thread <span class="number">0x7f2e9abfd700</span> (LWP <span class="number">3885</span>)):<span class="comment">// 工作线程3</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">8</span> (Thread <span class="number">0x7f2e9a1fc700</span> (LWP <span class="number">3886</span>)):<span class="comment">// 工作线程4</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">7</span> (Thread <span class="number">0x7f2e997fb700</span> (LWP <span class="number">3887</span>)):<span class="comment">//这就是我暂时不是很清楚的那个时间线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da98e</span> <span class="keyword">in</span> pthread_cond_timedwait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004baf04</span> <span class="keyword">in</span> bool tbutil::Cond::timedWaitImpl&lt;tbutil::Mutex&gt;(tbutil::Mutex const&amp;, tbutil::Time const&amp;) const ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004ba145</span> <span class="keyword">in</span> tbutil::Monitor&lt;tbutil::Mutex&gt;::timedWait(tbutil::Time const&amp;) const ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b9459</span> <span class="keyword">in</span> tbutil::Timer::run() ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">6</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">6</span> (Thread <span class="number">0x7f2e98dfa700</span> (LWP <span class="number">3892</span>)):<span class="comment">// 心跳线程1</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e8ee54</span> <span class="keyword">in</span> usleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000043c53a</span> <span class="keyword">in</span> tfs::dataserver::DataService::run_heart(int) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">5</span> (Thread <span class="number">0x7f2e983f9700</span> (LWP <span class="number">3894</span>)):<span class="comment">// 心跳线程2</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e8ee54</span> <span class="keyword">in</span> usleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000043c476</span> <span class="keyword">in</span> tfs::dataserver::DataService::run_heart(int) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">4</span> (Thread <span class="number">0x7f2e979f8700</span> (LWP <span class="number">3896</span>)):<span class="comment">// 校对线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e59b50</span> <span class="keyword">in</span> sleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x0000000000438633</span> <span class="keyword">in</span> tfs::dataserver::DataService::run_check() ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">3</span> (Thread <span class="number">0x7f2e96ff7700</span> (LWP <span class="number">3897</span>)):<span class="comment">// 压缩线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x000000000042f3a9</span> <span class="keyword">in</span> tfs::dataserver::CompactBlock::run_compact_block() ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">2</span> (Thread <span class="number">0x7f2e8ffff700</span> (LWP <span class="number">3899</span>)):<span class="comment">// 复制线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da98e</span> <span class="keyword">in</span> pthread_cond_timedwait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x000000000042b7ff</span> <span class="keyword">in</span> tfs::dataserver::ReplicateBlock::run_replicate_block() ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">1</span> (Thread <span class="number">0x7f2ea2f02720</span> (LWP <span class="number">3875</span>)):<span class="comment">// 主线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x000000000048c4dc</span> <span class="keyword">in</span> tfs::common::BaseMain::wait_for_shutdown() ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000048d632</span> <span class="keyword">in</span> tfs::common::BaseMain::start(int, char**, bool) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x000000000048db2d</span> <span class="keyword">in</span> tfs::common::BaseMain::main(int, char**) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x000000000040f0c0</span> <span class="keyword">in</span> main ()</div></pre></td></tr></table></figure></p>
<p>因此，dataserver开启之后，总共有13个线程在跑着，最主要的线程是tbnet的事件监听线程和4个工作线程，因为这两个是处理客户端请求最主要的线程；</p>
<h1>dataserver处理请求过程</h1>
<hr>
<p>dataserver处理客户端的请求过程可比dataserver启动过程复杂的多，先简要说下过程;</p>
<blockquote>
<p>tbnet线程监听到客户端有数据可读，读取数据并将数据封装成packet，放入队列中；之前的四个工作线程一开始都阻塞在条件变量上，当有个packet放入队列并唤醒一个工作线程处理这个packet，处理结束之后，把回复客户端的内容放入链接缓冲区中，并在这个连接上注册一个可写事件，在可读事件结束之后,直接执行可写事件,把消息回复给客户端.</p>
</blockquote>
<p>ok，我开始分析吧!</p>
<p>这里就不分析网络模块的线程是怎么创建的，只分析处理过程，因为单独分析tbnet就可以写一篇文章。但是tfs如何创建线程估计就理解一小会，主要过程就是tbnet模块最主要类Transport通过调用start方法把自己传入CThread的start方法中，然后再回调Transport的run方法，实现创建线程的目的；</p>
<p>我们来看下eventLoop线程主要事件回调代码：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bool rc = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (events[i]._readOccurred) &#123;</div><div class="line">    <span class="function"><span class="title">rc</span> = ioc-&gt;</span>handleReadEvent();</div><div class="line">    <span class="comment">//ioc为iocomponent,即将与网络io相关的部分封装在一起，一个f客户端对应一个iocomponent</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (rc &amp;&amp; events[i]._writeOccurred) &#123;</div><div class="line">    <span class="function"><span class="title">rc</span> = ioc-&gt;</span>handleWriteEvent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>listenfd和clientfd对应的iocomponent是不一样的，对于listenfd对应的iocomponent为tcpacceptor.cpp/TCPAcceptor这个类，这个类只有handleReadEvent方法，即将接收的客户端加入事件监听中，并注册可写事件。而clientfd对应的iocomponent为tcpconnnection.cpp/TCPConnection类，这个类的handleReadEvent处理客户端的请求，而handleWriteEvent处理回复客户端事件。</p>
<ol>
<li>我们从clientfd的iocomponent--&gt;handleReadEvent开始说起：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bool</span> TCPComponent::handleReadEvent() &#123;</div><div class="line">    _lastUseTime = tbsys::CTimeUtil::getTime();</div><div class="line">    <span class="built_in">bool</span> rc = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (_state == TBNET_CONNECTED) &#123;</div><div class="line">        rc = _connection-&gt;readData();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>可以看到在TCPComponent::handleReadEvent方法中，只是简单的调用对应的_connection&gt;readData()方法。接下来，我们深入_connection-&gt;readData()方法。在readData方法中，</p>
<ul>
<li>首先调用socket的read方法将客户端的数据读取进_input缓冲区中；</li>
<li>接着调用方法_streamer-&gt;getPacketInfo，解析出包头;</li>
<li>最后调用handlePacket方法处理包；</li>
</ul>
<p>这个handlePacket方法在TCPConnection类中是找不到的，而是存在该类的父类Connection中，在handlePacket方法中，最重要的就是解析出包，然后调用
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">rc</span> = _serverAdapter-&gt;handlePacket(this, packet);</div></pre></td></tr></table></figure></p>
<p>来处理包；到这里，可能又要开始迷糊了，这个_serverAdapter是什么鬼？</p>
<blockquote>
<p>到这里需要先来介绍下tbnet模块的Transport类，为了tbnet模块接口的简单，tbnet就提供了Transport这类给其他模块调用，而这个类主要最主要就是listen方法和start方法；listen方法用于设置监听的套接字，start用于开启tbnet模块的两个线程；</p>
</blockquote>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IOComponent *Transport::listen(<span class="keyword">const</span> <span class="keyword">char</span> *spec, IPacketStreamer *streamer, IServerAdapter *serverAdapter)</div></pre></td></tr></table></figure></p>
<p>这个listen方法第一个参数为监听套接字，第二个参数为转码用的streamer，第三个参数为每个服务器处理包的适配器，因此tbnet模块所有的serverAdapter都是从这个listen接口传进去的。我们来看下dataserver调用listen接口：
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">tbnet:</span><span class="symbol">:IOComponent*</span> com = transport<span class="number">_</span>-&gt;listen(spec, streamer<span class="number">_</span>, this);</div></pre></td></tr></table></figure></p>
<p>在DataService类调用listen方法时，把自己作为serverAdapter传入tbnet模块，因为DataService继承自base_service,而base_service继承自IServerAdapter，因此DataService可以作为IServerAdapter的子类传入tbnet模块中；现在我们可以看下DataService-&gt;handlePacket方法做了什么？</p>
<ol start="2">
<li>在DataService-&gt;handlePacket方法中，最要就是调用push方法，而push方法主要就是将packet存入工作线程队列中
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool </span><span class="keyword">BaseService::push(BasePacket* </span>packet, <span class="keyword">bool </span><span class="keyword">block)</span></div><div class="line">    &#123;</div><div class="line">      return main_workers_.<span class="keyword">push(packet, </span>work_queue_size_, <span class="keyword">block);</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>在main_workers_为tbnet的PacketQueueThread类，我们定位到该类的push方法，在push方法中，最重要的就是</p>
<p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">_cond</span>.<span class="built_in">lock</span>();</div><div class="line">  <span class="variable">_queue</span>.push(packet);</div><div class="line">  <span class="variable">_cond</span>.unlock();</div><div class="line">  <span class="variable">_cond</span>.signal();</div></pre></td></tr></table></figure></p>
<p>将packet存入队列中，并且调用_cond.signal方法唤醒一个工作线程；到这时，tbnet的eventLoop线程即处理结束一个客户端的请求，接下来的处理就交给工作线程处理。</p>
<ol start="3">
<li>之前有提到，工作线程当初调用/PacketQueueThread/run方法，阻塞在条件变量中，因此可以和eventLoop线程共享packet队列。我们看下某个线程被唤醒后，做了什么？</li>
</ol>
<p>可以在run方法中，可以看到最重要的一行代码为:
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="variable">_handler</span>) &#123;</div><div class="line">           ret = <span class="variable">_handler</span>-&gt;handlePacketQueue(packet, <span class="variable">_args</span>);</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>即调用handler-&gt;handlePacketQueue方法，之前有提到过，这个_handler即为DataService类，可以定位到DataService-&gt;handlePacketQueue方法，在该方法中，根据packet的类型，执行不同的操作：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> DataService::handlePacketQueue(tbnet::Packet* packet, <span class="keyword">void</span>* args)</div><div class="line">   &#123;</div><div class="line">     <span class="keyword">bool</span> bret = BaseService::handlePacketQueue(packet, args);</div><div class="line">     <span class="keyword">if</span> (bret)</div><div class="line">     &#123;</div><div class="line">       <span class="keyword">int32_t</span> pcode = packet-&gt;getPCode();</div><div class="line">       <span class="keyword">int32_t</span> ret = LOCAL_PACKET == pcode ? TFS_ERROR : TFS_SUCCESS;</div><div class="line">       <span class="keyword">if</span> (TFS_SUCCESS == ret)</div><div class="line">       &#123;</div><div class="line">         <span class="keyword">switch</span> (pcode)</div><div class="line">         &#123;</div><div class="line">           <span class="keyword">case</span> CREATE_FILENAME_MESSAGE:</div><div class="line">             ret = create_file_number(<span class="keyword">dynamic_cast</span>&lt;CreateFilenameMessage*&gt;(packet));</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> WRITE_DATA_MESSAGE:</div><div class="line">             ret = write_data(<span class="keyword">dynamic_cast</span>&lt;WriteDataMessage*&gt;(packet));</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> CLOSE_FILE_MESSAGE:</div><div class="line">             ret = close_write_file(<span class="keyword">dynamic_cast</span>&lt;CloseFileMessage*&gt;(packet));</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">    .........................</div></pre></td></tr></table></figure></p>
<p>我们以创建一个文件为例，此时执行的是create_file_number方法，在该方法中首先调用DataManagement-&gt;create_file方法，执行创建文件的操作；DataManagement专门负责DataServer文件存储各种方法调用，后面再写一篇文章，专门介绍DataServer如何存储文件。</p>
<p>在create_file_number方法中，接下来先定义一个回复给客户端的消息类，并且执行请求消息的reply方法将消息准备回复给客户端。
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RespCreateFilenameMessage* resp_cfn_msg = new RespCreateFilenameMessage()<span class="comment">;</span></div><div class="line">      resp_cfn_msg-&gt;set_block_id(<span class="name">block_id</span>)<span class="comment">;</span></div><div class="line">      resp_cfn_msg-&gt;set_file_id(<span class="name">file_id</span>)<span class="comment">;</span></div><div class="line">      resp_cfn_msg-&gt;set_file_number(<span class="name">file_number</span>)<span class="comment">;</span></div><div class="line">      message-&gt;reply(<span class="name">resp_cfn_msg</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时的message是一个BasePacket的子类，我们定位到BasePacket-&gt;reply方法。</p>
<p>在reply方法中，一开始是先设置回复消息类的一些属性，然后最重要的是调用_connection-&gt;postPacket方法:
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool </span><span class="keyword">bret= </span>connection_-&gt;postPacket(packet)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>在postPacket方法中，我们提取出最重要的两行代码
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将回复客户端的消息packet存入输出队列中</span></div><div class="line"> <span class="variable">_outputQueue</span>.push(packet);</div><div class="line"><span class="comment">// 注册当前连接的可写事件</span></div><div class="line"> <span class="variable">_iocomponent</span>-&gt;enableWrite(<span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<ol start="4">
<li>因为eventLoop的事件监听中，先执行可读事件，紧接着执行可写事件，因此上述注册可写事件之后，即可直接执行可写事件，把消息回复给客户端。</li>
</ol>
<p>可写事件的回调函数是</p>
<p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">rc</span> = ioc-&gt;handleWriteEvent()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>ok，我们定位到TCPComponent-&gt;handleWriteEvent方法，可以看到最主要还是执行TCPConnection-&gt;writedata方法</p>
<p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">rc</span> = _connection-&gt;writeData()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>在TCPConnection-&gt;writeData方法中，去除输出队列的第一个消息包，然后调用</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ret = _socket-&gt;write(<span class="name">_output</span>.getData(), _output.getDataLen())<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>把消息回复给客户端。</p>
<p>上述就是客户端和DataServer一次完整的交互过程。</p>
<p>如果要按编程模型分类，DataServer属于多线程模型，这种多线程模型又区别于memcache，它是某个线程监听所有套接字，然后将客户端的请求封装成消息包，放入公共队列中；接着由4个工作线程同步地去除消息队列的第一个消息包，并执行；这种模式可缺点就是公共队列要加锁同步，有一定开销；优点就是eventLoop线程可以很快的返回，加快处理客户端的请求，然后把可能消耗大量时间的业务处理放在了工作线程，极大加快系统的响应速度，这点和linux内核中断上下文原理类似。</p>
<p>DataServer整体的执行过程就先分析到这，后续可能会分析tbnet模块和DataServer存储数据过程。</p>
]]></content>
      
        <categories>
            
            <category> tfs </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习Linux高性能服务器编程的一些收获]]></title>
      <url>http://luodw.cc/2016/04/29/HighLinux/</url>
      <content type="html"><![CDATA[<p>最近把 <strong>Linux高性能服务器编程</strong> 编程这本书给看了,之前在知乎上看好多人推荐这本书,于是乎在我看了这本书之后,我发现这本书真的很值得看,这本书适合有Linux基础的的人看,特别是看过一些成熟框架的人看,像redis,memcache,最好还有nginx,因为这本书介绍了服务器端开发的一些术语以及模式,如果没看过源码实现,这些理论我觉得会很空洞,即使书本提供了一些示例,看着也会比较吃力.</p>
<p>我这篇文章主要记录在这本书见到的新知识,虽然很多内容在之前有接触过,但是还是有一些内容让我眼前一亮.</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-shuming.png" alt="Linux高性能服务器编程"></p>
<p>这本书篇章布局也很合理,第一篇介绍了网络的一些基础知识,tcp,ip,dns,arp等等,这些本科的网络课都有学过,但是我强烈推荐好好掌握下tcpdump这个命令(第一次见到这个命令是在unp网络编程),对网络上的的数据包进行截获的包分析工具,例如可以查看网络建立的三次握手数据包收发过程以及四次挥手过程,还可以查看icmp等等,非常方便.当然像route,netstat,ifconfig,ping,traceroute也是需要掌握的,还有和域名解析相关的三个命令dig,host,nslookup.</p>
<p>这本书的第二篇前半部分介绍了网络编程的一些函数调用;中间部分介绍了与网络相关的三种事件,文件io读写事件,定时事件,信号事件以及如何统一这三种事件源;最后一部分介绍了服务器编程中常用的多进程和多线程实现.</p>
<p>这本书的第三篇介绍了高性能服务器优化和检测,主要就是服务器调试,包括资源的调整,gdb调试和压力测试;还有一些和服务器性能相关的命令,例如stat系列,netstat,vmstat,ifstat,mpstat等等.</p>
<p>接下来,我就介绍下这本书中,给我眼前一亮的东西.</p>
<h1>sendfile,splice和tee函数</h1>
<hr>
<p>这三个函数在我没读这本书之前是没有遇到过的,unp网络编程我看了前半部分我也没见着,而且在redis和memcache我也没见着,关键是这三个函数效率很高,避免了用户态和内核态之间的数据拷贝.我经过一番思考之后,是因为服务器端程序都有业务逻辑,必须将数据拷贝至用户态,然后处理数据,最后再将数据拷贝进内核态发送出去,所以这三个函数在服务器上出场率不是很高;</p>
<h2>sendfile函数</h2>
<p>sendfile函数主要是用于在文件服务器上,在两个文件描述符之间直接传递数据(完全在内核中操作),从而避免了内核缓冲区和用户缓冲区之间的数据拷贝,效率很高,这种称为零拷贝.函数接口如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd,<span class="keyword">int</span> in_fd,<span class="keyword">off_t</span>* offset,<span class="keyword">size_t</span> count)</div></pre></td></tr></table></figure></p>
<p>outf_fd为待写入的文件描述符,一般是一个socket,in_fd是一个写入文件描述符,一般是一个磁盘文件描述符,offset是一个输入流的偏移量,如果为空,则从输入流的起始位置开始;count是文件描述符in_fd和out_fd之间传递的字节数.函数成功调用返回传递的字节数,失败返回-1,并设置error值.</p>
<p>sendfile函数使用场景最常见就是发送文件:</p>
<ul>
<li>从磁盘文件读取数据至内核缓冲区,用sendfile函数直接在内核将数据拷贝至socket输出缓冲区,发送出去;</li>
</ul>
<p>平时,我们如果要在网络上传输一个文件,要有以下步奏:</p>
<ol>
<li>打开一个文件fd,将文件的数据首先从磁盘拷贝至内核缓冲区;</li>
<li>然后将内核缓存区数据拷贝至用户态缓冲区;</li>
<li>将用户态缓冲区的数据拷贝至socket输出缓冲区;</li>
<li>将socket缓冲区数据发送出去;</li>
</ol>
<p>但是如果我们使用sendfile函数,则可以省去内核态拷贝至用户态这一过程:</p>
<ol>
<li>打开一个文件fd,将文件的数据首先从磁盘拷贝至内核缓冲区;</li>
<li>将内核哈缓冲区的数据拷贝至socket输出缓冲区;</li>
<li>将socket缓冲区数据发送出去;</li>
</ol>
<h2>splice函数</h2>
<p>这个函数主要是在两个文件描述符上移动数据,其中有一个必须是管道,主要是利用管道的在内核中缓冲区暂存数据,函数接口如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> splice(<span class="keyword">int</span> fd_in,<span class="keyword">loff_t</span>* off_in,in fd_out, <span class="keyword">loff_t</span>* off_out,</div><div class="line">  <span class="keyword">size_t</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</div></pre></td></tr></table></figure></p>
<p>splice用于在两个文件描述符之间移动数据， 也是零拷贝。fd_in参数是待输入描述符。如果它是一个管道文件描述符，则off_in必须设置为NULL；否则off_in表示从输入数据流的何处开读取，此时若为NULL，则从输入数据流的当前偏移位置读入。fd_out/off_out与上述相同，不过是用于输出。len参数指定移动数据的长度。flags参数则控制数据如何移动：</p>
<ul>
<li>SPLICE_F_NONBLOCK：splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞。</li>
<li>SPLICE_F_MORE：告知操作系统内核下一个 splice 系统调用将会有更多的数据传来。</li>
<li>SPLICE_F_MOVE：如果输出是文件，这个值则会使得操作系统内核尝试从输入管道缓冲区直接将数据读入到输出地址空间，这个数据传输过程没有任何数据拷贝操作发生。</li>
</ul>
<p>所以可以想象以下两个使用场景:</p>
<ol>
<li>回显服务器 从socket读入数据,并用splice函数输出到管道的写端;然后从管道的读端用splice函数输出到socket,实现回显服务器.</li>
<li>文件拷贝 从一个磁盘文件读取数据,用splice函数输出到管道的写端;然后从管道的读端用splice函数输出到另外一个磁盘文件.</li>
</ol>
<p>使用方法大概如下:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这是测试示例主要部分</span></div><div class="line">  int pipefd[2];               </div><div class="line">  <span class="keyword">ret</span> = pipe(pipefd);  <span class="comment">//创建管道  </span></div><div class="line">  <span class="keyword">assert</span>(<span class="keyword">ret</span> != -1);  </div><div class="line">  <span class="comment">//将connfd上的客户端数据定向到管道中  </span></div><div class="line">  <span class="keyword">ret</span> = splice(connfd, NULL, pipefd[1], NULL,  </div><div class="line">                32768, SPLICE_F_MORE | SPLICE_F_MOVE);  </div><div class="line">  <span class="keyword">assert</span>(<span class="keyword">ret</span> != -1);  </div><div class="line">  <span class="comment">//将管道的输出定向到connfd上  </span></div><div class="line">  <span class="keyword">ret</span> = splice(pipefd[0], NULL, connfd, NULL,  </div><div class="line">                32768, SPLICE_F_MORE | SPLICE_F_MOVE);  </div><div class="line">  <span class="keyword">assert</span>(<span class="keyword">ret</span> != -1);</div></pre></td></tr></table></figure></p>
<p>从代码中可以看出没有使用到任何缓冲区,因为数据都是在内核实现了传递或者零传递,只是更改缓冲区的指针.</p>
<h2>tee函数</h2>
<p>tee函数是在两个管道文件描述符之间复制数据,也是零拷贝数据;因为只是从源管道复制到另外管道,所以原管道中保存的数据仍然可以用于后续操作,例如可以重定向到其他文件描述符;函数接口如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> tee(<span class="keyword">int</span> fdin, <span class="keyword">int</span> fdout, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</div></pre></td></tr></table></figure></p>
<p>fdin参数：待读取数据的文件描述符。fdout参数：待写入数据的文件描述符。len参数：表示复制的数据的长度。flags参数：同splice( )函数。fdin和fdout必须都是管道文件描述符。</p>
<p>返回值&gt;0：表示复制的字节数。返回0：表示没有复制任何数据。返回-1：表示失败，并设置errno。</p>
<p>这个函数的使用场景在我认知范围内,估计就是实现tee命令,可以实现将输入的数据输出到标准输出,同时输出到某个文件.基本使用方法如下:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int fd1 = open(<span class="string">"./1.txt"</span>, O_RDONLY);</div><div class="line">int fd2 = open(<span class="string">"./2.txt"</span>, O_RDWR| O_CREAT | O_TRUNC, <span class="number">0666</span>);</div><div class="line">int fd3 = open(<span class="string">"./3.txt"</span>, O_RDWR| O_CREAT | O_TRUNC, <span class="number">0666</span>);</div><div class="line"><span class="comment">/*用于向"./2.txt"输入数据*/</span></div><div class="line">int pipefd2[<span class="number">2</span>];</div><div class="line"><span class="comment">/*用于向"./3.txt"输入数据*/</span></div><div class="line">int pipefd3[<span class="number">2</span>];</div><div class="line">pipe(pipefd2);</div><div class="line">pipe(pipefd3);</div><div class="line"><span class="comment">/*将fd1文件的内容输入管道pipefd2中*/</span></div><div class="line">splice(fd1, NULL, pipefd2[<span class="number">1</span>], NULL, <span class="number">10086</span>, SPLICE_F_MORE);</div><div class="line"><span class="comment">/*将管道pipefd2的内容复制到管道pipefd3中，不消耗管道pipefd2上的数据，管道pipefd2上的数据可以用于后续操作*/</span></div><div class="line">tee(pipefd2[<span class="number">0</span>], pipefd3[<span class="number">1</span>], <span class="number">10086</span>, SPLICE_F_NONBLOCK);</div><div class="line"><span class="comment">/*将管道pipefd2的内容写入fd2文件中*/</span></div><div class="line">splice(pipefd2[<span class="number">0</span>], NULL, fd2, NULL, <span class="number">10086</span>, SPLICE_F_MORE);</div><div class="line"><span class="comment">/*将管道pipefd3的内容写入fd3文件中*/</span></div><div class="line">splice(pipefd3[<span class="number">0</span>], NULL, fd3, NULL, <span class="number">10086</span>, SPLICE_F_MORE);</div></pre></td></tr></table></figure></p>
<p>这个程序是将fd1中的数据重定向到两个磁盘文件,而tee命令是将fd1的数据重定向到fd2和标准输出,即最后一行代码的fd3替换为STDOUT_FILENO.</p>
<p>那有人可能会问,最后一行代码为什么不能pipefd3[0],也就是两次都从管道pipefd2[0]读取数据? 我试着修改pipefd3[0]该pipefd2[0],会造成输出阻塞. 因为splice函数将pipefd2[0]的缓冲区数据消耗了,所以第二次在pipefd2[0]调用splice会因为无数据读入而阻塞.而因为tee不会消耗数据,所以tee函数之后,还可以继续使用splice从相同pipefd2[0]读取数据.</p>
<h1>统一事件源</h1>
<hr>
<p>这个是我看这本书最喜欢的设计,因为它打通了我之前在libevent理解上的阻塞.之前在memcache时,有大概看了下libevent的实现原理,因为时间事件和io读写事件和redis的mainae模块一样,很好理解,但是信号事件我始终想不明白是如何加入到事件处理的?这里又不得不表扬管道了,具体实现后面在说明.</p>
<p>服务器常见的有三种事件类型,IO读写事件,信号事件和时间事件,如果分别去监听这三种事件,那么代码将会非常复杂,而将这三种事件整合在一个事件源中,代码将会更加简洁,而且逻辑非常清楚.libevent就是这么做的.所以这里借助libevent来分析如何将三种事件整合在一起,参考资料为张亮的 <strong>libevent 源码深度剖析</strong>,我上传到我的github,有需要可以下载看<a href="https://github.com/luodw/Material/blob/master/libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90.pdf" target="_blank" rel="external">libevent源码剖析下载地址</a></p>
<p>libevent是一个轻量级的开源高性能网络库,底层支持多种I/O多路复用技术,epoll,poll,dev/poll,select和kqueue等,同时还支持定时器和信号事件;先看下libevent的整体框架
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0041.png" alt="libevent整体框架" title=" "></p>
<p>一开始,应用程序定义事件,可以是io读写事件,信号事件或者时间事件;定义好之后,接下来将事件放在各自的等待链表中;io读写事件和信号事件放在链表中,时间事件放在最小堆中.当io多路复用调用时间超时时,再检查每个事件,看是否就绪,例如可读可写事件是否可读可写,是否产生信号事件以及时间事件是否到期,并将所有就绪的事件放入就绪链表中,最后按优先级执行每个事件的事件处理函数.</p>
<p>了解了libevent执行过程之后,再来分析libevent是如何将三种事件整合在一起的.</p>
<ol>
<li>IO读写事件 因为libevent底层支持多种IO多路复用技术,以epoll为例,当我们定义个IO事件时,将IO事件的fd可读事件注册到epoll调用中;当客户端给服务器发送数据之后,触发服务器可读事件,服务器读取客户端的数据,并且经过业务逻辑处理之后,将数据放入输出缓冲区,并在fd上注册一个可写事件;在下一次事件循环中,检测到可写事件,最后执行可写事件的处理函数将数据发送给客户端.这就是libevent处理IO事件的过程.</li>
<li>时间事件 libevent用最小堆来管理时间事件,每次从堆中取出的时间事件是事件到期时间离当前最近的时间点. 如果epoll每次的超时时间都采用堆的根元素到期时间,那么epoll超时时间到期之后,最小堆的根元素事件肯定也到期了,在处理完IO事件之后,即可处理根元素时间事件,而且必须处理诺干个最小到期时间事件,直到到期时间在当前时间之后. 因为IO事件可能比较耗时,所以除了堆顶时间外,其他时间事件可能也到期了.这样就把时间事件和IO事件整合到一块了.</li>
<li>信号事件 libevent整合信号事件是最出彩的地方, 采用的方法如下:在主线程定义一对管道,然后将管道的读端注册到io多路复用的可读事件;当产生某个信号时,在信号处理函数中,往这对管道的写端写入这个信号的数值,这样即可触发管道读端的可读事件;然后在IO多路复用超时之后,根据不同的信号,执行不同的函数. 这样就可以把信号事件整合在IO事件中.</li>
</ol>
<p>一开始接触管道的时候,并没有发现管道是如此的神器; 我们在linux下遇到最多的就是磁盘文件描述符,socket描述符和管道描述符,而管道描述符属于最灵活,即可以作为其他两者的连接桥梁,如上述的splice函数,还可以作为进程间通信以及将信号事件整合IO事件中等等.</p>
<h1>多进程/多线程并发模式</h1>
<hr>
<p>服务器端编程三大模型,redis的单进程模型,memcache的单进程多线程模型和nginx的多进程模型.由于我看过redis,memcache源码,我对前两者模型很熟悉;而nginx源码我没看过,也没认真区研究nginx,所以对多进程模型也是一知半解; <strong>Linux服务器高性能编程</strong> 举出一个多进程通用模式,看完之后,我对这种模型有了一定的了解.</p>
<h2>多线程并发模式</h2>
<p>书本中列出多线程的两种模式,半同步半异步反应堆模式;下图是该模式的示意图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0042.png" alt="半同步半异步反应堆模式" title=" ">
该模式的主线程负责监听所有socket,包括listenfd和客户端fd.当客户端给服务器发送数据时,主线程将客户端的fd以及客户端的元数据打包成任务对象放入请求队列,然后工作线程同步的从请求队列中获取任务对象,并且处理任务对象逻辑.因为多个线程会从工作队列中争夺任务对象,所以工作队列必须加锁以保持同步.这种模式的客户端是无状态的,因为同一个连接上的不同请求可能会由不同的线程处理.</p>
<p>高性能半同步半异步模式,这也是memcache采用的多线程模式,下图是该模式的示意图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0052.png" alt="高性能半同步半异步模式">
该模式的主线程主要负责监听listenfd,当有客户端连接到服务器时,主线程accept这个客户端socket,然后将这个socket放入工作线程的libevent的实例中,从此就由这个libevent实例来负责这个客户端socket的事件处理.</p>
<p>那么怎么通知工作线程什么时候去接收这个socket? 这时又是管道的功劳.每个工作线程都定义一对管道,工作线程监听管道的读端; 当有客户端连接时,主线程向管道的写端写入一个字符,触发工作线程的可写事件,这样工作线程就可以执行管道读端的事件处理函数,在函数中接收这个socket并为这个socket注册一个可读事件,从此以后,这个客户端就由这个工作线程监听处理.</p>
<h2>多进程模式</h2>
<p><strong>Linux服务器高性能编程</strong> 书中实现的多进程模型如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0062.png" alt="多进程编程模型">
主进程和工作进程利用管道来进行通信,工作进程注册管道的可读事件; 二者同时监听listanfd,也就是说如果有客户端连接的话,主进程和工作进程都能触发可读事件,也就是惊群现象. 但是主进程并不接收客户端socket,而是通过轮询的方式选择一个工作进程来接收这个客户端,并向这个工作进程管道的写端写入一个标志,触发工作进程的可读事件,在管道读事件的处理函数中,工作进程接收这个客户端. 之后这个客户端与服务器的通信就由这个工作进程负责监听. 所以这种模式的主进程主要起负载均衡作用,所有任务主要是由工作进程负责.</p>
<p>对多进程的理解,必须对fork系统调用以及copy on write机制有足够的理解,因为主进程和工作进程间有共享的部分listenfd也有各自独享部分.</p>
<h1>总结</h1>
<hr>
<p>如果想从事后台开发,了解常用的开发框架是很有必要的,因为对于理解后台软件web服务器或者数据库很有帮助.而且我发现多进程比较适合web服务器,多线程比较适合数据库.因为数据库需要在同一块内存中存储数据,由于多线程并发处理内存数据,而多进程的每个进程内存空间是隔离的,每个进程处理数据导致会导致多份数据;而web数据库主要是接收客户端请求并返回网页,每个客户端对网页的请求相互独立,所以适合多进程模型.</p>
<p>这本书对后台知识讲解归纳的很到位,可以对后台开发有个整体的认识,有linux基础之后,推荐读读...</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写MyDB收获的经验和遇到的坑]]></title>
      <url>http://luodw.cc/2016/04/09/mydb/</url>
      <content type="html"><![CDATA[<p>之前在用C++写NoSQL时,收获了一些经验也遇到了一些坑;今天想总结下这些经验和坑,避免以后重走弯路;mydb github地址为:<a href="https://github.com/luodw/MyDB" target="_blank" rel="external">https://github.com/luodw/MyDB</a></p>
<h1>为什么要写NoSQL?</h1>
<hr>
<p>首先说明下为什么要写这个NoSQL了.因为研一开始,我就给自己定下了三步走计划,操作系统+编程语言+开源软件;因为了所有软件都是用某种编程语言编写,运行在某个操作系统之上,所以先学好操作系统特别关键,我推荐的是linux系统;</p>
<p>操作系统要学哪些了?我当初是从基本的linxu命令开始,书本推荐的是<strong>Linux Shell脚本攻略</strong>和<strong>鸟哥的私房菜</strong>;然后看关于系统调用的书籍,如果是C++后台编程,系统调用是免不了的,入门级看,<strong>LINUX系统编程</strong>,然后才是apue和unp1,2.不推荐直接apue,过来人的忠告.最后看内核的东西,这是必须看的,否则对linux很多东西是理解不透彻.例如平时用的管道,了解管道是怎么实现的吗(pipefs)?fork子进程copy on write机制是什么?动态链接库是怎么实现的等等;理解这些原理,对实际的应用非常有帮助,可以说是得心应手;我推荐的书是<strong>Linux内核设计与实现</strong>,还有本厚的<strong>深入理解Linux内核</strong>,我看了部分.还有<a href="http://duartes.org/gustavo/blog/archives/" target="_blank" rel="external">Gustavo Duarte的博客</a>和<a href="https://pdos.csail.mit.edu/6.828/2008/readings/i386/toc.htm" target="_blank" rel="external">Intel 80386编程手册</a>,内核主要研究的就是文件系统,内存管理(虚拟地址和物理地址的映射非常重要,很多东西的理解都需要这块知识),进程调度,网络模块;</p>
<p>编程语言,我选择的是C/C++;主要是这两门语言接近底层,可以控制内存,可以给用户编程极大的灵活性;就像当初选择linux编程学习而不是window一样;<strong>C++primer</strong> ,<strong>深入理解C++对象模型</strong>和<strong>STL源码剖析</strong>没看完这三本书,真得不敢说自己会C++.我不多说这个,看了都说好.</p>
<p>还有开源软件,我目前有看源码的是leveldb,memcache和redis大部分;我推荐的就是这三个.leveldb整体的设计中包含了很多学习的亮点:内存池arena,缓存的设计,内存屏障,迭代器的设计等等;memcache学习的亮点最重要的就是多线程下的编程模型,当然还有slab内存池;redis这个真推荐,这是我觉得这三个框架里面,代码写的最优雅,思路最清晰,高度模块化；底层用C with class写，而且都是多态类型；事件驱动模块mainae(libevent针对不同平台的封装，代码量太长)，还有主从复制原理，心跳机制等等，看redis收获非常大．</p>
<p>之前在知乎上看到陈硕大哥说的一句话：单进程单线程编程模型的巅峰是redis；单进程多线程编程模型的巅峰是memcache；多进程编程模型的ngnix；说的还是有点道理的；</p>
<p>现在要说下为什么写NoSQL了．因为之前提到的都是看书得到，但是没有实战，很多东西理解的不够透彻；就像没有装个linux双系统来学习，命令很快就忘了．所以我必须将我所学的理论知识，通过实践转化为自己的能力；当然实践会遇到很多问题，这就需要记录下来，避免重蹈覆辙；</p>
<h1>一些经验</h1>
<hr>
<ol>
<li>使用C++11的function类来实现回调函数声明．一开始时，我在纳闷，C++怎么实现回调函数，用函数指针吧，感觉没脱离C的影子；用函数对象吧，感觉挺麻烦的，啥事都要写个类，所以最后选择了C++11function类；而且function类可以结合bind函数以及lambda函数非常灵活实用，我在给事件注册回调函数时，使用的就是lambda函数注册．</li>
<li>使用nocopyable类来实现避免函数复制，这在**Effective C++**中也有提及，就是定义一个类，将复制构造函数和赋值操作符声明为private，其他类继承nocopyable即可实现避免函数复制；在C++11中可以使用=delete来实现类避免复制．</li>
<li>使用C++ string而不是c字符数组．因为string使用的是copy on write机制，每次复制时，只是简单的复制成员变量，并没有重新开辟一块内存，而是当要更新字符串时，才重新分配内存，达到复制时间复杂度为常数时间．而且不用担心内存泄露(暂时没考虑return或者sigjmp造成的对象没有析构问题，即使有还可以使用智能指针)．相反，使用c字符数组时时都要想着内存有没释放，啥时释放；
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clients[connfd].outbuf=<span class="type">string</span>(<span class="string">"usage:del key\r<span class="subst">\n</span>"</span>);</div></pre></td></tr></table></figure></li>
</ol>
<p>单看这行代码，等号右边生成一个临时string对象，然后左边的字符串调用赋值操作符，用右边临时字符串给自己赋值．而output并没有为字符串重新开辟内存，而是接管了临时string对象的字符串指针，临时string在这句代码之后就被回收了．而且之后每次给clients[connfd].outbuf赋值时，会先析构原先的字符串，然后才是指向新的字符串，所以不存在内存泄露的问题．</p>
<ol start="4">
<li>避免vector类型复制(赋值)．当vector存储大量拥有nontrival构造函数对象时，如果vector进行复制或赋值，那么每个对象都要执行构造函数生成对象，将会是非常耗时．所以一般采取的办法是先生成一个新的空的vector，然后新的空的vector调用swap函数与旧的vector进行交换，这样就可以避免新的vector存储对象执行构造函数，也可避免旧的vector存储的对象执行析构函数．如果是情况一个vector，也很适合用swap函数；</li>
<li>在不需要排序的情况，尽量使用unordered_map，而不是map．因为unordered_map底层是用哈希表实现的，负载因子和哈希函数设计的好，则可实现查找操作在常数时间以内，而map底层是红黑树实现的，查找操作则需要O(logn)．</li>
<li>STL函数库和lambda函数二者的集合，代码更加简练；原先为了输出一个vector中所有的变量，需要写一个输出仿函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> output</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>&#125;;</div><div class="line">    for_each(v.begin(),v.end(),output());</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>但是C++11引入lambda函数之后，代码如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>&#125;;</div><div class="line">    for_each(v.begin(),v.end(),[](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有很多太细微的经验没列出来，而且我发现我在使用过程中，C++11真的带来了很多优秀的特性，给代码编写带来极大的便利．</p>
<h1>一些坑</h1>
<hr>
<p>说是一些坑，但是我映像最深的还是segmentation fault (core dumped)，太可怕了，因为其他很多系统调用返回的错误，可以通过函数的返回值判断错误的类型，但是出现段错误之后，就直接退出了，经常是不好看出到底是哪行出现问题；我在写MyDB过程中，出现最多的就是段错误，不外乎就是内存访问错误，包括没有给数组分配内存，就访问更新数组元素；访问越界数组元素等等；</p>
<p>数组没有分配内存，程序访问数组元素；例如原先我在定义Client这个结构时，没有给参数数组分配内存，因为后面在分解参数时，需要将每个参数赋给参数数组，就必须访问参数数组，这样就出现段错误了．
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Client</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> fd;<span class="comment">//这个客户端的fd</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> outbuf;<span class="comment">//存储回复客户端的数据</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;<span class="comment">//存储用户输入的命令</span></div><div class="line">    &#125;;<span class="comment">//客户端结构体</span></div></pre></td></tr></table></figure></p>
<p>因为目前暂时还不需要客户端对象执行函数，所以暂时使用了struct．结构体中的args只是调用默认构造函数，此时不含有任何对象；当解析出各个命令参数，使用索引下标存储时，则出现了段错误,如下：
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  mydb ./mydb</div><div class="line">2016-04-10 15:47:16 360 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=240 [TRACE] Ionet: mydb init successfully!</div><div class="line">2016-04-10 15:47:18 360 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=173 [TRACE] Ionet: Accept a clientfd=5</div><div class="line">[1]    360 segmentation fault (core dumped)  ./mydb</div></pre></td></tr></table></figure></p>
<p>而且错误提示很不友好，只是说明了出现了段错误，并没有具体指出哪出现问题了．所以调试代码也是一项能力，我原本对于小型的程序习惯用输出即可解决，但是对于大点的程序，逻辑稍微复杂点，输出调试就没那么简单了，所以这时就必须使用gdb了．</p>
<p>我用gdb运行程序，然后出现错误之后，输出如下:
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(gdb) r</div><div class="line">Starting <span class="string">program:</span> <span class="regexp">/home/</span>charles<span class="regexp">/mydir/</span>mywork<span class="regexp">/mydb/</span>mydb </div><div class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2638</span> .<span class="regexp">/net/</span>Ionet.cc line=<span class="number">240</span> [TRACE] <span class="string">Ionet:</span> mydb init successfully!</div><div class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">05</span> <span class="number">2638</span> .<span class="regexp">/net/</span>Ionet.cc line=<span class="number">173</span> [TRACE] <span class="string">Ionet:</span> Accept a clientfd=<span class="number">5</span></div><div class="line"></div><div class="line">Program received signal SIGSEGV, Segmentation fault.</div><div class="line"><span class="number">0x00007ffff7b8f7e0</span> <span class="keyword">in</span> <span class="string">std:</span>:<span class="string">string:</span>:swap(<span class="string">std:</span>:string&amp;) () from <span class="regexp">/usr/</span>lib<span class="regexp">/x86_64-linux-gnu/</span>libstdc++.so<span class="number">.6</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>看吧，这样虽然看出来是什么段错误，调用std::string::swap(std::string&amp;)函数出现了错误，我们可以猜测是由于std::string对象在调用swap函数时，原对象没有分配内存，但是从gdb目前提示的错误还看不出问题具体出在哪．</p>
<p>所以这时就需要用到where或bt命令，输出调用的函数栈，可以看出问题出现在哪个函数调用上，如下:
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(gdb) bt</div><div class="line">#<span class="number">0</span>  <span class="number">0x00007ffff7b8f7e0</span> <span class="keyword">in</span> std::string::swap(std::string&amp;) () <span class="keyword">from</span> /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007ffff7b8f829</span> <span class="keyword">in</span> std::string::operator=(std::string&amp;&amp;) ()</div><div class="line">   <span class="keyword">from</span> /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004101a5</span> <span class="keyword">in</span> ionet::Parse::parseArgs(ionet::Client&amp;) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x0000000000408b13</span> <span class="keyword">in</span> ionet::Ionet::FdHandler(int) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x000000000040bcb1</span> <span class="keyword">in</span> ionet::Ionet::FdAccept(int)::$_2::operator()(int) const ()</div><div class="line">#<span class="number">5</span>  <span class="number">0x000000000040ba33</span> <span class="keyword">in</span> std::_Function_handler&lt;void (int), ionet::Ionet::FdAccept(int)::$_2&gt;::_M_invoke(std::_Any_data const&amp;, int) ()</div><div class="line">#<span class="number">6</span>  <span class="number">0x000000000040821c</span> <span class="keyword">in</span> std::function&lt;void (int)&gt;::operator()(int) const ()</div><div class="line">#<span class="number">7</span>  <span class="number">0x000000000040808a</span> <span class="keyword">in</span> ionet::Fdevent::handler(int) ()</div><div class="line">#<span class="number">8</span>  <span class="number">0x0000000000404751</span> <span class="keyword">in</span> ionet::EventLoop::startLoop() ()</div><div class="line">#<span class="number">9</span>  <span class="number">0x000000000040b53e</span> <span class="keyword">in</span> ionet::Ionet::run() ()</div><div class="line">#<span class="number">10</span> <span class="number">0x0000000000402670</span> <span class="keyword">in</span> main ()</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>这个输出从下到上是从最开始的main函数到出现问题的函数的函数栈．第0和第1个都是标准库string的成员函数，第2个才是我自己定义的函数，这样我就定位到错误出现的函数，我们定位到Parse::parseArgs这个函数
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void <span class="keyword">Parse</span>::parseArgs(Client &amp;client)</div><div class="line">    &#123;</div><div class="line">        int i=0; <span class="keyword">char</span> *q=<span class="keyword">query</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* delim=<span class="string">" "</span>;</div><div class="line">        <span class="keyword">char</span> *p=strtok(q,delim);</div><div class="line">        client.<span class="keyword">args</span>[i++]=<span class="built_in">string</span>(p);</div><div class="line">        <span class="comment">//strtok函数第二次调用时,必须传递NULL值,否则会无限迭代</span></div><div class="line">        <span class="keyword">while</span>((p=strtok(NULL,delim))!=NULL)</div><div class="line">        &#123;</div><div class="line">            client.<span class="keyword">args</span>[i++]=<span class="built_in">string</span>(p);</div><div class="line">        &#125;</div><div class="line">        i--;</div><div class="line">        size_t pos=client.<span class="keyword">args</span>[i].find(<span class="built_in">string</span>(<span class="string">"\r\n"</span>));</div><div class="line">        client.<span class="keyword">args</span>[i].<span class="keyword">erase</span>(pos);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>有之前的输出，我们知道错误是字符串的赋值错误，而在这个函数内部，就是给client.args参数数组赋值错误，所以我们可以把错误定位在这个client.args这个数组上，再结合段错误的一些原因，即可分析出错误的原因．</p>
<p>如果还是不知道错误，可以在这函数内部采用输出调试或者定点单步调试．</p>
<p>定点调试可以先定位到parse.cc这个文件
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.<span class="built_in">args</span>[i++]=<span class="built_in">string</span>(p);</div></pre></td></tr></table></figure></p>
<p>然后执行程序到此，可以输出client.args[i++]这个变量，看看得出什么结果．
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(gdb) b <span class="keyword">parse</span>.<span class="keyword">cc</span>:27 <span class="comment">//定位到赋值语句位置</span></div><div class="line">Breakpoint 1 at 0x40d9e1: <span class="keyword">file</span> ./util/<span class="keyword">parse</span>.<span class="keyword">cc</span>, <span class="keyword">line</span> 27.</div><div class="line">(gdb) <span class="built_in">r</span></div><div class="line">Starting <span class="keyword">program</span>: /home/charles/mydir/mywork/mydb/mydb </div><div class="line">2016-04-10 16:35:03 14443 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=240 [TRACE] Ionet: mydb init successfully!</div><div class="line">2016-04-10 16:35:07 14443 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=173 [TRACE] Ionet: Accept a clientfd=5</div><div class="line"></div><div class="line">Breakpoint 1, ionet::<span class="keyword">Parse</span>::parseArgs (this=0x7fffffffdd68, client=...) at ./util/<span class="keyword">parse</span>.<span class="keyword">cc</span>:27</div><div class="line">27	        client.<span class="keyword">args</span>[i++]=<span class="built_in">string</span>(p);</div><div class="line">(gdb)  p  client.<span class="keyword">args</span>[i++]</div><div class="line"><span class="variable">$1</span> = &lt;<span class="keyword">error</span> reading variable: Cannot access <span class="keyword">memory</span> at address 0x0&gt;</div><div class="line">(gdb) p client</div><div class="line"><span class="variable">$2</span> = (ionet::Client &amp;) @0x6183b0: &#123;fd = 5, outbuf = <span class="string">""</span>, <span class="keyword">args</span> = std::vector of length 0, capacity 0&#125;</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>当输出client.args[i++]时，输出的错误，没看过vector源码可能理解不是很清楚，我把源码黏贴如下:
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">const_reference</span> <span class="selector-tag">operator</span><span class="selector-attr">[]</span>(size_type n) <span class="selector-tag">const</span> &#123; <span class="selector-tag">return</span> *(begin() + n); &#125;</div><div class="line"><span class="comment">//========================================================================</span></div><div class="line"><span class="selector-tag">vector</span>() : <span class="selector-tag">start</span>(<span class="number">0</span>), <span class="selector-tag">finish</span>(<span class="number">0</span>), <span class="selector-tag">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>当调用clients.args[i++]时，会调用重载下标操作符函数，在重载下标函数内部，返回begin()迭代器向前移动n个位置元素的引用，而begin()返回是start迭代器，这个迭代器在没有参数的默认构造函数中初始为0，所以当输出client.args[i++]即输出start指向的值，就是位置0x0．</p>
<p>从输出client也可以看出args长度为0．</p>
<p>其他段错误也可以通过这种方法找出问题所在；如何调试段错误也是我写这篇文章最重要的原因，因为之前我对这不是很在行，所以需要记录下这过程，今后再出现段错误，可以快速解决问题．</p>
<h1>聊聊gdb原理</h1>
<hr>
<p>之前实习面试时，一位面试官问了我gdb设断点的原理，我一下懵了，因为我之前就是使用，没想过这个问题，这激发我极大的好奇心，我通过查找资料，发现gdb的实现主要是靠ptrace这个函数．简单的说gdb ./mydb时，会在gdb程序中fork和execl(./mydb)这个子进程，当我们设置断点时，其实是将原先设置断点处的指令替换为int 3指令，这样当进程运行到断点处时，会给gdb进程发送SIGTRAP信号，子进程则阻塞；父进程接收到此信号之后，则根据用户的输入，做出相应的回答．</p>
<p>ptrace这个系统调用还可以用来输出程序调用的系统调用，strace命令底层使用的就是这个系统调用．</p>
<p>ptrace还可以用来输出函数栈，pstack命令底层就是使用pstrace函数实现的，我之前还一直以为是backtrace函数实现的．但是回过头来想想，backtrace只是个函数，他必须嵌入到程序中才能输出函数栈，所以pstack底层不可能是backtrace函数实现．</p>
<p>理解了gdb的实现原理，再来使用gdb，会更加的得心应手...</p>
]]></content>
      
        <categories>
            
            <category> mydb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mydb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[innodb_ruby工具使用]]></title>
      <url>http://luodw.cc/2016/03/15/innodb03/</url>
      <content type="html"><![CDATA[<p>之前跟着Jeremy Cole的博客分析了单表空间的文件布局,这篇文章分析下如何使用innodb_ruby这个工具来分析.ibd表空间文件.</p>
<p>这个工具,可以自行到Jeremy Cole的github下载,他的github也有教如何安装使用.</p>
<h1>分析一个最小空表格</h1>
<hr>
<p>我在MySQL5.7.11建立了一个只有一个主键的表,然后没有插入任何数据,也就是说是一个空表格.我们可以使用space-page-type-regions模式来查看这个表空间的初始页类型
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-page-type-regions</div><div class="line">start       end         count       type                </div><div class="line"><span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           FSP_HDR             </div><div class="line"><span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>           IBUF_BITMAP         </div><div class="line"><span class="number">2</span>           <span class="number">2</span>           <span class="number">1</span>           INODE               </div><div class="line"><span class="number">3</span>           <span class="number">3</span>           <span class="number">1</span>           INDEX               </div><div class="line"><span class="number">4</span>           <span class="number">5</span>           <span class="number">2</span>           FREE (ALLOCATED)</div></pre></td></tr></table></figure></p>
<p>由这个输出可以看出,这个表分配了ibd文件的标准页:FSP_HDR,IBUF_BITMAP,INODE和空的root索引页.还有两个没有被使用的free页.</p>
<p>space-lists模式可以用来输出extent描述符和inode链表信息
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">free_frag           <span class="number">1</span>           <span class="number">0</span>           <span class="number">158</span>         <span class="number">0</span>           <span class="number">158</span>         </div><div class="line">full_frag           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full_inodes         <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">free_inodes         <span class="number">1</span>           <span class="number">2</span>           <span class="number">38</span>          <span class="number">2</span>           <span class="number">38</span></div></pre></td></tr></table></figure></p>
<p>初始化时,只有free_frag有extent描述符项,而且只有一个,即第一个extent,此时第一个extent为fragment extent,即该extent内的页是单独分配的.而且也只有一个INODE页.</p>
<p>free_frag里的内容可以使用space-list-iterate模式输出('#'表示页已被使用,'.'表示页是free)
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -L free_frag space-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">0</span>           ####..</div></pre></td></tr></table></figure></p>
<p>所有索引段的内存信息可以使用space-indexes模式来输出;
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-indexes</div><div class="line">id          name                            root        fseg        used        allocated   fill_factor </div><div class="line"><span class="number">409</span>                                         <span class="number">3</span>           internal    <span class="number">1</span>           <span class="number">1</span>           <span class="number">100.00</span>%     </div><div class="line"><span class="number">409</span>                                         <span class="number">3</span>           leaf        <span class="number">0</span>           <span class="number">0</span>           <span class="number">0.00</span>%</div></pre></td></tr></table></figure></p>
<p>因为只有一个主键索引,所以只有两个段internal和leaf.又因为是空数据库,所以只有一个空的root页,没有叶子节点页.</p>
<p>接下来可以使用index-fseg-internal-lists模式来输出主键索引的内部节点extent信息以及使用index-fseg-leaf-lists模式来输出主键索引叶子节点extent信息.
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-leaf-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>因为是一个空表,所以任何链表都为空.那么有人可能会问,主键的root页在哪了?其实这root就是在frag page里面.因为每个段优先使用INODE entry优先使用32个frag page,这32个页全部使用之后,才会申请整个extent.</p>
<p>我们可以用index-fseg-internal-frag-pages模式来分析这个段零碎页的使用情况:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-frag-pages</div><div class="line">page        index   level   data    free    records </div><div class="line"><span class="number">3</span>           <span class="number">409</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">16252</span>   <span class="number">0</span>     </div><div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-leaf-frag-pages</div><div class="line">page        index   level   data    free    records</div></pre></td></tr></table></figure></p>
<p>由上述输出可以看出,内部索引段使用了一个零碎页,而叶子段没有使用任何一个页.</p>
<h1>拥有一百万条记录的表</h1>
<hr>
<p>接下来,我向之前的空表插入100万条记录,插入记录时必须用事务,而且等全部插入之后才commit,否则会很慢.</p>
<p>我们先来看下space-page-type-regions的输出
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-page-type-regions</div><div class="line">start       end         count       type                </div><div class="line"><span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           FSP_HDR             </div><div class="line"><span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>           IBUF_BITMAP         </div><div class="line"><span class="number">2</span>           <span class="number">2</span>           <span class="number">1</span>           INODE               </div><div class="line"><span class="number">3</span>           <span class="number">37</span>          <span class="number">35</span>          INDEX               </div><div class="line"><span class="number">38</span>          <span class="number">63</span>          <span class="number">26</span>          FREE (ALLOCATED)    </div><div class="line"><span class="number">64</span>          <span class="number">1511</span>        <span class="number">1448</span>        INDEX               </div><div class="line"><span class="number">1512</span>        <span class="number">1663</span>        <span class="number">152</span>         FREE (ALLOCATED)</div></pre></td></tr></table></figure></p>
<p>我的这个输出和Jeremy Cole输出不一样,可能是5.7对底层页的使用进行了优化,没有那么多碎片.这100万条记录总共使用了35+1448个页;因为这个表的B+树有三层,一个root页,两个中间节点,其他都是叶子节点.所以对于内部节点段使用了3个零碎页,而叶子节点使用了32个零碎页,总共35个零碎页.剩下的26个页等需要时才会被使用.</p>
<p>我们再看下这个表空间的链表情况;
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">2</span>           <span class="number">0</span>           <span class="number">1118</span>        <span class="number">0</span>           <span class="number">1158</span>        </div><div class="line">free_frag           <span class="number">1</span>           <span class="number">0</span>           <span class="number">158</span>         <span class="number">0</span>           <span class="number">158</span>         </div><div class="line">full_frag           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full_inodes         <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">free_inodes         <span class="number">1</span>           <span class="number">2</span>           <span class="number">38</span>          <span class="number">2</span>           <span class="number">38</span></div></pre></td></tr></table></figure></p>
<p>可以看到还是只使用了一个fragment extent,以及分配了两个free extent.可以用space-list-iterate来显示是哪两个extents被分配free
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -L free space-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">1536</span>        ................................................................</div><div class="line"><span class="number">1600</span>        ................................................................</div></pre></td></tr></table></figure></p>
<p>我们可以看到最后之前space-page-type-regions最后输出的两个extent是free,完全没有被使用.同时可以使用space-list-iterate来输出free-frag信息
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -L free_frag space-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">0</span>           ######################################..........................</div></pre></td></tr></table></figure></p>
<p>接下来,在来看下这两个段各自使用页信息:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-indexes</div><div class="line">id          name                            root        fseg        used        allocated   fill_factor </div><div class="line"><span class="number">410</span>                                         <span class="number">3</span>           internal    <span class="number">3</span>           <span class="number">3</span>           <span class="number">100.00</span>%     </div><div class="line"><span class="number">410</span>                                         <span class="number">3</span>           leaf        <span class="number">1480</span>        <span class="number">1504</span>        <span class="number">98.40</span>%</div></pre></td></tr></table></figure></p>
<p>可以看出来,内部节点有三个,即root页以及两个中间页.最后叶子节点页分配了1504个页,使用了1480个页.</p>
<p>因为内部节点段只使用了3个页,所以并没有分配任何的extent,而是只使用了3个零碎页
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      </div><div class="line"><span class="comment">//-----------------------------------------------------------------------------------------------------------</span></div><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-frag-pages</div><div class="line">page        index   level   data    free    records </div><div class="line"><span class="number">3</span>           <span class="number">410</span>     <span class="number">2</span>       <span class="number">26</span>      <span class="number">16226</span>   <span class="number">2</span>       </div><div class="line"><span class="number">36</span>          <span class="number">410</span>     <span class="number">1</span>       <span class="number">7813</span>    <span class="number">8139</span>    <span class="number">601</span>     </div><div class="line"><span class="number">37</span>          <span class="number">410</span>     <span class="number">1</span>       <span class="number">11427</span>   <span class="number">4389</span>    <span class="number">879</span></div></pre></td></tr></table></figure></p>
<p>可以看出root页在page 3,中间两个页分别在page 36和page 37. 两个中间节点的子节点即为叶子节点的数量601+879=1480,等于上述space-indexes的输出.</p>
<p>而叶子节点不仅使用了32个零碎页,还使用了22个extents和一个未满的extent,如下:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-leaf-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">1</span>           <span class="number">0</span>           <span class="number">1078</span>        <span class="number">0</span>           <span class="number">1078</span>        </div><div class="line">full                <span class="number">22</span>          <span class="number">0</span>           <span class="number">198</span>         <span class="number">0</span>           <span class="number">1038</span></div></pre></td></tr></table></figure></p>
<p>我们还可以迭代输出这三个链表的每一个,例如输出未满的链表:
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> -L not_full index-fseg-leaf-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">1472</span>        ########################################........................</div></pre></td></tr></table></figure></p>
<p>这里只是跟着Jeremy简单的使用innodb_ruby工具,还有一些使用方法,这里就没列出了,在我的github上也有一个简要的教程.自己亲自用innodb_ruby来输出ibd文件,可以加深对文件结构的理解记忆.</p>
<p>下篇文章将会分析ibd文件中,最重要的索引页结构,记着,在ibd文件中,存储索引和数据的页都是索引页.</p>
]]></content>
      
        <categories>
            
            <category> innodb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> innodb </tag>
            
            <tag> innodb_ruby </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[innodb_ruby工具分析innob表空间文件Part-02]]></title>
      <url>http://luodw.cc/2016/03/15/innodb02/</url>
      <content type="html"><![CDATA[<p>上篇文章分析了系统表空间和单独表空间的文件结构，这篇文章主要分析单独表空间各个页具体的结构，以及InnoDB是如何管理这些页，区和段信息．在看这篇文章之前，必须有上篇文章的基础，否则很难理解这篇文章．</p>
<h1>Extent和extent描述符</h1>
<hr>
<p>上篇文章有说到，一个表空间被被分成了一个个16KB的页，然后64个连续页(1MB)又分为一组．InnoDB在固定的位置分配FSP_HDR和XDES来跟踪extents的使用情况以及extents内部页的使用情况．这些页的结构如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-FSP_HDR%20Page%20Overview.png" alt="FSP_HDR/XDES页结构"></p>
<p>该页有常规的FTL header和trailer，一个FSP header(这个后面分析)以及256个&quot;extent 描述符&quot;.这个extent描述符保存了这个extent页的使用情况；每个XDES Entry结构如下所示；
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-XDES%20Entry.png" alt="XDES Entry结构"></p>
<p>结构图中不同的域表示的意思如下:</p>
<ol>
<li>File Segment ID: 表示这个extent属于那个段，例如主键内部节点段，主键叶子节点段等．</li>
<li>List node for XDES list: 因为所有的XDES是由双向链表串起来的，所以这个域保存了当前extent 描述符的前一个和后一个描述符指针；</li>
<li>State: 表示这个extent的状态，目前InnoDB只定义了4个状态值:FREE,FREE_FARG,FULL_FARG和FSEG．FREE表示这个extent还没使用，可以用于分配；FREE_FARG表示这个extent属于fragment，即碎片页，而且这个extent有可用的页，每个段一开始时会先从fragment分配32个零散页，32个零散页使用完毕之后，才会分配一整个extent；FULL_FRAG表示这个fragment以使用完毕，没有可用的页；FSEG表示这个extent已经被分配给某个段，有File Segment ID指示;</li>
<li>Page State Bitmap: 这个域用来指示extent内每个页使用情况；每一个页使用2位，那么64个页有128位，16字节．第一位表示这个页是否可free，第二个位预留用来表示这个页是否clean(has no un-flushed data)，但是目前这个还没有被使用，始终设为1</li>
</ol>
<h1>List base nodes和list nodes</h1>
<hr>
<p>链表是一种连接多个相同数据类型的数据结构，为了适用于磁盘，InnoDB设计了如下链表数据类型:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-List%20Base%20Nodes.png" alt="链表数据类型">
这其实相当于链表的head节点，存储链表的长度，第一个节点和最后一个节点．这种base node一般是存储在高层的数据结构，真正的节点类型为
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-List%20Nodes.png" alt="链表节点类型">
节点类型保存了上一个页节点的number和偏移量以及下一个页的number和偏移量．</p>
<p>因为接下来经常会看到链表和节点，所以这里就先稍微介绍下；</p>
<h1>文件空间头和extent链表</h1>
<hr>
<p>FSP_HDR页(page 0)除了保存了256个extent描述符之外，还有一个FSP header，这也是FSP_HDR和XDES页的区别．FSP header拥有好几个链表，用来保存extent,fragment以及inode的使用情况:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-FSP%20Header.png" alt="FSP Header">
非链表属性域解释如下:</p>
<ol>
<li>Space id: 当前表空间的id</li>
<li>Highest page number in file(size): 当前表空间有效的最大page number，随着文件的增大而增大；这些页不一定全都初始化了，一些可能用0填充；</li>
<li>Highest page number initialized(free limit): 已经被初始化的最大页number，free limit永远小于等于上述size；</li>
<li>Flags: 这个表空间的一些标志；</li>
<li>Next Unused Segment ID:本表空间中下一个未使用的段ID．</li>
<li>Number of pages used in the FREE_FARG:这是一个优化，方便快速获取FREE_FRAG链表free页的数量，而不用去遍历链表；</li>
</ol>
<p>图中的list节点解释如下:</p>
<ol>
<li>FREE_FRAG:这个链表存储的是有free页的fragment extent(作为fragment使用的extent)．fragment extent是按页来分配使用的，例如包含FSP_HDR和XDES的extent将会被标记为fragment使用，之后如果有新建一个索引，那么这个索引段的32个碎片页就可以从这个FREE_FRAG链表中获取；</li>
<li>FULL_FRAG:这和FREE_FRAG类似，也是存储fragment extent，但是FULL_FRAG存储的是使用完毕，已经没有空闲页的fragment extent．如果在FREE_FARG中的fragment extent使用完毕，没有空闲页之后，会被移到FULL_FARG链表中；如果FULL_FARG链表中的fragment extent不再使用时，将会被释放；</li>
<li>FREE:完全还没被使用的extent，也就是说这个extent可以被分配给段(file segment,放置在恰当的INODE链表中)，也可以被移到到FREE_FARG链表中，页单独分配使用；</li>
</ol>
<p>FSP Header保存了一个表空间的最上层的元数据，即表空间可以使用的extents,可以的fragment extent,已满的fragment extent等等；当某个段(需要存储空间时)需要到FSP Header来分配可用的extents；</p>
<p>FSP Header保存的是整个extent的使用信息，而没有保存extent内部页的使用信息，因为每个extent描述符中有保存了该extent内部页的使用信息；</p>
<h1>段(file segments)和inodes</h1>
<hr>
<p>我之前就是被file segment这个概念给弄糊涂了．人家就是个段，还一定要加个file,如果之前没看<strong>InnoDB存储引擎</strong>还真的没法参透这个概念.INODE Pages是一种页类型,这个页拥有许多的INODE项.每个INODE entries描述了一个段(FSEG).INODE pages的文件结构如下所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-INODE%20Page%20Overview.png" alt="INODE页结构">
每个页有85个INODE Entry,也就是可以保存85个段信息;所以一个INODE页最多可以保存42个索引信息(一个索引使用两个段).如果表空间有超过42个索引,则必须再分配一个INODE页.下面可以解释在FSP_HDR结构中出现的两个关于INODE的链表</p>
<ol>
<li>FREE_INODES:一系列INODE页,这些INODE页至少有一个可用的INODE entry.</li>
<li>FULL_INODES:一些列INODE页,这些INODE页所有INODE entry已使用;在独立表中的,只有表的索引超过42个,FULL_INODES才会有一个元素.</li>
</ol>
<p>一个段INODE entry有如下格式:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-INODE%20Entry.png" alt="INODE Entry结构">
这个INODE entry非链表结构解释如下:</p>
<ol>
<li>FSEG ID:这个INODE entry描述的段ID,如果这个entry没有被使用,那么这个ID值为0.</li>
<li>Magic Number:魔数,表示这个段INODE entry被正常初始化;</li>
<li>Number of used pages in the NOT_FULL list:像FSP header中的FREE_FRAG,作为一种优化,保存在链表NOT_NULL链表中页使用数量;</li>
<li>Fragment Array:大小为32的页数组,保存单独从fragment extent分配的页.如果数组32个页已经全部使用完毕,那么接下来就必须分配整个extent.</li>
</ol>
<p>随着表的增长,段一开始现在fragment分配页,当32页满了之后,则必须转向分配整个extent</p>
<p>对于INODE entry中的链表结构,解释如下:</p>
<ol>
<li>FREE:分配给这个段且完全没有被使用的extents</li>
<li>NOT_FULL:分配给这个段的extent,且这个extent至少有一个页可以使用;如果这个extent全部页使用完毕,则这这个extent被移至FULL链表中.</li>
<li>FULL:这分配给这个段,且全部页都使用完毕的extent;如果有某个页变为可用,则被移至NOT_FULL链表中.</li>
</ol>
<h1>索引是如何使用段(file segments)</h1>
<hr>
<p>虽然索引页还没介绍,我们这可以先来看下索引页是怎么使用file segments.每个root索引页FSEG header包含了这个索引使用INODE entries(用于描述file segments)的指针;每个索引有一个B+树叶子节点段和非叶子节点段.这些信息保存在INDEX页的FSEG header.
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-FSEG%20Header.png" alt="FSEG Header结构">
Space id指向这个表空间的id,这个Page Number和Offset指向这个file segment的INODE entry.例如,一个新创建的表空间,唯一存在的索引页就是root页,也是一个叶子页.这个root存在于internal段,&quot;leaf&quot;段和fragment array暂时为空.</p>
<h1>把所有整在一起</h1>
<p>我们现在来看下单独表空间文件的整体布局:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-Index%20File%20Segment%20Structure.png" alt="Index File Segment Structure"></p>
<p>这个图很好展示了一个表空间的布局情况.我们从第四个页root页开始,在root页的FSEG Header中有保存着两个段leaf Inode(fseg_id=2)和Internal Inode(fseg_id=3).这两个段指向了INODE页中各自的Inode entry.两个Inode entry都有一个frag array指向单独分配的零碎的页和若干个extents,由链表串起来.最后由extent描述符来跟踪extent内的页的使用情况.</p>
<p>总结下,这篇文章主要就是介绍了单个表空间几个主要页的结构信息以及各个页结构之间的关系.接下来,继续跟着Jeremy Cole来演示下innodb_ruby是如何使用的.</p>
]]></content>
      
        <categories>
            
            <category> innodb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> innodb </tag>
            
            <tag> innodb_ruby </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[innodb_ruby工具分析innodb表空间文件Part-01]]></title>
      <url>http://luodw.cc/2016/03/14/innodb01/</url>
      <content type="html"><![CDATA[<p>一次偶然的机会进入一位谷歌工程师Jeremy Cole的博客<a href="http://blog.jcole.us/innodb/" target="_blank" rel="external">http://blog.jcole.us/innodb/</a>．该博客关于innodb一系列文章，我看之后获益匪浅，而且我第一次看时，由于不熟悉Jeremy的对变量的命名或者说是对innodb表空间文件的概念不是很熟，所以有点吃力，因此想通过博客记录下自己学习心得．</p>
<p>Jeremy自己开发了一个分析表空间的工具innodb_ruby(用ruby语言开发)，和<strong>MySQL技术内幕　InnoDB存储引擎</strong>中使用的py_innodb_page_info.py(用python语言开发)类似，主要是通过底层文件协议来解析表空间文件．Jeremy还上传了他用innodb_ruby解析表空间的各种图片示例．我将上述的两个开发工具和表空间的示例图上传到我的github上了，有需要可以到我github上下载<a href="https://github.com/luodw/Innodb" target="_blank" rel="external">https://github.com/luodw/Innodb</a></p>
<p>言归正传，接下来开始使用innodb_ruby工具以及配合Jeremy Cole博客来分析innodb表空间文件．</p>
<p>在MySQL5.5之前，所有数据默认是存储在共享表空间ibdata1中，但是可以通过innodb_file_per_table设置为每一个表一个文件．从MySQL5.6开始，已经默认使用一个表格一个表空间文件．我是更喜欢一表一文件形式，便于分析管理；</p>
<h1>关于表空间的一些基础知识</h1>
<hr>
<p>之前在看<strong>InnoDB存储引擎</strong>时，了解到一个表空间文件是由一个一个16kb大小的页组成，然后64页，刚好是1MB组成一个区(extent)，然后由若干个区组成了段．也就是说一个表空间是分段管理的，假如有一个表只有一个主键索引，那么这个表就有两个段，一个是内部节点段，即非叶子节点段，还有一个是叶子段，即存储数据的节点．如果一个表除了主键索引，还有一个辅助索引，那么这个这个表空间有四个段，主键内部节点段，主键叶子节点段，辅助索引内部节点段，辅助索引叶子节点段．<strong>InnoDB存储引擎</strong>有有一张图很好展示了段，区，页的关系:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_064.png" alt="InnoDB逻辑存储结构"></p>
<p>当然共享表空间ibdata和用户表空间是不一样的，因为它需要存储更多全局的一些信息，例如doublewrite,undo等等，所以共享表空间拥有更多的段，这篇文章先分析用户表空间．</p>
<p>每个表空间都有一个唯一space id，因为很多地方都需要使用到这个id，例如内存数据刷到磁盘时，需要使用这个space id来寻找表空间文件．InnoDB总有一个&quot;系统空间&quot;，即共享表空间，这个表系统表空间的space id始终为0．</p>
<h1>页空间结构</h1>
<hr>
<p>之前有说过，一个表空间文件被分为一个个16kb的页，每个页都有一个32位序号(page number)，通常称为偏移量，即离表空间初始位置的偏移量．因为每个页大小为16kb，所以第0个页的偏移量为0，第一个页的偏移量为16384等等．因为32位的最大值为2^32，所以一个表空间的最大值为2^32*16kb=64TB．</p>
<p>一个页的布局如下:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-Basic%20Page%20Overview.png" alt="InnoDB页布局"></p>
<p>每一个页都有一个38字节的FIL header和8字节的FIL trailer(FIL即为file缩写)，header结构有一个属性表明这个页是什么类型，而这个类型决定了页其他内容的结构，来看下FIL header和FIL trailer结构:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-FIL%20Header%20and%20Trailer.png" alt="FIL header和trailer结构图"></p>
<ol>
<li>Checksum为校验和，和磁盘打交道的程序为了保证数据正确性，都必须使用校验和，目的是验证因为磁盘空间损坏导致数据损坏；</li>
<li>offset(Page Number)为页的序号，即偏移量；</li>
<li>Previous Page和Next Page InnoDB的数据在内存缓冲区是由B+树组织的，而B+树中的每一层的页是由双向链表串起来，因为每个页header有指向上一个和下一个页的指针；这种结构可以提升全表扫描的效率；</li>
<li>LSN for last page modification　LSN如果不懂，可以查看<strong>InnoDB存储引擎</strong>这本书，简单说就是用于表示刷新到重做日志数据量，可用于重做日志恢复数据库.</li>
<li>Page Type 即页的类型，页的类型决定了这个页其他部分存储的数据，常见的页类型有数据业，undo页，系统页等等；</li>
<li>space id 即这个页属于的表空间</li>
<li>flush LSN 这个值存储了刷新到整个系统任何页的最大LSN值．</li>
</ol>
<h1>表空间结构</h1>
<hr>
<p>一个表空间文件是由一系列的页组成的，页数量最多可达2^32个．为了更好管理页，页又按1MB(64个连续的页)分为组，这个组称为区，InnoDB一般情况下是按区来给段分配空间．</p>
<p>为了管理表空间所有页，区以及表空间自己，Innodb必须使用一些数据结构来跟踪保存页区等信息，下图展示了一个表空间的示意图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-Space%20File%20Overview.png" alt="表空间文件示意图"></p>
<p>每一个表空间的第一个页为FSP_HDR(file space header)页，这个页保存了FSP header结构，这个结构保存了这个表空间的大小，以及完全没有被使用的extents，fragment的使用情况，以及inode使用情况等等，后面再详细介绍．</p>
<p>第1个页只能保存256个extents，也就是16384个页，256MB．因此每隔16384个页必须分配一个页来保存接下来的16384个页的信息，这个页就是XDES页，这个XDES页和第１个页除了FSP_HDR结构置0外，其他都一样．IBUF_BITMAP这个页就是插入缓存bitmap页，用于记录插入缓冲区的一些信息．</p>
<p>第三个页是inode页，该页用一个链表存储表空间中所有段(file segments)；之前说段是由若干个extents组成，其实段除了extents之外，还有32个单独分配的&quot;碎片&quot;页组成，因为有些段可能用不到一个区，所以这里主要是为了节省空间．</p>
<h1>共享表空间</h1>
<hr>
<p>共享表空间space id为0，包含了很多分配在固定偏移量上的页，用来存储和InnoDB操作相关的大量信息．系统表空间和其他空间一样，也有FSP_HDR,IBUF_BITMAP和INODE页，并且分配在前三个页，但是第四个页之后，和独立表空间就不太一样了
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-ibdata1%20File%20Overview.png" alt="共享表空间结构">
下面是分配的页:</p>
<ol>
<li>Page 3，type SYS:保存和插入缓存相关的信息</li>
<li>Page 4,type INDEX:插入缓存的索引结构的root页，插入缓存也是一个B+树；</li>
<li>Page 5,type TRX_SYS: 记录和InnoDB事务操作相关的信息，例如最近一次的事务id,MySQL二进制日志信息以及两次写缓冲区的位置信息；</li>
<li>Page 6,type SYS: 第一个回滚段(rollback segment)页，回滚段例外的页或者整个区当需要的时候才会被分配出来存储回滚段信息；</li>
<li>Page 7,type SYS: 存储和数据字典相关的信息，包含了数据字典中所有表格root页面的个数．当我们要访问数据字典表页时，就需要这些信息．</li>
<li>Pages 64-127: 第一个double write buffer页块（64块，即一个extent）．double write buffer是InnoDB的一个恢复机制；</li>
<li>Pages 128-191:double write buffer的第二个页块．</li>
</ol>
<p>系统表空间其他页则在索引，回滚段和undo logs等等需要时分配．</p>
<h1>单独表空间</h1>
<hr>
<p>这篇文章的最后一部分就是单独表空间．从MySQL5.6开始，默认就是一个表，一个表空间文件．以.ibd后缀的文件就是单独表空间文件，有如下结构
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IBD%20File%20Overview.png" alt="独立表空间"></p>
<p>单独表空间文件结构很简单，没有共享表空间存储数据类型种类多；前三个页分别是FSP_HDR,IBUF_BITMAP和INODE页，从第四个页开始存储索引页．在InnoDB中，B+树内部节点页和叶子节点页统称为索引页(index pages)．第四个页固定为主键的root页，其他页则可能是内部节点页，主键叶子节点，辅助索引root页，辅助索引内部节点页和辅助索引叶子节点页．</p>
<p>因为大部分InnoDB系统信息都保存在共享表空间中，所以单独表空间(per-table space)大部分都是type INDEX页保存表数据．</p>
<p>熟悉表空间的文件结构对于理解InnoDB缓冲区中的B+树很有帮助，第一次看MySQL B+结构时，我就没搞清楚叶子节点是怎么存储单条数据的（其实是一个页的数据）．后来看了<strong>InnoDB存储引擎</strong>才知道原来叶子节点保存的是记录集合，记录由单链表连在一起，查找到页之后，还需通过页目录定位到一部分数据，最后再便利这一小部分数据找到所需的数据．</p>
<p>这篇文章先大概介绍下单独表空间和系统表空间结构，接下来跟着大神Jeremy Cole的脚步，我们来分析下单独表空间具体页的结构信息．</p>
<p>感谢Jeremy Cole<a href="http://blog.jcole.us/innodb/" target="_blank" rel="external">http://blog.jcole.us/innodb/</a></p>
]]></content>
      
        <categories>
            
            <category> innodb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> innodb </tag>
            
            <tag> innodb_ruby </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL一些基础知识]]></title>
      <url>http://luodw.cc/2016/03/04/mysql-01/</url>
      <content type="html"><![CDATA[<p>最近在深入学习MySQL存储引擎innodb,使用书籍为**MySQL技术内幕(InnoDB存储引擎)**第二版;在学习过程中,由于有之前看NoSQL数据库的基础,学习比较快,但是也发现了一个问题,即show环境变量,到底什么时候是会话变量,什么时候是全局变量,以及'select+函数'怎么用等等;很多都是基础问题,虽然会用,但是总是迷迷糊糊,所以打算通过这篇文章记录下来,今后查找,也方便;</p>
<p>首先一开始,先介绍MySQL数据库的变量.MySQL数据库有四种变量,会话范围内的系统变量,全局范围内的系统变量,用户自定义变量和局部变量;</p>
<h1>变量</h1>
<p>在**MySQL技术内幕(InnoDB存储引擎)**这本书中,好多地方用到show variables like'pattern'\G;来查看系统变量,MySQL提供两种方法来设置系统变量.</p>
<p>第一种方法,使用set和select
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">设置系统变量:</div><div class="line"><span class="keyword">set</span> @@[<span class="keyword">session</span>|<span class="keyword">global</span>].变量名=值;  默认(没有指明session或者global)为session</div><div class="line">例如: <span class="keyword">set</span> @@session.sort_buffer_size=<span class="number">4000</span>;</div><div class="line"></div><div class="line">显示系统变量:</div><div class="line"><span class="keyword">select</span> @@[<span class="keyword">session</span>|<span class="keyword">global</span>].变量名  默认为<span class="keyword">session</span></div><div class="line">例如: <span class="keyword">select</span> @@session.sort_buffer_size\G;</div></pre></td></tr></table></figure></p>
<p>第二种方法,使用set和show,推荐使用这种方法,因为经常记不住变量名时,可以使用show来模糊查找变量名
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">设置系统变量:</div><div class="line"><span class="keyword">set</span> [<span class="keyword">session</span>|<span class="keyword">global</span>] 变量名=值  默认为<span class="keyword">session</span></div><div class="line">例如: <span class="keyword">set</span> <span class="keyword">session</span> sort_buffer_size=<span class="number">4000</span>;</div><div class="line"></div><div class="line">显示系统变量:</div><div class="line"><span class="keyword">show</span> [<span class="keyword">session</span>|<span class="keyword">global</span>] <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'pattern'</span>;</div><div class="line">例如: <span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sort_buffer_size'</span>\G;</div></pre></td></tr></table></figure></p>
<p>用户变量:即用户在MySQL客户端设置的变量,只有在当前连接有效,如果客户端重新连接,则之前设置的用户变量全部失效;可以如下设置用户变量:
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">设置用户变量:</div><div class="line"><span class="keyword">set</span> @变量名=值   或者<span class="keyword">select</span> @变量名:=值</div><div class="line">例如: <span class="keyword">set</span> @<span class="keyword">name</span>=<span class="string">'jason'</span>;  或者<span class="keyword">select</span> @<span class="keyword">name</span>:=<span class="string">'jason'</span>;</div><div class="line">显示用户变量:</div><div class="line"><span class="keyword">select</span> @变量名</div><div class="line">例如: <span class="keyword">select</span> @<span class="keyword">name</span>\G;</div></pre></td></tr></table></figure></p>
<p>局部变量即为在存储过程,函数或者触发器begin和end声明的变量,例如:
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">begin</span> </div><div class="line">    delcare <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="string">'hello world'</span>;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<h1>select和show使用情况</h1>
<p>第二个经常碰到的基础知识是select和show的使用,因为这两个在MySQL使用比较频繁,所以这里总结下使用情况:</p>
<p>一般使用show的情况是</p>
<ol>
<li>显示系统变量,正如上述所说</li>
<li>显示系统资源,例如
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">databases</span>\G;</div><div class="line"><span class="keyword">show</span> <span class="keyword">tables</span>\G;</div><div class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>\G;</div><div class="line"><span class="keyword">show</span> <span class="keyword">processlist</span>\G;</div><div class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>\G;</div><div class="line"><span class="keyword">show</span> <span class="keyword">function</span> <span class="keyword">status</span>\G;</div><div class="line">....等等</div></pre></td></tr></table></figure></li>
</ol>
<p>一般使用select的情况是</p>
<ol>
<li>显示系统和用户变量,如上述所说</li>
<li>用在查询语句中</li>
<li>后接函数,执行函数,经常使用的函数有:
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">select</span> <span class="title">database</span>(<span class="params"></span>)\G</span>;<span class="comment">//显示当前使用的数据库</span></div><div class="line"><span class="function"><span class="keyword">select</span> <span class="title">connection_id</span>(<span class="params"></span>)\G</span>;<span class="comment">//显示当前连接id</span></div><div class="line"><span class="function"><span class="keyword">select</span> <span class="title">user</span>(<span class="params"></span>)</span>;/<span class="function"><span class="keyword">select</span> <span class="title">system_user</span>(<span class="params"></span>)</span>; <span class="comment">//显示当前的登陆用户</span></div><div class="line"><span class="function"><span class="keyword">select</span> <span class="title">version</span>(<span class="params"></span>)</span>;<span class="comment">//显示当前MySQL的版本</span></div><div class="line">如果是显示innodb的版本,可以使用</div><div class="line"><span class="keyword">select</span> @@innodb_version</div></pre></td></tr></table></figure></li>
</ol>
<p>以上是我最近在使用过程中的一些基础知识总结,后续有,再补充...</p>
<ul>
<li></li>
</ul>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> innodb </tag>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb回顾之任务调度器]]></title>
      <url>http://luodw.cc/2016/02/27/leveldb-schedule/</url>
      <content type="html"><![CDATA[<p>今天偶然在浏览技术博客的时候,突然发现了leveldb原来还有一个很有意思的模块,即任务调度模块.leveldb任务调度模块,主要思想就是消费者与生产者.即任务调度器往任务队列添加任务,当后台没有任务调度时,调度器会从任务队列中取出第一个任务执行,即先进先出队列.</p>
<p>我们来源码看下,任务调度函数主要是:
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> PosixEnv::Schedule(<span class="keyword">void</span> (*<span class="function"><span class="keyword">function</span>)(<span class="params">void*</span>), <span class="title">void</span>* <span class="title">arg</span>) </span>&#123;</div><div class="line">  PthreadCall(<span class="string">"lock"</span>, pthread_mutex_lock(&amp;mu_));</div><div class="line">  <span class="comment">// 如果没有后台线程,则直接从任务队列中取出最后一个任务执行</span></div><div class="line">  <span class="keyword">if</span> (!started_bgthread_) &#123;</div><div class="line">    started_bgthread_ = <span class="literal">true</span>;</div><div class="line">    PthreadCall(</div><div class="line">        <span class="string">"create thread"</span>,</div><div class="line">        pthread_create(&amp;bgthread_, NULL,  &amp;PosixEnv::BGThreadWrapper, <span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 如果任务队列为空,则唤醒BGThread后台线程,因为即将往队列添加任务</span></div><div class="line">  <span class="keyword">if</span> (queue_.empty()) &#123;</div><div class="line">    PthreadCall(<span class="string">"signal"</span>, pthread_cond_signal(&amp;bgsignal_));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 任务添加进队列</span></div><div class="line">  queue_.push_back(BGItem());</div><div class="line">  queue_.back().function = <span class="function"><span class="keyword">function</span>;</span></div><div class="line">  <span class="title">queue_</span>.<span class="title">back</span>(<span class="params"></span>).<span class="title">arg</span> = <span class="title">arg</span>;</div><div class="line"></div><div class="line">  <span class="title">PthreadCall</span>(<span class="params"><span class="string">"unlock"</span>, pthread_mutex_unlock(&amp;mu_</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程函数&amp;PosixEnv::BGThreadWrapper其实就是BGThread函数的封装,在BGThread就函数中,先判断队列是否为空,如果是,则wait,等待被调度器唤醒.如果不为空,则取出第一个任务,执行:
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">void</span> PosixEnv::BGThread() &#123;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="comment">// Wait until there is an item that is ready to run</span></div><div class="line">    PthreadCall(<span class="string">"lock"</span>, pthread_mutex_lock(&amp;mu_));</div><div class="line">    <span class="keyword">while</span> (queue_.empty()) &#123;</div><div class="line">      PthreadCall(<span class="string">"wait"</span>, pthread_cond_wait(&amp;bgsignal_, &amp;mu_));</div><div class="line">    &#125;<span class="comment">//等待被唤醒</span></div><div class="line"></div><div class="line">    <span class="built_in">void</span> (*<span class="function"><span class="keyword">function</span>)(<span class="params"><span class="built_in">void</span>*</span>) = <span class="title">queue_</span>.<span class="title">front</span>(<span class="params"></span>).<span class="function"><span class="keyword">function</span></span>;</span></div><div class="line">    <span class="title">void</span>* <span class="title">arg</span> = <span class="title">queue_</span>.<span class="title">front</span>(<span class="params"></span>).<span class="title">arg</span>;</div><div class="line">    queue_.pop_front();<span class="comment">//弹出第一个任务</span></div><div class="line"></div><div class="line">    PthreadCall(<span class="string">"unlock"</span>, pthread_mutex_unlock(&amp;mu_));</div><div class="line">    (*<span class="function"><span class="keyword">function</span>)(<span class="params">arg</span>)</span>;<span class="comment">//执行任务函数</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个任务队列挺简单的,我写这个的目的了,是因为之前的生产者消费者模型队列主要是用于存储数据,而这次是用于存储任务函数指针,这是一个亮点,给了我对任务调度最初步的理解.</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CPU缓存L1和L2]]></title>
      <url>http://luodw.cc/2016/02/27/cpu-cache/</url>
      <content type="html"><![CDATA[<p>上篇文章分析了CPU如何向内存请求数据，我们也知道cpu请求的数据是先放到L1和L2缓存中，那么这篇文章来分析下cpu内部是如何组织访问缓存的．本科计算机体系结构课上有学过缓存的三种方式，全相连，直接相连，组相连．组相连是全相连和直接相连的折中，了解了组相连，其他两个也就很好理解了．这个博客分析的是36位地址总线，虽然现在是32位地址总线，但是不影响分析．</p>
<p>我还是以大神<a href="http://duartes.org/gustavo/blog/post/intel-cpu-caches/" target="_blank" rel="external">Gustavo Duarte</a>为基础，再加上一些自己的想法来写这篇文章．我们先上图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_061.png" alt="8路组相连">
l1 cache有32kb，８路组相连，总共有64行(64组)，每个缓存行为64byte．当cpu给出一个虚拟地址，然后经过TLB或者MMU转换成物理地址之后，</p>
<ol>
<li>其中的12-35位为物理页的标签，已4kb对齐，也就是以内存页对齐，那么24位总共有2^24个物理页，而每个物理页是4kb，所以总的物理内存为2^36=64G.</li>
<li>其中的11-6位的组索引，6位对应着64组．</li>
<li>最低6位为缓存行内寻址．每个缓存行为64b，所以需要6位进行寻址</li>
</ol>
<p>由图可知，每一路为64*6b=4kb，总共有８路，所有L1 cache有32kb总量．</p>
<p>当cpu给出一个逻辑地址，然后经过TLB或者MMU转换为物理地址之后，我们先通过组索引找到数据在哪一组；然后将给组的所有缓存行的标识位取出来和地址中的标志为比较，如果没有命中，则需要到主存中获取一块64字节的缓存行，存入L1中；如果命中，则通过最低6位定位缓存行中具体字节．如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_062.png" alt="cache命中"></p>
<p>而L2 cache缓存有4M，所以就不能和L1 cache缓存一样组织．在L2缓存中，缓存行的大小还是64b，但将组数增加到4096，然后路数增加到16路，这样以来，每一组就有16*64=1024b=1kb，总共有4096组，所以L2 cache有1kb*4096=4096kb=4M．</p>
<p>理解了组相连之后，我们先说下直接映射．对与直接映射，其实就是组相连的特例，将每一组的路数设为1，即1路组相连．这样当有相同的页映射到同一块缓存行时，之前缓存的数据必须被提出；而８路组相连可以缓存映射到同一组的8个缓存行，这样缓存行在缓存的时间会更长，更能利用局部性原理．
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_063.png" alt="三种缓存映射方式"></p>
<p>而全相连也是组相连的一种特例，即只有一组，然后这组有n路．这样一来，只要缓存有空间，任何安页对齐的64字节主存块都可以存储到缓存中．这样每次查找时，都要遍历所有的缓存行，一一匹配．</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cpu </tag>
            
            <tag> L1cache </tag>
            
            <tag> L2cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CPU访问物理内存]]></title>
      <url>http://luodw.cc/2016/02/25/cache/</url>
      <content type="html"><![CDATA[<p>有了之前linux内核对内存管理这块知识后,接下来,我想通过这篇文章分析下cpu如何获取内存数据以及如何缓存数据.在这里要感谢国外的一位大神<a href="http://duartes.org/gustavo/blog/archives/" target="_blank" rel="external">Gustavo Duarte</a>,我在一次偶然之间遇到了他的博客,然后学到了很多关于linux内核以及架构的知识,包括这篇文章.</p>
<p>我们在计算机体系结构课上有学过cpu在获取数据时,是先在cpu内的缓存中查找,如果缓存有,则无需到主存中获取数据;如果缓存没有数据,则需要先到主存获取数据,并存入cpu缓存中,然后从cpu缓存中将数据返回.这篇文章主要想说说这这个过程的具体执行情况.</p>
<p>先说下cpu中的缓存为什么比主存快?我当初想当然的以为是因为离的近,可能这是一方面(虽然影响微乎其微),最主要还是主存使用的态存储功能的存储器(DRAM),而缓存使用的是具有静态存取功能的存储器(SRAM).DRAM内存需要每隔一段时间刷新充电一次,否则内部数据会消失.而SRAM不需要刷新电路即能保存内部存储的数据,所以SRAM性能高于DRAM.StackExchange有一帖子也有关于SRAM比DRAM的原因<a href="http://superuser.com/questions/648370/why-is-sram-faster-than-dram" target="_blank" rel="external">Why is SRAM faster than DRAM?</a></p>
<p>在介绍之前,先看下CPU内部图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_056.png" alt="CPU内部图">
这是Intel Core 2 Duo Processor处理器,目前的处理器和这个相差不大,可能增加一个L3缓存或者增加核数,但不影响我们分析原理.</p>
<p>由图可知,cpu的两个核是统一的一个整体,每个核都有执行单元,指令获取解码单元以及32kb的数据和指令缓存.在CPU内部,核外有一个6M的L2缓存,是两个核共享的缓存.接下来是bus接口单元.在整个CPU外部,有775个引脚(pins),用于CPU外部和CPU内部传输数据,其中有一半是提供电,并不传输数据.如果按功能分的话,其中有三类重要的引脚,可以分为33个地址线引脚,64个数据线引脚以及请求控制线引脚,这些引脚涉及内存或IO端口操作,而这些操作发生在front side bus事务上下文中.</p>
<p>fsb(front side bus)事务有5个过程,仲裁(arbitration),请求(request),探测(snoop),回复(response),数据(data).在不同的过程中,FSB对于处理器和北桥(northbridge)扮演着不同的角色.在这里,我们只看下cpu请求过程,cpu请求过程,处理器将会发送两个包,两个包都是由地址总线引脚和请求总线引脚发出,我们来看下第一个包Packet A的所包含的信息:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_057.png" alt="请求包结构">
由第一张图可知,地址总线占有33个bits(35-3),其中2-0bits为0.因此这个cpu有36位地址总线,并且以8字节对齐,64G可寻址物理内存.而请求引脚的5个bits则解释了这次事务是什么类型,如下图.
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_058.png" alt="请求控制信息">
由这个图,可以知道cpu的这次事务可能为内存访问或者IO请求,取决于请求引脚5位包含的信息.</p>
<p>在第一个包发出之后的下一个bus clock cycle,在相同的引脚上,就发出了第二个包Packet B
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_059.png" alt="Packet B">
对于第二包,我们主要关注的是Attribute Signals这块内容,因为这影响着访问内存区域的缓存行为.将这块信息放入FSB,请求的agents就可以让其他处理器知道这次事务影响了他们的缓存以及内存控制器(northbridge)应该怎么处理.处理器通过查看页表决定访问的内存区域的类型.</p>
<p>通常内核将所有的内存看作是write-back,因为这有很好的性能.在这种模式下,cpu访问内存单元是一块内存行,在上图core 2中是64字节.如果一个进程需要读取一个字节的数据,那么处理器会将这个字节所在的64字节内存行载入L2和L1缓存中.当处理器需要向内存写数据时,也是先修改缓存中的数据,并未修改内存中的数据.之后,当必须将修改的数据写回主存时,那么整个缓存行会一次全部写进物理内存.下面图展示了处理器向内存读取数据的过程:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_060.png" alt="处理器向内存取数据过程">
Intel计算机中的一些物理内存是映射到设备的,例如硬盘和网卡.这就允许这些设备的驱动器通过读写这些内存来和设备进行交流.对于这些内存区域,内核在页表中标注为uncacheable不可缓存的,所以每次需要访问不可缓存的内存,即使每次都是一个字节,都必要到主存中访问,不能在L1或L2中缓存.对于每次读取一字节的,可以通过上述的Packet B的enable mask来设置.</p>
<p>上述原语有许多的含义,例如:</p>
<ol>
<li>对于性能敏感的应用程序尽量将相关联的数据打包在同一个cache行.这样一来,当这块内存行被载入缓存时,读取缓存行中的其他数据会更快,而且避免了额外的主存访问.例如C++的数组和vector在一定条件下会比list速度块,因为前者的数据是存储在线性空间,而后者是离散的.</li>
<li>任何的内存访问(假设这些访问都落在同一个缓存行中)都保证是原子的,这样的访问是通过处理器的L1缓存提供的而且数据的读或写都是同时完成的,不能被其他处理器或者线程影响.</li>
<li>front bus是所有处理器共享的,所以每个处理器在开始事务之前都需要仲裁谁获取front bus的控制权.而且所有的处理器必须监听所有的事务,为的是保证每个缓存的一致性.由于CPU向更多核发展,因此bus竞争将会是个很严重的问题.</li>
</ol>
<p>以上就是物理内存请求的重点,这在以后理解锁,多线程和缓存一致性有很大的帮助.</p>
<p>注：Frontside Bus(FSB)是计算机架构中一个重要的组件，允许CPU与不同的计算机系统资源交流．FSB连接了CPU和系统内存，input/output(I/O)外围设备以及其他一些主板组件．</p>
<p>上图中的northbridge就是连接内存和FSB组件，还有一个southbridge是连接IO设备和FSB的组件</p>
]]></content>
      
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> cache </tag>
            
            <tag> cpu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[malloc实现原理]]></title>
      <url>http://luodw.cc/2016/02/17/malloc/</url>
      <content type="html"><![CDATA[<h1>malloc的实现原理</h1>
<p>在开发c或c++时，经常需要分配内存，如今常用的分配内存函数为malloc,tcmalloc,jemalloc,其中属于malloc使用最平常，因为属于c标准库函数，但是网上有有实验证明另外两个效率比malloc高，这篇文章主要还是分析malloc，因为经常用到malloc来分配内存，而且大家也知道这malloc分配的内存是从堆中分配的。但是malloc到底是怎么实现的了？有了之前linux内存管理的基础，如今可以来分析下malloc是如何实现的。</p>
<p>linux系统向用户提供申请的内存有brk(sbrk)和mmap函数，我们就从这两个函数开始说起。首先再次给出linux进程的内存模型
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0172.png" alt="linux进程内存模型"></p>
<h1>brk()和sbrk()函数</h1>
<p>这两个函数的定义如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *addr )</span></span></div><div class="line"><span class="keyword">void</span>* <span class="title">sbrk</span> <span class="params">( <span class="keyword">intptr_t</span> incr )</span>;</div></pre></td></tr></table></figure></p>
<p>这两个函数的作用主要是扩展heap的上界brk。第一个函数的参数为设置的新的brk上界地址，如果成功返回0，失败返回-1。第二个函数的参数为需要申请的内存的大小，然后返回heap新的上界brk地址。如果sbrk的参数为0，则返回的为原来的brk地址。</p>
<h1>mmap函数</h1>
<p>mmap和munmap函数定义如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, size\<span class="keyword">_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, off\<span class="keyword">_t</span> offset)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</div></pre></td></tr></table></figure></p>
<p>mmap函数第一种用法是映射磁盘文件到内存中；而malloc使用的mmap函数的第二种用法，即匿名映射，匿名映射不映射磁盘文件，而是向映射区申请一块内存。munmap函数是用于释放内存，第一个参数为内存首地址，第二个参数为内存的长度。接下来看下mmap函数的参数。</p>
<ol>
<li>prot:期望的内存保护标志,不能与文件的打开模式冲突。是以下的某个值,可以通过 or 运算合理地组合在一起。PROT_EXEC(页内容可以被执行);PROT_READ(页内容可以被读取);PROT_WRITE(页可以被写入);PROT_NONE(页不可访问).</li>
<li>flags:指定映射对象的类型,映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体</li>
</ol>
<ul>
<li>MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</li>
<li>MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。</li>
<li>MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。</li>
<li>MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。</li>
<li>MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。</li>
</ul>
<ol start="3">
<li>fd为映射的文件，如果是匿名映射，可以设为-1；</li>
<li>offset为被映射文件内容的起点偏移；</li>
</ol>
<p>malloc函数使用MAP_ANONYMOUS匿名映射，length为申请内存块大小，返回内存块的首地址；</p>
<p>当申请小内存的时，malloc使用sbrk分配内存；当申请大内存时，使用mmap函数申请内存；但是这只是分配了虚拟内存，还没有映射到物理内存，当访问申请的内存时，才会因为缺页异常，内核分配物理内存。</p>
<h1>malloc实现原理</h1>
<h2>chunk简介</h2>
<p>由于brk/sbrk/mmap属于系统调用，如果每次申请内存，都调用这三个函数中的一个，那么每次都要产生系统调用开销，这是非常影响性能的；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果低地址的内存没有被释放，高地址的内存就不能被回收。</p>
<p>鉴于此，malloc采用的是内存池的实现方式，malloc内存池实现方式更类似于STL分配器和memcached的内存池，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。</p>
<p>malloc利用chunk结构来管理内存块，malloc就是由不同大小的chunk链表组成的。一个使用中的chunk的结构如下图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0173.png" alt="chunk格式">
malloc会给用户分配的空间的前后加上一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。chunk指针指向chunk开始的地方,图中的mem指针才是真正返回给用户的内存指针。</p>
<ol>
<li>chunk 的第二个域的最低一位为 P,它表示前一个块是否在使用中,P 为 0 则表示前一个 chunk 为空闲,这时chunk的第一个域 prev_size 才有效,prev_size 表示前一个 chunk 的 size,程序可以使用这个值来找到前一个 chunk 的开始地址。当 P 为 1 时,表示前一个 chunk 正在使用中,prev_size程序也就不可以得到前一个 chunk 的大小。不能对前一个 chunk 进行任何操作。malloc分配的第一个块总是将 P 设为 1,以防止程序引用到不存在的区域。</li>
<li>Chunk 的第二个域的倒数第二个位为 M,他表示当前 chunk 是从哪个内存区域获得的虚拟内存。M 为 1 表示该 chunk 是从 mmap 映射区域分配的,否则是从 heap 区域分配的。</li>
<li>Chunk 的第二个域倒数第三个位为 A,表示该 chunk 属于主分配区或者非主分配区,如果属于非主分配区,将该位置为 1,否则置为 0。</li>
</ol>
<p>以下图是一个空闲的chunk在内存中的结构:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0183.png" alt="空闲chunk">
当chunk空闲时，其M状态是不存在的，只有AP状态，原本是用户数据区的地方存储了四个指针，指针fd指向后一个空闲的chunk,而bk指向前一个空闲的chunk，malloc通过这两个指针将大小相近的chunk连成一个双向链表。在large bin中的空闲chunk，还有两个指针，fd_nextsize和bk_nextsize，用于加快在large bin中查找最近匹配的空闲chunk。不同的chunk链表又是通过bins或者fastbins来组织的。</p>
<h2>chunk容器bins</h2>
<p>malloc将内存分成了大小不同的chunk，然后通过bins来组织起来，先来看下bin结构:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0193.png" alt="bin结构">
malloc将相似大小的chunk用双向链表链接起来，这样一个链表被称为一个bin。malloc一共维护了128个bin，并使用一个数组来存储这些bin。数组中第一个为unsorted bin,数组从2开始编号，前64个bin为small bins，同一个small bin中的chunk具有相同的大小，两个相邻的small bin中的chunk大小相差8bytes。small bins后面的bin被称作large bins。large bins中的每一个bin分别包含了一个给定范围内的chunk，其中的chunk按大小序排列。large bin的每个bin相差64字节。</p>
<p>malloc除了有unsorted bin，small bin,large bin三个bin之外，还有一个fast bin。一般的情况是,程序在运行时会经常需要申请和释放一些较小的内存空间。当分配器合并了相邻的几个小的 chunk 之后,也许马上就会有另一个小块内存的请求,这样分配器又需要从大的空闲内存中切分出一块,这样无疑是比较低效的,故而,malloc 中在分配过程中引入了 fast bins,不大于 max_fast(默认值为 64B)的 chunk 被释放后,首先会被放到 fast bins中,fast bins 中的 chunk 并不改变它的使用标志 P。这样也就无法将它们合并,当需要给用户分配的 chunk 小于或等于 max_fast 时,malloc 首先会在 fast bins 中查找相应的空闲块,然后才会去查找 bins 中的空闲 chunk。在某个特定的时候,malloc 会遍历 fast bins 中的 chunk,17将相邻的空闲 chunk 进行合并,并将合并后的 chunk 加入 unsorted bin 中,然后再将 usorted bin 里的 chunk 加入 bins 中。</p>
<p>unsorted bin 的队列使用 bins 数组的第一个,如果被用户释放的 chunk 大于 max_fast,或者 fast bins 中的空闲 chunk 合并后,这些 chunk 首先会被放到 unsorted bin 队列中,在进行 malloc 操作的时候,如果在 fast bins 中没有找到合适的 chunk,则malloc 会先在 unsorted bin 中查找合适的空闲 chunk,然后才查找 bins。如果 unsorted bin 不能满足分配要求。 malloc便会将 unsorted bin 中的 chunk 加入 bins 中。然后再从 bins 中继续进行查找和分配过程。从这个过程可以看出来,unsorted bin 可以看做是 bins 的一个缓冲区,增加它只是为了加快分配的速度。</p>
<p>除了上述四种bins之外，malloc还有三种内存区。</p>
<ol>
<li>当fast bin和bins都不能满足内存需求时，malloc会设法在top chunk中分配一块内存给用户；top chunk为在mmap区域分配一块较大的空闲内存模拟sub-heap。</li>
<li>当chunk足够大，fast bin和bins都不能满足要求，甚至top chunk都不能满足时，malloc会从mmap来直接使用内存映射来将页映射到进程空间，这样的chunk释放时，直接解除映射，归还给操作系统。</li>
<li>Last remainder是另外一种特殊的chunk，就像top chunk和mmaped chunk一样，不会在任何bins中找到这种chunk。当需要分配一个small chunk,但在small bins中找不到合适的chunk，如果last remainder chunk的大小大于所需要的small chunk大小，last remainder chunk被分裂成两个chunk，其中一个chunk返回给用户，另一个chunk变成新的last remainder chunk。</li>
</ol>
<h1>malloc内存分配</h1>
<p>一开始时，brk和start_brk是相等的，这时实际heap大小为0；如果第一次用户请求的内存大小小于mmap分配阈值，则malloc会申请(chunk_size+128kb) align 4kb大小的空间作为初始的heap。初始化heap之后，第二次申请的内存如果还是小于mmap分配阈值时，malloc会先查找fast bins,如果不能找到匹配的chunk，则查找small bins。若还是不行，合并fast bins,把chunk 加入到unsorted bin，在unsorted bin中查找，若还是不行，把unsorted bin中的chunk全加入large bins中，并查找large bins。在fast bins和small bins中查找都需要精确匹配，而在large bins中查找时，则遵循&quot;smalest-first,best-fit&quot;的原则，不需要精确匹配。</p>
<p>若以上都失败了，malloc则会考虑使用top chunk。若top chunk也不能满足分配，且所需的chunk大小大于mmap分配阈值，则使用mmap进行分配。否则增加heap，增加top chunk，以满足分配要求。</p>
<p>以上内容大部分参考阿里华庭写的Glibc内存管理，Ptmalloc2源代码分析。</p>
]]></content>
      
        <categories>
            
            <category> libc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> malloc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux内存管理]]></title>
      <url>http://luodw.cc/2016/02/17/linux-memory/</url>
      <content type="html"><![CDATA[<h1>linux内核内存管理</h1>
<p>今天这篇文章主要是我之前看linux内核相关知识和博客<a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/" target="_blank" rel="external">Gustavo Duarte</a>中。我主要是看了这篇博客，并且结合之前的知识，对内存管理的的理解又上升了一个档次。所以想通过这篇文章总结下。</p>
<p>我们先来看下linux内存布局，此图比我之前写的那篇文章写的布局更详细
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_014.png" alt="linux进程内存布局">
在linux中，每一个进程都被抽象为task_struct结构体，称为进程描述符，存储着进程各方面的信息；例如打开的文件，信号以及内存等等；然后task_struct的一个属性mm_struct管理着进程的所有虚拟内存，称为内存描述符。在mm_struct结构体中，存储着进程各个内存段的开始以及结尾，如上图所示；这个进程使用的物理内存，即常驻内存RSS页数，这个内存使用的虚拟地址空间VSZ页数，还有这个进程虚拟内存区域集合和页表。</p>
<p>从上面这个图可以看出，进程是有代码段Text segment,数据段（已初始化的全局，静态变量），BSS段（未初始化的全局，静态变量），堆，内存映射区以及栈；</p>
<p>每一块虚拟内存区(VMA)都是由一块连续的虚拟地址组成，这些地址从不覆盖。一个vm_area_struct实例描述了一块内存区域，包括这块内存区域的开始以及结尾地址；flags标志决定了这块内存的访问权限和行为；vm_file决定这块内存是由哪个文件映射的，如果没有文件映射，则这块内存为匿名的(anonymous)。上述图中提到的每个内存段，都对应于一个vm_area_struct结构。如下图所示
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_015.png" alt="内存段vm_area_struct结构">
上图即为/bin/gonzo进程的内存布局。程序的二进制文件映射到代码段和数据段，代码段为只读只执行，不可更改；全局以及静态的未初始化的变量映射到BSS段，为匿名映射，堆和栈也是匿名映射，因为没有相应的文件映射；内存映射区可以映射共享库，映射文件以及匿名映射，所以这块内存段可以是文件映射也可以是匿名映射。而且不同的文件，映射到不同的vm_area_struct区。</p>
<p>这些vm_area_struct集合存储在mm_struct中的一个单向链表和红黑树中；当输出/proc/pid/maps文件时，只需要遍历这个链表即可。红黑树主要是为了快速定位到某一个内存块,红黑树的根存储在mm_rb域。</p>
<p>之前介绍过，线性地址需要通过页表才能转换为物理地址。每个进程的内存描述符也保存了这个进程页表指针pgd，每一块虚拟内存页都和页表的某一项对应。</p>
<p>虚拟内存是不存储任何数据的，它只是将地址空间映射到物理内存。物理内存有内核伙伴系统分配，如果一块物理内存没有被映射，就可以被伙伴系统分配给虚拟内存。刚分配的物理内存叶框可能是匿名的，存储进程数据，也可能是也缓存，存储文件或块设备的数据。一块虚拟内存vm_area_struct块是由连续的虚拟内存页组成的，而这些虚拟内存块映射的物理内存却不一定连续，如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0191.png" alt="虚拟内存映射到物理内存">
如上图所示，有三个页映射到物理内存，还有两个页没有映射，所以常驻内存RSS为12kb，而虚拟内存大小为20kb。对于有映射到物理内存的三个页的页表项PTE的Present标志设为1，而两个没有映射物理内存的虚拟内存页表项的Present位清除。所以这时访问那两块内存，则会导致异常缺页。</p>
<p>vma就像应用程序和内核的一个契约。当应用程序申请内存或者文件映射时，内核先响应这个请求，分配或更新虚拟内存；但是这些虚拟内存并没有映射到真实的物理内存。而是等到内存访问产生一个内存异常缺页时才真正映射物理内存。即当访问没有映射的虚拟内存时，由于页表项的Present位没有被设置，所以此时会产生一个缺页异常。vma记录和页表项两个在解决内存缺页，释放内存以及内存swap out都起着重要的作用。下面图展示了上述情况:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0201.png" alt="内存分配情况"></p>
<ol>
<li>一开始堆中只有8kb的内存，而且都已经映射到物理内存；</li>
<li>当调用brk()函数扩展堆时，新的页是没有映射到物理内存的，</li>
<li>当处理器需要访问一个地址，而且这个地址在上述刚分配的虚拟内存中，这时产生一个缺页异常；</li>
<li>这时进程向伙伴系统申请一页的物理内存，映射到那块虚拟内存上，并添加页表项，设置Present位.</li>
</ol>
<p>自此，这个内存管理暂时就说到这。总结下：</p>
<ol>
<li>linux进程的内存布局的每个段都是有一个vm_area_struct,而这个实例是由连续的虚拟内存地址组成；</li>
<li>当请求内存时，先是扩展vm_area_struct或者新分配一个vm_area_struct，但是并不映射物理内存，只有等到访问这块内存时，产生缺页异常，内核才分配物理内存。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux虚拟地址转物理地址]]></title>
      <url>http://luodw.cc/2016/02/17/address/</url>
      <content type="html"><![CDATA[<h1>80386虚拟地址和物理地址转换</h1>
<h1>CPU的发展</h1>
<p>之前在看malloc内存分配函数的原理时，有涉及到分配虚拟内存，然后再映射到物理内存，当初也是看得一头雾水，因为对虚拟内存和物理内存不是很了解。所以这篇文章总结下我在学习虚拟内存和物理内存的一些收获。</p>
<p>首先给出CPU的进化表，图片来自博客<a href="http://blog.chinaunix.net/uid-23069658-id-3569341.html" target="_blank" rel="external">wjlkoorey的博客</a>
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_003.png" alt="cpu进化表"></p>
<p>CPU发展从寻址物理地址；寻址段地址到物理地址转换；寻址逻辑地址转换为线性地址，再转换为物理地址。在8086之前的CPU，寻址都为物理地址，是并没有段的概念。当程序要访问内存时都是要给出内存的实际物理地址，这样在程序源代码中就会出现很多硬编码的物理地址。这样的程序可想而知，难重定位，可控性弱，结构丑陋，那个年代写这样的程序在我们现在看来是多么让人恼火的一件事儿。</p>
<p>后来8086引入一个非常重要的概念--段，这样就实现了分段机制；8086CPU地址总线为16，这样寻址范围为2^16=64k,而8086的寻址空间为1M，那么是怎么实现的了？原来这时候cpu给出的地址为段地址，需要加上段地址（由cs,ds,ss,es）之后才构成物理地址。物理地址为=段地址：段内偏移量；段地址左移4位+段内偏移量，即可构成20位的物理地址。例如ES=0x1000,DI=0xFFFF,那么物理地址为：</p>
<blockquote>
<p>AD(Absolute Address)=(ES)*(0x10)+(DI)=0x1FFFF</p>
</blockquote>
<p>0x10为16，段地址*16（2^4）,即向左移动4位。这样就可以对20位的1M内存空间进行寻址。</p>
<p>而这这种方式的寻址最大地址为0xFFFF:0xFFFF=0x10FFEF，大于1M空间，这样如果访问大于1M的内存空间时，将会产生结果了？8086的做法是自动从物理内存0地址开始寻址，有人就是说[0x0000,0x10FFEF]地址是按0xFFFF取模寻址。下图说明这种情况:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_004.png" alt="20位寻址空间"></p>
<p>CPU发展的下一个里程碑是1985年80386的问世，从16位到32位CPU的飞跃，这中间80286就成了这次飞跃的跳板，80286地址上升到24位并且引入了保护模式。保护模式即规定进程能访问的内存，有些内存是不能访问的，例如进程不能访问内核代码。80386继承了80286的内存保护模式和分段机制，并且引入了分页虚拟机制。首先80386继承了80286的基础上添加两个段寄存器FS和GS。很显然，为了实现保护模式，段寄存器只存储段基地址是不够的，至少还需要段地址的长度还有一些诸如访问权限之类的其他信息。所以段寄存器存储的并不是真正的段基地址，而是存储每个段描述符的选择符，通过这个选择符在GDT表格中找到这个段的基地址。</p>
<p>现在主流的x86CPU上的主流操作系统，Linux,FreeBSD,Windows等待都是工作在保护模式下，处理器只有在上电启动，引导阶段初始化时在会进入实时模式，实时模式任务处理之后，即进入保护模式。</p>
<h1>80386CPU逻辑地址转换为物理地址</h1>
<h2>逻辑地址转化为线性地址</h2>
<p>80386cpu当需要访问内存时，首先给出的逻辑地址，然后通过MMU内存管理单元分段机制转换为线性地址，然后线性地址再通过MMU内存管理单元分页机制转换为物理地址。</p>
<p>首先来看下cs，ds等段寄存器的内容，如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_005.png" alt="选择符格式"></p>
<ol>
<li>INDEX为在描述符表的索引，因为总共13位，所以描述符表总共可以存储8192个描述符，处理器将INDEX*8(一个描述符占8个字节)+GDTR(全局描述符表)/LDTR(局部描述符表)即为这个段的描述符。</li>
<li>TI(TABLE INDICATOR)指明在哪个描述符查找段描述符;如果为0，则在GDT查找，如果为1，则在LDT查找。</li>
<li>RPL(REQUESTOR'S PRIVILEGE LEVEL)请求权限，用于保护机制，0为最高优先级，3为最低优先级，linux只使用0和3优先级，分别表示内核态和用户态。</li>
</ol>
<p>当处理器需要访问内存时，给出的逻辑地址是:选择符+偏移量,然后通过MMU的分段机制，取出的逻辑地址的INDEX，乘以8,再加上GDTR存储的全局描述符表的基地址，即可获取这个段的描述符，然后存入描述符寄存器(一种对用户隐藏的寄存器，也称为不可编程寄存器)，然后取出这个64位的段描述符的段基地址+偏移量，即可获得这个逻辑地址对应的线性地址，下图展示了转换过程:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_008.png" alt="逻辑地址转线性地址"></p>
<p>线性地址由目录项(DIR)+页表项(PAGE)+页内偏移(OFFSET)组成。在介绍页地址转物理地址时，先介绍下段描述符的格式，如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_007.png" alt="段描述符格式"></p>
<ol>
<li>BASE:定义了4G的线程地址空间的基地址，处理器将描述符中三个BASE字段拼接成一个32位的值，这样就可以寻址4G的线性地址空间。</li>
<li>LIMIT:定义了段的空间大小，由描述符中的两个字段拼接而成，形成一个20位的值，20位总共可以表示为1M个数值，而这个1M个数值的单位则由Granularity bit位决定:</li>
</ol>
<ul>
<li>当granularity bit为0时，单位为1字节，这时limit表示的是1M的内存；</li>
<li>当granularity bit为1时，此时单位为4kb，这时limit表示的是4g的内存；</li>
</ul>
<ol start="3">
<li>TYPE: 区别不同的描述符，即描述符的类型。</li>
<li>DPL(Descriptor Privilege Level),描述符访问权限，用于保护机制。</li>
<li>Segment-Present bit:如果这个bit设置为0，则这个描述符不能被使用来进行地址转换，如果这个描述符被载入段描述符，处理器将会发出一个异常，下图展示了bit=0时的描述符格式，处理器可以使用标有AVALABLE的位置存储描述符。
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_010.png" alt="可用的描述符格式"></li>
<li>Accessed bit:当这个描述符被访问时，设置为1.</li>
</ol>
<h2>线性地址转化为物理地址</h2>
<p>之前，已经将逻辑地址转换为线性地址，接下来看下是如何从线性地址转化为物理地址，先给出下面示意图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_009.png" alt="线性地址转物理地址"></p>
<p>一个线性地址由10位目录表+10位页表+12位偏移量组成，当给定一个线性地址时，</p>
<ol>
<li>首先从控制寄存器CR3获取页目录基地址，然后加上线性地址的前10位页目录偏移量即可得到页表的基地址；</li>
<li>接着页表基地址+线性地址第二个10位的页表偏移，即可得到内存页的首地址；</li>
<li>最后内存页的首地址+线性地址的最后12位偏移量，即可得到最后的物理地址；</li>
</ol>
<p>这样就完成了从线性地址转为物理地址</p>
<p>接下来，看下页表项的格式。先来看下空闲的页表项和存储数据的页表项的格式:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_011.png" alt="无效的页表项">
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_012.png" alt="页表项格式">
三层页表都有着相同的格式，页帧地址为一块内存页的首地址，而内存页是4kb对齐的，所以页表项的低12位为0；而页目录项指向的是页表的首地址。</p>
<ol>
<li>Present bit表示这个页表项是否可以用于地址转换，p=1表示可以使用。当p=0时，表示这个页表项可以被进程使用。</li>
<li>Accessed and Dirty Bits这些位表示一个页中数据的使用情况。当要对一个页写或读之前，处理器会在两个层次的页表格设置访问位；当要对一个地址进行写操作，而这个操作在第二表格某个表项指向的内存页中，这时处理器会设置第二个表格相对应的页表项的脏位，设置页目录的脏位是未定义的。操作系统可以根据这些位来决定当内存不够时，换出哪些物理内存。</li>
<li>Read/Write和User/Supervisor Bits位在地址转换过程中，没有使用。</li>
</ol>
<h1>页转换缓存</h1>
<p>为了提高系统，防止每次地址转换都需要访问页表，处理器还设置了TLB(Translation lookaside buffer)转换后备高速缓冲区，存储最近使用的线性地址到物理地址的映射；下面给出TLB的原理图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_013.png" alt="TLB原理图"></p>
<p>当CPU需要访问一个一个内存地址时，给出一个虚拟地址，先是到TLB中查找是否有对应的物理地址，如果有，即命中，直接用TLB中的对应物理地址访问缓存；如果在TLB中没有对应的物理地址，即未命中，则需要到内存页表求出物理地址，并将这个物理地址存入TLB中。访问cache时，如果Cache中有需要的数据，则直接返回需要的数据，如果Cache中没有需要访问的数据，则需要到内存获取数据返回给用户，并将获取的数据存入Cache中。</p>
<p>所以，如果对计算机有足够的了解，那么就会发现计算机架构里面存在着好多的缓存设计，首先应用程序从磁盘获取数据时，在内核有一块内存存储最近访问的数据缓存；当CPU从主存获取数据时，也是先从缓冲区获取数据，然后在读进CPU。还有应用程序也有缓存，例如MySQL的存储引擎innodb也有一块缓冲区，存储磁盘数据；在web网站应用程序中，当从数据库获取数据时，先用memcache或者redis获取最近访问的数据等等。</p>
<p>缓存，让性能更美好。</p>
<p>参考:</p>
<ol>
<li><a href="http://blog.chinaunix.net/uid-23069658-id-3569341.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-23069658-id-3569341.html</a></li>
<li><a href="https://pdos.csail.mit.edu/6.828/2008/readings/i386/s05_01.htm" target="_blank" rel="external">https://pdos.csail.mit.edu/6.828/2008/readings/i386/s05_01.htm</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux寄存器简介]]></title>
      <url>http://luodw.cc/2016/02/17/register/</url>
      <content type="html"><![CDATA[<h1>80386常用寄存器</h1>
<p>最近在看书的过程中，发现好多都需要汇编寄存器的知识。例如，在gdb调试反汇编调试程序时需要会看懂汇编代码；在通过汇编了解系统调用原理时，也需要知道汇编寄存器知识；在了解linux内核内存管理时，需要知道段描述符寄存器GDTR/LDTR等等。本科学过汇编，有点基础，所以这篇文章想总结下80386各个寄存器的作用。</p>
<p>80386寄存器共有34个寄存器，可分为7类，它们是通用寄存器，指令指针和标志寄存器，段寄存器，系统地址寄存器，控制寄存器、调试和测试寄存器。我们经常碰到的是前四类寄存器，也是我这篇文章总结的重点。</p>
<h1>通用寄存器</h1>
<p>80386寄存器有8个32位通用寄存器这8个通用寄存器都是由8088/8086/80286的相应的16位通用寄存器扩展成32位而得。名字分别是：EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP。每个32位的通用寄存器的低16位可以单独使用，对应于8088/8086/80286的相应16位通用寄存器作用相同。同时，EAX，EBX，ECX，EDX四个寄存器的低16位AX,BX,CX,DX还可以继续分为各高8位，低8位寄存器单独使用，例如AX可以分为AH和AL，每个都是8位寄存器。</p>
<p>这8个为通用寄存器，说明它们的用处不止一个。它们通常既可以保存逻辑和算术运算中的那个操作数，也可以保存地址运算中的操作数。</p>
<p>下面说下我在c程序和系统调用时，这些寄存器的用法；</p>
<p>在函数调用和系统调用时，需要先将参数压入栈，然后被调用函数再从相应的寄存器获取参数值，存储在被调用函数的栈中，所以被调用函数对参数做出的改变并不会修改主函数的数值，因为他们在不同的栈中。函数的参数存入栈的顺序是从右到左，如果是调用函数sum(x,y),则是先将y压入栈，然后再将x压入栈，具体可以参考我之前的文章<a href="http://luodw.cc/2015/10/07/gdb/">用gdb反汇编理解c函数栈调用过程</a>;</p>
<p>对于寄存器而言,c程序和系统调用的参数则必须按顺序放到寄存器 ebx，ecx，edx，esi，edi 中，而函数调用的参数操作是从右到左，所以最后一个参数放入esi，倒数第二个参数存入edi等以此类推。对于上述的例子main函数调用sum(x,y)，main函数将y存入esi，x存入edi。然后sum函数内部从esi和edi获取参数值。</p>
<p>而eax在函数调用中，经常用来存储函数的返回值。上述例子中，sum函数将值存入eax寄存器中，main函数再从eax寄存器获取返回值。对于fork函数返回两个值，也可以通过eax来理解，当内核调度父进程时，键pid存入eax寄存器，当内核调度子进程时，将0存入eax寄存器。</p>
<p>esp寄存器为栈顶寄存器，并且始终指向栈顶。</p>
<p>ebp寄存器为基址寄存器，其实就是每个函数栈的栈底寄存器，通过这个基址寄存器，再加上偏移量，即可获取参数以及局部变量的值。</p>
<h1>指令指针寄存器和标志寄存器</h1>
<p>EIP为指令指针寄存器，是32位寄存器，低16位称为IP，用于兼容16为CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当程序刚运行时，系统把EIP清零，每取入一条指令，EIP自动增加相应的字节数，指向下一条指令。</p>
<p>EFLAGS也是为标志寄存器，低16位称为FLAGS，与16位CPU的标志寄存器同名，同作用。可分为3类：状态标志，控制标志和系统标志，简述如下：</p>
<ol>
<li>AF——辅助进位标志。若该位置位时，表示最低有效的4位向高位产生了进位或借位，则该标志位主要用于BCD算术运算。</li>
<li>CF——进位标志。当该位置位，表示8位或16位或32位数的算术操作产生了进位或借位。进行多字节数的加、减时要使用该标志。循环移位指令也影响进位标志。</li>
<li>PF——奇偶标志。主要用于数据通讯应用程序中，当该位置位时，表示结果数据位中有偶数个1，可以检查数据传送中是否出现错误。</li>
<li>SF——符号标志。该位置位时表示结果的最高位(符号位)为1。对于带符号数，该位为1表示负数，该位为0表示正数。</li>
<li>ZF——零标志。当该位置位时，表示操作的结果为0。</li>
<li>DF——方向标志。用于控制数据串操作指令中的地址变化方向。DF为0时，SI/DI或ESI/EDI为自动增量，地址从低向高变化，DF为1，SI/DI或ESI/EDI为自动减量，地址从高向低变化。</li>
<li>IF——中断允许标志。该位置1时允许响应外部可屏蔽中断(INTR)，该位复位时禁止响应外部可屏蔽中断。IF不影响非屏蔽外部中断(NMI)或内部产生的中断。</li>
<li>OF——溢出标志。若该位置位表示此次运算发生了溢出，即作为带符号数运算，其结果值超出目的单位所能表示的数值范围。这时目的单位的内容对带符号数没有意义。</li>
<li>TF——陷阱标志。当该位置位时，把处理器置成供调试的单步方式。在这种方式中，每条指令执行后CPU自动产生一个内部中断，使调试者可以观察程序中该条指令执行的情况。</li>
<li>NT——嵌套任务标志。用来表示当前的任务是否嵌套在另一任务内，当该位置1时，表示当前的任务有一个有效的链连接到前一个任务(被嵌套)，如果执行IRET指令，则转换到前一个任务。</li>
<li>IOPL——输入/输出特权级标志，用于定义允许执行输入/输出指令的I/O特权级的数值。</li>
<li>RF——恢复标志。它是与调试寄存器的断点一起使用的标志，当该位置1时，即使遇到断点或调试故障，也不产生异常中断1。在成功地执行每条指令时，RF将自动复位。</li>
<li>VM——虚拟8086方式标志。当该位置位时，CPU工作在虚拟8086模式(简称为拟86模式)，在这种模式下运行8086的程序就好象是在8086CPU上运行一样。</li>
<li>AC——对准检查标志。这是80486新定义的标志位。该位置位时，如果进行未对准的地址访问，则产生异常中断17。所谓未对准的地址访问，是指访问字数据时为奇地址，访问双字数据时不是4的倍数地址，访问8字节数据时，不是8的倍数的地址。对准检查在特权级为0，1，2时无效，只有在特权级3时有效。</li>
<li>s—状态标志；c—控制标志；x—系统标志</li>
</ol>
<h1>段寄存器</h1>
<p>可能在刚接触汇编时，会觉得段寄存器存储的就是程序每个段的基地址，在了解了linux虚拟地址转为物理地址之后，我才知道原来段描述符存储的并不是段基地址，而是存储了在段描述符表的索引以及一些属性。</p>
<p>80386有6个段寄存器，分别是CS，DS，SS，ES，FS和GS，是16位寄存器。前4个段寄存器的名称与8088/8086相同，在实地址方式下使用方式也和8088/8086相同。80386又增加了FS与GS，主要为了减轻对DS段和ES段的压力。</p>
<p>这些16位段寄存器存放的并不是段基地址，而是存储了在段描述符表的索引，D3-D15位是索引值,D0-D1位是优先级(RPL)用于特权检查,D2位是描述符表引用指示位TI,TI=0指示从全局描述表GDT中读取描述符，TI=1指示从局部描述符中LDT中读取描述符。这些信息总称段选择器(段选择子).</p>
<p>具体等到虚拟内存与物理内存转换时在具体说明。</p>
<h1>系统地址寄存器</h1>
<p>这些寄存器是我写这篇文章最主要的原因，因为这些寄存器在汇编代码中很少见，而在理解地址转换又是那么重要。</p>
<p>系统地址寄存器有四个，用来存储操作系统需要的保护信息和地址转换表信息、定义目前正在执行任务的环境、地址空间和中断向量空间。</p>
<ol>
<li>
<p>GDTR 48位全局描述符表寄存器，用于保存全局描述符表的32位基地址和全局描述符表的16位界限（全局描述符表最大为216字节，共2^16/8=8K个全局描述符）。GDT表里面的每一项都表明一个段的信息，或者是一个LDT表的相关信息。其实一个LDT表也是一个段。所以也可以说GDT表的每一项都描述一个段。就像一个文件夹下面可以有文件，也可以有文件夹一样，GDT表里面既可以有段描述符，也可以有LDT的表。</p>
</li>
<li>
<p>IDTR 48位中断描述符表寄存器，用于保存中断描述符表的32位基地址和中断描述符表的16位界限（中断描述符表最大为216字节，共2^16/8=8K个中断描述符）。</p>
</li>
<li>
<p>LDTR 16位局部描述符表寄存器，用于保存局部描述符表的选择符。一旦16位的选择符（也叫选择子）放入LDTR，CPU会自动将选择符所指定的局部描述符装入64位的局部描述符寄存器中。</p>
</li>
<li>
<p>TR 16位任务状态段寄存器，用于保存任务状态段(TSS)的16位选择符。与LDTR类似，一旦16位的选择符放入TR，CPU会自动将该选择符所指定的任务描述符装入64位的任务描述符寄存器中。注：TSS是一个段，所以在GDT中有对应的表项描述。</p>
</li>
</ol>
<p>所以LDTR和TR寄存器分别是局部描述符表的选择符和任务状态段选择符，它们需要到GDT表格中找到各自的描述符才能定位到各自的表格，所以可以把这两个寄存器看作是和cs,ds等段寄存器一样，局部描述符表和任务状态段看作是一个段。</p>
<p>对于寄存器先说到这，有了这些基础之后，就可以分析linux虚拟地址向物理地址的转换过程了。</p>
<p>参考：</p>
<ol>
<li><a href="http://mcit.xjtu.edu.cn/wlkj/wykj/ch2/ch2_4_1.htm" target="_blank" rel="external">http://mcit.xjtu.edu.cn/wlkj/wykj/ch2/ch2_4_1.htm</a></li>
<li><a href="https://linux.cn/blog-11720-5749.html" target="_blank" rel="external">https://linux.cn/blog-11720-5749.html</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下资源设置]]></title>
      <url>http://luodw.cc/2016/02/16/limit/</url>
      <content type="html"><![CDATA[<h1>linux下ulimit和sysctl设置原理和区别</h1>
<p>在linux下网络编程开发过程中，如果服务器用户量很大，就会开启很多连接，这时可能就会导致服务器进程文件描述符不够的情况。经常，我们会关闭服务器进程，然后在进程中调用setrlimit函数或者ulimit来设置服务器进程描述符的数量。那么ulimit设置原理是怎么样的了？以及sysctl设置原理了？这票文章主要分析下二者的设置原理以及区别。</p>
<h1>ulimit设置</h1>
<p>在linux下面，每个进程都有一个进程描述符struct_task，该结构体含有大量的属性用来描述一个进程的各个属性，其中有一个属性为struct rlimit rlim[RLIM_NLIMITS];用于描述该进程资源的限定值，其中struct rlimit定义如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> rlimit &#123;</div><div class="line">	<span class="keyword">rlim_t</span> rlim_cur;<span class="comment">//软限制，即某项资源的最大值</span></div><div class="line">	<span class="keyword">rlim_t</span> rlim_max;<span class="comment">//硬限制，即软限制的最大值</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所以当我们调用setrlimit和ulimit时，主要是设置进程描述符的struct rlimit资源数组。当我们读取资源时，主要是读取/proc/&lt;oid&gt;/limits文件，/proc文件夹为进程或系统的虚拟文件系统，只存在于内存中，是不占用磁盘空间的，可以通过命令ll /来检验，反应系统或进程的属性。/proc/&lt;pid&gt;/limits文件内容如下
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//资源名称                //软限制             //硬限制             //单位</div><div class="line">Limit                     Soft Limit           Hard Limit           Units     </div><div class="line">Max cpu time              unlimited            unlimited            seconds   </div><div class="line">Max file size             unlimited            unlimited            bytes     </div><div class="line">Max data size             unlimited            unlimited            bytes     </div><div class="line">Max stack size            8388608              unlimited            bytes     </div><div class="line">Max core file size        0                    unlimited            bytes     </div><div class="line">Max resident <span class="keyword">set</span>          <span class="keyword">unlimited</span>            <span class="keyword">unlimited</span>            <span class="keyword">bytes</span>     </div><div class="line"><span class="keyword">Max</span> processes             <span class="number">23235</span>                <span class="number">23235</span>                processes</div><div class="line"><span class="keyword">Max</span> <span class="keyword">open</span> files            <span class="number">1048</span>                 <span class="number">1048</span>                 files     </div><div class="line"><span class="keyword">Max</span> <span class="keyword">locked</span> <span class="keyword">memory</span>         <span class="number">65536</span>                <span class="number">65536</span>                <span class="keyword">bytes</span>     </div><div class="line"><span class="keyword">Max</span> address <span class="keyword">space</span>         <span class="keyword">unlimited</span>            <span class="keyword">unlimited</span>            <span class="keyword">bytes</span>     </div><div class="line"><span class="keyword">Max</span> <span class="keyword">file</span> locks            <span class="keyword">unlimited</span>            <span class="keyword">unlimited</span>            locks     </div><div class="line"><span class="keyword">Max</span> pending signals       <span class="number">23235</span>                <span class="number">23235</span>                signals   </div><div class="line"><span class="keyword">Max</span> msgqueue <span class="keyword">size</span>         <span class="number">819200</span>               <span class="number">819200</span>               <span class="keyword">bytes</span>     </div><div class="line"><span class="keyword">Max</span> nice <span class="keyword">priority</span>         <span class="number">0</span>                    <span class="number">0</span>                    </div><div class="line"><span class="keyword">Max</span> realtime <span class="keyword">priority</span>     <span class="number">0</span>                    <span class="number">0</span>                    </div><div class="line"><span class="keyword">Max</span> realtime <span class="keyword">timeout</span>      <span class="keyword">unlimited</span>            <span class="keyword">unlimited</span>            us</div></pre></td></tr></table></figure></p>
<p>这和我们运行ulimit -a命令显示出的资源列表大部分是一样的。
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">charles@charles-Aspire<span class="number">-4741</span>:/<span class="keyword">proc</span>/2584$<span class="title"> ulimit</span> -a<span class="title"></span></div><div class="line">core file<span class="title"> size</span>          (blocks, -c) 0<span class="title"></span></div><div class="line">data seg<span class="title"> size</span>           (kbytes, -d)<span class="title"> unlimited</span></div><div class="line">scheduling<span class="title"> priority</span>             (-e) 0<span class="title"></span></div><div class="line">file size               (blocks, -f)<span class="title"> unlimited</span></div><div class="line">pending<span class="title"> signals</span>                 (-i) 23235<span class="title"></span></div><div class="line">max locked<span class="title"> memory</span>       (kbytes, -l) 64<span class="title"></span></div><div class="line">max memory<span class="title"> size</span>         (kbytes, -m)<span class="title"> unlimited</span></div><div class="line">open<span class="title"> files</span>                      (-n) 2048<span class="title"></span></div><div class="line">pipe size            (512<span class="title"> bytes,</span> -p) 8<span class="title"></span></div><div class="line">POSIX message<span class="title"> queues</span>     (bytes, -q) 819200<span class="title"></span></div><div class="line">real-time priority              (-r) 0<span class="title"></span></div><div class="line">stack size              (kbytes, -s) 8192<span class="title"></span></div><div class="line">cpu time               (seconds, -t)<span class="title"> unlimited</span></div><div class="line">max<span class="title"> user</span> processes              (-u) 23235<span class="title"></span></div><div class="line">virtual memory          (kbytes, -v)<span class="title"> unlimited</span></div><div class="line">file<span class="title"> locks</span>                      (-x)<span class="title"> unlimited</span></div></pre></td></tr></table></figure></p>
<p>所以ulimit设置只是对当前进程有效。那么通过setlimit设置很好解释，因为直接操作进程描述符资源数组即可。但是ulimint命令怎么也会生效了？bash也是一个进程，那么在bash中调用ulimit设置的是bash的资源。那是因为在bash中执行的任何进程都是通过bash-&gt;fork-&gt;exec启动，所以ulimit设置了bash的资源，然后通过继承，传递给了bash中的子进程。所以ulimit对bash会话内的进程有效。</p>
<h1>sysctl设置</h1>
<h2>sysctl读取属性</h2>
<p>对于系统级别的资源，或者说想影响所有进程而不是单个进程时，只能通过sysctl函数或命令来读取设置。我们可以通过sysctl -a读取所有系统级别的资源限制。而sysctl读取的属性主要来自/proc/sys文件下的所有文件:
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">charles@charles-Aspire-4741:/proc/sys$ ll</div><div class="line">总用量 0</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 3 </span><span class="number"> 2016 </span>./</div><div class="line">dr-xr-xr-x<span class="number"> 217 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 3 </span><span class="number"> 2016 </span>../</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 2 </span>20:09 abi/</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 2 </span>20:09 debug/</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 2 </span>20:09 dev/</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 2 </span>19:32 fs/</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 3 </span><span class="number"> 2016 </span>kernel/</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 2 </span>19:32 net/</div><div class="line">dr-xr-xr-x  <span class="number"> 1 </span>root root<span class="number"> 0 </span> 2月 <span class="number"> 2 </span>19:32 vm/</div></pre></td></tr></table></figure></p>
<p>注意看，该文件是不占用磁盘空间的。在这文件下下，经常使用的是fs,net,vm文件夹下的文件：</p>
<ol>
<li>fs中的文件主要是文件系统的一些属性，例如打开文件的最大数量，管道数量的最大值以及epoll的一些设置；</li>
<li>net是网络的一些属性。例如网络接口wlan0,eth,lo的属性设置，还有tcp选项的设置，例如keepalive</li>
<li>vm是对虚拟内存的设置，例如redis有设置vm.overcommit_memory属性。</li>
</ol>
<p>这个属性设置原理如下：
vm.overcommit_memory 默认值为0，可以设置为0,1,2，分别代表意思为：</p>
<ul>
<li>0:当用户空间请求更多的的内存时，内核尝试估算出剩余可用的内存。如果内存不够，进程可能会崩溃。</li>
<li>1:当设这个参数值为1时，内核允许超量使用内存直到用完为止，主要用于科学计算;</li>
<li>2:当设这个参数值为2时，内核会使用一个决不过量使用内存的算法，即系统整个内存地址空间不能超过swap+50%的RAM值，50%参数的设定是在overcommit_ratio中设定。</li>
</ul>
<p>vm.overcommit_ratio默认值为50,这个参数值只有在vm.overcommit_memory=2的情况下，这个参数才会生效。</p>
<p>当我们需要读取某个资源限制时，可以通过如下两个命令进行读取:
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sysctl -<span class="keyword">a</span> | grep <span class="built_in">file</span>-<span class="built_in">max</span></div><div class="line">sysctl fs.<span class="built_in">file</span>-<span class="built_in">max</span></div></pre></td></tr></table></figure></p>
<p>但是我推荐第二种，因为第一种要先读取/proc/sys下所有文件，然后一个一个过滤，效率很低，而且有些文件是没有权限的，还会报提示。</p>
<p>第二种写法，其实就是文件夹.属性的形式。例如：
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果要读取文件最大描述符</span></div><div class="line">sysctl fs.<span class="keyword">file</span>-max ----&gt;  文件<span class="regexp">/proc/</span>sys<span class="regexp">/fs/</span><span class="keyword">file</span>-max</div><div class="line"><span class="comment">//读取overcommit_memory值</span></div><div class="line">sysctl vm.overcommit_memory  -----&gt;  文件<span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>overcommit_memory</div><div class="line"><span class="comment">//读取keepalive_time值</span></div><div class="line">sysctl net.ipv4.tcp_keepalive_time  -----&gt;  文件<span class="regexp">/proc/</span>sys<span class="regexp">/net/i</span>pv4<span class="regexp">/tcp_keepalive_time</span></div></pre></td></tr></table></figure></p>
<h2>sysctl设置属性</h2>
<p>如果要设置系统级别的属性，有两种方法：</p>
<ol>
<li>设置/proc/sys文件夹下，属性文件的值。这种方法只能在当前系统生效，系统重启，则还原为默认值。</li>
<li>通过修改/etc/sysctl.conf文件，这样可以永久改变属性值，因为每次开机系统启动后, init 会执行 /etc/rc.d/rc.sysinit,便会使用 /etc/sysctl.conf 的预设值去执行 sysctl</li>
</ol>
<p>先来谈谈如何通过修改/proc/sys来设置属性值。
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//通过重定向输出到属性文件中，覆盖原有的值</span></div><div class="line">echo <span class="string">'1'</span> &gt; /proc/sys/net/ipv4/ip_forward</div><div class="line"><span class="comment">//用sysctl命令-w属性，直接对变量写入值</span></div><div class="line">sysctl -w net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_forward</span>=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>net.ipv4.ip_forward用于设置主机是否支持转发数据包，0为不转发，1转发。以上两种方法都可以达到修改属性值的目的，但是重定向的方式需要root权限，因为操作的都是系统文件，以下是结果
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># sysctl net.ipv4.ip_forward</span></div><div class="line">net.ipv4.ip_forward = <span class="number">0</span></div><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># echo '1' &gt; /proc/sys/net/ipv4/ip_forward</span></div><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># sysctl net.ipv4.ip_forward</span></div><div class="line">net.ipv4.ip_forward = <span class="number">1</span></div><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># echo '0' &gt; /proc/sys/net/ipv4/ip_forward</span></div><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># sysctl net.ipv4.ip_forward</span></div><div class="line">net.ipv4.ip_forward = <span class="number">0</span></div><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># sysctl -w net.ipv4.ip_forward=1</span></div><div class="line">net.ipv4.ip_forward = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>如果想让系统重启之后，配置还生效，则必须通过修改/etc/sysctl.conf文件，打开/etc/sysctl.conf文件，在文件末尾添加
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_forward</span>=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>然后调用sysctl -p命令使/etc/sysctl.conf文件生效，以下是结果
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># sysctl net.ipv4.ip_forward</span></div><div class="line">net.ipv4.ip_forward = <span class="number">0</span></div><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># vim /etc/sysctl.conf</span></div><div class="line">root<span class="variable">@charles</span>-Aspire-<span class="number">4741</span><span class="symbol">:/proc/sys</span><span class="comment"># sysctl -p</span></div><div class="line">net.ipv4.ip_forward = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<h1>/etc/security/limits.conf设置</h1>
<p>之前也有说道，ulimit设置是在当前会话有效，如果bash重启之后，则ulimit设置失效。如果要下次重启bash之后设置仍然有效，则需要把设置写进当前用户文件夹下的.profile文件中。但是这也是对当前用户有效，如果要对系统所有用户有效，则需要把ulimit命令写进/etc/profile文件中。但是如果设置了～/.profile文件之后，则/etc/profile文件设置对当前用户为无效。</p>
<p>linux还提供了对某一用户设置权限，即为/etc/security/limits.conf文件。要使用该文件，则必须保证/etc/pam.d/login中有下面:
session    required   pam_limits.so</p>
<p>/etc/security/limits.conf文件格式为:
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">username|@groupname   <span class="keyword">type</span>  <span class="type">item  </span>limit</div></pre></td></tr></table></figure></p>
<ol>
<li>username|@groupname 设置需要被限制的用户名，组名前加@与用户名区分开来,*表示所有用户。</li>
<li>type 类型有soft，hard 和 -，其中soft 指的是当前系统生效的设置值。hard 表明系统中所能设定的最大值。soft 的限制不能比har 限制高。用 - 就表明同时设置了soft 和hard的值</li>
<li>item 表示要限制的资源,有core,data,nofile等待，具体如文件注释所说:
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;item&gt; can be one of the following:</div><div class="line"><span class="meta">#        - core - limits the core file size (KB)</span></div><div class="line"><span class="meta">#        - data - max data size (KB)</span></div><div class="line"><span class="meta">#        - fsize - maximum filesize (KB)</span></div><div class="line"><span class="meta">#        - memlock - max locked-in-memory address space (KB)</span></div><div class="line"><span class="meta">#        - nofile - max number of open files</span></div><div class="line"><span class="meta">#        - rss - max resident set size (KB)</span></div><div class="line"><span class="meta">#        - stack - max stack size (KB)</span></div><div class="line"><span class="meta">#        - cpu - max CPU time (MIN)</span></div><div class="line"><span class="meta">#        - nproc - max number of processes</span></div><div class="line"><span class="meta">#        - as - address space limit (KB)</span></div><div class="line"><span class="meta">#        - maxlogins - max number of logins for this user</span></div><div class="line"><span class="meta">#        - maxsyslogins - max number of logins on the system</span></div><div class="line"><span class="meta">#        - priority - the priority to run user process with</span></div><div class="line"><span class="meta">#        - locks - max number of file locks the user can hold</span></div><div class="line"><span class="meta">#        - sigpending - max number of pending signals</span></div><div class="line"><span class="meta">#        - msgqueue - max memory used by POSIX message queues (bytes)</span></div><div class="line"><span class="meta">#        - nice - max nice priority allowed to raise to values: [-20, 19]</span></div><div class="line"><span class="meta">#        - rtprio - max realtime priority</span></div><div class="line"><span class="meta">#        - chroot - change root to directory (Debian-specific)</span></div></pre></td></tr></table></figure></li>
</ol>
<p>所以要设置所有用户最大文件描述符，则需要在文件中添加一行
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">*   </span>soft   nofile   4096</div></pre></td></tr></table></figure></p>
<p>linux下资源的设置，常用大概就这几个。最关键的还是ulimit命令和sysctl命令，需要好好掌握。</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码分析之广播订阅机制]]></title>
      <url>http://luodw.cc/2016/02/15/redis-msgpub/</url>
      <content type="html"><![CDATA[<h1>redis消息队列之发布/订阅</h1>
<p>这篇文章分析下redis发布/订阅。这种模式的特点就是有一个客户端向某个频道channel发布消息msg，N个订阅了这个频道的客户端都会接收到消息msg，有点类似广播的感觉。下面先用实例展示pub/sub是如何使用，最后在分析源码是如何实现的。</p>
<h1>redis使用订阅/发布</h1>
<p>首先开启一个客户端，然后订阅到test频道:
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; subscribe test</div><div class="line"><span class="function"><span class="title">Reading</span></span> messages... (press Ctrl-C to quit)</div><div class="line"><span class="number">1</span>) <span class="string">"subscribe"</span><span class="comment">//订阅操作</span></div><div class="line"><span class="number">2</span>) <span class="string">"test"</span><span class="comment">//订阅频道名称</span></div><div class="line"><span class="number">3</span>) (<span class="keyword">integer</span>) <span class="number">1</span><span class="comment">//订阅频道唯一标识</span></div></pre></td></tr></table></figure></p>
<p>然后在另一个客户端，向这个频道发布一条消息:
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">publish</span> <span class="selector-tag">test</span> "<span class="selector-tag">hello</span> <span class="selector-tag">world</span>!"</div><div class="line">(<span class="selector-tag">integer</span>) 1</div></pre></td></tr></table></figure></p>
<p>这时之前订阅test频道的客户端将会收到这条消息：
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; subscribe test</div><div class="line"><span class="function"><span class="title">Reading</span></span> messages... (press Ctrl-C to quit)</div><div class="line"><span class="number">1</span>) <span class="string">"subscribe"</span></div><div class="line"><span class="number">2</span>) <span class="string">"test"</span></div><div class="line"><span class="number">3</span>) (<span class="keyword">integer</span>) <span class="number">1</span></div><div class="line"><span class="number">1</span>) <span class="string">"message"</span><span class="comment">//表明这条是消息</span></div><div class="line"><span class="number">2</span>) <span class="string">"test"</span><span class="comment">//消息来自的频道</span></div><div class="line"><span class="number">3</span>) <span class="string">"hello world!"</span><span class="comment">//消息内容</span></div></pre></td></tr></table></figure></p>
<p>以上就是订阅与发布的使用示例，还有两个命令是可以订阅和退订带有通配符的频道名称，即psubscribe和punsubscribe,官网介绍psubscribe命令时，支持下面三种匹配：</p>
<ul>
<li>h?llo subscribes to hello, hallo and hxllo</li>
<li>h*llo subscribes to hllo and heeeello</li>
<li>h[ae]llo subscribes to hello and hallo, but not hillo</li>
</ul>
<h1>发布/订阅源码实现</h1>
<p>这个发布和订阅实现很简单，因为并不需要将数据插入到数据库中，只需要操作服务器和客户端的两个属性即可。</p>
<p>我们先来看下服务器和客户端相关属性介绍：
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> </span>&#123;</div><div class="line">  .......</div><div class="line">  <span class="comment">/* Pubsub */</span></div><div class="line">  dict *pubsub_channels;  <span class="comment">/* 映射频道和订阅频道的客户端链表 */</span></div><div class="line">  <span class="keyword">list</span> *pubsub_patterns;  <span class="comment">/* 订阅模式列表，为pubsubPattern结构 */</span></div><div class="line">  .......</div><div class="line">&#125;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> </span>&#123;</div><div class="line">  .....</div><div class="line">  dict *pubsub_channels;  <span class="comment">/* 这个客户端感兴趣的频道列表,值为NULL */</span></div><div class="line">  <span class="keyword">list</span> *pubsub_patterns;  <span class="comment">/* 这个客户端感兴趣的频道模式，为字符串对象*/</span></div><div class="line">  ........</div><div class="line">&#125;redisClient;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> </span>&#123;</div><div class="line">    redisClient *client;</div><div class="line">    robj *pattern;</div><div class="line">&#125; pubsubPattern;<span class="comment">/* 服务器和客户端中的链表存储的数据类型 */</span></div></pre></td></tr></table></figure></p>
<p>当客户端调用subscribe订阅一个频道时，就往server的pubsub_channels相关的频道所对应的链表添加这个客户端。并往redisClient的pubsub_channels添加这个频道信息。当一个客户端publish一个频道一条信息后，会到server查找订阅这个频道所对应的客户端链表，并将消息发送给这些客户端。</p>
<p>先来看下subscribe源码分析:
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* pubsub.c */</span></div><div class="line">void subscribeCommand(redisClient *<span class="built_in">c</span>) &#123;</div><div class="line">    int j;</div><div class="line">    <span class="comment">//subscribe channel1 channel2 ,,,，所以c-&gt;argv[]从第二个参数开始存储频道名称</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="built_in">c</span>-&gt;argc; j++)</div><div class="line">        pubsubSubscribeChannel(<span class="built_in">c</span>,<span class="built_in">c</span>-&gt;argv[j]);<span class="comment">//调用订阅函数</span></div><div class="line">    <span class="built_in">c</span>-&gt;flags |= <span class="type">REDIS_PUBSUB</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++</span></div><div class="line">int pubsubSubscribeChannel(redisClient *<span class="built_in">c</span>, robj *channel) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    list *clients = <span class="type">NULL</span>;</div><div class="line">    int retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 将频道添加进客户端的channel-&gt;clients_list字典中*/</span></div><div class="line">    <span class="keyword">if</span> (dictAdd(<span class="built_in">c</span>-&gt;pubsub_channels,channel,<span class="type">NULL</span>) == <span class="type">DICT_OK</span>) &#123;</div><div class="line">        retval = <span class="number">1</span>;</div><div class="line">        incrRefCount(channel);</div><div class="line">        <span class="comment">/* 在server查找这个频道的客户端链表是否存在 */</span></div><div class="line">        de = dictFind(server.pubsub_channels,channel);</div><div class="line">        <span class="keyword">if</span> (de == <span class="type">NULL</span>) &#123;<span class="comment">//如果不存在，则新建一个</span></div><div class="line">            clients = listCreate();</div><div class="line">            dictAdd(server.pubsub_channels,channel,clients);<span class="comment">//添加进字典中</span></div><div class="line">            incrRefCount(channel);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            clients = dictGetVal(de);<span class="comment">//如果已存在，则直接获取频道所对应的客户端链表</span></div><div class="line">        &#125;</div><div class="line">        listAddNodeTail(clients,<span class="built_in">c</span>);<span class="comment">//将客户端添加进客户端链表中</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* 初始化客户端信息 */</span></div><div class="line">    addReply(<span class="built_in">c</span>,shared.mbulkhdr[<span class="number">3</span>]);<span class="comment">//输出"*3\r\n"</span></div><div class="line">    addReply(<span class="built_in">c</span>,shared.subscribebulk);<span class="comment">//输出“$9\r\nsubscribe\r\n”</span></div><div class="line">    addReplyBulk(<span class="built_in">c</span>,channel);<span class="comment">//将频道名称封装成"$4\r\ntest\r\n"形式</span></div><div class="line">    addReplyLongLong(<span class="built_in">c</span>,clientSubscriptionsCount(<span class="built_in">c</span>));<span class="comment">//输出客户端订阅个数，也就是频道序号</span></div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样这个客户端就订阅了test这个频道，而且这时的客户端由于订阅了某一个频道，则调用read阻塞等待服务器给他发送频道信息。接下来就看下publish这个命令的执行函数:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void publishCommand(redisClient *c) &#123;</div><div class="line">    <span class="comment">//c-&gt;argv[1]为频道的名称，c-&gt;argv[2]为消息对象。下面函数就是将消息发送给所有订阅频道的客户端</span></div><div class="line">    <span class="function"><span class="title">int</span> receivers = pubsubPublishMessage(c-&gt;</span><span class="function"><span class="title">argv</span>[1],c-&gt;</span>argv[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled)</div><div class="line">        <span class="function"><span class="title">clusterPropagatePublish</span>(c-&gt;</span><span class="function"><span class="title">argv</span>[1],c-&gt;</span>argv[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        forceCommandPropagation(c,REDIS_PROPAGATE_REPL);</div><div class="line">    <span class="function"><span class="title">addReplyLongLong</span>(c,receivers);//给调用publish命令的客户端发送订阅c-&gt;</span>argv[<span class="number">1</span>]频道的客户端数</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来看下pubsubPublishMessage函数是如何将消息发送给客户端的：
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Publish a message */</span></div><div class="line">int pubsubPublishMessage(robj *channel, robj *message) &#123;</div><div class="line">    int receivers = 0;</div><div class="line">    dictEntry *<span class="keyword">de</span>;</div><div class="line">    listNode *ln;</div><div class="line">    listIter <span class="keyword">li</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 发送消息给订阅频道的客户端 */</span></div><div class="line">    <span class="keyword">de</span> = dictFind(server.pubsub_channels,channel);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">de</span>) &#123;</div><div class="line">        <span class="keyword">list</span> *<span class="keyword">list</span> = dictGetVal(<span class="keyword">de</span>);<span class="comment">//获得客户端链表</span></div><div class="line">        listNode *ln;</div><div class="line">        listIter <span class="keyword">li</span>;</div><div class="line"></div><div class="line">        listRewind(<span class="keyword">list</span>,&amp;<span class="keyword">li</span>);<span class="comment">//迭代器初始化</span></div><div class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;<span class="keyword">li</span>)) != NULL) &#123;<span class="comment">//迭代链表的每一个客户端</span></div><div class="line">            redisClient *c = ln-&gt;value;</div><div class="line">            <span class="comment">//发送消息</span></div><div class="line">            addReply(c,shared.mbulkhdr[3]);<span class="comment">//输出"*3\r\n"</span></div><div class="line">            addReply(c,shared.messagebulk);<span class="comment">//输出"$7\r\nmessage\r\n"</span></div><div class="line">            addReplyBulk(c,channel);<span class="comment">//输出"$4\r\ntest\r\n"格式</span></div><div class="line">            addReplyBulk(c,message);<span class="comment">//输出"$5\r\nhello\r\n"</span></div><div class="line">            receivers++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数先取出server.pubsub_channels字典中，订阅这个频道的客户端链表，然后将消息发送给每一个客户端即可。</p>
<p>当调用unscubscribe退订频道时，只是简单将频道从客户端c-&gt;pubsub_channels删除，以及将客户端从server.pubsub_channels频道所对应的链表中删除即可。</p>
<p>redis还支持订阅模式匹配的的多个频道，用psubscribe订阅和punsubscribe退订。本质上和订阅一个明确的频道没什么差别，只是最后在publish发送消息给客户端时，除了要发给明确的频道外，还需将消息发送给模式匹配的所有客户端。</p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码分析之慢日志]]></title>
      <url>http://luodw.cc/2016/02/14/redis-slowlog/</url>
      <content type="html"><![CDATA[<h1>redis慢查询日志</h1>
<p>在mysql中，有一类日志，叫慢查询日志，主要是保存查询时间超过一定阈值的sql语句，用于分析如何优化查询。redis也有一个慢查询日志，功能类似，存储查询时间超过事先定义的阈值的命令，用来分析和优化查询。</p>
<p>redis有两个和慢查询日志相关的选项：</p>
<ul>
<li>slowlog-log-slower-than 选项指定执行时间超过多少微秒（1 秒等于 1,000,000 微秒）的命令请求会被记录到日志上。举个例子， 如果这个选项的值为 100 ， 那么执行时间超过 100 微秒的命令就会被记录到慢查询日志； 如果这个选项的值为 500 ， 那么执行时间超过 500 微秒的命令就会被记录到慢查询日志； 诸如此类。</li>
<li>slowlog-max-len 选项指定服务器最多保存多少条慢查询日志。服务器使用先进先出的方式保存多条慢查询日志： 当服务器储存的慢查询日志数量等于 slowlog-max-len 选项的值时， 服务器在添加一条新的慢查询日志之前， 会先将最旧的一条慢查询日志删除。举个例子， 如果服务器 slowlog-max-len 的值为 100 ， 并且假设服务器已经储存了 100 条慢查询日志， 那么如果服务器打算添加一条新日志的话， 它就必须先删除目前保存的最旧的那条日志， 然后再添加新日志。</li>
</ul>
<p>我们先来看下慢查询日志是如何使用的，可以通过redis.conf配置文件配置上述两项，或者采用config set命令来设置
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">slowlog</span> <span class="selector-tag">get</span></div><div class="line">(<span class="selector-tag">empty</span> <span class="selector-tag">list</span> <span class="selector-tag">or</span> <span class="selector-tag">set</span>)</div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">config</span> <span class="selector-tag">get</span> <span class="selector-tag">slowlog-log-slower-than</span></div><div class="line">1) "<span class="selector-tag">slowlog-log-slower-than</span>"</div><div class="line">2) "1"</div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">config</span> <span class="selector-tag">set</span> <span class="selector-tag">slowlog-log-slower-than</span> 2</div><div class="line"><span class="selector-tag">OK</span></div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">config</span> <span class="selector-tag">get</span> <span class="selector-tag">slowlog-log-slower-than</span></div><div class="line">1) "<span class="selector-tag">slowlog-log-slower-than</span>"</div><div class="line">2) "2"</div><div class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">set</span> <span class="selector-tag">name</span> <span class="selector-tag">hello</span></div><div class="line"><span class="selector-tag">OK</span></div></pre></td></tr></table></figure></p>
<p>一开始慢日志为空，然后通过config get先获取变量slowlog-log-slower-than的值，为我之前设置的1，单位为微秒。然后通过命令config set命令设置为2微秒，然后执行一个set命令，我们来看下慢查询日志
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; slowlog get</div><div class="line"><span class="number">1</span>) <span class="number">1</span>) (<span class="keyword">integer</span>) <span class="number">0</span><span class="comment">//日志的唯一标识符</span></div><div class="line">   <span class="number">2</span>) (<span class="keyword">integer</span>) <span class="number">1454593637</span><span class="comment">//命令执行时的unix时间戳</span></div><div class="line">   <span class="number">3</span>) (<span class="keyword">integer</span>) <span class="number">14</span><span class="comment">//命令执行的时长，以微秒计算</span></div><div class="line">   <span class="number">4</span>) <span class="number">1</span>) <span class="string">"set"</span> <span class="comment">//命令以及命令参数</span></div><div class="line">      <span class="number">2</span>) <span class="string">"name"</span></div><div class="line">      <span class="number">3</span>) <span class="string">"hello"</span></div></pre></td></tr></table></figure></p>
<p>其实之前的config命令，也会在慢日志中，我没列出。可以看下慢查询日志格式。慢查询日志还有一个选项是最多保留慢查询日志的条数slowlog-max-len，如果慢查询日志数量超出设定的阈值，则最旧的日志会被删除。</p>
<h1>慢查询源码分析</h1>
<p>解析来看下慢查询日志源码是如何实现的。慢查询日志数据结构为
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//slowlog.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> slowlogEntry &#123;</div><div class="line">    robj **argv;        <span class="comment">/* 命令参数对象数组 */</span></div><div class="line">    <span class="keyword">int</span> argc;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;       <span class="comment">/* Unique entry identifier. */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> duration; <span class="comment">/* Time spent by the query, in nanoseconds. */</span></div><div class="line">    <span class="keyword">time_t</span> time;        <span class="comment">/* Unix time at which the query was executed. */</span></div><div class="line">&#125; slowlogEntry;</div></pre></td></tr></table></figure></p>
<p>这里注释的命令执行时间为纳秒，但是官网上是微秒，而且我觉得微秒更可信点，在server结构中，也有几个属性与慢日志相关
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> redisServer &#123;</div><div class="line">    <span class="comment">//..................</span></div><div class="line">    <span class="built_in">list</span> *slowlog;                  <span class="comment">/* SLOWLOG list of commands */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;     <span class="comment">/* SLOWLOG current entry ID */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than; <span class="comment">/* SLOWLOG time limit (to get logged) */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len;     <span class="comment">/* SLOWLOG max number of items logged */</span></div><div class="line">    <span class="comment">//......................</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>redis用一个链表来存储所有的慢查询日志，在redis.c/main函数中的initServer函数中，调用slowlogInit函数初始化慢查询日志:
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> slowlogInit(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">server</span>.slowlog = listCreate();<span class="comment">//创建链表</span></div><div class="line">    <span class="keyword">server</span>.slowlog_entry_id = <span class="number">0</span>;<span class="comment">//初始化日志id</span></div><div class="line">    listSetFreeMethod(<span class="keyword">server</span>.slowlog,slowlogFreeEntry);<span class="comment">//注册日志析构函数，主要</span></div><div class="line"><span class="comment">//为了回收argv中存储的参数对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始化好慢查询日志之后，接下来在哪进行慢查询日志插入了？因为慢查询日志是需要知道命令的执行时间，所以肯定必须在命令执行之后，根据这个思路，我们在call函数中找到了慢查询日志插入点。
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void call(redisClient *c, int flags) &#123;</div><div class="line">    <span class="comment">/* ..... */</span></div><div class="line">       start = ustime();</div><div class="line">       <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">cmd</span>-&gt;</span>proc(c);</div><div class="line">       duration = ustime()-start;</div><div class="line">    <span class="comment">/* ......*/</span></div><div class="line">       <span class="function"><span class="title">slowlogPushEntryIfNeeded</span>(c-&gt;</span><span class="function"><span class="title">argv</span>,c-&gt;</span>argc,duration);</div></pre></td></tr></table></figure></p>
<p>所以，这个命令时长是调用命令的执行函数所持续的时间，最后调用slowlog.c中的slowlogPushEntryIfNeeded函数如果有必要插入。
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> slowlogPushEntryIfNeeded(robj **argv, <span class="keyword">int</span> argc, <span class="keyword">long</span> <span class="keyword">long</span> duration) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">server</span>.slowlog_log_slower_than &lt; <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* Slowlog disabled */</span></div><div class="line">    <span class="keyword">if</span> (duration &gt;= <span class="keyword">server</span>.slowlog_log_slower_than)</div><div class="line">        listAddNodeHead(<span class="keyword">server</span>.slowlog,slowlogCreateEntry(argv,argc,duration));</div><div class="line"></div><div class="line">    <span class="comment">/* 如果慢查询日志链表已满，则删除最旧的日志 */</span></div><div class="line">    <span class="keyword">while</span> (listLength(<span class="keyword">server</span>.slowlog) &gt; <span class="keyword">server</span>.slowlog_max_len)</div><div class="line">        listDelNode(<span class="keyword">server</span>.slowlog,listLast(<span class="keyword">server</span>.slowlog));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>必须先创建好一个日志项，然后再将日志项插入慢日志列表头:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">slowlogEntry *slowlogCreateEntry(robj **argv, int argc, long long duration) &#123;</div><div class="line">    slowlogEntry *se = zmalloc(sizeof(*se));</div><div class="line">    int j, slargc = argc;</div><div class="line">    <span class="comment">//判断参数是否过多</span></div><div class="line">    <span class="keyword">if</span> (slargc &gt; SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;</div><div class="line">    <span class="function"><span class="title">se</span>-&gt;</span>argc = slargc;</div><div class="line">    <span class="function"><span class="title">se</span>-&gt;</span>argv = zmalloc(sizeof(robj*)*slargc);</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; slargc; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (slargc != argc &amp;&amp; j == slargc-<span class="number">1</span>) &#123;</div><div class="line">            <span class="function"><span class="title">se</span>-&gt;</span>argv[j] = createObject(REDIS_STRING,</div><div class="line">                sdscatprintf(sdsempty(),<span class="string">"... (%d more arguments)"</span>,</div><div class="line">                argc-slargc+<span class="number">1</span>));<span class="comment">//在最后一个参数输出提示</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* 有些字符串太长，进行缩减 */</span></div><div class="line">            <span class="function"><span class="title">if</span> (argv[j]-&gt;</span>type == REDIS_STRING &amp;&amp;</div><div class="line">                sdsEncodedObject(argv[j]) &amp;&amp;</div><div class="line">                <span class="function"><span class="title">sdslen</span>(argv[j]-&gt;</span>ptr) &gt; SLOWLOG_ENTRY_MAX_STRING)</div><div class="line">            &#123;</div><div class="line">                <span class="function"><span class="title">sds</span> s = sdsnewlen(argv[j]-&gt;</span>ptr, SLOWLOG_ENTRY_MAX_STRING);</div><div class="line"></div><div class="line">                s = sdscatprintf(s,<span class="string">"... (%lu more bytes)"</span>,</div><div class="line">                    (unsigned long)</div><div class="line">                    <span class="function"><span class="title">sdslen</span>(argv[j]-&gt;</span>ptr) - SLOWLOG_ENTRY_MAX_STRING);</div><div class="line">                <span class="function"><span class="title">se</span>-&gt;</span>argv[j] = createObject(REDIS_STRING,s);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="function"><span class="title">se</span>-&gt;</span>argv[j] = argv[j];</div><div class="line">                incrRefCount(argv[j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//为slowlogEntry其他选项赋值</span></div><div class="line">    <span class="function"><span class="title">se</span>-&gt;</span><span class="built_in">time</span> = <span class="built_in">time</span>(NULL);</div><div class="line">    <span class="function"><span class="title">se</span>-&gt;</span>duration = duration;</div><div class="line">    <span class="function"><span class="title">se</span>-&gt;</span>id = server.slowlog_entry_id++;</div><div class="line">    return se;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后再来看下slowlog命令执行函数
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void slowlogCommand(redisClient *c) &#123;</div><div class="line">    <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">argc</span> == 2 &amp;&amp; !strcasecmp(c-&gt;</span><span class="function"><span class="title">argv</span>[1]-&gt;</span>ptr,<span class="string">"reset"</span>)) &#123;</div><div class="line">        slowlogReset();</div><div class="line">        addReply(c,shared.ok);</div><div class="line">    &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (c-&gt;</span><span class="function"><span class="title">argc</span> == 2 &amp;&amp; !strcasecmp(c-&gt;</span><span class="function"><span class="title">argv</span>[1]-&gt;</span>ptr,<span class="string">"len"</span>)) &#123;</div><div class="line">        addReplyLongLong(c,listLength(server.slowlog));</div><div class="line">    &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> ((c-&gt;</span><span class="function"><span class="title">argc</span> == 2 || c-&gt;</span>argc == <span class="number">3</span>) &amp;&amp;</div><div class="line">               !<span class="function"><span class="title">strcasecmp</span>(c-&gt;</span><span class="function"><span class="title">argv</span>[1]-&gt;</span>ptr,<span class="string">"get"</span>))</div><div class="line">    &#123;</div><div class="line">        long count = <span class="number">10</span>, sent = <span class="number">0</span>;</div><div class="line">        listIter li;</div><div class="line">        void *totentries;</div><div class="line">        listNode *ln;</div><div class="line">        slowlogEntry *se;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">if</span> (c-&gt;</span>argc == <span class="number">3</span> &amp;&amp;</div><div class="line">            <span class="function"><span class="title">getLongFromObjectOrReply</span>(c,c-&gt;</span>argv[<span class="number">2</span>],&amp;count,NULL) != REDIS_OK)</div><div class="line">            return;</div><div class="line"></div><div class="line">        listRewind(server.slowlog,&amp;li);</div><div class="line">        totentries = addDeferredMultiBulkLength(c);</div><div class="line">        <span class="keyword">while</span>(count-- &amp;&amp; (ln = listNext(&amp;li))) &#123;</div><div class="line">            int j;</div><div class="line"></div><div class="line">            <span class="function"><span class="title">se</span> = ln-&gt;</span>value;</div><div class="line">            addReplyMultiBulkLen(c,<span class="number">4</span>);</div><div class="line">            <span class="function"><span class="title">addReplyLongLong</span>(c,se-&gt;</span>id);</div><div class="line">            <span class="function"><span class="title">addReplyLongLong</span>(c,se-&gt;</span><span class="built_in">time</span>);</div><div class="line">            <span class="function"><span class="title">addReplyLongLong</span>(c,se-&gt;</span>duration);</div><div class="line">            <span class="function"><span class="title">addReplyMultiBulkLen</span>(c,se-&gt;</span>argc);</div><div class="line">            <span class="function"><span class="title">for</span> (j = 0; j &lt; se-&gt;</span>argc; j++)</div><div class="line">                <span class="function"><span class="title">addReplyBulk</span>(c,se-&gt;</span>argv[j]);</div><div class="line">            sent++;</div><div class="line">        &#125;</div><div class="line">        setDeferredMultiBulkLength(c,totentries,sent);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        addReplyError(c,</div><div class="line">            <span class="string">"Unknown SLOWLOG subcommand or wrong # of args. Try GET, RESET, LEN."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>slowlog命令有三个子命令，</p>
<ol>
<li>
<p>第一个是reset,这时调用slowlogReset函数恢复日志列表，即删除所有日志:
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> slowlogReset(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">while</span> (listLength(<span class="keyword">server</span>.slowlog) &gt; <span class="number">0</span>)</div><div class="line">        listDelNode(<span class="keyword">server</span>.slowlog,listLast(<span class="keyword">server</span>.slowlog));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>第二个是len，返回日志链表长度
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">else</span> <span class="keyword">if</span> (c-&gt;</span><span class="function"><span class="title">argc</span> == 2 &amp;&amp; !strcasecmp(c-&gt;</span><span class="function"><span class="title">argv</span>[1]-&gt;</span>ptr,<span class="string">"len"</span>)) &#123;</div><div class="line">        addReplyLongLong(c,listLength(server.slowlog));</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>第三个是get，返回的是所有慢日志,很简单，只是简单的迭代slowlog链表，输出每一个日志项。</p>
</li>
</ol>
<p>慢查询日志整体相对较简单，在每次执行命令时，判断执行时间是否超时，如果超时，就插入慢查询日志链表中，之后就可以调用slowlog命令查询.</p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis消息队列之链表实现]]></title>
      <url>http://luodw.cc/2016/02/13/redis-msglist/</url>
      <content type="html"><![CDATA[<h1>redis消息队列之链表实现</h1>
<p>之前在知乎上看到用redis来实现消息队列，其实消息队列，linux在进程间通信有提到过，以及在memcache主线程和工作线程之间通信也是通过消息队列，但是我认为redis消息队列有一个好处，就是可以实现分布式和共享，就和memcache作为mysql的缓存和mysql自带的缓存一样。</p>
<p>redis有两种方式实现消息队列</p>
<ol>
<li>用redis自带的链表数据结构</li>
<li>用redis发布/订阅模式</li>
</ol>
<h1>链表实现消息队列</h1>
<p>redis链表支持前后插入以及前后取出，所以如果往尾部插入元素，往头部取出元素，这就是一种消息队列，也可以说是消费者/生产者模型。可以利用lpush和rpop来实现。但是有一个问题，如果链表中没有数据，那么消费者将要在while循环中调用rpop，这样以来就浪费cpu资源，好在redis提供一种阻塞版pop命令brpop或者blpop，用法为brpop/blpop list timeout, 当链表为空的时候，brpop/blpop将阻塞，直到设置超时时间到或者list插入一个元素。看下用法如下:
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">charles@charles<span class="params">-Aspire</span><span class="number">-4741</span>:~/mydir/mylib/redis$ ./src/redis<span class="params">-cli</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush <span class="built_in">list</span> hello</div><div class="line">(<span class="built_in">integer</span>) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop <span class="built_in">list</span> <span class="number">0</span></div><div class="line"><span class="number">1</span>) <span class="string">"list"</span></div><div class="line"><span class="number">2</span>) <span class="string">"hello"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop <span class="built_in">list</span> <span class="number">0</span></div><div class="line"><span class="comment">//阻塞在这里</span></div><div class="line"><span class="comment">/* ---------------------------------------------------- */</span></div><div class="line"><span class="comment">//当我在另一个客户端lpush一个元素之后，客户端输出为</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; brpop <span class="built_in">list</span> <span class="number">0</span></div><div class="line"><span class="number">1</span>) <span class="string">"list"</span></div><div class="line"><span class="number">2</span>) <span class="string">"world"</span></div><div class="line">(<span class="number">50.60</span>s)<span class="comment">//阻塞的时间</span></div></pre></td></tr></table></figure></p>
<p>当链表为空的时候，brpop是阻塞的，等待超时时间到或者另一个客户端lpush一个元素。接下来，看下源码是如何实现阻塞brpop命令的。要实现客户端阻塞，只需要服务器不给客户端发送消息，那么客户端就会阻塞在read调用中，等待消息到达。这是很好实现的，关键是如何判断这个客户端阻塞的链表有数据到达以及通知客户端解除阻塞？redis的做法是，将阻塞的键以及阻塞在这个键上的客户端链表存储在一个字典中，然后每当向数据库插入一个链表时，就判断这个新插入的链表是否有客户端阻塞，有的话，就解除这个阻塞的客户端，并且发送刚插入链表元素给客户端，客户端就这样解除阻塞。</p>
<p>先看下有关数据结构，以及server和client有关属性
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//阻塞状态</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">blockingState</span> </span>&#123;</div><div class="line">    <span class="comment">/* Generic fields. */</span></div><div class="line">    mstime_t timeout;       <span class="comment">/* 超时时间 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* REDIS_BLOCK_LIST */</span></div><div class="line">    dict *keys;             <span class="comment">/* The keys we are waiting to terminate a blocking</span></div><div class="line">                             * operation such as BLPOP. Otherwise NULL. */</div><div class="line">    robj *target;           <span class="comment">/* The key that should receive the element,</span></div><div class="line">                             * for BRPOPLPUSH. */</div><div class="line"></div><div class="line">    <span class="comment">/* REDIS_BLOCK_WAIT */</span></div><div class="line">    int numreplicas;        <span class="comment">/* Number of replicas we are waiting for ACK. */</span></div><div class="line">    long long reploffset;   <span class="comment">/* Replication offset to reach. */</span></div><div class="line">&#125; blockingState;</div><div class="line"><span class="comment">//继续列表</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">readyList</span> </span>&#123;</div><div class="line">    redisDb *db;<span class="comment">//就绪键所在的数据库</span></div><div class="line">    robj *key;<span class="comment">//就绪键</span></div><div class="line">&#125; readyList;</div><div class="line"><span class="comment">//客户端有关属性</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> </span>&#123;</div><div class="line">   int btype;              <span class="comment">/* Type of blocking op if REDIS_BLOCKED. */</span></div><div class="line">    blockingState bpop;     <span class="comment">/* blocking state */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//服务器有关属性</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> </span>&#123;</div><div class="line">     <span class="comment">/* Blocked clients */</span></div><div class="line">    unsigned int bpop_blocked_clients; <span class="comment">/* Number of clients blocked by lists */</span></div><div class="line">    <span class="keyword">list</span> *unblocked_clients; <span class="comment">/* list of clients to unblock before next loop */</span></div><div class="line">    <span class="keyword">list</span> *ready_keys;        <span class="comment">/* List of readyList structures for BLPOP &amp; co */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//数据库有关属性</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> </span>&#123;</div><div class="line">       <span class="comment">//keys-&gt;redisCLient映射</span></div><div class="line">       dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span></div><div class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></div><div class="line">&#125;redisDB</div></pre></td></tr></table></figure></p>
<p>必须对上述的数据结构足够了解，否则很难看懂下面的代码，因为这些代码需要操作上述的数据结构。先从brpop命令执行函数开始分析，brpop命令执行函数为
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">void brpopCommand(redisClient *c) &#123;</div><div class="line">    blockingPopGenericCommand(c,REDIS_TAIL);</div><div class="line">&#125;</div><div class="line"><span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++</span></div><div class="line">void blockingPopGenericCommand(redisClient *c, int <span class="keyword">where</span>) &#123;</div><div class="line">    robj *o;</div><div class="line">    mstime_t timeout;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;</span><span class="function"><span class="title">argv</span>[c-&gt;</span>argc-<span class="number">1</span>],&amp;timeout,UNIT_SECONDS)</div><div class="line">        != REDIS_OK) return;<span class="comment">//将超时时间保存在timeout中</span></div><div class="line"></div><div class="line">    <span class="function"><span class="title">for</span> (j = 1; j &lt; c-&gt;</span>argc-<span class="number">1</span>; j++) &#123;</div><div class="line">        <span class="function"><span class="title">o</span> = lookupKeyWrite(c-&gt;</span><span class="function"><span class="title">db</span>,c-&gt;</span>argv[j]);<span class="comment">//在数据库中查找操作的链表</span></div><div class="line">        <span class="keyword">if</span> (o != NULL) &#123;<span class="comment">//如果不为空</span></div><div class="line">            <span class="function"><span class="title">if</span> (o-&gt;</span>type != REDIS_LIST) &#123;<span class="comment">//不是链表类型</span></div><div class="line">                addReply(c,shared.wrongtypeerr);<span class="comment">//报错</span></div><div class="line">                return;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (listTypeLength(o) != <span class="number">0</span>) &#123;<span class="comment">//链表不为空</span></div><div class="line">                    <span class="comment">/* Non empty list, this is like a non normal [LR]POP. */</span></div><div class="line">                    char *event = (<span class="keyword">where</span> == REDIS_HEAD) ? <span class="string">"lpop"</span> : <span class="string">"rpop"</span>;</div><div class="line">                    robj *value = listTypePop(o,<span class="keyword">where</span>);<span class="comment">//从链表中pop出一个元素</span></div><div class="line">                    redisAssert(value != NULL);</div><div class="line">                    <span class="comment">//给客户端发送pop出来的元素信息</span></div><div class="line">                    addReplyMultiBulkLen(c,<span class="number">2</span>);</div><div class="line">                    <span class="function"><span class="title">addReplyBulk</span>(c,c-&gt;</span>argv[j]);</div><div class="line">                    addReplyBulk(c,value);</div><div class="line">                    decrRefCount(value);</div><div class="line">                    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,</div><div class="line">                                        <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">argv</span>[j],c-&gt;</span><span class="function"><span class="title">db</span>-&gt;</span>id);</div><div class="line">                    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;<span class="comment">//如果链表为空，从数据库删除链表</span></div><div class="line">                        <span class="function"><span class="title">dbDelete</span>(c-&gt;</span><span class="function"><span class="title">db</span>,c-&gt;</span>argv[j]);</div><div class="line">                        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">"del"</span>,</div><div class="line">                                            <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">argv</span>[j],c-&gt;</span><span class="function"><span class="title">db</span>-&gt;</span>id);</div><div class="line">                    &#125;</div><div class="line">                 <span class="comment">/* 省略一部分 */</span></div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">/* 如果链表为空，则阻塞客户端 */</span></div><div class="line">        <span class="function"><span class="title">blockForKeys</span>(c, c-&gt;</span><span class="function"><span class="title">argv</span> + 1, c-&gt;</span>argc - <span class="number">2</span>, timeout, NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以看出，brpop可以操作多个链表变量，例如brpop list1 list2 0，但是只能输出第一个有元素的链表。如果list1没有元素，而list2有元素，则输出list2的元素；如果两个都有元素，则输出list1的元素；如果都没有元素，则等待其中某个链表插入一个元素，之后在2返回。最后调用blockForyKeys阻塞
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">void blockForKeys(redisClient *c, robj **keys, <span class="keyword">int</span> numkeys, mstime_t timeout, robj *target) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    <span class="keyword">list</span> *l;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">    c-&gt;bpop.timeout = timeout;<span class="comment">//超时时间赋值给客户端blockingState属性</span></div><div class="line">    c-&gt;bpop.target = target;<span class="comment">//这属性适用于brpoplpush命令的输入对象，如果是brpop,    //则target为空</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">NULL</span>) incrRefCount(target);<span class="comment">//不为空，增加引用计数</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</div><div class="line">        <span class="comment">/* 将阻塞的key存入c.bpop.keys字典中 */</span></div><div class="line">        <span class="keyword">if</span> (dictAdd(c-&gt;bpop.keys,keys[j],<span class="keyword">NULL</span>) != DICT_OK) <span class="keyword">continue</span>;</div><div class="line">        incrRefCount(keys[j]);</div><div class="line"></div><div class="line">        <span class="comment">/* And in the other "side", to map keys -&gt; clients */</span></div><div class="line">        <span class="comment">//将阻塞的key和客户端添加进c-&gt;db-&gt;blocking_keys</span></div><div class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</div><div class="line">        <span class="keyword">if</span> (de == <span class="keyword">NULL</span>) &#123;</div><div class="line">            <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">            <span class="comment">/* For every key we take a list of clients blocked for it */</span></div><div class="line">            l = listCreate();</div><div class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</div><div class="line">            incrRefCount(keys[j]);</div><div class="line">            redisAssertWithInfo(c,keys[j],retval == DICT_OK);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            l = dictGetVal(de);</div><div class="line">        &#125;</div><div class="line">        listAddNodeTail(l,c);<span class="comment">//添加到阻塞键的客户点链表中</span></div><div class="line">    &#125;</div><div class="line">    blockClient(c,REDIS_BLOCKED_LIST);<span class="comment">//设置客户端阻塞标志</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>blockClient函数只是简单的设置客户端属性，如下
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void blockClient(redisClient *c, int btype) &#123;</div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span>flags |= REDIS_BLOCKED;<span class="comment">//设置标志</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span>btype = btype;<span class="comment">//阻塞操作类型</span></div><div class="line">    server.bpop_blocked_clients++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于这个函数之后，brpop命令执行函数就结束了，由于没有给客户端发送消息，所以客户端就阻塞在read调用中。那么如何解开客户端的阻塞了？</p>
<h1>插入一个元素解阻塞</h1>
<p>任何指令的执行函数都是在processCommand函数中调用call函数，然后在call函数中调用命令执行函数，lpush也一样。当执行完lpush之后，此时链表不为空，回到processCommand调用中，执行以下语句
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (<span class="name">listLength</span>(<span class="name">server</span>.ready_keys))</div><div class="line">          handleClientsBlockedOnLists()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>这两行代码是先检查server.ready_keys是否为空，如果不为空，说明已经有一些就绪的链表，此时可以判断是否有客户端阻塞在这个键值上，如果有，则唤醒；现在问题又来了，这个server.ready_keys在哪更新链表了？</p>
<p>原来是在dbAdd函数中，当往数据库中添加的值类型为REDIS-LIST时，这时就要调用signalListAsReady函数将链表指针添加进server.ready_keys:
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//db.c</span></div><div class="line">void dbAdd(redisDb *db, robj *<span class="built_in">key</span>, robj *val) &#123;</div><div class="line">    sds copy = sdsdup(<span class="built_in">key</span>-&gt;ptr);</div><div class="line">    int retval = dictAdd(db-&gt;dict, copy, val);<span class="comment">//将数据添加进数据库</span></div><div class="line"></div><div class="line">    redisAssertWithInfo(<span class="built_in">NULL</span>,<span class="built_in">key</span>,retval == REDIS_OK);</div><div class="line">    <span class="comment">//判断是否为链表类型，如果是，调用有链表已经ready函数</span></div><div class="line">    <span class="keyword">if</span> (val-&gt;<span class="built_in">type</span> == REDIS_LIST) signalListAsReady(db, <span class="built_in">key</span>);</div><div class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(<span class="built_in">key</span>);</div><div class="line"> &#125;</div><div class="line"><span class="comment">//t_list.c</span></div><div class="line">void signalListAsReady(redisDb *db, robj *<span class="built_in">key</span>) &#123;</div><div class="line">    readyList *rl;</div><div class="line"></div><div class="line">    <span class="comment">/* 没有客户端阻塞在这个键上，则直接返回. */</span></div><div class="line">    <span class="keyword">if</span> (dictFind(db-&gt;blocking_keys,<span class="built_in">key</span>) == <span class="built_in">NULL</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 这个键已近被唤醒了，所以没必要重新入队 */</span></div><div class="line">    <span class="keyword">if</span> (dictFind(db-&gt;ready_keys,<span class="built_in">key</span>) != <span class="built_in">NULL</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Ok, 除了上述两情况，把这个键放入server.ready_keys */</span></div><div class="line">    rl = zmalloc(sizeof(*rl));</div><div class="line">    rl-&gt;<span class="built_in">key</span> = <span class="built_in">key</span>;</div><div class="line">    rl-&gt;db = db;</div><div class="line">    incrRefCount(<span class="built_in">key</span>);</div><div class="line">    listAddNodeTail(server.ready_keys,rl);<span class="comment">//添加链表末尾</span></div><div class="line"></div><div class="line">    <span class="comment">/* We also add the key in the db-&gt;ready_keys dictionary in order</span></div><div class="line">     * to avoid adding it multiple times into a list with a simple O(1)</div><div class="line">     * check. */</div><div class="line">    incrRefCount(<span class="built_in">key</span>);</div><div class="line">    <span class="comment">//同时将这个阻塞键放入db-&gt;ready_keys</span></div><div class="line">    redisAssert(dictAdd(db-&gt;ready_keys,<span class="built_in">key</span>,<span class="built_in">NULL</span>) == DICT_OK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，这时server.ready_keys上已经有就绪键了，这时就调用processCommand函数中的handleClientsBlockedOnLists()函数来处理阻塞客户端,在这个函数中，
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">void handleClientsBlockedOnLists(void) &#123;</div><div class="line">    <span class="keyword">while</span>(listLength(server.ready_keys) != <span class="number">0</span>) &#123;</div><div class="line">        list *l;</div><div class="line">        <span class="comment">/* 将server.ready_keys赋给一个新的list,再将server.ready_keys清空  */</span></div><div class="line">        l = server.ready_keys;</div><div class="line">        server.ready_keys = listCreate();</div><div class="line">        <span class="comment">/* 迭代每一个就绪的每一个readyList  */</span></div><div class="line">        <span class="keyword">while</span>(listLength(l) != <span class="number">0</span>) &#123;</div><div class="line">            listNode *ln = listFirst(l);<span class="comment">//获取第一个就绪readyList</span></div><div class="line">            <span class="function"><span class="title">readyList</span> *rl = ln-&gt;</span>value;</div><div class="line"></div><div class="line">            <span class="comment">/* 从rl所属的数据库中删除rl */</span></div><div class="line">            <span class="function"><span class="title">dictDelete</span>(rl-&gt;</span><span class="function"><span class="title">db</span>-&gt;</span><span class="function"><span class="title">ready_keys</span>,rl-&gt;</span>key);</div><div class="line"></div><div class="line">            <span class="comment">/* 查询rl所属的数据库查找rl-&gt;key ,给阻塞客户端回复rl-&gt;key链表中的第一个元素*/</span></div><div class="line">            <span class="function"><span class="title">robj</span> *o = lookupKeyWrite(rl-&gt;</span><span class="function"><span class="title">db</span>,rl-&gt;</span>key);</div><div class="line">            <span class="function"><span class="title">if</span> (o != NULL &amp;&amp; o-&gt;</span>type == REDIS_LIST) &#123;</div><div class="line">                dictEntry *de;</div><div class="line"></div><div class="line">                <span class="comment">/* 在rl-&gt;db-&gt;blocking_keys查找阻塞在rl-&gt;key的客户端链表 */</span></div><div class="line">                <span class="function"><span class="title">de</span> = dictFind(rl-&gt;</span><span class="function"><span class="title">db</span>-&gt;</span><span class="function"><span class="title">blocking_keys</span>,rl-&gt;</span>key);</div><div class="line">                <span class="keyword">if</span> (de) &#123;</div><div class="line">                    list *clients = dictGetVal(de);<span class="comment">//转换为客户端链表</span></div><div class="line">                    int numclients = listLength(clients);</div><div class="line"></div><div class="line">                    <span class="keyword">while</span>(numclients--) &#123;<span class="comment">//给每个客户端发送消息</span></div><div class="line">                        listNode *clientnode = listFirst(clients);</div><div class="line">                        <span class="function"><span class="title">redisClient</span> *receiver = clientnode-&gt;</span>value;<span class="comment">//阻塞的客户端</span></div><div class="line">                        <span class="function"><span class="title">robj</span> *dstkey = receiver-&gt;</span>bpop.target;<span class="comment">//brpoplpush命令目的链表</span></div><div class="line">                        <span class="function"><span class="title">int</span> <span class="keyword">where</span> = (receiver-&gt;</span>lastcmd &amp;&amp;</div><div class="line">                                     <span class="function"><span class="title">receiver</span>-&gt;</span><span class="function"><span class="title">lastcmd</span>-&gt;</span>proc == blpopCommand) ?</div><div class="line">                                    REDIS_HEAD : REDIS_TAIL;<span class="comment">//获取取出的方向</span></div><div class="line">                        robj *value = listTypePop(o,<span class="keyword">where</span>);<span class="comment">//取出就绪链表的元素</span></div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (value) &#123;</div><div class="line">                            <span class="comment">/* Protect receiver-&gt;bpop.target, that will be</span></div><div class="line">                             * freed by the next unblockClient()</div><div class="line">                             * call. */</div><div class="line">                            <span class="keyword">if</span> (dstkey) incrRefCount(dstkey);</div><div class="line">                            unblockClient(receiver);<span class="comment">//设置客户端为非阻塞状态</span></div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (serveClientBlockedOnList(receiver,</div><div class="line">                                <span class="function"><span class="title">rl</span>-&gt;</span><span class="function"><span class="title">key</span>,dstkey,rl-&gt;</span>db,value,</div><div class="line">                                <span class="keyword">where</span>) == REDIS_ERR)</div><div class="line">                            &#123;</div><div class="line">                                <span class="comment">/* If we failed serving the client we need</span></div><div class="line">                                 * to also undo the POP operation. */</div><div class="line">                                    listTypePush(o,value,<span class="keyword">where</span>);</div><div class="line">                            &#125;<span class="comment">//给客户端回复链表中的元素内容</span></div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (dstkey) decrRefCount(dstkey);</div><div class="line">                            decrRefCount(value);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//如果链表为空，则从数据库中删除</span></div><div class="line">                <span class="function"><span class="title">if</span> (listTypeLength(o) == 0) dbDelete(rl-&gt;</span><span class="function"><span class="title">db</span>,rl-&gt;</span>key);</div><div class="line">                <span class="comment">/* We don't call signalModifiedKey() as it was already called</span></div><div class="line">                 * when an element was pushed on the list. */</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* 回收rl */</span></div><div class="line">            <span class="function"><span class="title">decrRefCount</span>(rl-&gt;</span>key);</div><div class="line">            zfree(rl);</div><div class="line">            listDelNode(l,ln);</div><div class="line">        &#125;</div><div class="line">        listRelease(l); <span class="comment">/* We have the new list on place at this point. */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个源码可知，如果有两个客户端，同时阻塞在一个链表上面，那么如果链表插入一个元素之后，只有先阻塞的那个客户端收到消息，后面阻塞的那个客户端继续阻塞，这也是先阻塞先服务的思想。handleClientsBlockedOnLists函数调用了unblockClient(receiver)，该函数功能为接触客户端阻塞标志，以及找到db阻塞在key上的客户端链表，并将接触阻塞的客户端从链表删除。然后调用serveClientBlockOnList给客户端回复刚在链表插入的元素。
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">serveClientBlockedOnList</span>(<span class="params">redisClient *receiver, robj *key, robj *dstkey, redisDb *db, robj *<span class="keyword">value</span>, <span class="keyword">int</span> <span class="keyword">where</span></span>)</span></div><div class="line">&#123;</div><div class="line">    robj *argv[<span class="number">3</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (dstkey == NULL) &#123;</div><div class="line">        <span class="comment">/* Propagate the [LR]POP operation. */</span></div><div class="line">        argv[<span class="number">0</span>] = (<span class="keyword">where</span> == REDIS_HEAD) ? shared.lpop :</div><div class="line">                                          shared.rpop;</div><div class="line">        argv[<span class="number">1</span>] = key;</div><div class="line">        propagate((<span class="keyword">where</span> == REDIS_HEAD) ?</div><div class="line">            server.lpopCommand : server.rpopCommand,</div><div class="line">            db-&gt;id,argv,<span class="number">2</span>,REDIS_PROPAGATE_AOF|REDIS_PROPAGATE_REPL);</div><div class="line"></div><div class="line">        <span class="comment">/* BRPOP/BLPOP */</span></div><div class="line">        addReplyMultiBulkLen(receiver,<span class="number">2</span>);</div><div class="line">        addReplyBulk(receiver,key);</div><div class="line">        addReplyBulk(receiver,<span class="keyword">value</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/* BRPOPLPUSH */</span></div><div class="line">          <span class="comment">/* 省略  */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>propagate函数主要是将命令信息发送给aof和slave。函数中省略部分是brpoplpush list list1 0命令的目的链表list1非空时，将从list链表pop出来的元素插入list1中。当给客户端发送消息之后，客户端就从read函数调用中返回，变为不阻塞。</p>
<h1>通过超时时间解阻塞</h1>
<p>如果链表一直没有数据插入，那么客户端将会一直阻塞下去，这肯定是不行的，所以brpop还支持超时阻塞，即阻塞时间超过一定值之后，服务器返回一个空值，这样客户端就解脱阻塞了。</p>
<p>对于时间超时，都放在了100ms执行一次的时间事件中；超时解脱阻塞函数也在serverCron中；在serverCron-&gt;clientsCron-&gt;clientsCronHandleTimeout
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int clientsCronHandleTimeout(redisClient *<span class="built_in">c</span>, mstime_t now_ms) &#123;</div><div class="line">    time_t now = now_ms/<span class="number">1000</span>;</div><div class="line">    <span class="comment">//..........</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;flags &amp; <span class="type">REDIS_BLOCKED</span>) &#123;</div><div class="line">        <span class="comment">/* Blocked OPS timeout is handled with milliseconds resolution.</span></div><div class="line">         * However note that the actual resolution is limited by</div><div class="line">         * server.hz. */</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;bpop.timeout != <span class="number">0</span> &amp;&amp; <span class="built_in">c</span>-&gt;bpop.timeout &lt; now_ms) &#123;</div><div class="line">            <span class="comment">/* Handle blocking operation specific timeout. */</span></div><div class="line">            replyToBlockedClientTimedOut(<span class="built_in">c</span>);</div><div class="line">            unblockClient(<span class="built_in">c</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//.............</span></div></pre></td></tr></table></figure></p>
<p>把这个函数不相干的代码删除，主要部分先判断这个客户端是否阻塞，如果是，超时时间是否到期，如果是，则调用replyToBlockedClientTimedOut给客户端回复一个空回复，以及接触客户端阻塞。</p>
<p>链表消息队列实现暂时分析到这，下篇文章分析下订阅与发布。</p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码分析之命令处理过程]]></title>
      <url>http://luodw.cc/2016/02/05/redis-procCom/</url>
      <content type="html"><![CDATA[<h1>命令执行过程</h1>
<p>这篇文章分析下客户端连接redis服务器，并且输入命令之后，redis服务器做了什么。这里以最基础的set命令为例。</p>
<h1>客户端连接服务器</h1>
<p>要分析客户端是如何连接服务器，即客户端调用connect之后，服务器做了啥，首先就是看下监听listenfd可读事件(listenfd永远为可读事件，等有客户端connect之后，此时产生可读事件)的回调函数acceptTcpHandler
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//networking.c</span></div><div class="line"><span class="comment">/* ------------------------------------------------------------------------- */</span></div><div class="line"><span class="keyword">void</span> acceptTcpHandler(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask) &#123;</div><div class="line">    <span class="keyword">int</span> cport, cfd, <span class="built_in">max</span> = MAX_ACCEPTS_PER_CALL;</div><div class="line">    <span class="keyword">char</span> cip[REDIS_IP_STR_LEN];</div><div class="line">    REDIS_NOTUSED(el);</div><div class="line">    REDIS_NOTUSED(mask);</div><div class="line">    REDIS_NOTUSED(privdata);</div><div class="line"></div><div class="line">    <span class="built_in">while</span>(<span class="built_in">max</span>--) &#123;</div><div class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</div><div class="line">        <span class="built_in">if</span> (cfd == ANET_ERR) &#123;</div><div class="line">            <span class="built_in">if</span> (errno != EWOULDBLOCK)</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</div><div class="line">            <span class="built_in">return</span>;</div><div class="line">        &#125;</div><div class="line">        redisLog(REDIS_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</div><div class="line">        acceptCommonHandler(cfd,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>常量MAX_ACCEPTS_PER_CALL=1000，所以对于listenfd一次可读事件，可以接收最多1000个客户端。这个回调函数先调用anetTcpAccept函数，accept客户端socket，接着把accept接收的客户端cfd传递给函数acceptCommonHandler处理
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> acceptCommonHandler(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags) &#123;</div><div class="line">    redisClient *c;</div><div class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == NULL) &#123;</div><div class="line">        redisLog(REDIS_WARNING,</div><div class="line">            <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</div><div class="line">            strerror(errno),fd);</div><div class="line">        close(fd); <span class="comment">/* May be already closed, just ignore errors */</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (listLength(<span class="keyword">server</span>.clients) &gt; <span class="keyword">server</span>.maxclients) &#123;</div><div class="line">        <span class="keyword">char</span> *err = <span class="string">"-ERR max number of clients reached\r\n"</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* That's a best effort error message, don't check write errors */</span></div><div class="line">        <span class="keyword">if</span> (write(c-&gt;fd,err,strlen(err)) == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">server</span>.stat_rejected_conn++;</div><div class="line">        freeClient(c);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">server</span>.stat_numconnections++;</div><div class="line">    c-&gt;flags |= flags;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数先是调用createClient创建一个redisClient，每一个客户端fd对应一个redisClient，用于存储读取的操作命令以及缓存输出的结果。然后就是判断客户端数量是否超出事先定义的个数，如果是则向客户端回复一个错误信息，并且回收这个redisClient。接下来主要看下创建redisClient函数
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">redisClient *createClient(int fd) &#123;</div><div class="line">    redisClient *<span class="built_in">c</span> = zmalloc(<span class="built_in">sizeof</span>(redisClient));</div><div class="line"></div><div class="line">    <span class="comment">/* passing -1 as fd it is possible to create a non connected client.</span></div><div class="line">     * This is useful since all the Redis commands needs to be executed</div><div class="line">     * in the context of a client. When commands are executed in other</div><div class="line">     * contexts (for instance a Lua script) we need a non connected client. */</div><div class="line">    <span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</div><div class="line">        anetNonBlock(<span class="type">NULL</span>,fd);</div><div class="line">        anetEnableTcpNoDelay(<span class="type">NULL</span>,fd);</div><div class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</div><div class="line">            anetKeepAlive(<span class="type">NULL</span>,fd,server.tcpkeepalive);</div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,<span class="type">AE_READABLE</span>,</div><div class="line">            readQueryFromClient, <span class="built_in">c</span>) == <span class="type">AE_ERR</span>)</div><div class="line">        &#123;</div><div class="line">            close(fd);</div><div class="line">            zfree(<span class="built_in">c</span>);</div><div class="line">            <span class="keyword">return</span> <span class="type">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    selectDb(<span class="built_in">c</span>,<span class="number">0</span>);<span class="comment">//初始化为0数据库，默认16个</span></div><div class="line">    <span class="built_in">c</span>-&gt;id = server.next_client_id++;</div><div class="line">    <span class="built_in">c</span>-&gt;fd = fd;</div><div class="line">    <span class="comment">/* 省略初始化redisClient各个属性部分 */</span></div><div class="line">    <span class="keyword">if</span> (fd != -<span class="number">1</span>) listAddNodeTail(server.clients,<span class="built_in">c</span>);<span class="comment">//加入server.clients客户端链表末尾</span></div><div class="line">    initClientMultiState(<span class="built_in">c</span>);<span class="comment">//初始化事物机制属性</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">c</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注释中也有说明当fd==-1时，可用于lua 脚本执行脚本。如果不是-1，则说明是客户端连接，这时设置为非阻塞，允许Nagle算法，TCP默认是禁止的。如果需要，开启keepalive设置。接着在这个fd上创建可读事件，等待客户端发送命令。以上就是redis客户端连接的过程。</p>
<h1>服务器执行命令过程</h1>
<p>当客户端连上服务器之后，接下来，就会向服务器发送执行命令。这时，就要从客户端fd的回调函数readQueryFromClient开始分析:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) &#123;</div><div class="line">    redisClient *c = (redisClient*) privdata;</div><div class="line">    int nread, readlen;</div><div class="line">    size_t qblen;</div><div class="line">    server.current_client = c;</div><div class="line">    readlen = REDIS_IOBUF_LEN;</div><div class="line">    <span class="function"><span class="title">qblen</span> = sdslen(c-&gt;</span>querybuf);</div><div class="line">    <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">querybuf_peak</span> &lt; qblen) c-&gt;</span>querybuf_peak = qblen;</div><div class="line">    <span class="comment">//为查询缓冲区分配内存空间</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">querybuf</span> = sdsMakeRoomFor(c-&gt;</span>querybuf, readlen);</div><div class="line">    <span class="comment">/* 读取客户端发送的命令  */</span></div><div class="line">    <span class="function"><span class="title">nread</span> = read(fd, c-&gt;</span>querybuf+qblen, readlen);</div><div class="line"></div><div class="line">    <span class="comment">/* 省略...... */</span></div><div class="line">    processInputBuffer(c);<span class="comment">//处理输入的命令字符串，</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>redis命令有分为单结果回复和多结果回复，例如get命令，就是获取一个键的value,即为单回复；lrange命令就是获取列表某一范围的元素，即为多结果回复。具体参考<a href="http://www.redis.cn/topics/protocol.html" target="_blank" rel="external">redis官网</a>。这里说下最简单的set mykey myvalue命令格式，这个命令会被转化为如下单引号字符串:
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">"*3<span class="symbol">\r</span><span class="symbol">\n</span>$3<span class="symbol">\r</span><span class="symbol">\n</span>SET<span class="symbol">\r</span><span class="symbol">\n</span>$5<span class="symbol">\r</span><span class="symbol">\n</span>mykey<span class="symbol">\r</span><span class="symbol">\n</span>$7<span class="symbol">\r</span><span class="symbol">\n</span>myvalue<span class="symbol">\r</span><span class="symbol">\n</span>"</div></pre></td></tr></table></figure></p>
<p>这个是二进制安全的命令字符串格式，每个参数之前都有这个参数的字节数，这样及时碰到'\0'，也会按普通字符处理。在processInputBuffer函数中调用processMultibulkBuffer。redis还支持旧式命令字符串格式，这些字符串格式只有空格作为分隔符，所以如果碰到'\0'，字符串会提前终止，是二进制不安全的，在processInputBuffer中调用processInlineBuffer处理。通常在客户端为telnet时产生不安全的二进制字符串，可以在redis-cli和telnet分别分发送ping命令，并用tcpdump查看字节数即可知道。</p>
<ol>
<li>当使用telnet客户端，输入命令为ping时，tcpdump输出如下:
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">18<span class="selector-pseudo">:21</span><span class="selector-pseudo">:39.609411</span> <span class="selector-tag">IP</span> <span class="selector-tag">localhost</span><span class="selector-class">.37721</span> &gt; <span class="selector-tag">localhost</span><span class="selector-class">.6379</span>: <span class="selector-tag">Flags</span> <span class="selector-attr">[P.]</span>, <span class="selector-tag">seq</span> 2174951300<span class="selector-pseudo">:2174951306</span>, <span class="selector-tag">ack</span> 1980339778, <span class="selector-tag">win</span> 342, <span class="selector-tag">options</span> <span class="selector-attr">[nop,nop,TS val 7060488 ecr 7050263]</span>, <span class="selector-tag">length</span> 6</div></pre></td></tr></table></figure></li>
</ol>
<p>发出的字符串长度为6，说明字符串格式为&quot;ping\r\n&quot;;</p>
<ol start="2">
<li>当使用redis自带客户端，即redis-cli时，tcpdump输出如下:
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">18<span class="selector-pseudo">:26</span><span class="selector-pseudo">:17.986651</span> <span class="selector-tag">IP</span> <span class="selector-tag">localhost</span><span class="selector-class">.37728</span> &gt; <span class="selector-tag">localhost</span><span class="selector-class">.6379</span>: <span class="selector-tag">Flags</span> <span class="selector-attr">[P.]</span>, <span class="selector-tag">seq</span> 26<span class="selector-pseudo">:40</span>, <span class="selector-tag">ack</span> 41, <span class="selector-tag">win</span> 342, <span class="selector-tag">options</span> <span class="selector-attr">[nop,nop,TS val 7130083 ecr 7129312]</span>, <span class="selector-tag">length</span> 14</div></pre></td></tr></table></figure></li>
</ol>
<p>这时发出的字符串长度为14，此时的字符串格式为&quot;*1\r\n$4\r\nping\r\n&quot;</p>
<p>在processInputBuffer函数中调用processMultibulkBuffer，将c-&gt;querybuf中的命令二进制字符串分解为字符串数组，并保存在redisClient属性中，例如
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">"*3<span class="symbol">\r</span><span class="symbol">\n</span>$3<span class="symbol">\r</span><span class="symbol">\n</span>SET<span class="symbol">\r</span><span class="symbol">\n</span>$5<span class="symbol">\r</span><span class="symbol">\n</span>mykey<span class="symbol">\r</span><span class="symbol">\n</span>$7<span class="symbol">\r</span><span class="symbol">\n</span>myvalue<span class="symbol">\r</span><span class="symbol">\n</span>"</div><div class="line">分割成字符数组保存在redisCLient数组中:</div><div class="line">c-&gt;argv[0]="set",c-&gt;argv[1]="mykey",c-&gt;argv[2]="myvalue"</div><div class="line">c-&gt;argc=3</div></pre></td></tr></table></figure></p>
<p>接下来就调用processCommand(c)来处理这个命令，在这个函数中，分别讨论了很多中情况，例如是否集群模式。是否为事务执行等等，最关键的一行是
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">call</span><span class="comment">(c,REDIS_CALL_FULL)</span>;</div></pre></td></tr></table></figure></p>
<p>在call函数中，分别讨论了不同情况，我们也是找到最关键的一行代码:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">cmd</span>-&gt;</span>proc(c);</div></pre></td></tr></table></figure></p>
<p>这行代码调用了当前执行命令的命令执行函数，对于set命令为setCommand函数,而set命令也有几种，例如set [nx][xx][ex &lt;seconds&gt;][px&lt;milliseconds&gt;],在这里，我们先关注最简单的set key value格式，在setCommand函数中调用setGenericCommand,在后者函数内部，调用
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setKey(c-&gt;db,key,val);</div><div class="line">addReply(c, ok_reply ? ok_reply : shared.ok);</div></pre></td></tr></table></figure></p>
<p>setkey函数先查找db中是否有含有key的键值对，如果没有，则添加，如果有，则覆盖。最后调用addReply回复客户端。</p>
<h1>回复客户端</h1>
<p>当有需要返回给客户端时，调用addReply函数，在该函数中，先调用prepareClientToWrite函数给fd注册一个写事件，然后将回复字符串写进redisCLient输出缓存c-&gt;buf
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int prepareClientToWrite(redisClient *<span class="built_in">c</span>) &#123;</div><div class="line">    <span class="comment">/*  ......    */</span></div><div class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, <span class="built_in">c</span>-&gt;fd, <span class="type">AE_WRITABLE</span>,</div><div class="line">                sendReplyToClient, <span class="built_in">c</span>) == <span class="type">AE_ERR</span>)</div><div class="line">        &#123;</div><div class="line">            freeClientAsync(<span class="built_in">c</span>);</div><div class="line">            <span class="keyword">return</span> <span class="type">REDIS_ERR</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>这样在下一次事件循环中，即可通知c-&gt;fd可写事件，调用可写事件的回调函数sendReplyToClient，在该回调函数中，最要几行代码如下
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* .............  */</span></div><div class="line"><span class="function"><span class="title">nwritten</span> = write(fd,c-&gt;</span><span class="function"><span class="title">buf</span>+c-&gt;</span><span class="function"><span class="title">sentlen</span>,c-&gt;</span><span class="function"><span class="title">bufpos</span>-c-&gt;</span>sentlen);</div><div class="line"><span class="comment">/* ..............  */</span></div><div class="line">  <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">bufpos</span> == 0 &amp;&amp; listLength(c-&gt;</span>reply) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>sentlen = <span class="number">0</span>;</div><div class="line">        <span class="function"><span class="title">aeDeleteFileEvent</span>(server.el,c-&gt;</span>fd,AE_WRITABLE);</div><div class="line"></div><div class="line">        <span class="comment">/* Close connection after entire reply has been sent. */</span></div><div class="line">        <span class="function"><span class="title">if</span> (c-&gt;</span>flags &amp; REDIS_CLOSE_AFTER_REPLY) freeClient(c);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>先是调用系统调用write将输出缓冲区的数据返回给客户端，最后再将这个客户端的写事件删除，因为以无数据可写，但是读事件还在，等待客户端下一次输入命令。</p>
<p>到这里，一次命令执行就结束了，这里只是介绍简单的set命令，不同的命令执行函数不同，但是大部分命令执行流程都是一样的。</p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码分析之启动过程]]></title>
      <url>http://luodw.cc/2016/02/01/redis-startup/</url>
      <content type="html"><![CDATA[<p>今天这篇文章主要是分析下redis的启动流程，作为一个完整的软件，分析开启过程主要是分析main函数，当然，这主要还是在对redis有一定的了解，否则很难读懂redis的各个函数。</p>
<p>redis服务器所有属性都保存在struct redisServer这个结构体中，所以服务器一开始时，首先是先初始化服务器属性，然后在建立事件驱动，将listenfd可读事件添加进EventLoop事件驱动中，等待客户端连接，然后服务器处于事件驱动的无限循环中。</p>
<p>在main函数中，首先做的就是为改服务器进程标题做好初始化操作。首先调用 spt_init(argc, argv);再调用 redisSetProcTitle(argv[0]);修改标题。我们都知道argv[0]就是进程的名称，是否可以直接修改了？</p>
<p>首先需要说明一点就是linux进程栈上面还有main函数参数和环境变量指针，都为字符数组指针，以NULL结尾，而且argv[]参数和environ参数是在连续内存中，这样一来，如果新的进程名称长度大于旧的argv[0]，那么就会改变argv[1]的值。所以redis采用的方法是先将[argv[1],argv[argc-1]]参数和environ的值移到另一块内存块，然后再对argv[0]进行赋值，此时argv[0]拥有原argv和environ所有内存。</p>
<p>接下来分析下重要的几个设置。</p>
<h1>initServerConfig函数</h1>
<p>这个函数主要就是初始化server结构体，这个结构体有大量的属性，这里说下几个重要属性。</p>
<ol>
<li>server.lruclock=getLRUClock();这个为redis运行时钟，主要是用于判断键值队是否到期，代码如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mstime()函数返回unix时间毫秒数</span></div><div class="line"><span class="comment">//#define REDIS_LRU_BITS 24</span></div><div class="line"><span class="comment">//#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;lru */</span></div><div class="line"><span class="comment">//#define REDIS_LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLRUClock</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (mstime()/REDIS_LRU_CLOCK_RESOLUTION) &amp; REDIS_LRU_CLOCK_MAX;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>这个REDIS_LRU_CLOCK_RESOLUTION常量主要是unix运行时钟精度，这里值为1000ms，所以 (mstime()/REDIS_LRU_CLOCK_RESOLUTION)所得值最后三位为0，即精度为秒。即server.lruclock为unix某个时间点的秒数。</p>
<ol start="2">
<li>将命令列表挂到server属性中。
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.commands = <span class="keyword">dictCreate(&amp;commandTableDictType,NULL);</span></div><div class="line">server.<span class="keyword">orig_commands </span>= <span class="keyword">dictCreate(&amp;commandTableDictType,NULL);</span></div><div class="line">populateCommandTable()<span class="comment">;</span></div></pre></td></tr></table></figure></li>
</ol>
<p>populateCommandTable()函数将命令数组redisCommandTable中的所有命令添加到server.commands和server.orig_commands。因为在redis.conf可能被rename命令改变，所以需要在server.orig_commands再保存一份命令表。</p>
<h1>从命令行和redis.conf读取配置项</h1>
<p>初始化好server之后，接下来redis读取用户设置选项，然后对server属性重新赋值。代码如下:
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</div><div class="line">        int j = <span class="number">1</span>; <span class="regexp">/* argv第一个选项 */</span></div><div class="line">        sds options = sdsempty();</div><div class="line">        char *configfile = NULL;<span class="regexp">//</span>配置文件路径</div><div class="line"></div><div class="line">        <span class="regexp">/* H处理特殊选项 --help 和 --version */</span></div><div class="line">        <span class="keyword">if</span> (strcmp(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</div><div class="line">            strcmp(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) version();</div><div class="line">        <span class="keyword">if</span> (strcmp(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</div><div class="line">            strcmp(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) usage();</div><div class="line">        <span class="keyword">if</span> (strcmp(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</div><div class="line">                memtest(atoi(argv[<span class="number">2</span>]),<span class="number">50</span>);</div><div class="line">                <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                fprintf(stderr,<span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</div><div class="line">                fprintf(stderr,<span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</div><div class="line">                <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>这段代码先是处理一些特殊的选项，例如版本，帮助和内存测试。而且这些选项函数执行之后，redis服务器就退出。而且我也发现，在linux下面，完整选项必须加'--'，而缩写选项加'-'。</p>
<p>接下来就是读取真正的配置项。</p>
<p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 判断第一个参数是否为配置文件 */</span></div><div class="line">     <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>)</div><div class="line">         configfile = argv[j++];<span class="comment">//如果是，赋值给configfile，并将j+1，开始解析第二个参数</span></div><div class="line"><span class="keyword">while</span>(j != argc) &#123;</div><div class="line">         <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</div><div class="line">             <span class="comment">/* (1)选项的名称 */</span></div><div class="line">             <span class="keyword">if</span> (sdslen(<span class="keyword">options</span>)) <span class="keyword">options</span> = sdscat(<span class="keyword">options</span>,<span class="string">"\n"</span>);</div><div class="line">             <span class="keyword">options</span> = sdscat(<span class="keyword">options</span>,argv[j]+<span class="number">2</span>);</div><div class="line">             <span class="keyword">options</span> = sdscat(<span class="keyword">options</span>,<span class="string">" "</span>);</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             <span class="comment">/* (2)选项的值 */</span></div><div class="line">             <span class="keyword">options</span> = sdscatrepr(<span class="keyword">options</span>,argv[j],strlen(argv[j]));</div><div class="line">             <span class="keyword">options</span> = sdscat(<span class="keyword">options</span>,<span class="string">" "</span>);</div><div class="line">         &#125;</div><div class="line">         j++;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>根据源码，配置文件只能在第二个参数(第一个为程序名称)，然后跟着配置文件后面可以是各个配置选项，都存储在option字符串中。加入有一个配置项是--port 6380，那么在option字符串会添加&quot;port 6380\n&quot;。然后调用函数 loadServerConfig(configfile,options);将文件读进内存，并给server赋值:
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> loadServerConfig(<span class="keyword">char</span> *filename, <span class="keyword">char</span> *options) &#123;</div><div class="line">    sds <span class="built_in">config</span> = sdsempty();</div><div class="line">    <span class="keyword">char</span> buf[REDIS_CONFIGLINE_MAX+<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* 读取配置文件的内容 */</span></div><div class="line">    <span class="built_in">if</span> (filename) &#123;</div><div class="line">        FILE *fp;</div><div class="line"></div><div class="line">        <span class="built_in">if</span> (filename[<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; filename[<span class="number">1</span>] == <span class="string">'\0'</span>) &#123;</div><div class="line">            fp = stdin;<span class="comment">//配置文件为空，则从标准输入读取</span></div><div class="line">        &#125; <span class="built_in">else</span> &#123;</div><div class="line">            <span class="built_in">if</span> ((fp = fopen(filename,<span class="string">"r"</span>)) == NULL) &#123;</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    <span class="string">"Fatal error, can't open config file '%s'"</span>, filename);</div><div class="line">                exit(<span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">while</span>(fgets(buf,REDIS_CONFIGLINE_MAX+<span class="number">1</span>,fp) != NULL)</div><div class="line">            <span class="built_in">config</span> = sdscat(<span class="built_in">config</span>,buf);<span class="comment">//将配置文件的每一行读取进config字符串</span></div><div class="line">        <span class="built_in">if</span> (fp != stdin) fclose(fp);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Append the additional options */</span></div><div class="line">    <span class="built_in">if</span> (options) &#123;</div><div class="line">        <span class="built_in">config</span> = sdscat(<span class="built_in">config</span>,<span class="string">"\n"</span>);</div><div class="line">        <span class="built_in">config</span> = sdscat(<span class="built_in">config</span>,options);<span class="comment">//将options接着配置文件字符串后面</span></div><div class="line">    &#125;</div><div class="line">　　<span class="comment">//最后读取config字符串，将配置项赋值给server</span></div><div class="line">    loadServerConfigFromString(<span class="built_in">config</span>);</div><div class="line">    sdsfree(<span class="built_in">config</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这段代码即可得知，命令行参数配置选项是跟在配置文件之后的，所以如果命令行参数配置选项和配置文件有同样的配置，则命令行参数选项会覆盖配置文件中的配置选项。 loadServerConfigFromString(config);这个函数代码比较长，主要就是比较配置选项名称，给server属性赋值。</p>
<p>接下来主要就是分析initServer()函数</p>
<h1>initServer函数</h1>
<p>这个函数非常重要，主要就是在服务器进入事件循环之前，做的一些工作，例如忽略SIGHUP,SIGPIPE信号，监听listenfd并加入Eventloop,以及监听unix域并加入Eventloop等等。</p>
<ol>
<li>
<p>创建EventLoop实例 事件监听的文件描述符个数为客户端数量的最大值+预留值。
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">server</span>.el = aeCreateEventLoop(<span class="keyword">server</span>.maxclients+REDIS_EVENTLOOP_FDSET_INCR);</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>获取监听的ip数组以及个数
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</div><div class="line">       listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == REDIS_ERR)</div><div class="line">       <span class="keyword">exit</span>(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这个函数主要做的就是先判断用户是否有提供监听地址，如果没有，则监听0,0,0,0地址，即INADDR_ANY，也就是所有地址。并监听0,0,0,0的ipv4和ipv6地址，并设置为非阻塞；如果有设置监听地址，可以是一个地址队列，则只监听用户自己设置的ip地址队列。最后server.ipfd为监听套接字数组，server.ipfd_count为套接字数组个数。</p>
<ol start="3">
<li>设置unix域套接字监听
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">server</span>.unixsocket != <span class="literal">NULL</span>) &#123;</div><div class="line">       unlink(<span class="built_in">server</span>.unixsocket); /* 防止unix套接字文件存在 */</div><div class="line">       <span class="built_in">server</span>.sofd = anetUnixServer(<span class="built_in">server</span>.neterr,<span class="built_in">server</span>.unixsocket,</div><div class="line">           <span class="built_in">server</span>.unixsocketperm, <span class="built_in">server</span>.tcp_backlog);</div><div class="line">       <span class="keyword">if</span> (<span class="built_in">server</span>.sofd == ANET_ERR) &#123;</div><div class="line">           redisLog(REDIS_WARNING, <span class="string">"Opening Unix socket: %s"</span>, <span class="built_in">server</span>.neterr);</div><div class="line">           <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">       &#125;</div><div class="line">       anetNonBlock(<span class="literal">NULL</span>,<span class="built_in">server</span>.sofd);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>anetUnixServer函数主要工作就是创建unix域套接字，并返回文件描述符sofd。因为在创建域套接字时，会创建文件，所以需要先unlink这个文件，防止已经存在了。</p>
<ol start="4">
<li>
<p>更新unix缓存时间
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateCachedTime</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    server.unixtime = time(<span class="literal">NULL</span>);<span class="comment">//以秒数为单位</span></div><div class="line">    server.mstime = mstime();<span class="comment">//以毫秒为单位</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>创建时间事件和网络事件
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span>时间事件</div><div class="line">  <span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, NULL, NULL) == AE_ERR) &#123;</div><div class="line">        redisPanic(<span class="string">"Can't create the serverCron time event."</span>);</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"><span class="regexp">//</span>文件描述符事件</div><div class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</div><div class="line">            acceptTcpHandler,NULL) == AE_ERR)</div><div class="line">            &#123;</div><div class="line">                redisPanic(</div><div class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"><span class="regexp">//</span>域套接字文件描述符事件</div><div class="line"><span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</div><div class="line">        acceptUnixHandler,NULL) == AE_ERR) redisPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这个没啥好说的，因为之前有介绍过Mainae模块，就是调用相应函数，但是要关注下回调函数，这个等后面分析。还有一个就是时间事件的回调函数，非常重要，在redis运行期间，每一秒执行一次，后面再分析。</p>
<ol start="6">
<li>一些初始化</li>
</ol>
<p>例如如果有必要打开aof文件，lua脚本环境初始化，慢日志初始化等待。</p>
<p>initServer函数结束之后，调用aeMain()函数进入事件驱动循环，到此为止，redis服务器就运行起来了，等客户端的连接。接下来要分析redis时间事件回调函数serverCron，每秒执行一次，非常重要，很多都基于这个回调函数更新。</p>
<h1>serverCron</h1>
<p>像memecache的时间事件主要是更新时间戳，而且是每秒执行一次，所以秒数就一秒一秒更新，因为需要用当前时间来判断键值对item是否过期。而redis的时间事件第一次是1毫秒执行，后面就是100毫秒执行一次。serverCron除了更新时间外，还做了很多工作:</p>
<ol>
<li>更新时间缓存
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> /<span class="bullet">* Update the time cache. *</span>/</div><div class="line"><span class="code">    updateCachedTime();</span></div><div class="line">//<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></div><div class="line">void updateCachedTime(void) &#123;</div><div class="line"><span class="code">    server.unixtime = time(NULL);</span></div><div class="line"><span class="code">    server.mstime = mstime();</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>主要是因为后期有大量需要获取时间的情况，如果每次都调用time(NULL)，那么将降低系统的性能，所以在server全局变量中缓存时间，这样以后每次就可以从这获取时间了。</p>
<ol start="2">
<li>跟新LRU时钟
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.lruclock = getLRUClock()<span class="comment">;</span></div></pre></td></tr></table></figure></li>
</ol>
<p>更新时钟缓存，减少time系统调用.</p>
<ol start="3">
<li>
<p>更新内存使用的最大值
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Record the max memory used since the server was started. */</span></div><div class="line">   <span class="keyword">if</span> (zmalloc_used_memory() &gt; <span class="keyword">server</span>.stat_peak_memory)</div><div class="line">       <span class="keyword">server</span>.stat_peak_memory = zmalloc_used_memory();</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>更新常驻内存的大小
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Sample the RSS here since this is a relatively slow call. */</span></div><div class="line">    <span class="keyword">server</span>.resident_set_size = zmalloc_get_rss();</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这个函数其实取出/proc/&lt;pid&gt;/stat文件第23个选项，然后乘以内存页的大小即为常驻内存的大小。</p>
<ol start="5">
<li>优雅执行shutdown
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (server.shutdown_asap) &#123;</div><div class="line">       <span class="keyword">if</span> (prepareForShutdown(<span class="number">0</span>) == REDIS_OK) <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">       redisLog(REDIS_WARNING,<span class="string">"SIGTERM received but errors trying to shut down the server, check the logs for more information"</span>);</div><div class="line">       server.shutdown_asap = <span class="number">0</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>当执行shutdown命令时或者产生SIGINT或者SIGTERM信号，不是直接exit退出程序，而是设置server.shutdown_asap=1，然后在时间事件中，调用prepareForShutdown函数，先准一些关闭前的操作，例如刷新aof和rdb文件，关闭监听描述符等等,最后再关闭。</p>
<ol start="6">
<li>
<p>展示一些非空数据库信息</p>
</li>
<li>
<p>如果是sentinel模式，展示客户端连接信息</p>
</li>
<li>
<p>处理客户端信息
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* We need <span class="keyword">to</span> do a few operations <span class="keyword">on</span> clients asynchronously. */</div><div class="line">  clientsCron();</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>主要就是判断是否有客户端空闲时间超过一定值，即keepalive设置的，有的话，删除。</p>
<ol start="9">
<li>更新数据库信息
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* Handle background operations <span class="keyword">on</span> Redis databases. */</div><div class="line">   databasesCron();</div></pre></td></tr></table></figure></li>
</ol>
<p>主要就是哈希表扩容</p>
<ol start="10">
<li>
<p>调度aof或者rdb读写子进程</p>
</li>
<li>
<p>复制同步，集群同步，sentinel定时器</p>
</li>
</ol>
<p>定时事件做的事情很多，可以说redis充分利用了定时器，这样就少了很多线程，因为memcache很多事都交给了线程，所以时间事件只是更新时间戳。</p>
<h1>分析redis开启过程的一些收获</h1>
<h2>服务器如何监听ipv6地址</h2>
<p>现在ipv6越来越普及，服务器也必须支持ipv6，当初getaddrinfo函数就是为了ipv6而出的。那如何监听ipv6地址了？</p>
<ol>
<li>
<p>创建ipv6套接字
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int s=socket(<span class="name">AF_INET6</span>,SOCK_STREAM,<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>设置套接字选项IPV6_V6ONLY
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int yes = <span class="number">1</span><span class="comment">;</span></div><div class="line">setsockopt(<span class="name">s</span>,IPPROTO_IPV6,IPV6_V6ONLY,<span class="symbol">&amp;yes</span>,sizeof(<span class="name">yes</span>))</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>当绑定或者accept地址时时，需要使用sockaddr_in6</p>
</li>
</ol>
<h2>RSS和VSZ的区别</h2>
<p>今天在看redis时，有看到进程获取rss的大小；在调用ps命令时，也经常看到rss和vsz这两个选项，那么这两个选项是什么意思了？</p>
<p>RSS(Resident Set Size)是进程常驻内存的大小,用来表示进程在RAM中分配了多少内存。RSS不包括被swapped out出去的swap内存部分，RSS包括在内存中的共享库部分，在内存中代码部分，堆，栈。</p>
<p>VSZ(Virtual Memory Size)是虚拟内存部分，也就是进程可以操控的内存部分。包括进程所有内存，包括在内存中或者swap out在交换空间中。</p>
<p>举个例子，如果一个进程有500k的二进制代码，2500k的共享库，200k的堆栈；其中100k堆栈在内存中（其他被swapped），400k的二进制代码和1000k共享库在实际内存中(其他被swapped)。</p>
<blockquote>
<p>RSS:400k+1000k+100k = 1500k
VSZ:500k+2500k+200k = 3200k</p>
</blockquote>
<p>参考stackoverflow一个帖子<a href="http://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management" target="_blank" rel="external">What is RSS and VSZ in Linux memory management</a></p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈epoll实现原理]]></title>
      <url>http://luodw.cc/2016/01/24/epoll/</url>
      <content type="html"><![CDATA[<p>最近看的memcache和redis都使用了基于IO多路复用的高性能网络库．memcache使用了libevent，redis使用了自己封装的Mainae，原理都一样，都是封装底层的epoll,select,kqueue等等．而在linux平台下，使用最多的就是epoll，所以这篇文章想对epoll做个总结．</p>
<h1>epoll接口</h1>
<hr>
<p>epoll接口非常简单，只有三个：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这就是创建一个epoll句柄，同时也占用一个文件描述符．size指明这个epoll监听的数目有多大．</p>
<p>因为经常看到说这个size参数是个hint，所以我就man了下，发现从Linux 2.8.8开始，这个
size就被忽略了，只是个hint，内核会自动分配所有事件所需要的内存，但是size必须大于０，主要是为了与旧版本的epoll兼容．</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">__uint32_t</span> u32;</div><div class="line">    <span class="keyword">__uint64_t</span> u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></div><div class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></div><div class="line">&#125;;</div><div class="line">------------------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数用于向epoll注册一个事件，而且明确监听的事件类型；第一个参数为epoll句柄，第一个参数表示对这个fd监听事件的操作，用宏来表示，有以下三种:</p>
<ol>
<li>EPOLL_CTL_ADD　将fd监听事件添加进epfd中；</li>
<li>EPOLL_CTL_MOD　修改已经注册的fd监听事件；</li>
<li>EPOLL_CTL_DEL　从epfd中删除fd事件
第三个参数为监听的套接字，第四个参数为监听fd的事件．</li>
</ol>
<p>对于epoll_event结构体，events有以下几种:</p>
<ol>
<li>EPOLLIN 表示对应的文件描述符可读(包括对端socket关闭)</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的；</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li>
</ol>
<p>而epoll_data_t是一个union，所以一次只能存储其中一种数据，可以是文件描述符fd，可以是传递的数据void*，可以是一个无符号长整形等等，但是最经常使用的是fd．</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数用于等待事件的发生．第二个参数是用户自己开辟的一块事件数组，用于存储就绪的事件，第三个参数为这个数组的最大值，就是第二个参数事件数组的最大值，用户想监听fd的个数，第四个参数为超时时间(0表示立即返回，-1表示永久阻塞，直到有就绪事件)</p>
<h1>epoll使用框架</h1>
<hr>
<p>epoll经常使用框架包括监听listenfd以及clientfd，当epoll_wait返回时，迭代每个事件，如果是listenfd,则接收客户端fd，并在epoll注册一个读事件；如果是clientfd的可读事件，则先读取数据，然后处理数据，将数据写进输出缓冲区，最后将clientfd可读事件改为可写事件，这也是异步写的精髓；如果是clientfd可写事件，则先发送数据，然后将可写事件改为可读事件．
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( ; ; )</div><div class="line">    &#123;</div><div class="line">        nfds = epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(events[i].<span class="keyword">data</span>.fd==listenfd) <span class="comment">//如果是主socket的事件，则表示有新的连接</span></div><div class="line">            &#123;</div><div class="line">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></div><div class="line">                ev.<span class="keyword">data</span>.fd=connfd;</div><div class="line">                ev.events=EPOLLIN|EPOLLET;</div><div class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></div><div class="line">            &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ( (sockfd = events[i].<span class="keyword">data</span>.fd) &lt; <span class="number">0</span>) continue;</div><div class="line">                n = read(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></div><div class="line">                ev.<span class="keyword">data</span>.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></div><div class="line">                ev.events=EPOLLOUT|EPOLLET;</div><div class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></div><div class="line">            &#123;</div><div class="line">                struct myepoll_data* md = (myepoll_data*)events[i].<span class="keyword">data</span>.ptr;    <span class="comment">//取数据</span></div><div class="line">                <span class="function"><span class="title">sockfd</span> = md-&gt;</span>fd;</div><div class="line">                <span class="function"><span class="title">send</span>( sockfd, md-&gt;</span><span class="function"><span class="title">ptr</span>, strlen((char*)md-&gt;</span>ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></div><div class="line">                ev.<span class="keyword">data</span>.fd=sockfd;</div><div class="line">                ev.events=EPOLLIN|EPOLLET;</div><div class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="comment">//其他情况的处理</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于libevent和redis的Mainae模块，原理一样，只是将处理数据部分替换成了回调函数，稍微更复杂一些．</p>
<h1>epoll实现原理</h1>
<hr>
<p>在linux，一切皆文件．所以当调用epoll_create时，内核给这个epoll分配一个file，但是这个不是普通的文件，而是只服务于epoll．</p>
<p>所以当内核初始化epoll时，会开辟一块内核高速cache区，用于安置我们监听的socket，这些socket会以红黑树的形式保存在内核的cache里，以支持快速的查找，插入，删除．同时，建立了一盒list链表，用于存储准备就绪的事件．所以调用epoll_wait时，在timeout时间内，只是简单的观察这个list链表是否有数据，如果没有，则睡眠至超时时间到返回；如果有数据，则在超时时间到，拷贝至用户态events数组中．</p>
<p>那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。</p>
<p>epoll有两种模式LT(水平触发)和ET(边缘触发)，LT模式下，主要缓冲区数据一次没有处理完，那么下次epoll_wait返回时，还会返回这个句柄；而ET模式下，缓冲区数据一次没处理结束，那么下次是不会再通知了，只在第一次返回．所以在ET模式下，一般是通过while循环，一次性读完全部数据．epoll默认使用的是LT．</p>
<p>这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回。而ET模式的句柄，除非有新中断到，即使socket上的事件没有处理完，也是不会次次从epoll_wait返回的．</p>
<p>经常看到比较ET和LT模式到底哪个效率高的问题．有一个回答是说ET模式下减少epoll系统调用．这话没错，也可以理解，但是在ET模式下，为了避免数据饿死问题，用户态必须用一个循环，将所有的数据一次性处理结束．所以在ET模式下下，虽然epoll系统调用减少了，但是用户态的逻辑复杂了，write/read调用增多了．所以这不好判断，要看用户的性能瓶颈在哪．</p>
<h1>epoll与select</h1>
<hr>
<p>最后需要说明的就是epoll与select/poll相比的优点．</p>
<ol>
<li>首先select/poll监听的文件描述符个数受限．select的文件描述符默认为2048，而现在的服务器连接数在轻轻松松就超过2048个；epoll支持的fd个数不受限制，它支持的fd上限是最大可以打开文件的数目，一般远大于2048，1G内存的机器上是大约10万左右．</li>
<li>select和poll需要循环检测所有fd是否就绪，当fd数量百万或者更多时，这是很耗时的，根据前面原理分析可知，epoll只处理就绪的fd，而一般一次epoll_wait返回时，就绪的fd是不多的，所以处理起来不是很耗时．</li>
</ol>
<p>还有两点是关于用户态和内核态复制文件描述符，epoll使用的是共享内存，select全部复制，所以效率更低；epoll支持内核微调．</p>
<p>参考:</p>
<ol>
<li><a href="http://www.cnblogs.com/tangr206/articles/3118135.html" target="_blank" rel="external">http://www.cnblogs.com/tangr206/articles/3118135.html</a></li>
<li><a href="http://www.cnblogs.com/panfeng412/articles/2229095.html" target="_blank" rel="external">http://www.cnblogs.com/panfeng412/articles/2229095.html</a></li>
<li><a href="http://blog.csdn.net/hdutigerkin/article/details/7517390" target="_blank" rel="external">http://blog.csdn.net/hdutigerkin/article/details/7517390</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> epoll </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis源码之Mainae模块]]></title>
      <url>http://luodw.cc/2016/01/23/redis-mainae/</url>
      <content type="html"><![CDATA[<p>redis源码是我研一下学期和暑假学习的，后来研二上学期又看了leveldb和memcache源码，感觉redis源码是最好阅读，结构很清晰，代码写得也很优美．再读memcache源码之前有想过读libevent的源码，但是仔细想想，redis自己也实现了事件驱动机制，所以我就不看libevent源码，在memcache源码分析之后，回过头来看下redis的事件驱动机制即可，因为我主要还是想看看实现原理．</p>
<p>所以想利用研二寒假总结下redis源码一些特色的东西，例如事件驱动模块，sentinel，cluster,订阅，慢查询等等，今天开篇就说说事件驱动机制Mainae模块．</p>
<h1>Mainae模块概要</h1>
<hr>
<p>Redis采用的是单进程单线程模型(开启aof时，创建子进程将数据刷新到磁盘)，一开始Mainae模块监听listenfd和域套接字，等待客户端的连接．当有一个客户端达到之后，接收这个客户端clientfd，为这个客户端添加可读事件，并将这个客户端加入事件驱动中；当客户端发送一条命令之后，这个clientfd产生可读事件，redis服务器调用这个clientfd的回调函数，处理命令请求，处理完请求之后，将回复给客户端的内容写进输出缓冲区，然后给这个clientfd注册一个可写事件，那么下一次事件通知时，将数据写回给客户端，再删除这个clientfd的可写事件，但是这个clientfd可读事件还是存在的，等待下一次客户端输入．</p>
<p>所以对于redis而言，Mainae模块是至关重要的，它直接掌控着redis的运行．Mainae模块和libevent一样，先写一个通用接口，然后底层用select,epoll,evport,kqueue分别实现了这个通用接口，在不同的系统调用适合的接口，linux下面优先使用epoll，所以这篇文章主要是分析epoll实现．</p>
<h1>Mainae一些定义</h1>
<hr>
<p>首先来看下，Mainae模块的一些结构体定义和函数指针定义，因为这些是接下去看源码的一些先决条件．
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> aeEventLoop;<span class="comment">//先前声明，因为函数指针用到了</span></div><div class="line"><span class="comment">/* Types and data structures */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">aeFileProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">void</span> *clientData, <span class="keyword">int</span> mask)</span></span>;<span class="comment">//socket可写可读事件的回调函数指针类型</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">aeTimeProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span></span>;<span class="comment">//时间事件回调函数指针类型</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">aeEventFinalizerProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="keyword">void</span> *clientData)</span></span>;<span class="comment">//事件消除函数指针类型</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">aeBeforeSleepProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop)</span></span>;<span class="comment">//在开始事件循环之前执行的函数指针类型</span></div><div class="line"></div><div class="line"><span class="comment">/* File event structure */</span></div><div class="line"><span class="comment">/* 文件事件结构体 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFileEvent &#123;</div><div class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) ,事件类型(可读可写)*/</span></div><div class="line">    aeFileProc *rfileProc;<span class="comment">//socket可读事件回调函数</span></div><div class="line">    aeFileProc *wfileProc;<span class="comment">//socket可写事件回调函数</span></div><div class="line">    <span class="keyword">void</span> *clientData;<span class="comment">//客户端数据，即代表客户端的redisClient结构体</span></div><div class="line">&#125; aeFileEvent;</div><div class="line"></div><div class="line"><span class="comment">/* Time event structure */</span></div><div class="line"><span class="comment">/* 时间事件结构体 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeTimeEvent &#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* 这个时间事件编号. */</span></div><div class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* 秒数 */</span></div><div class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* 毫秒数 */</span></div><div class="line">    aeTimeProc *timeProc;<span class="comment">//时间事件回调函数</span></div><div class="line">    aeEventFinalizerProc *finalizerProc;<span class="comment">//时间事件销毁函数</span></div><div class="line">    <span class="keyword">void</span> *clientData;<span class="comment">//客户端结构体</span></div><div class="line">    <span class="keyword">struct</span> aeTimeEvent *next;<span class="comment">//指向下一个时间事件</span></div><div class="line">&#125; aeTimeEvent;</div><div class="line"></div><div class="line"><span class="comment">/* A fired event */</span></div><div class="line"><span class="comment">/* 激活的事件 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFiredEvent &#123;</div><div class="line">    <span class="keyword">int</span> fd;<span class="comment">//哪个fd上有事件</span></div><div class="line">    <span class="keyword">int</span> mask;<span class="comment">//这个事件的类型</span></div><div class="line">&#125; aeFiredEvent;</div><div class="line"></div><div class="line"><span class="comment">/* State of an event based program */</span></div><div class="line"><span class="comment">/* Mainae的主体结构体　 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop &#123;</div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* 目前为止注册的最大文件描述符 */</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* 监听文件描述符的最大值 */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;<span class="comment">//时间事件的下一个id</span></div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* 检测系统时钟倾斜 */</span></div><div class="line">    aeFileEvent *events; <span class="comment">/* 注册的所有文件描述符事件 */</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">/* 激活的事件 */</span></div><div class="line">    aeTimeEvent *timeEventHead;<span class="comment">//注册的所有时间事件</span></div><div class="line">    <span class="keyword">int</span> stop;<span class="comment">//用于关闭这个Mainae事件循环</span></div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* 这是每种实现的具体数据，epoll是aeApiState结构体 */</span></div><div class="line">    aeBeforeSleepProc *beforesleep;<span class="comment">//进入事件循环前的函数指针</span></div><div class="line">&#125; aeEventLoop;</div></pre></td></tr></table></figure></p>
<p>关于几个结构体，有几点需要说明，</p>
<ol>
<li>文件事件类型有AE_NONE,AE_READABLE,AE_WRTABLE三种以及后两者的或．</li>
<li>激活事件结构体是作为epoll_event和aeFileEvent的中间桥梁，当epoll检测到事件之后，将产生事件的fd以及事件类型赋给aeFiredEvent，然后根据aeFiredEvent事件的fd，找到aeFileEvent结构，根据事件类型，调用相应的回调函数．</li>
<li>aeEventLoop结构体相当于libevent中的event_base，作为整个模块的中心结构体，掌管着所有事件．</li>
</ol>
<h1>Mainae模块函数解析</h1>
<hr>
<h2>EventLoop创建函数</h2>
<p>接下来主要看下Mainae提供的主要接口，首先是创建一个EventLoop事件循环:
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">ac.c</div><div class="line">--------------------------------------------------------------------</div><div class="line">millisecondsaeEventLoop *aeCreateEventLoop(<span class="keyword">int</span> setsize) &#123;</div><div class="line">    aeEventLoop *eventLoop;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="comment">//为EventLoop分配内存空间</span></div><div class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(sizeof(*eventLoop))) == <span class="keyword">NULL</span>) <span class="keyword">goto</span> err;</div><div class="line">　　<span class="comment">//为事件分配内存空间</span></div><div class="line">    eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize);</div><div class="line">　　<span class="comment">//为了激活事件分配内存空间</span></div><div class="line">    eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize);</div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="keyword">NULL</span> || eventLoop-&gt;fired == <span class="keyword">NULL</span>) <span class="keyword">goto</span> err;</div><div class="line">    eventLoop-&gt;setsize = setsize;<span class="comment">//默认值为10032,32是预留出来的</span></div><div class="line">    eventLoop-&gt;lastTime = time(<span class="keyword">NULL</span>);<span class="comment">//获取目前时间</span></div><div class="line">    eventLoop-&gt;timeEventHead = <span class="keyword">NULL</span>;</div><div class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</div><div class="line">    eventLoop-&gt;beforesleep = <span class="keyword">NULL</span>;</div><div class="line">　　<span class="comment">//调用底层函数，设置apidata</span></div><div class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</div><div class="line"> 　 <span class="comment">//初始化每个事件的类型为AE_NONE</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</div><div class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</div><div class="line">    <span class="keyword">return</span> eventLoop;</div><div class="line"></div><div class="line">ae_epoll.c</div><div class="line">----------------------------</div><div class="line"><span class="comment">/* epoll这个实现的私有数据结构 */</span></div><div class="line">typedef struct aeApiState &#123;</div><div class="line">    <span class="keyword">int</span> epfd;<span class="comment">//epoll_create返回的实例</span></div><div class="line">    struct epoll_event *events;<span class="comment">//epoll_wait返回激活的事件</span></div><div class="line">&#125; aeApiState;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> aeApiCreate(aeEventLoop *eventLoop) &#123;</div><div class="line">    aeApiState *state = zmalloc(sizeof(aeApiState));<span class="comment">//分配内存</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="comment">//为存储激活事件预先分配内存</span></div><div class="line">    state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize);</div><div class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">　　<span class="comment">//调用epoll_create创建一个epoll实例</span></div><div class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></div><div class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</div><div class="line">        zfree(state-&gt;events);</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    eventLoop-&gt;apidata = state;<span class="comment">//赋值</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上就创建好了一个EventLoop，包括为文件事件和时间事件预留了空间等等；创建好之后，接下来就是往里面添加事件和删除事件了．</p>
<h2>添加事件</h2>
<p>添加事件时，先将事件添加进epoll中，然后再初始化EventLoop中相应的文件事件结构体
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">ae.c</div><div class="line">-----------------------------------------------------------------------</div><div class="line"><span class="keyword">int</span> aeCreateFileEvent(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</div><div class="line">        aeFileProc *proc, void *clientData)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;<span class="comment">//文件描述符超出最大值，报错返回</span></div><div class="line">        errno = ERANGE;</div><div class="line">        <span class="keyword">return</span> AE_ERR;</div><div class="line">    &#125;</div><div class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];<span class="comment">//获取EventLoop中fd对应的结构体</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)<span class="comment">//将fd添加进epoll中</span></div><div class="line">        <span class="keyword">return</span> AE_ERR;</div><div class="line">    fe-&gt;mask |= mask;<span class="comment">//设置文件类型</span></div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;<span class="comment">//设置回调函数</span></div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</div><div class="line">    fe-&gt;clientData = clientData;<span class="comment">//客户端数据</span></div><div class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</div><div class="line">        eventLoop-&gt;maxfd = fd;<span class="comment">//设置最大值</span></div><div class="line">    <span class="keyword">return</span> AE_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ae_epoll.c</div><div class="line">-----------------------------------------------------------------------</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> aeApiAddEvent(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask) &#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;<span class="comment">//获取epoll私有数据</span></div><div class="line">    struct epoll_event ee;<span class="comment">//定义一个epoll事件</span></div><div class="line">    <span class="comment">/* 如果fd上的事件为AE_NONE，这时用add操作；如果fd上事件不为空，则</span></div><div class="line">　　为mod修改操作 */</div><div class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">    ee.events = <span class="number">0</span>;</div><div class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* 合并原来的事件类型 */</span></div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;<span class="comment">//设置epoll事件类型</span></div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</div><div class="line">    ee.data.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning(我感觉是初始化后面四个字节为０)</span></div><div class="line">    因为ee.data为union，占８字节,而fd4字节 */</div><div class="line">    ee.data.fd = fd;</div><div class="line">　　<span class="comment">//添加进epoll事件中</span></div><div class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加可读事件一般是在redis主程序初始化时，添加listenfd为可读事件，等待客户端连接；还有就是一个客户端连上之后，也注册一个可读事件，准备接收客户端发来的数据；当服务器处理好数据之后，需要回复客户端时，则注册一个可写事件；</p>
<h2>删除事件</h2>
<p>删除事件也是一样，先删除epoll事件，再删除EventLoop中对应的事件
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">ae.c</div><div class="line">------------------------------------------------------------------------</div><div class="line">void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="title">if</span> (fd &gt;= eventLoop-&gt;</span>setsize) return;</div><div class="line">    <span class="function"><span class="title">aeFileEvent</span> *fe = &amp;eventLoop-&gt;</span>events[fd];<span class="comment">//获取相应的事件类型</span></div><div class="line">    <span class="function"><span class="title">if</span> (fe-&gt;</span>mask == AE_NONE) return;<span class="comment">//这个fd没有监听事件类型，直接返回</span></div><div class="line">　　</div><div class="line">　　<span class="comment">//删除epoll上fd事件类型</span></div><div class="line">    aeApiDelEvent(eventLoop, fd, mask);</div><div class="line">    <span class="function"><span class="title">fe</span>-&gt;</span><span class="function"><span class="title">mask</span> = fe-&gt;</span>mask &amp; (~mask);<span class="comment">//关闭对应类型</span></div><div class="line">    <span class="function"><span class="title">if</span> (fd == eventLoop-&gt;</span><span class="function"><span class="title">maxfd</span> &amp;&amp; fe-&gt;</span>mask == AE_NONE) &#123;</div><div class="line">        <span class="comment">/* Update the max fd */</span></div><div class="line">        int j;</div><div class="line">　　　　<span class="comment">//如果这个关闭的fd是最大值，且没有事件监听类型，则更新fd最大值</span></div><div class="line">        <span class="function"><span class="title">for</span> (j = eventLoop-&gt;</span>maxfd-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</div><div class="line">            <span class="function"><span class="title">if</span> (eventLoop-&gt;</span>events[j].mask != AE_NONE) break;</div><div class="line">        <span class="function"><span class="title">eventLoop</span>-&gt;</span>maxfd = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ae_epoll.c</div><div class="line">-----------------------------------------------------------------------</div><div class="line">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) &#123;</div><div class="line">    <span class="function"><span class="title">aeApiState</span> *state = eventLoop-&gt;</span>apidata;</div><div class="line">    struct epoll_event ee;</div><div class="line">    <span class="function"><span class="title">int</span> mask = eventLoop-&gt;</span>events[fd].mask &amp; (~delmask);<span class="comment">//关闭事件类型</span></div><div class="line"></div><div class="line">    ee.events = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</div><div class="line">    ee.<span class="keyword">data</span>.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning */</span></div><div class="line">    ee.<span class="keyword">data</span>.fd = fd;</div><div class="line">    <span class="keyword">if</span> (mask != AE_NONE) &#123;<span class="comment">//如果这个fd上没有监听事件，则从epoll中删除</span></div><div class="line">        <span class="function"><span class="title">epoll_ctl</span>(state-&gt;</span>epfd,EPOLL_CTL_MOD,fd,&amp;ee);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果这个fd还有事件监听，则修改事件监听类型(删除delmask类型)</span></div><div class="line">        <span class="comment">/* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for</span></div><div class="line">         * EPOLL_CTL_DEL. */</div><div class="line">        <span class="function"><span class="title">epoll_ctl</span>(state-&gt;</span>epfd,EPOLL_CTL_DEL,fd,&amp;ee);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再redis中一般情况下有两种情况会删除事件</p>
<ol>
<li>一是服务器给客户端回复之后，因为后面没有数据可写，需要把可写事件删除；</li>
<li>另一个是客户端关闭时，需要把这个fd的可读事件删除；</li>
</ol>
<h2>事件驱动</h2>
<p>将事件添加进epoll事件之后，这时调用epoll_wait函数等待可读或可写事件发生，将激活的事件存储在epoll_wait函数的第二个参数中，接下来看下redis是如果是如何实现的．
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">ae.c</div><div class="line">--------------------------------------------------------------------------</div><div class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags)</div><div class="line">&#123;</div><div class="line">    int processed = <span class="number">0</span>, numevents;</div><div class="line">    <span class="comment">/* 省略不必要代码  */</span></div><div class="line">       <span class="comment">//调用底层事件函数，返回激活事件的个数</span></div><div class="line">       numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">　　　　　　<span class="comment">//获取激活事件</span></div><div class="line">            <span class="function"><span class="title">aeFileEvent</span> *fe = &amp;eventLoop-&gt;</span><span class="function"><span class="title">events</span>[eventLoop-&gt;</span>fired[j].fd];</div><div class="line">            <span class="function"><span class="title">int</span> mask = eventLoop-&gt;</span>fired[j].mask;<span class="comment">//激活事件类型</span></div><div class="line">            <span class="function"><span class="title">int</span> fd = eventLoop-&gt;</span>fired[j].fd;<span class="comment">//激活事件描述符</span></div><div class="line">            int rfired = <span class="number">0</span>;</div><div class="line"></div><div class="line">	    <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></div><div class="line">             * event removed an element that fired and we still didn't</div><div class="line">             * processed, so we check if the event is still valid. */</div><div class="line">            <span class="function"><span class="title">if</span> (fe-&gt;</span>mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                rfired = <span class="number">1</span>;<span class="comment">//可读事件，调用相应回调函数</span></div><div class="line">                <span class="function"><span class="title">fe</span>-&gt;</span><span class="function"><span class="title">rfileProc</span>(eventLoop,fd,fe-&gt;</span>clientData,mask);</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="title">if</span> (fe-&gt;</span>mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">　　　　　　<span class="comment">//可写事件，调用相应回调函数</span></div><div class="line">                <span class="function"><span class="title">if</span> (!rfired || fe-&gt;</span><span class="function"><span class="title">wfileProc</span> != fe-&gt;</span>rfileProc)</div><div class="line">                    <span class="function"><span class="title">fe</span>-&gt;</span><span class="function"><span class="title">wfileProc</span>(eventLoop,fd,fe-&gt;</span>clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;<span class="comment">//处理个数加1．</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">ae_epoll.c</div><div class="line">----------------------------------------------------------------------------</div><div class="line">static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123;</div><div class="line">    <span class="function"><span class="title">aeApiState</span> *state = eventLoop-&gt;</span>apidata;</div><div class="line">    int retval, numevents = <span class="number">0</span>;</div><div class="line">  </div><div class="line">    <span class="comment">//调用epoll_wait函数，激活事件存储在state-&gt;events数组中</span></div><div class="line">    <span class="function"><span class="title">retval</span> = epoll_wait(state-&gt;</span><span class="function"><span class="title">epfd</span>,state-&gt;</span><span class="function"><span class="title">events</span>,eventLoop-&gt;</span>setsize,</div><div class="line">            <span class="function"><span class="title">tvp</span> ? (tvp-&gt;</span><span class="function"><span class="title">tv_sec</span>*1000 + tvp-&gt;</span>tv_usec/<span class="number">1000</span>) : -<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;<span class="comment">//如果有事件发生</span></div><div class="line">        int j;</div><div class="line"></div><div class="line">        numevents = retval;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">            int mask = <span class="number">0</span>;</div><div class="line">            <span class="function"><span class="title">struct</span> epoll_event *e = state-&gt;</span>events+j;</div><div class="line"></div><div class="line">            <span class="function"><span class="title">if</span> (e-&gt;</span>events &amp; EPOLLIN) mask |= AE_READABLE;</div><div class="line">            <span class="function"><span class="title">if</span> (e-&gt;</span>events &amp; EPOLLOUT) mask |= AE_WRITABLE;</div><div class="line">            <span class="function"><span class="title">if</span> (e-&gt;</span>events &amp; EPOLLERR) mask |= AE_WRITABLE;</div><div class="line">            <span class="function"><span class="title">if</span> (e-&gt;</span>events &amp; EPOLLHUP) mask |= AE_WRITABLE;</div><div class="line">　　　　　　<span class="comment">//fired数组存储激活事件的fd和事件类型</span></div><div class="line">            <span class="function"><span class="title">eventLoop</span>-&gt;</span><span class="function"><span class="title">fired</span>[j].fd = e-&gt;</span><span class="keyword">data</span>.fd;</div><div class="line">            <span class="function"><span class="title">eventLoop</span>-&gt;</span>fired[j].mask = mask;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return numevents;<span class="comment">//返回激活事件个数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Mainae事件驱动先是调用epoll_wait函数，返回激活的事件以及事件个数，然后设置eventLoop-&gt;fired数组，最后在aeProcessEvents函数迭代每个事件，并调用相应的回调函数．redis主程序其实就是这样在一个while循环中，调用aeProcessEvent,不断等待事件发生，不断处理．
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void aeMain(aeEventLoop *eventLoop) &#123;</div><div class="line">    <span class="function"><span class="title">eventLoop</span>-&gt;</span>stop = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">while</span> (!eventLoop-&gt;</span>stop) &#123;</div><div class="line">        <span class="function"><span class="title">if</span> (eventLoop-&gt;</span>beforesleep != NULL)</div><div class="line">            <span class="function"><span class="title">eventLoop</span>-&gt;</span>beforesleep(eventLoop);</div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>Mainae时间事件</h2>
<p>在redis中，初始化服务器时，会定时处理一些业务，此时就需要设置定时事件．创建时间事件函数如下:
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">ae.c</div><div class="line">--------------------------------------------------------------------</div><div class="line">ong <span class="keyword">long</span> aeCreateTimeEvent(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds,</div><div class="line">        aeTimeProc *proc, void *clientData,</div><div class="line">        aeEventFinalizerProc *finalizerProc)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id = eventLoop-&gt;timeEventNextId++;<span class="comment">//时间事件id</span></div><div class="line">    aeTimeEvent *te;</div><div class="line"></div><div class="line">    te = zmalloc(sizeof(*te));<span class="comment">//分配内存空间</span></div><div class="line">    <span class="keyword">if</span> (te == <span class="keyword">NULL</span>) <span class="keyword">return</span> AE_ERR;</div><div class="line">    te-&gt;id = id;</div><div class="line">　　<span class="comment">//为这个时间事件设置时间，即离现在的时间</span></div><div class="line">    aeAddMillisecondsToNow(milliseconds,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</div><div class="line">    te-&gt;timeProc = proc;</div><div class="line">    te-&gt;finalizerProc = finalizerProc;</div><div class="line">    te-&gt;clientData = clientData;</div><div class="line">    te-&gt;next = eventLoop-&gt;timeEventHead;<span class="comment">//插入eventLoop时间事件链表</span></div><div class="line">    eventLoop-&gt;timeEventHead = te;</div><div class="line">    <span class="keyword">return</span> id;</div><div class="line">&#125;</div><div class="line"></div><div class="line">------------------------------------------------------------------------</div><div class="line"><span class="keyword">static</span> void aeAddMillisecondsToNow(<span class="keyword">long</span> <span class="keyword">long</span> milliseconds, <span class="keyword">long</span> *sec, <span class="keyword">long</span> *ms) &#123;</div><div class="line">    <span class="keyword">long</span> cur_sec, cur_ms, when_sec, when_ms;</div><div class="line"></div><div class="line">    aeGetTime(&amp;cur_sec, &amp;cur_ms);<span class="comment">//获取当前时间</span></div><div class="line">    when_sec = cur_sec + milliseconds/<span class="number">1000</span>;<span class="comment">//离现在多少秒</span></div><div class="line">    when_ms = cur_ms + milliseconds%<span class="number">1000</span>;<span class="comment">//离现在多少毫秒</span></div><div class="line">    <span class="keyword">if</span> (when_ms &gt;= <span class="number">1000</span>) &#123;</div><div class="line">        when_sec ++;</div><div class="line">        when_ms -= <span class="number">1000</span>;</div><div class="line">    &#125;<span class="comment">//进位</span></div><div class="line">    *sec = when_sec;</div><div class="line">    *ms = when_ms;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-------------------------------------------------------------------------</div><div class="line"><span class="keyword">static</span> void aeGetTime(<span class="keyword">long</span> *seconds, <span class="keyword">long</span> *milliseconds)</div><div class="line">&#123;</div><div class="line">    struct timeval tv;</div><div class="line"></div><div class="line">    gettimeofday(&amp;tv, <span class="keyword">NULL</span>);</div><div class="line">    *seconds = tv.tv_sec;</div><div class="line">    *milliseconds = tv.tv_usec/<span class="number">1000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建时间事件，并插入时间事件链表中．Mainae模块，调用epoll_wait的阻塞时间为时间事件的最小值，这样当epoll_wait函数返回时，可以先处理文件描述符事件，再处理到期的时间事件．</p>
<p>在调用aeProcessEvents函数时，先获取最近的时间事件以及最短时间struct tvp，然后调用epoll_wait阻塞tvp秒．先看下获取最近的时间事件
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//时间事件链表的第一个时间事件</span></div><div class="line">    <span class="function"><span class="title">aeTimeEvent</span> *te = eventLoop-&gt;</span>timeEventHead;</div><div class="line">    aeTimeEvent *nearest = NULL;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(te) &#123;</div><div class="line">        <span class="function"><span class="title">if</span> (!nearest || te-&gt;</span><span class="function"><span class="title">when_sec</span> &lt; nearest-&gt;</span>when_sec ||</div><div class="line">                (<span class="function"><span class="title">te</span>-&gt;</span><span class="function"><span class="title">when_sec</span> == nearest-&gt;</span>when_sec &amp;&amp;</div><div class="line">                 <span class="function"><span class="title">te</span>-&gt;</span><span class="function"><span class="title">when_ms</span> &lt; nearest-&gt;</span>when_ms))</div><div class="line">            nearest = te;</div><div class="line">        <span class="function"><span class="title">te</span> = te-&gt;</span>next;</div><div class="line">    &#125;</div><div class="line">    return nearest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取最近时间事件之后，先获得最近时间事件离现在的时间，再调用aeApiPoll获取文件描述符激活事件，最后调用processTimeEvents处理事件事件
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">static int processTimeEvents(aeEventLoop *eventLoop) &#123;</div><div class="line">    int processed = <span class="number">0</span>;</div><div class="line">    aeTimeEvent *te;</div><div class="line">    long long maxId;</div><div class="line">    time_t now = <span class="built_in">time</span>(NULL);</div><div class="line">    <span class="function"><span class="title">if</span> (now &lt; eventLoop-&gt;</span>lastTime) &#123;</div><div class="line">        <span class="function"><span class="title">te</span> = eventLoop-&gt;</span>timeEventHead;</div><div class="line">        <span class="keyword">while</span>(te) &#123;</div><div class="line">            <span class="function"><span class="title">te</span>-&gt;</span>when_sec = <span class="number">0</span>;</div><div class="line">            <span class="function"><span class="title">te</span> = te-&gt;</span>next;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="comment">//据说这个是为了检测系统时钟倾斜，但是一开始lastTime初始化为创建eventLoop</span></div><div class="line">　　<span class="comment">//的时间点，按理说第一次调用时，是不会比now小</span></div><div class="line">    <span class="function"><span class="title">eventLoop</span>-&gt;</span>lastTime = now;<span class="comment">//将上次处理时间事件的时间设为now．</span></div><div class="line"></div><div class="line">    <span class="function"><span class="title">te</span> = eventLoop-&gt;</span>timeEventHead;</div><div class="line">    <span class="function"><span class="title">maxId</span> = eventLoop-&gt;</span>timeEventNextId-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(te) &#123;</div><div class="line">        long now_sec, now_ms;</div><div class="line">        long long id;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">if</span> (te-&gt;</span>id &gt; maxId) &#123;</div><div class="line">            <span class="function"><span class="title">te</span> = te-&gt;</span>next;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">        <span class="comment">//判断这个时间事件的到期时间在now之前，如果是，则调用相应的回调函数</span></div><div class="line">        <span class="function"><span class="title">if</span> (now_sec &gt; te-&gt;</span>when_sec ||</div><div class="line">            (<span class="function"><span class="title">now_sec</span> == te-&gt;</span><span class="function"><span class="title">when_sec</span> &amp;&amp; now_ms &gt;= te-&gt;</span>when_ms))</div><div class="line">        &#123;</div><div class="line">            int retval;</div><div class="line"></div><div class="line">            <span class="function"><span class="title">id</span> = te-&gt;</span>id;</div><div class="line">            <span class="function"><span class="title">retval</span> = te-&gt;</span><span class="function"><span class="title">timeProc</span>(eventLoop, id, te-&gt;</span>clientData);</div><div class="line">            processed++;</div><div class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;<span class="comment">//判断是否出错，如果没出错，则返回的是</span></div><div class="line">            <span class="comment">//这个时间事件的下一次到期时间</span></div><div class="line">                <span class="function"><span class="title">aeAddMillisecondsToNow</span>(retval,&amp;te-&gt;</span><span class="function"><span class="title">when_sec</span>,&amp;te-&gt;</span>when_ms);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//调用出错，则删除这个时间事件</span></div><div class="line">                aeDeleteTimeEvent(eventLoop, id);</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="title">te</span> = eventLoop-&gt;</span>timeEventHead;<span class="comment">//执行完一次时间事件之后，即从头再此次便利</span></div><div class="line">　　　　<span class="comment">//因为这时又有事件到期了</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="function"><span class="title">te</span> = te-&gt;</span>next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return processed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此，redis的Mainae模块就分析结束了．相对第一次看源码，这次明显看得块，可能是我对这种机制很熟悉，所以看得也快．</p>
<p>相对于memcache的多线程编程，redis单线程模型更简单，思路更清晰．</p>
<p>据说libevent代码量就1.5w行，而Mainae模块代码几乎除了select,evport,select三个底层实现之外，其他都在这了，代码量还是很少的，关键是代码很清晰，很优美，很好阅读．</p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码中一些网络设置]]></title>
      <url>http://luodw.cc/2016/01/21/memcache-socket/</url>
      <content type="html"><![CDATA[<p>memcache网络这一块内容，其实就是调用linux下的网络接口，看过apue和unp，这些接口都听熟悉的，今天主要是分析下，在一个完整的服务器端软件，需要对socket设置些什么．</p>
<h1>SO_KEEPALIVE选项</h1>
<hr>
<p>对于高并发的服务器，服务器会有很多客户端连接，如果有些客户端突然断电，因为没有给服务器发送数据，所以服务器也不知道这个客户端已＂死＂，这样会占着服务器一个文件描述符，如果有很多这样的客户端，这样必然会降低服务器端的并发性．还好tcp套接字有一个保持存活的选项．即如果在２小时(/proc/sys/net/ipv4/tcp_keepalive_time 7200 即2小时)内该套接字的任何一方向上都没有数据交换，TCP就自动给对方发送一个保持存活探测分节(keep-alive probe)，这是对端必须响应的一个TCP分节．网络编程那本书上会说，保活分节会导致以下三种情况发生</p>
<ol>
<li>client端连接正常,返回一个ACK.server端收到ACK后重置计时器,在2小时后在发送探测.如果2小时内连接上有数据传输,那么在该时间的基础上向后推延2小时发送探测包;</li>
<li>客户端异常关闭,或网络断开。client无响应,server收不到ACK,在一定时间(/proc/sys/net/ipv4/tcp_keepalive_intvl 75 即75秒)后重发keepalive packet, 并且重发一定次数(/proc/sys/net/ipv4/tcp_keepalive_probes 9 即9次);，如果还是没有回应，则放弃，套接字关闭；</li>
<li>客户端曾经崩溃,但已经重启.server收到的探测响应是一个复位,该套接字被置为ECONNREST，套接字本身则被关闭．
我们可以在编程实现中通过调用setsockopt函数来修改这三个变量;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>                 keepIdle =<span class="number">1800</span> ;<span class="comment">//半小时</span></div><div class="line"><span class="keyword">int</span>                 keepInterval = <span class="number">60</span>;<span class="comment">//第二次开始，每个一分钟发送一次</span></div><div class="line"><span class="keyword">int</span>                 keepCount = <span class="number">10</span>;<span class="comment">//总共发送10个保活探测分节</span></div><div class="line">Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span> *)&amp;keepIdle, <span class="keyword">sizeof</span>(keepIdle));</div><div class="line">Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepInterval, <span class="keyword">sizeof</span>(keepInterval));</div><div class="line">Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepCount, <span class="keyword">sizeof</span>(keepCount));</div></pre></td></tr></table></figure></li>
</ol>
<h1>SO_REUSEADDR选项</h1>
<hr>
<p>经常在开启一个服务器之后，处于某些原因需要重启，我们经常做的是关闭服务器，然后马上开启，这时经常会出现＂Port is already in use＂的错误，这是因为，计算机上不允许两个进程绑定到同一个端口．上述出现错误的原因是服务器刚关闭时，还处于time_wait状态，还没有完全释放端口，所以重用会报错．但是tcp提供一个选项SO_REUSEADDR来设置处于time_wait的端口重用．</p>
<p>网络编程那本书解释了这个选项有四个用途，但是我觉得实际应用中，记者这个上述说的功能即可．</p>
<h1>SO_LINGER选项</h1>
<hr>
<p>在讲这个选项之前，可以先了解下shutdown和close这两个函数的区别．</p>
<ol>
<li>close函数主要是把描述符的引用计数减一，仅在该计数变为０时，才关闭这个套接字．当调用close(fd)时，这时就不能往这个fd读写数据了，然而tcp会尝试发送已排队等待发送到对端的任何数据，最后再发送FIN．</li>
<li>shutdown函数依赖与参数howto，但是它不会将描述符引用计数减一而是直接切断连接．</li>
</ol>
<p>shutdown函数可以关闭一半，也可以全关闭，取决为howto</p>
<ol>
<li>SHUT_RD　关闭连接的读这一半－－套接字不再有数据可以接收，而且该套接字中现有的数据都被丢弃．进程不能对该套接字调用任何读函数．</li>
<li>SHUT_WR　关闭连接的写一半－－对于TCP套接字，这称为半关闭．当前留在套接字发送缓冲区中的数据将被发送掉，后跟TCP正常终止序列．不管套接字引用计数是否为0，写半部照样关闭．进程不能对套接字调用任何写函数．</li>
<li>SHUT_RDWR　连接的读半部和写半部都关闭．这等于调用两次shutdown，一次关闭读，一次关闭写．</li>
</ol>
<p>对于close减少引用计数，主要是用在多进程环境中，子进程继承父进程的fd，我在一篇博客上看到一个例子，
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* First  Sample client fragment, </span></div><div class="line"> * 多余的代码及变量的声明已略       */  </div><div class="line">   s=<span class="built_in">connect</span>(...);  </div><div class="line">   <span class="built_in">if</span>( fork() )&#123;   <span class="comment">/*      The child, it copies its stdin to the socket              */</span>  </div><div class="line">       <span class="built_in">while</span>( gets(<span class="built_in">buffer</span>) &gt;<span class="number">0</span>)  </div><div class="line">           <span class="built_in">write</span>(s,buf,strlen(<span class="built_in">buffer</span>));  </div><div class="line">           <span class="built_in">close</span>(s);  </div><div class="line">           exit(<span class="number">0</span>);  </div><div class="line">   &#125;  </div><div class="line">   <span class="built_in">else</span> &#123;          <span class="comment">/* The parent, it receives answers  */</span>  </div><div class="line">        <span class="built_in">while</span>( (n=<span class="built_in">read</span>(s,<span class="built_in">buffer</span>,<span class="keyword">sizeof</span>(<span class="built_in">buffer</span>))&#123;  </div><div class="line">            do_something(n,<span class="built_in">buffer</span>);  </div><div class="line">            <span class="comment">/* Connection break from the server is assumed  */</span>  </div><div class="line">            <span class="comment">/* ATTENTION: deadlock here                     */</span>  </div><div class="line">         wait(<span class="number">0</span>); <span class="comment">/* Wait for the child to exit          */</span>  </div><div class="line">         exit(<span class="number">0</span>);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实就是子进程从stdio输入数据，然后发给服务器，父进程从服务器接收数据．当子进程收到EOF时，则close(fd)，但是这个只是将引用计数减一，父进程的fd还存活着，且一直阻塞在read调用上．如果子进程中的fd调用shutdown，则会关闭这个套接字．</p>
<p>好，来看下SO_LINGER这个选项．首先要知道的是close函数调用之后，会立即返回到用户态，然后发送缓冲区的数据将继续发送，最后接FIN．但是可以通过SO_LINGER这个选项改变．</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> linger &#123;</div><div class="line">     <span class="keyword">int</span> l_onoff; <span class="comment">/* 0 = off, nozero = on */</span></div><div class="line">     <span class="keyword">int</span> l_linger; <span class="comment">/* linger time */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>第一个参数为这个选项的开关，第二个参数为延迟时间
有三种情况:</p>
<ol>
<li>置 l_onoff为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close调用会立即返回给调用者，如果可能将会传输任何未发送的数据；</li>
<li>设置 l_onoff为非0，l_linger为0，则套接口关闭时TCP夭折连接，TCP将丢弃保留在套接口发送缓冲区中的任何数据并发送一个RST给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态；</li>
<li>设置 l_onoff 为非0，l_linger为非0，当套接口关闭时内核将拖延一段时间（由l_linger决定）。如果套接口缓冲区中仍残留数据，进程将处于睡眠状态，直 到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。此种情况下，应用程序检查close的返回值是非常重要的，如果在数据发送完并被确认前时间到，close将返回EWOULDBLOCK错误且套接口发送缓冲区中的任何数据都丢失。close的成功返回仅告诉我们发送的数据（和FIN）已由对方TCP确认，它并不能告诉我们对方应用进程是否已读了数据。如果套接口设为非阻塞的，它将不等待close完成。</li>
</ol>
<h1>TCP_NODELAY</h1>
<hr>
<p>TCP_NODELAY选项在redis源码中也有看到，当初不理解这个的用法，现在看了网络编程之后，对这个选项还是有点理解．TCP_NODELAY是为了关闭Nagle's Algorithm．</p>
<p>Nagles Algorithm是为了提高带宽利用率设计的算法，其做法是合并小的TCP包为一个，避免了过多的小报文的TCP头头所浪费的宽带．如果开启了这个算法(默认),则协议栈会积累数据直到以下两个条件之一满足的时候才真正发送出去:</p>
<ol>
<li>积累的数据量达到最大的TCP Segment Size</li>
<li>收到了一个Ack</li>
</ol>
<p>还有一个算法经常和Nagles Algorithm算法配合使用，称为TCP Delayed Acknoledgement，这个算法也是为了类似的目的被设计出来的，它的作用就是延迟Ack包的发送，使得协议栈有机会合并多个Ack，提高网络性能．</p>
<p>下面给出网络编程上的一张图片，说明Nagles算法运行机制
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_055.png" alt="Nagles算法">
假设每个字符间隔正好是250ms，到服务器的RTT为600ms．当禁用Nagles算法时，每隔250ms准时发送一个字符．而禁用Nagles算法之后，第一次发送不需要等待，但是第二发送必须等待接收到第一次发送的ack才能发送，这样第二和第三个字符就可以一起发送．</p>
<p>可以这样设想，2个(1字节的数据+20字节的tcp头)和2个2字节的数据+20字节的tcp头，首先提高了网络利用率，其次减少了网络上tcp包数量，降低网络拥堵．</p>
<p>如果对端开启ack延滞算法，那么发送端就可以积累更多的包为一个tcp包．对端的ack会在以下两种情况下发回发送端</p>
<ol>
<li>超时时间到，默认为40ms</li>
<li>对端有数据回显，则可以捎带上这个ack</li>
</ol>
<p>有以下两种情况不适合使用Nagles算法，</p>
<ol>
<li>对于其服务器不在相反方向产生数据以便携带ACK的客户来说，ACK延滞算法出现问题．客户会明显感到延迟，因为客户TCP需要等待服务器的ACK延滞定时器超时才能才继续给服务器发送数据．这些客户需要禁用Nagles算法，TCP_NODELAY算法就起到这个作用．</li>
<li>另一类不适用使用Nagles算法和TCP延滞算法的客户是以若干小片数据向服务器发送单个逻辑请求的客户．例如像memcache的set命令分为两次发送，而且每次都是小片数据，因为第一次发送set键值部分，服务器是不会回复数据，所以必须等待ack延滞超时才能发送set命令值部分，这就出现延迟了．所以memcache必须关闭Nagles算法．redis有些命令也是类似</li>
</ol>
<p>以上就是一个服务器端软件经常碰到的socket选项设置．还有一个需要提到的就是需要捕获SIGPIPE信号，因为如果一个客户端突然断线，服务器向他写一个数据包客户端会发送RST给服务器，如果服务器再向客户发送数据，则系统给服务器发送SIGPIPE信号，默认是退出，所以必须捕获SIGPIPE信号．</p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
            <tag> socket </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码分析之lru维护线程]]></title>
      <url>http://luodw.cc/2016/01/19/memcache-lru-maintenance/</url>
      <content type="html"><![CDATA[<p>memcache和数据有关的数据结构有三个slab,lru和哈希表,所以在memcache运行过程中,需要不断维护这三个数据结构,以免降低性能.之前两篇文章,分析维护哈希表的扩容线程和维护slab的平衡线程.今天这篇文章主要分析了维护lru,即清除lru队列中不恰当的item.这部分较难,因为这部分在版本1.2.23版本开始,重写了实现,网上源码分析较少,所以看得有点吃力,今天把知识点好好整理下.</p>
<h1>真实的lru队列</h1>
<hr>
<p>直到看了这部分内容,我才真正认识了lru,虽然叫lru,但是这个真正的lru是不一样的,Linux内核和leveldb都有lru缓冲区,这个是按最近最少访问策略来剔除缓存节点,这种模式是,如果某个节点被访问,则先删除,再重新插入,这样就可以移到最新的数据区.但是memcache并不是这样,在do_item_get函数里面即使访问一个节点,也没有更新它的位置.但是memcache有把缓存数据分为hot,warm和cold三种,hot都是最新的数据,当内存不足时,最终删除的是cold数据区.</p>
<p>我猜测memcache这样设计的理由是:memcache在实际使用中,作为缓存数据库,那么它存储的都是最经常访问的数据,所以它整体就是最热的数据区</p>
<p>一开始看memcache源码,可能会觉得lru就是和slabclass_t数组一一对应,即有多少个slabclass_t,就有多少个lru队列.但是看到最后才发现原来每一个lru有分为hot,warm,cold三种,如下分析:slabclass_t数组最大为64,即0-63.但是lru数组最大值为255,为啥了?
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HOT_LRU 0<span class="comment">//hot数据区</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WARM_LRU 64<span class="comment">//warm数据区</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> COLD_LRU 128<span class="comment">//cold数据区</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NOEXP_LRU 192<span class="comment">//没有过期时间数据区</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> lru_type_map[<span class="number">4</span>] = &#123;HOT_LRU, WARM_LRU, COLD_LRU, NOEXP_LRU&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR_LRU(id) (id &amp; ~(3&lt;&lt;6))<span class="comment">//最原始的数据区,即hot数据区</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LARGEST_ID POWER_LARGEST<span class="comment">//lru数组最大值256,即0-255</span></span></div></pre></td></tr></table></figure></p>
<p>因为一个slabclass_t对应三条lru队列,即hot,warm,cold lru.一般函数给出的是slabclass_t的索引id,也就是hot lru的索引,如果要操作warm lru队列,则需要id |= WARM_LRU,如果要操作cold lru,则只需要id |= COLD_LRU.因为id值的范围为[0,63],即最大值63为0011 1111,而64二进制为0100 0000,id | 64,即id+64,128二进制为1000 0000,id | 128 ,即id+128,192二进制为1100 0000,id | 192即id+192.因为id最大值为63,所以lru最大值为255.就是说当hot lru的索引为8时,warm lru索引为72,cold lru索引为136,noexp_lru索引为200.</p>
<p>当然,</p>
<ol>
<li>每次插入数据时,总是插在hot lru队列中,因为最新的数据,在一定程度上就是最热的数据.</li>
<li>warm lru的数据来源与cold lru,当cold lru的数据被访问活跃时,则被提到warm区;</li>
<li>hot和warm lru默认各占slabclass_t的32%,可以通过memcached开启时,通过-o设置.cold lru则为剩下的部分.当hot和warm lru超出32%之后,则被踢到cold lru中.</li>
</ol>
<h1>memcache惰性删除机制</h1>
<hr>
<p>memcache并没有直接删除过期的键值对,而是采取惰性删除的机制.即键值对到期之后,并没有调用item_unlink删除,而是继续占着lru和哈希表,等到如下情况才把item删除:</p>
<ol>
<li>当调用do_item_get函数时,先判断获取到的item是否过期,过期则删除,返回null;</li>
<li>当调用do_item_alloc时,如果从slab不能分到内存,则会进行一次检查是否有过期的item,有则直接用这个过期的item存储目前这个键值对.如果没有,则直接从cold lru尾部删除一个item,供目前这个键值对使用.</li>
<li>使用maintenance和crawler线程,删除过期的item.</li>
</ol>
<p>而键值对过期也有两种情况:</p>
<ol>
<li>在插入item时,设定的过期时间到期了;</li>
<li>调用flush_all命令,会将flush_all命令之前创建的item都标注为过期了.真正实现更新settings.oldest_live,即在这创建,更新的Item都失效.</li>
</ol>
<h2>惰性删除之do_item_get</h2>
<p>之前说到,当memcache调用do_item_get函数获取键值对时,会先判断获取的键值对是否过期,如果是返回null,并删除这个Item,来看下源码:
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">item *do_item_get(<span class="name">const</span> char *key, const size_t nkey, const uint32_t hv) &#123;</div><div class="line">    item *it = assoc_find(<span class="name">key</span>, nkey, hv)<span class="comment">;</span></div><div class="line">    if (<span class="name">it</span> != NULL) &#123;</div><div class="line">        refcount_incr(<span class="name">&amp;it-&gt;refcount</span>)<span class="comment">;//找到这个item,这个item引用+1</span></div><div class="line">     &#125;</div><div class="line">    int was_found = <span class="number">0</span><span class="comment">;</span></div><div class="line"></div><div class="line">    if (<span class="name">it</span> != NULL) &#123;//item不为空</div><div class="line">        if (<span class="name">is_flushed</span>(<span class="name">it</span>)) &#123;//这个item是否在flush_all之前,如果是,则删除</div><div class="line">            do_item_unlink(<span class="name">it</span>, hv)<span class="comment">;</span></div><div class="line">            do_item_remove(<span class="name">it</span>)<span class="comment">;</span></div><div class="line">            it = NULL<span class="comment">;</span></div><div class="line">            if (<span class="name">was_found</span>) &#123;</div><div class="line">                fprintf(<span class="name">stderr</span>, <span class="string">" -nuked by flush"</span>)<span class="comment">;</span></div><div class="line">            &#125;</div><div class="line">        //这个item是否过期,过期则删除</div><div class="line">        &#125; else if (<span class="name">it-&gt;exptime</span> != <span class="number">0</span> <span class="symbol">&amp;&amp;</span> it-&gt;exptime &lt;= current_time) &#123;</div><div class="line">            do_item_unlink(<span class="name">it</span>, hv)<span class="comment">;</span></div><div class="line">            do_item_remove(<span class="name">it</span>)<span class="comment">;</span></div><div class="line">            it = NULL<span class="comment">;</span></div><div class="line">            if (<span class="name">was_found</span>) &#123;</div><div class="line">                fprintf(<span class="name">stderr</span>, <span class="string">" -nuked by expire"</span>)<span class="comment">;</span></div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;//如果这个item没有在flush_all之前也没有过期,则标注为活跃item</div><div class="line">        //以及被获取</div><div class="line">            it-&gt;it_flags |= ITEM_FETCHED|ITEM_ACTIVE<span class="comment">;</span></div><div class="line">            DEBUG_REFCNT(<span class="name">it</span>, '+')<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (<span class="name">settings</span>.verbose &gt; <span class="number">2</span>)</div><div class="line">        fprintf(<span class="name">stderr</span>, <span class="string">"\n"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">    return it<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>惰性删除之do_item_alloc</h2>
<p>当worker线程要插入一个键值对时,需要先分配item内存.但是如果此时slab内存全都已使用完毕,那么这时先检查是否有过期的item,有则将过期的item直接给插入的键值对使用.如果没有,则将cold lru最后一个强制删除,留出空间.
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">item *do_item_alloc(<span class="keyword">char</span> *key, <span class="keyword">const</span> size_t nkey, <span class="keyword">const</span> <span class="keyword">int</span> flags,</div><div class="line">           <span class="keyword">const</span> rel_time_t exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</div><div class="line">           <span class="keyword">const</span> uint32_t cur_hv) &#123;</div><div class="line">		<span class="comment">/*</span></div><div class="line">		.........</div><div class="line">		*/</div><div class="line">	 <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="comment">/* Try to reclaim memory first */</span></div><div class="line">        <span class="keyword">if</span> (!settings.lru_maintainer_thread) &#123;</div><div class="line">            <span class="comment">//如果没有开启maintainer线程,则先看下cold lru是否有过期item回收,有则直接重复利用</span></div><div class="line">            lru_pull_tail(<span class="keyword">id</span>, COLD_LRU, <span class="number">0</span>, <span class="literal">false</span>, cur_hv);</div><div class="line">        &#125;</div><div class="line">        it = slabs_alloc(ntotal, <span class="keyword">id</span>, &amp;total_chunks);<span class="comment">//分配内存</span></div><div class="line">        <span class="keyword">if</span> (settings.expirezero_does_not_evict)</div><div class="line">            total_chunks -= noexp_lru_size(<span class="keyword">id</span>);</div><div class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;<span class="comment">//分不到内存,如果开启maintainer,则看下hot,warm,cold lru是否有过期item</span></div><div class="line">            <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123;</div><div class="line">                lru_pull_tail(<span class="keyword">id</span>, HOT_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</div><div class="line">                lru_pull_tail(<span class="keyword">id</span>, WARM_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</div><div class="line">                lru_pull_tail(<span class="keyword">id</span>, COLD_LRU, total_chunks, <span class="literal">true</span>, cur_hv);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没开启,则强制删除cold lru最后一个item</span></div><div class="line">                lru_pull_tail(<span class="keyword">id</span>, COLD_LRU, <span class="number">0</span>, <span class="literal">true</span>, cur_hv);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">		<span class="comment">/*</span></div><div class="line">		..........</div><div class="line">		*/</div></pre></td></tr></table></figure></p>
<p>当为item分配内存时,先是分析cold lru是否有过期item,有则回收.如果没有过期item,而且开启maintainer线程,则分析hot , warm lru是否有过期item以及直接删除cold lru最后一个item.lru_pull_tail函数用于分析hot,warm,cold lru是否有过期电费item,后面再分析.</p>
<h1>crawler线程</h1>
<hr>
<p>memcache支持手动和自动两种爬虫删除过期item.手动即在客户端中输入命令,自动即开启maintainer线程,接下来先介绍手动方式.当要开启crawler线程,可以通过memcached -o lru_crawler开启也可以在命令行中开启.但是一搬情况是用memcached开启时添加选项memcached -o lru_crawler,lru_maintainer同时开启两个线程,crawler线程开启之后睡眠,等待被唤醒;maintainer线程则不断对lru分析lru和warm使用空间是否已满,满则踢到cold lru.还分析warm和cold lru之间item的交换等等,最后唤醒crawler线程.</p>
<p>客户端也可以通过命令,指定对哪个lru爬虫;</p>
<ol>
<li>lru_crawler &lt;enable|disable&gt; 启动或者停止一个lru爬虫线程;</li>
<li>lru_crawler crawler&lt;classid,classid,classid | all&gt; 可以用2,3,6这样的列表指定对哪个lru队列进行清楚,也可以对所有队列清楚.</li>
<li>lru_crawler sleep&lt;microsecond&gt; 由于lru爬虫时会占用锁,影响worker线程正常作业,所以需要时不时休息下,默认是100微妙</li>
<li>lru_crawler tocrawl &lt;32u&gt; lru可能会有很多item失效,如果一个个去爬虫,则会影响其他worker线程工作,所以就可以用这个这只一次最多爬num个item.</li>
</ol>
<h2>crawler线程开启</h2>
<p>memcached -o lru_crawler或者命令行lru_crawler enable可以调用start_item_crawler_thread开启crawler线程,线程函数为:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">item_crawler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> crawls_persleep = settings.crawls_persleep;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;lru_crawler_lock);</div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Starting LRU crawler background thread\n"</span>);</div><div class="line">    <span class="keyword">while</span> (do_run_lru_crawler_thread) &#123;</div><div class="line">    pthread_cond_wait(&amp;lru_crawler_cond, &amp;lru_crawler_lock);</div><div class="line">    <span class="comment">/*</span></div><div class="line">    .........</div><div class="line">    */</div></pre></td></tr></table></figure></p>
<p>刚开启crawler线程时,先是睡眠,等待被唤醒.我们来假设下客户端命令此时发来爬虫请求,lru_crawler tocrawl 20,lru_crawler crawler 2,4,6即对原始id为2,4,6的lru队列爬虫20个item,此时对9个lru队列爬虫,因为每个原始id都有三个lru队列(hot,warm,cold).lru_crawler tocrawl 20只是简单的settings.lru_crawler_tocrawl属性,lru_crawler crawler命令调用的是lru_crawler_crawl(char *slabs)函数:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">enum</span> crawler_result_type <span class="title">lru_crawler_crawl</span><span class="params">(<span class="keyword">char</span> *slabs)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *b = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">uint32_t</span> sid = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> starts = <span class="number">0</span>;</div><div class="line">    <span class="keyword">uint8_t</span> tocrawl[MAX_NUMBER_OF_SLAB_CLASSES];</div><div class="line">    <span class="keyword">if</span> (pthread_mutex_trylock(&amp;lru_crawler_lock) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> CRAWLER_RUNNING;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 初始化tocrawl数组,存储被爬虫lru索引 */</span></div><div class="line">    <span class="built_in">memset</span>(tocrawl, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>) * MAX_NUMBER_OF_SLAB_CLASSES);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(slabs, <span class="string">"all"</span>) == <span class="number">0</span>) &#123;<span class="comment">//分析crawler命令后来的参数,如果是all</span></div><div class="line">        <span class="keyword">for</span> (sid = <span class="number">0</span>; sid &lt; MAX_NUMBER_OF_SLAB_CLASSES; sid++) &#123;</div><div class="line">            tocrawl[sid] = <span class="number">1</span>;<span class="comment">//对所有的lru队列爬虫</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> *p = strtok_r(slabs, <span class="string">","</span>, &amp;b);<span class="comment">//索引列表</span></div><div class="line">             p != <span class="literal">NULL</span>;</div><div class="line">             p = strtok_r(<span class="literal">NULL</span>, <span class="string">","</span>, &amp;b)) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!safe_strtoul(p, &amp;sid) || sid &lt; POWER_SMALLEST</div><div class="line">                    || sid &gt;= MAX_NUMBER_OF_SLAB_CLASSES<span class="number">-1</span>) &#123;</div><div class="line">                pthread_mutex_unlock(&amp;lru_crawler_lock);</div><div class="line">                <span class="keyword">return</span> CRAWLER_BADCLASS;</div><div class="line">            &#125;</div><div class="line">            tocrawl[sid] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (sid = POWER\_SMALLEST; sid &lt; MAX\_NUMBER_OF_SLAB_CLASSES; sid++) &#123;</div><div class="line">        <span class="keyword">if</span> (tocrawl[sid])</div><div class="line">            <span class="comment">//给原始id为sid的三个队列添加爬虫item</span></div><div class="line">            starts += do_lru_crawler_start(sid, settings.lru_crawler_tocrawl);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (starts) &#123;</div><div class="line">        <span class="comment">//唤醒crawler线程</span></div><div class="line">        pthread_cond_signal(&amp;lru_crawler_cond);</div><div class="line">        pthread_mutex_unlock(&amp;lru_crawler_lock);</div><div class="line">        <span class="keyword">return</span> CRAWLER_OK;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        pthread_mutex_unlock(&amp;lru_crawler_lock);</div><div class="line">        <span class="keyword">return</span> CRAWLER_NOTSTARTED;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数先解析出lru_crawler crawler命令之后的参数,然后分别标记哪些lru需要爬虫,调用do_lru_crawler_start函数安装一个爬虫item,然后唤醒crawler线程爬虫.爬虫item和正常的Item长的很像,但是不存储数据,我们看下它的定义</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">struct</span> _stritem *next;</div><div class="line">    <span class="keyword">struct</span> _stritem *prev;</div><div class="line">    <span class="keyword">struct</span> \_stritem \*h\_next;    <span class="comment">/* hash chain next */</span></div><div class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* least recent access */</span></div><div class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* expire time */</span></div><div class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* size of data */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  refcount;</div><div class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* length of flags-and-length string */</span></div><div class="line">    uint8\<span class="keyword">_t</span>         it\_flags;   <span class="comment">/* ITEM_* above */</span></div><div class="line">    uint8\<span class="keyword">_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></div><div class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key length, w/terminating null and padding */</span></div><div class="line">    <span class="keyword">uint32_t</span>        remaining;  <span class="comment">/* Max keys to crawl per slab per invocation */</span></div><div class="line">&#125; crawler;</div></pre></td></tr></table></figure></p>
<p>就最后一个属性和正常item不一样,其他都一样,所以二者指针可以相互转换,不影响属性值.先来思考一个问题,之前有说过可以设置每次对lru爬item的个数,但是lru为一个链表队列,不支持随机存储,每次访问一个Item都必须从head开始,一个一个访问,那么怎么记录哪些item已经访问,哪些没有访问.memcache设计了上述的crawler爬虫item,给每个lru队列尾端安装一个crawler,然后每次访问一个Item时,crawler前进一个位置.下次爬虫时,直接从crawler节点开始,往前走即可.下面图片来自网络,很好解释了crawler爬虫过程:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_054.png" alt="crawler爬虫过程"></p>
<p>先看下是如何安装爬虫线程
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_lru_crawler_start</span><span class="params">(uint32\<span class="keyword">_t</span> id, uint32\<span class="keyword">_t</span> remaining)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">uint32_t</span> sid;</div><div class="line">    <span class="keyword">uint32_t</span> tocrawl[<span class="number">3</span>];</div><div class="line">    <span class="keyword">int</span> starts = <span class="number">0</span>;</div><div class="line">    <span class="comment">//找到id的三个lru队列,分别安装crawler</span></div><div class="line">    tocrawl[<span class="number">0</span>] = id | HOT_LRU;</div><div class="line">    tocrawl[<span class="number">1</span>] = id | WARM_LRU;</div><div class="line">    tocrawl[<span class="number">2</span>] = id | COLD_LRU;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">        sid = tocrawl[i];</div><div class="line">        pthread_mutex_lock(&amp;lru_locks[sid]);</div><div class="line">        <span class="keyword">if</span> (tails[sid] != <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>)</div><div class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Kicking LRU crawler off for LRU %d\n"</span>, sid);</div><div class="line">            crawlers[sid].nbytes = <span class="number">0</span>;</div><div class="line">            crawlers[sid].nkey = <span class="number">0</span>;</div><div class="line">            crawlers[sid].it_flags = <span class="number">1</span>; <span class="comment">/* 表示这个crawler已开启. */</span></div><div class="line">            crawlers[sid].next = <span class="number">0</span>;</div><div class="line">            crawlers[sid].prev = <span class="number">0</span>;</div><div class="line">            crawlers[sid].time = <span class="number">0</span>;</div><div class="line">            crawlers[sid].remaining = remaining;</div><div class="line">            crawlers[sid].slabs_clsid = sid;</div><div class="line">            crawler_link_q((item *)&amp;crawlers[sid]);<span class="comment">//插索引为sid的lru队列的尾端</span></div><div class="line">            crawler_count++;<span class="comment">//本次爬虫的lru个数加1</span></div><div class="line">            starts++;</div><div class="line">        &#125;</div><div class="line">        pthread_mutex_unlock(&amp;lru_locks[sid]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     ......................</div><div class="line">    */</div></pre></td></tr></table></figure></p>
<p>安装好之后,接下来会唤醒crawler线程,线程开始爬虫
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">item_crawler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> crawls_persleep = settings.crawls_persleep;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;lru_crawler_lock);</div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Starting LRU crawler background thread\n"</span>);</div><div class="line">    <span class="keyword">while</span> (do_run_lru_crawler_thread) &#123;</div><div class="line">    pthread_cond_wait(&amp;lru_crawler_cond, &amp;lru_crawler_lock);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (crawler_count) &#123;</div><div class="line">        item *search = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">void</span> *hold_lock = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (i = POWER_SMALLEST; i &lt; LARGEST_ID; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (crawlers[i].it_flags != <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            pthread_mutex_lock(&amp;lru_locks[i]);</div><div class="line">            <span class="comment">//crawler\_crawl_q函数返回crawler前一个item,并把crawler向前移动一个位置</span></div><div class="line">            search = crawler_crawl_q((item *)&amp;crawlers[i]);</div><div class="line">            <span class="keyword">if</span> (search == <span class="literal">NULL</span> ||</div><div class="line">                (crawlers[i].remaining &amp;&amp; --crawlers[i].remaining &lt; <span class="number">1</span>)) &#123;</div><div class="line">            <span class="comment">//如果search为空或者remaining(一开始设置为爬item的个数)减到为0.</span></div><div class="line">            <span class="comment">//则说明已爬了一条lru</span></div><div class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>)</div><div class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Nothing left to crawl for %d\n"</span>, i);</div><div class="line">                crawlers[i].it_flags = <span class="number">0</span>;<span class="comment">//这个crawler关闭</span></div><div class="line">                crawler_count--;<span class="comment">//爬虫lru个数减1</span></div><div class="line">                crawler_unlink_q((item *)&amp;crawlers[i]);<span class="comment">//删除这个crawler</span></div><div class="line">                pthread_mutex_unlock(&amp;lru_locks[i]);</div><div class="line">                pthread_mutex_lock(&amp;lru_crawler_stats_lock);</div><div class="line">                crawlerstats[CLEAR_LRU(i)].end_time = current_time;</div><div class="line">                crawlerstats[CLEAR_LRU(i)].run_complete = <span class="literal">true</span>;</div><div class="line">                pthread_mutex_unlock(&amp;lru_crawler_stats_lock);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">uint32_t</span> hv = hash(ITEM_key(search), search-&gt;nkey);</div><div class="line">            <span class="comment">/* Attempt to hash item lock the "search" item. If locked, no</span></div><div class="line">             * other callers can incr the refcount</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> ((hold_lock = item_trylock(hv)) == <span class="literal">NULL</span>) &#123;</div><div class="line">                pthread_mutex_unlock(&amp;lru_locks[i]);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* Now see if the item is refcount locked */</span></div><div class="line">            <span class="keyword">if</span> (refcount_incr(&amp;search-&gt;refcount) != <span class="number">2</span>) &#123;</div><div class="line">                refcount_decr(&amp;search-&gt;refcount);</div><div class="line">                <span class="keyword">if</span> (hold_lock)</div><div class="line">                    item_trylock_unlock(hold_lock);</div><div class="line">                pthread_mutex_unlock(&amp;lru_locks[i]);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Frees the item or decrements the refcount. */</span></div><div class="line">            <span class="comment">/* Interface for this could improve: do the free/decr here</span></div><div class="line">             * instead? */</div><div class="line">            pthread_mutex_lock(&amp;lru_crawler_stats_lock);</div><div class="line">            item_crawler_evaluate(search, hv, i);<span class="comment">//这个函数用于判断这个search是否过期,过期则删除.</span></div><div class="line">            pthread_mutex_unlock(&amp;lru_crawler_stats_lock);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (hold_lock)</div><div class="line">                item_trylock_unlock(hold_lock);</div><div class="line">            pthread_mutex_unlock(&amp;lru_locks[i]);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (crawls_persleep &lt;= <span class="number">0</span> &amp;&amp; settings.lru_crawler_sleep) &#123;</div><div class="line">                <span class="comment">//睡眠一段时间,供worker线程操作lru</span></div><div class="line">                usleep(settings.lru_crawler_sleep);</div><div class="line">                crawls_persleep = settings.crawls_persleep;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个爬虫函数对给定的lru队列一个一个爬虫,每次爬一个item,直到爬完整条Lru或者指定的item个数减为0.当所有crawler结束之后,本次爬虫就结束.</p>
<h1>maintainer线程</h1>
<hr>
<p>maintainer线程处于一个while循环中,不断进行lru表维护,即删除过期的item,以及如果hot,warm lru占有内存超过限定额度,则移至cold lru等等.执行完这些操作之后,还会唤醒crawler线程,执行爬虫删除过期item.来看下线程函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">lru_maintainer_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    useconds\<span class="keyword">_t</span> to\_sleep = MIN_LRU_MAINTAINER_SLEEP;</div><div class="line">    rel_time\<span class="keyword">_t</span> last\_crawler_check = <span class="number">0</span>;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;lru_maintainer_lock);</div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Starting LRU maintainer background thread\n"</span>);</div><div class="line">    <span class="keyword">while</span> (do_run_lru_maintainer_thread) &#123;</div><div class="line">        <span class="keyword">int</span> did_moves = <span class="number">0</span>;</div><div class="line">        pthread_mutex_unlock(&amp;lru_maintainer_lock);</div><div class="line">        usleep(to_sleep);</div><div class="line">        pthread_mutex_lock(&amp;lru_maintainer_lock);</div><div class="line"></div><div class="line">        STATS_LOCK();</div><div class="line">        stats.lru_maintainer_juggles++;</div><div class="line">        STATS_UNLOCK();</div><div class="line">        <span class="comment">/* We were asked to immediately wake up and poke a particular slab</span></div><div class="line">         * class due to a low watermark being hit */</div><div class="line">        <span class="keyword">if</span> (lru_maintainer_check_clsid != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//执行维护任务,即上述所说的</span></div><div class="line">            did_moves = lru_maintainer_juggle(lru_maintainer_check_clsid);</div><div class="line">            lru_maintainer_check_clsid = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (i = POWER_SMALLEST; i &lt; MAX_NUMBER_OF_SLAB_CLASSES; i++) &#123;</div><div class="line">                <span class="comment">//对每一个slabclass_t的lru执行维护任务</span></div><div class="line">                did_moves += lru_maintainer_juggle(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (did_moves == <span class="number">0</span>) &#123;<span class="comment">//如果没有移动,则增加睡眠时间</span></div><div class="line">            <span class="keyword">if</span> (to_sleep &lt; MAX_LRU_MAINTAINER_SLEEP)</div><div class="line">                to_sleep += <span class="number">1000</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            to_sleep /= <span class="number">2</span>;<span class="comment">//如果有hot,warm,cold有数据move,则睡眠时间减少</span></div><div class="line">            <span class="keyword">if</span> (to_sleep &lt; MIN_LRU_MAINTAINER_SLEEP)</div><div class="line">                to_sleep = MIN_LRU_MAINTAINER_SLEEP;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* 当有移动时,说明lru数据需要维护,所以睡眠时间减少,如果</span></div><div class="line">           没有移动,说明lru变化不大,则增长睡眠时间</div><div class="line">        */</div><div class="line">        <span class="keyword">if</span> (settings.lru_crawler &amp;&amp; last_crawler_check != current_time) &#123;</div><div class="line">            lru_maintainer_crawler_check();<span class="comment">//执行lru_crawler_start函数,唤醒crawler线程</span></div><div class="line">            last_crawler_check = current_time;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;lru_maintainer_lock);</div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"LRU maintainer thread stopping\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个维护线程不断的维护hot,warm,cold lru,然后再唤醒crawler线程进行爬虫删除.最后再看下lru维护函数
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> lru_maintainer_juggle(<span class="keyword">const</span> <span class="keyword">int</span> slabs_clsid) &#123;</div><div class="line"><span class="comment">//.....................</span></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        <span class="keyword">int</span> do_more = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (lru_pull_tail(slabs_clsid, HOT_LRU, total_chunks, <span class="keyword">false</span>, <span class="number">0</span>) ||</div><div class="line">            lru_pull_tail(slabs_clsid, WARM_LRU, total_chunks, <span class="keyword">false</span>, <span class="number">0</span>)) &#123;</div><div class="line">            do_more++;</div><div class="line">        &#125;</div><div class="line">        do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_chunks, <span class="keyword">false</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (do_more == <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        did_moves++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> did_moves;</div><div class="line"><span class="comment">//这是维护线程调用的一个函数,在这个函数中调用lru_pull_tail函数进行维护</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> lru_pull_tail(<span class="keyword">const</span> <span class="keyword">int</span> orig_id, <span class="keyword">const</span> <span class="keyword">int</span> cur_lru,</div><div class="line">        <span class="keyword">const</span> unsigned <span class="keyword">int</span> total_chunks, <span class="keyword">const</span> <span class="keyword">bool</span> do_evict, <span class="keyword">const</span> uint32_t cur_hv) &#123;</div><div class="line">    item *it = <span class="keyword">NULL</span>;</div><div class="line">    <span class="keyword">int</span> id = orig_id;</div><div class="line">    <span class="keyword">int</span> removed = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> tries = <span class="number">5</span>;</div><div class="line">    item *search;</div><div class="line">    item *next_it;</div><div class="line">    void *hold_lock = <span class="keyword">NULL</span>;</div><div class="line">    unsigned <span class="keyword">int</span> move_to_lru = <span class="number">0</span>;</div><div class="line">    uint64_t limit;</div><div class="line"></div><div class="line">    id |= cur_lru;<span class="comment">//获取真实的lru id. 原始orig_id为hot lru id</span></div><div class="line">    pthread_mutex_lock(&amp;lru_locks[id]);</div><div class="line">    search = tails[id];<span class="comment">//这个lru最后一个item</span></div><div class="line">    <span class="comment">/* We walk up *only* for locked items, and if bottom is expired. */</span></div><div class="line">    <span class="keyword">for</span> (; tries &gt; <span class="number">0</span> &amp;&amp; search != <span class="keyword">NULL</span>; tries--, search=next_it) &#123;</div><div class="line">        <span class="comment">/* we might relink search mid-loop, so search-&gt;prev isn't reliable */</span></div><div class="line">        next_it = search-&gt;prev;</div><div class="line">        <span class="keyword">if</span> (search-&gt;nbytes == <span class="number">0</span> &amp;&amp; search-&gt;nkey == <span class="number">0</span> &amp;&amp; search-&gt;it_flags == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">/* 是一个crawler,直接跳过 */</span></div><div class="line">            tries++;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        uint32\_t\ hv = hash(ITEM\_key(search), search-&gt;nkey);<span class="comment">//这个item的哈希值</span></div><div class="line">        <span class="comment">/* Attempt to hash item lock the "search" item. If locked, no</span></div><div class="line">         * other callers can incr the refcount. Also skip ourselves. */</div><div class="line">        <span class="keyword">if</span> (hv == cur\_hv || (hold\_lock = item\_trylock(hv)) == <span class="keyword">NULL</span>)<span class="comment">//锁住这个哈希桶</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="comment">/* Now see if the item is refcount locked */</span></div><div class="line">        <span class="keyword">if</span> (refcount_incr(&amp;search-&gt;refcount) != <span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">/* Note pathological case with ref'ed items in tail.</span></div><div class="line">             * Can still unlink the item, but it won't be reusable yet */</div><div class="line">            itemstats[id].lrutail_reflocked++;</div><div class="line">            <span class="comment">/* In case of refcount leaks, enable for quick workaround. */</span></div><div class="line">            <span class="comment">/* WARNING: This can cause terrible corruption */</span></div><div class="line">            <span class="keyword">if</span> (settings.tail_repair_time &amp;&amp;</div><div class="line">                    search-&gt;time + settings.tail_repair_time &lt; current_time) &#123;</div><div class="line">                itemstats[id].tailrepairs++;</div><div class="line">                search-&gt;refcount = <span class="number">1</span>;</div><div class="line">                <span class="comment">/* This will call item_remove -&gt; item_free since refcnt is 1 */</span></div><div class="line">                do_item_unlink_nolock(search, hv);</div><div class="line">                item_trylock_unlock(hold_lock);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* 下面这个if语句判断是否过期或者被flush */</span></div><div class="line">        <span class="keyword">if</span> ((search-&gt;exptime != <span class="number">0</span> &amp;&amp; search-&gt;exptime &lt; current_time)</div><div class="line">            || is_flushed(search)) &#123;</div><div class="line">            itemstats[id].reclaimed++;</div><div class="line">            <span class="keyword">if</span> ((search-&gt;it_flags &amp; ITEM_FETCHED) == <span class="number">0</span>) &#123;</div><div class="line">                itemstats[id].expired_unfetched++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/* refcnt 2 -&gt; 1 */</span></div><div class="line">            do_item_unlink_nolock(search, hv);</div><div class="line">            <span class="comment">/* refcnt 1 -&gt; 0 -&gt; item_free */</span></div><div class="line">            do_item_remove(search);</div><div class="line">            item_trylock_unlock(hold_lock);</div><div class="line">            removed++;</div><div class="line"></div><div class="line">            <span class="comment">/* If all we're finding are expired, can keep going */</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.</span></div><div class="line">         * If we're COLD_LRU, send to WARM_LRU unless we need to evict</div><div class="line">         */</div><div class="line">        <span class="keyword">switch</span> (cur_lru) &#123;</div><div class="line">            <span class="keyword">case</span> HOT_LRU:<span class="comment">//这个case没有break,则与warm_lru共用代码</span></div><div class="line">                limit = total_chunks * settings.hot_lru_pct / <span class="number">100</span>;</div><div class="line">            <span class="keyword">case</span> WARM_LRU:</div><div class="line">                limit = total_chunks * settings.warm_lru_pct / <span class="number">100</span>;</div><div class="line">                <span class="keyword">if</span> (sizes[id] &gt; limit) &#123;<span class="comment">//如果hot和warm lru区item空间利用大于32%</span></div><div class="line">                    itemstats[id].moves_to_cold++;</div><div class="line">                    move_to_lru = COLD_LRU;<span class="comment">//移到cold lru区</span></div><div class="line">                    do_item_unlink_q(search);<span class="comment">//先从lru删除,后面会再加到cold lru中</span></div><div class="line">                    it = search;</div><div class="line">                    removed++;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((search-&gt;it_flags &amp; ITEM_ACTIVE) != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">/* Only allow ACTIVE relinking if we're not too large. */</span></div><div class="line">                    itemstats[id].moves_within_lru++;</div><div class="line">                    search-&gt;it_flags &amp;= ~ITEM_ACTIVE;</div><div class="line">                    <span class="comment">//被访问之后,节点就active,所以更新时间,并且插入到lru最前端</span></div><div class="line">                    do_item_update_nolock(search);</div><div class="line">                    do_item_remove(search);<span class="comment">//这里只是降低引用次数</span></div><div class="line">                    item_trylock_unlock(hold_lock);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">/* Don't want to move to COLD, not active, bail out */</span></div><div class="line">                    it = search;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> COLD_LRU:</div><div class="line">                it = search; <span class="comment">/* No matter what, we're stopping */</span></div><div class="line">                <span class="keyword">if</span> (do_evict) &#123;<span class="comment">//如果是可以删除节点</span></div><div class="line">                    <span class="keyword">if</span> (settings.evict_to_free == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">/* Don't think we need a counter for this. It'll OOM.  */</span></div><div class="line">                        <span class="comment">//如果之前设置了不驱逐节点</span></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    itemstats[id].evicted++;</div><div class="line">                    itemstats[id].evicted_time = current_time - search-&gt;time;</div><div class="line">                    <span class="keyword">if</span> (search-&gt;exptime != <span class="number">0</span>)</div><div class="line">                        itemstats[id].evicted_nonzero++;</div><div class="line">                    <span class="keyword">if</span> ((search-&gt;it_flags &amp; ITEM_FETCHED) == <span class="number">0</span>) &#123;</div><div class="line">                        itemstats[id].evicted_unfetched++;</div><div class="line">                    &#125;</div><div class="line">                    do_item_unlink_nolock(search, hv);<span class="comment">//删除这个节点</span></div><div class="line">                    removed++;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((search-&gt;it_flags &amp; ITEM_ACTIVE) != <span class="number">0</span></div><div class="line">                        &amp;&amp; settings.lru_maintainer_thread) &#123;</div><div class="line">                    itemstats[id].moves_to_warm++;</div><div class="line">                    search-&gt;it_flags &amp;= ~ITEM_ACTIVE;<span class="comment">//关闭active</span></div><div class="line">                    move_to_lru = WARM_LRU;<span class="comment">//移到warm lru</span></div><div class="line">                    do_item_unlink_q(search);<span class="comment">//先从这个cold lru删除</span></div><div class="line">                    removed++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (it != <span class="keyword">NULL</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pthread_mutex_unlock(&amp;lru_locks[id]);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (it != <span class="keyword">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (move_to_lru) &#123;</div><div class="line">            it-&gt;slabs\_clsid = ITEM\_clsid(it);<span class="comment">//更细item-&gt;slabs_clsid</span></div><div class="line">            it-&gt;slabs\_clsid |= move\_to_lru;<span class="comment">//找到这个slabs_clsid实际的lru,hot </span></div><div class="line">            <span class="comment">//warm,cold lru?</span></div><div class="line">            item_link_q(it);<span class="comment">//插入lru队列</span></div><div class="line">        &#125;<span class="comment">//不移动,即降低引用次数</span></div><div class="line">        do_item_remove(it);</div><div class="line">        item_trylock_unlock(hold_lock);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> removed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数比较长,也比较难懂.主要就是遍历Lru队列,检查是否有过期的Item,以及lru之间item的迁移,也很符合maintainer维护线程这个名称.</p>
<p>lru维护抓取线程就讲到这了,总结下:</p>
<ul>
<li>每一个slabclass_t都对应四个lru队列,hot,warm,cold,noexp lru,四个lru的索引相差64.</li>
<li>开启maintainer和crawler线程,可以通过memcached -o lru_crawler,lru_maintainer.</li>
<li>可以通过客户端命令指定抓取哪个lru,lru_crawler crawl &lt;classid,classid,classid | all&gt;</li>
<li>maintainer线程主要维护hot,warm,cold lru平衡.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码分析之slabs平衡线程]]></title>
      <url>http://luodw.cc/2016/01/18/memcache-slabs-rebalance/</url>
      <content type="html"><![CDATA[<p>上篇文章分析了memcache哈希表维护线程，其实就是哈希表的扩容线程。这篇文章分析memcache第二个辅助线程slabs平衡线程。先说下这个线程的由来。</p>
<p>在一开始，由于业务原因向memcached存储大量长度为1KB的数据，也就是说memcached服务器进程里面有很多大小为1KB的item。现在由于业务调整需要存储大量10KB的数据，并且很少使用1KB的那些数据了。由于数据越来越多，内存开始吃紧。大小为10KB的那些item频繁访问，并且由于内存不够需要使用LRU淘汰一些10KB的item。</p>
<p>对于上面的情景，会不会觉得大量1KB的item实在太浪费了。由于很少访问这些item，所以即使它们超时过期了，还是会占据着哈希表和LRU队列。LRU队列还好，不同大小的item使用不同的LRU队列。但对于哈希表来说大量的僵尸item会增加哈希冲突的可能性，并且在迁移哈希表的时候也浪费时间。有没有办法干掉这些item？使用LRU爬虫+lru_crawler命令是可以强制干掉这些僵尸item。但干掉这些僵尸item后，它们占据的内存是归还到1KB的那些slab分配器中。1KB的slab分配器不会为10KB的item分配内存。所以还是功亏一篑。</p>
<p>为了解决上述所说的内存浪费，memcache设计了两个辅助线程slab_mantenance_thread和slab_rebalance_thread。这两个线程是由同一个函数开启的，即
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (settings.slab_reassign &amp;&amp;</div><div class="line">        start_slab_maintenance_thread() == -<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>也就说如果要开启这两个线程必须在开启memcache服务器时，加上选项memcached -o slab_reassign. 开启这两个线程之后，需要先说明下这两个线程的作用:</p>
<ol>
<li>maintenance线程做的就是处于一个循环中，检查是否需要进行一次内存页迁移，如果条件满足，则slabs_reassign函数给rebalance线程发送信号，唤起rebalance线程处理内存页迁移操作。但是，如果要使maintenance线程起作用关键，还要设置settings.slab_automove=1.即在memcached启动时，加上memcached -o slab_reassign,slab_automove.这样开启时，automove默认值为1。</li>
<li>rebalance线程主要是处理内存页迁移，一开始该线程wait在一个条件变量中，等待slabs_reassign函数给该线程发送信号，然后才真正执行内存页的迁移。</li>
</ol>
<p>在客户端命令中，也可以设置automove的值，即slabs automove 1.命令行中也可以手动进行内存页迁移，即slabs reassign src dst。</p>
<p>综上所述，</p>
<ol>
<li>如果要开启这两个线程，只能在memcache开启时添加选项memcached -o slab_reassign。</li>
<li>如果要设置automove的值，则可以在memcached开启时设置memcached -o slab_automove;也可以在命令行中设置slabs automove 1.</li>
<li>也可以在命令行中手动指定两个slab进行内存页操作。slabs reassign src dst，前提是rebalance线程已开启。本质上也是调用slabs_reassign函数。</li>
</ol>
<p>automove可以设置为0,1,2。但是在1.4.24版本中，取消了automove=2的使用，所以只要记着automove=0，表示关闭maintenance线程，automove=1表示开启maintenance线程。</p>
<p>接下来，先介绍maintenance线程，因为rebalance线程一开始处于睡眠状态中。</p>
<h1>maintenance线程</h1>
<hr>
<p>maintenance线程开启之后，函数处于一个while循环中，不断进行检测哪个slabclass_t需要内存页slabclass_t[dst]，哪个slabclass_t[src]有多余的内存页，如果选出这两个src,dst，则调用slabs_reassign进行内存页迁移：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">slab_maintenance_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> src, dest;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (do_run_slab_thread) &#123;<span class="comment">//默认为1</span></div><div class="line">        <span class="keyword">if</span> (settings.slab_automove == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (slab_automove_decision(&amp;src, &amp;dest) == <span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">/* Blind to the return codes. It will retry on its own */</span></div><div class="line">                slabs_reassign(src, dest);</div><div class="line">            &#125;</div><div class="line">            sleep(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* Don't wake as often if we're not enabled.</span></div><div class="line">             * This is lazier than setting up a condition right now. */</div><div class="line">            sleep(<span class="number">5</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由函数可以知道，如果没有设置automove，则settings.slab_automove=0，则这个函数不断调用sleep(5)，即一直处于睡眠状态。当设置了automove=1之后，则进行src,dst决策。而且src,dst必须同时不为0，才能返回1，否则进行下一次判断。来看下slab_auto_decision函数：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_stats_evictions</span><span class="params">(<span class="keyword">uint64_t</span> *evicted)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; MAX_NUMBER_OF_SLAB_CLASSES; n++) &#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">int</span> x;</div><div class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</div><div class="line">            i = n | lru_type_map[x];</div><div class="line">            pthread_mutex_lock(&amp;lru_locks[i]);</div><div class="line">            <span class="comment">//这个itemstats数组为itemstats_t类型，属性evicted为lru中因为内存</span></div><div class="line">            <span class="comment">//不足，强制从lru尾部提出item的次数，这个次数在一定程度上反映这个</span></div><div class="line">            <span class="comment">//slabclass_t是否内存不足。</span></div><div class="line">            evicted[n] += itemstats[i].evicted;</div><div class="line">            pthread_mutex_unlock(&amp;lru_locks[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//这个函数用于取出每一个slabclass_t的lru中item驱逐的次数。</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">slab_automove_decision</span><span class="params">(<span class="keyword">int</span> *src, <span class="keyword">int</span> *dst)</span> </span>&#123;</div><div class="line">    <span class="comment">//以下4个变量为static,因为while循环要不断进入这个函数分析，这个四个变量需要</span></div><div class="line">    <span class="comment">//不断更新</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">uint64_t</span> evicted_old[MAX_NUMBER_OF_SLAB_CLASSES];<span class="comment">//之前统计被驱逐的次数</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> slab_zeroes[MAX_NUMBER_OF_SLAB_CLASSES];<span class="comment">//没有被驱逐次数</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> slab_winner = <span class="number">0</span>;<span class="comment">//急需内存页的候选slab</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> slab_wins   = <span class="number">0</span>;<span class="comment">//统计slab_winner被候选的次数</span></div><div class="line">    <span class="comment">//本次所有slabclass_t被驱逐的次数</span></div><div class="line">    <span class="keyword">uint64_t</span> evicted_new[MAX_NUMBER_OF_SLAB_CLASSES];</div><div class="line">    <span class="keyword">uint64_t</span> evicted_diff = <span class="number">0</span>;<span class="comment">//这次和上次驱逐次数的差值</span></div><div class="line">    <span class="keyword">uint64_t</span> evicted_max  = <span class="number">0</span>;<span class="comment">//本次驱逐次数的最大值</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> highest_slab = <span class="number">0</span>;<span class="comment">//本次被选出需要内存页的slab</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> total_pages[MAX_NUMBER_OF_SLAB_CLASSES];<span class="comment">//每个slab内存页总数</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> source = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> dest = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">rel_time_t</span> next_run;</div><div class="line"></div><div class="line">    <span class="comment">/* Run less frequently than the slabmove tester. */</span></div><div class="line">    <span class="keyword">if</span> (current_time &gt;= next_run) &#123;</div><div class="line">        next_run = current_time + <span class="number">10</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;<span class="comment">//这个if语句主要是控制这函数调用的频率，因为在较短时间内，驱逐次数变化不大</span></div><div class="line"></div><div class="line">    item_stats_evictions(evicted_new);<span class="comment">//获取最新的驱逐次数</span></div><div class="line">    pthread_mutex_lock(&amp;slabs_lock);</div><div class="line">    <span class="keyword">for</span> (i = POWER_SMALLEST; i &lt; power_largest; i++) &#123;</div><div class="line">        total_pages[i] = slabclass[i].slabs;<span class="comment">//获取每个slabclass_t总的内存页</span></div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;slabs_lock);</div><div class="line"></div><div class="line">    <span class="comment">/* Find a candidate source; something with zero evicts 3+ times */</span></div><div class="line">    <span class="keyword">for</span> (i = POWER_SMALLEST; i &lt; power_largest; i++) &#123;</div><div class="line">        evicted_diff = evicted_new[i] - evicted_old[i];<span class="comment">//本次和上次驱逐次数差</span></div><div class="line">        <span class="keyword">if</span> (evicted_diff == <span class="number">0</span> &amp;&amp; total_pages[i] &gt; <span class="number">2</span>) &#123;</div><div class="line">            slab_zeroes[i]++;<span class="comment">//如果diff=0,且内存页大于2,则没有被驱逐次数+1</span></div><div class="line">            <span class="keyword">if</span> (source == <span class="number">0</span> &amp;&amp; slab_zeroes[i] &gt;= <span class="number">3</span>)</div><div class="line">                source = i;<span class="comment">//如果source被设置，且没有被驱逐的次数大于3，则这个</span></div><div class="line">                           <span class="comment">//slabclass_t被设置为有多余的内存页。</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果diff!=0或者内存页数小于等于2</span></div><div class="line">            slab_zeroes[i] = <span class="number">0</span>;<span class="comment">//清空没有被驱逐的次数</span></div><div class="line">            <span class="keyword">if</span> (evicted_diff &gt; evicted_max) &#123;</div><div class="line">                evicted_max = evicted_diff;</div><div class="line">                highest_slab = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        evicted_old[i] = evicted_new[i];<span class="comment">//更新evicted_old数组</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Pick a valid destination */</span></div><div class="line">    <span class="keyword">if</span> (slab_winner != <span class="number">0</span> &amp;&amp; slab_winner == highest_slab) &#123;</div><div class="line">        <span class="comment">//如果slab_winner被设置且等于这次的highest_slab</span></div><div class="line">        slab_wins++;</div><div class="line">        <span class="keyword">if</span> (slab_wins &gt;= <span class="number">3</span>)<span class="comment">//如果slab_winner被选中三次，则被选为最需要内存的slabclass</span></div><div class="line">            dest = slab_winner;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则</span></div><div class="line">        slab_wins = <span class="number">1</span>;更新slab_wins=<span class="number">1</span></div><div class="line">        slab_winner = highest_slab;<span class="comment">//slab_winner更新为highest_slab。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (source &amp;&amp; dest) &#123;<span class="comment">//同时设置了source和dest才返回1，进行内存迁移操作。</span></div><div class="line">        *src = source;</div><div class="line">        *dst = dest;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于这个函数处于一个while循环中，所以执行的次数会比较频繁，可以说是一秒一次（sleep(1))，所以需要进行频率控制，全局变量current_time由libevent时间事件每1秒更新一次。所以两次执行函数主体间隔必须操过10秒。函数主体主要是选出有多余内存页和最缺少内存页的slabclass_t。</p>
<ol>
<li>对于选有多余内存页的slabclass_t很简单，主要没有被驱逐的次数超过三次以上且内存页大于2即可。</li>
<li>对于最需要内存页的slabclass_t的选择，主要连续三次被选为驱逐次数最多即可。</li>
</ol>
<p>如果选出了source和dest，则调用slabs_reassign函数，slabs_reassign函数调用do_slabs_reassign函数：
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">reassign_result_type</span> &#123;</span></div><div class="line">    REASSIGN_OK=<span class="number">0</span>, REASSIGN_RUNNING, REASSIGN_BADCLASS, REASSIGN_NOSPARE,</div><div class="line">    REASSIGN_SRC_DST_SAME</div><div class="line">&#125;;</div><div class="line"><span class="regexp">//do</span>_slabs_reassign函数返回类型</div><div class="line">static <span class="class"><span class="keyword">enum</span> <span class="title">reassign_result_type</span> <span class="title">do_slabs_reassign</span>(<span class="title">int</span> <span class="title">src</span>, <span class="title">int</span> <span class="title">dst</span>) &#123;</span></div><div class="line">    <span class="keyword">if</span> (slab_rebalance_signal != <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> REASSIGN_RUNNING;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (src == dst)</div><div class="line">        <span class="keyword">return</span> REASSIGN_SRC_DST_SAME;</div><div class="line"></div><div class="line">    <span class="regexp">/* Special indicator to choose ourselves. */</span></div><div class="line">    <span class="keyword">if</span> (src == -<span class="number">1</span>) &#123;</div><div class="line">        src = slabs_reassign_pick_any(dst);</div><div class="line">        <span class="regexp">/* TODO: If we end up back at -1, return a new error type */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (src &lt; POWER_SMALLEST || src &gt; power_largest ||</div><div class="line">        dst &lt; POWER_SMALLEST || dst &gt; power_largest)</div><div class="line">        <span class="keyword">return</span> REASSIGN_BADCLASS;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (slabclass[src].slabs &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> REASSIGN_NOSPARE;</div><div class="line">    <span class="regexp">//</span>设置全局变量s_clsid和d_clsid属性，用于在rebalance线程处理</div><div class="line">    slab_rebal.s_clsid = src;</div><div class="line">    slab_rebal.d_clsid = dst;</div><div class="line"></div><div class="line">    slab_rebalance_signal = <span class="number">1</span>;</div><div class="line">    pthread_cond_signal(&amp;slab_rebalance_cond);<span class="regexp">//</span>唤醒rebalance线程</div><div class="line"></div><div class="line">    <span class="keyword">return</span> REASSIGN_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要是判断src和dst是否恰当。对于src==-1的情形，是在automove=2的情形下才会出现的，所以就任选一个src。假设src和dst都恰当，则设置全局变量slab_rebal的s_clsid和d_clsid，并设置slab_rebalance_signal=1，这在rebalance线程有使用到，表示唤醒这个rebalance线程，最后唤醒rebalance线程。</p>
<h1>rebalance线程</h1>
<hr>
<p>接下来看下rebalance线程，它是和maintenance线程一起被创建的，一开始处于睡眠状态中，等待被唤醒;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">slab_rebalance_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> was_busy = <span class="number">0</span>;</div><div class="line">    <span class="comment">/* So we first pass into cond_wait with the mutex held */</span></div><div class="line">    mutex_lock(&amp;slabs_rebalance_lock);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (do_run_slab_rebalance_thread) &#123;</div><div class="line">        <span class="keyword">if</span> (slab_rebalance_signal == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (slab_rebalance_start() &lt; <span class="number">0</span>) &#123;<span class="comment">//这个函数主要是设置slab_rebal这个全局变量</span></div><div class="line">                <span class="comment">/* Handle errors with more specifity as required. */</span></div><div class="line">                slab_rebalance_signal = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            was_busy = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slab_rebalance_signal &amp;&amp; slab_rebal.slab_start != <span class="literal">NULL</span>) &#123;</div><div class="line">           <span class="comment">// 如果slab_rebalance_signal=2时，这里主要是为了重复进入move函数</span></div><div class="line">            was_busy = slab_rebalance_move();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (slab_rebal.done) &#123;</div><div class="line">            slab_rebalance_finish();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (was_busy) &#123;</div><div class="line">            <span class="comment">/* Stuck waiting for some items to unlock, so slow down a bit</span></div><div class="line">             * to give them a chance to free up */</div><div class="line">            usleep(<span class="number">50</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//一开始初始化时，rebalance线程睡眠于此</span></div><div class="line">        <span class="keyword">if</span> (slab_rebalance_signal == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/* always hold this lock while we're running */</span></div><div class="line">            pthread_cond_wait(&amp;slab_rebalance_cond, &amp;slabs_rebalance_lock);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数为rebalance线程函数，一开始时，slab_rebalance_signal为0，睡眠在pthread_cond_wait函数中。当被slabs_reassign函数唤醒时，则进入slab_rebalance_start函数，主要是设置需要转移的源slabclass_t和目的slabclass_t的id，以及开始迁移的初始item
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> slab_rebalance_start(void) &#123;</div><div class="line">    slabclass_t *s_cls;</div><div class="line">    <span class="keyword">int</span> no_go = <span class="number">0</span>;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;slabs_lock);</div><div class="line">    <span class="comment">//判断src和dst是否有效</span></div><div class="line">    <span class="keyword">if</span> (slab_rebal.s_clsid &lt; POWER_SMALLEST ||</div><div class="line">        slab_rebal.s_clsid &gt; power_largest  ||</div><div class="line">        slab_rebal.d_clsid &lt; POWER_SMALLEST ||</div><div class="line">        slab_rebal.d_clsid &gt; power_largest  ||</div><div class="line">        slab_rebal.s_clsid == slab_rebal.d_clsid)</div><div class="line">        no_go = <span class="number">-2</span>;</div><div class="line">    <span class="comment">//源slabclass_t</span></div><div class="line">    s_cls = &amp;slabclass[slab_rebal.s_clsid];</div><div class="line">    <span class="comment">//将slabclass_t[dst]的内存页数可能增加</span></div><div class="line">    <span class="keyword">if</span> (!grow_slab_list(slab_rebal.d_clsid)) &#123;</div><div class="line">        no_go = <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (s_cls-&gt;slabs &lt; <span class="number">2</span>)<span class="comment">//源slabclass_t自己不够内存页</span></div><div class="line">        no_go = <span class="number">-3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (no_go != <span class="number">0</span>) &#123;</div><div class="line">        pthread_mutex_unlock(&amp;slabs_lock);</div><div class="line">        <span class="keyword">return</span> no_go; <span class="comment">/* Should use a wrapper function... */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    s_cls-&gt;killing = <span class="number">1</span>;<span class="comment">//默认把第一个内存页迁移到slabclass_t[dst]</span></div><div class="line"></div><div class="line">    slab_rebal.slab_start = s_cls-&gt;slab_list[s_cls-&gt;killing - <span class="number">1</span>];<span class="comment">//第一个item</span></div><div class="line">    slab_rebal.slab_end   = (<span class="keyword">char</span> *)slab_rebal.slab_start +</div><div class="line">        (s_cls-&gt;size * s_cls-&gt;perslab);<span class="comment">//内存页结束位置</span></div><div class="line">    slab_rebal.slab_pos   = slab_rebal.slab_start;<span class="comment">//目前迁移的位置</span></div><div class="line">    slab_rebal.done       = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Also tells do_item_get to search for items in this slab */</span></div><div class="line">    slab_rebalance_signal = <span class="number">2</span>;<span class="comment">//这这个设置主要是为了slab_rebalance_thread线程函数不再进入slab_rebalance_start函数中。</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</div><div class="line">        fprintf(stderr, <span class="string">"Started a slab rebalance\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pthread_mutex_unlock(&amp;slabs_lock);</div><div class="line"></div><div class="line">    STATS_LOCK();</div><div class="line">    stats.slab_reassign_running = <span class="keyword">true</span>;</div><div class="line">    STATS_UNLOCK();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>slab_rebalance_start函数主要是设置slab_rebal这个全局变量，因为在后面的move函数进行真正的迁移时有用到：
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">static</span> int slab_rebalance_move(void) &#123;</div><div class="line">    slabclass_t *s_cls<span class="comment">;</span></div><div class="line">    int x<span class="comment">;</span></div><div class="line">    int was_busy = <span class="number">0</span><span class="comment">;</span></div><div class="line">    int refcount = <span class="number">0</span><span class="comment">;</span></div><div class="line">    uint32_t hv<span class="comment">;</span></div><div class="line">    void *hold_lock<span class="comment">;</span></div><div class="line">    enum <span class="keyword">move_status </span>status = <span class="keyword">MOVE_PASS;</span></div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;slabs_lock)<span class="comment">;</span></div><div class="line"></div><div class="line">    s_cls = &amp;slabclass[slab_rebal.s_clsid]<span class="comment">;//源slabclass_t</span></div><div class="line">    //slab_bulk_check为一次回收的<span class="keyword">item数量，默认为1</span></div><div class="line">    for (x = <span class="number">0</span><span class="comment">; x &lt; slab_bulk_check; x++) &#123;</span></div><div class="line">        hv = <span class="number">0</span><span class="comment">;</span></div><div class="line">        hold_lock = NULL<span class="comment">;</span></div><div class="line">        <span class="keyword">item </span>*<span class="keyword">it </span>= slab_rebal.slab_pos<span class="comment">;//本次回收的item内存位置</span></div><div class="line">        status = <span class="keyword">MOVE_PASS;</span></div><div class="line">        <span class="meta">if</span> (<span class="keyword">it-&gt;slabs_clsid </span>!= <span class="number">255</span>) &#123;</div><div class="line">            <span class="comment">/* ITEM_SLABBED can only be added/removed under the slabs_lock */</span></div><div class="line">            <span class="meta">if</span> (<span class="keyword">it-&gt;it_flags </span>&amp; <span class="keyword">ITEM_SLABBED) </span>&#123;//说明是空闲的<span class="keyword">item，直接从slots删除即可。</span></div><div class="line">                <span class="comment">/* remove from slab freelist */</span></div><div class="line">                <span class="meta">if</span> (s_cls-&gt;slots == <span class="keyword">it) </span>&#123;</div><div class="line">                    s_cls-&gt;slots = <span class="keyword">it-&gt;next;</span></div><div class="line">                &#125;</div><div class="line">                <span class="meta">if</span> (<span class="keyword">it-&gt;next) </span><span class="keyword">it-&gt;next-&gt;prev </span>= <span class="keyword">it-&gt;prev;</span></div><div class="line">                <span class="meta">if</span> (<span class="keyword">it-&gt;prev) </span><span class="keyword">it-&gt;prev-&gt;next </span>= <span class="keyword">it-&gt;next;</span></div><div class="line">                s_cls-&gt;sl_curr--<span class="comment">;</span></div><div class="line">                status = <span class="keyword">MOVE_FROM_SLAB;</span></div><div class="line">            &#125; <span class="meta">else</span> <span class="meta">if</span> ((<span class="keyword">it-&gt;it_flags </span>&amp; <span class="keyword">ITEM_LINKED) </span>!= <span class="number">0</span>) &#123;</div><div class="line">                //假如这个<span class="keyword">Item处于链表中</span></div><div class="line">                hv = hash(<span class="keyword">ITEM_key(it), </span><span class="keyword">it-&gt;nkey);</span></div><div class="line">                <span class="meta">if</span> ((hold_lock = <span class="keyword">item_trylock(hv)) </span>== NULL) &#123;</div><div class="line">                    status = <span class="keyword">MOVE_LOCKED;//这个item被其他worker线程锁住了</span></div><div class="line">                &#125; <span class="meta">else</span> &#123;</div><div class="line">                    refcount = refcount_incr(&amp;<span class="keyword">it-&gt;refcount);</span></div><div class="line">                    <span class="meta">if</span> (refcount == <span class="number">2</span>) &#123; <span class="comment">/* item is linked but not busy */</span></div><div class="line">                        <span class="comment">/* Double check ITEM_LINKED flag here, since we're</span></div><div class="line">                         * past a memory barrier from the mutex. */</div><div class="line">                        <span class="meta">if</span> ((<span class="keyword">it-&gt;it_flags </span>&amp; <span class="keyword">ITEM_LINKED) </span>!= <span class="number">0</span>) &#123;</div><div class="line">                            status = <span class="keyword">MOVE_FROM_LRU;</span></div><div class="line">                        &#125; <span class="meta">else</span> &#123;</div><div class="line">                            <span class="comment">/* refcount == 1 + !ITEM_LINKED means the item is being</span></div><div class="line">                             * uploaded to, or was just unlinked but hasn't been freed</div><div class="line">                             * yet. Let it bleed off on its own and try again later */</div><div class="line">                            status = <span class="keyword">MOVE_BUSY;</span></div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="meta">else</span> &#123;</div><div class="line">                        <span class="meta">if</span> (settings.verbose &gt; <span class="number">2</span>) &#123;</div><div class="line">                            fprintf(stderr, <span class="string">"Slab reassign hit a busy item: refcount: %d (%d -&gt; %d)\n"</span>,</div><div class="line">                                <span class="keyword">it-&gt;refcount, </span>slab_rebal.s_clsid, slab_rebal.d_clsid)<span class="comment">;</span></div><div class="line">                        &#125;</div><div class="line">                        status = <span class="keyword">MOVE_BUSY;</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">/* Item lock must be held while modifying refcount */</span></div><div class="line">                    <span class="meta">if</span> (status == <span class="keyword">MOVE_BUSY) </span>&#123;</div><div class="line">                        refcount_decr(&amp;<span class="keyword">it-&gt;refcount);</span></div><div class="line">                        <span class="keyword">item_trylock_unlock(hold_lock);</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">switch </span>(status) &#123;</div><div class="line">            case <span class="keyword">MOVE_FROM_LRU:</span></div><div class="line">                <span class="comment">/* Lock order is LRU locks -&gt; slabs_lock. unlink uses LRU lock.</span></div><div class="line">                 * We only need to hold the slabs_lock while initially looking</div><div class="line">                 * at an item, and at this point we have an exclusive refcount</div><div class="line">                 * (2) + the item is locked. Drop slabs lock, drop item to</div><div class="line">                 * refcount 1 (just our own, then fall through and wipe it</div><div class="line">                 */</div><div class="line">                pthread_mutex_unlock(&amp;slabs_lock)<span class="comment">;</span></div><div class="line">                do_item_unlink(<span class="keyword">it, </span>hv)<span class="comment">;</span></div><div class="line">                <span class="keyword">item_trylock_unlock(hold_lock);</span></div><div class="line">                pthread_mutex_lock(&amp;slabs_lock)<span class="comment">;</span></div><div class="line">            case <span class="keyword">MOVE_FROM_SLAB:</span></div><div class="line">                <span class="keyword">it-&gt;refcount </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">                <span class="keyword">it-&gt;it_flags </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">                <span class="keyword">it-&gt;slabs_clsid </span>= <span class="number">255</span><span class="comment">;</span></div><div class="line">                <span class="keyword">break;</span></div><div class="line">            case <span class="keyword">MOVE_BUSY:</span></div><div class="line">            case <span class="keyword">MOVE_LOCKED:</span></div><div class="line">                slab_rebal.<span class="keyword">busy_items++;</span></div><div class="line">                was_busy++<span class="comment">;</span></div><div class="line">                <span class="keyword">break;</span></div><div class="line">            case <span class="keyword">MOVE_PASS:</span></div><div class="line">                <span class="keyword">break;</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls-&gt;size<span class="comment">;</span></div><div class="line">        <span class="meta">if</span> (slab_rebal.slab_pos &gt;= slab_rebal.slab_end)</div><div class="line">            <span class="keyword">break;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">if</span> (slab_rebal.slab_pos &gt;= slab_rebal.slab_end) &#123;</div><div class="line">        <span class="comment">/* Some items were busy, start again from the top */</span></div><div class="line">        <span class="meta">if</span> (slab_rebal.<span class="keyword">busy_items) </span>&#123;</div><div class="line">            slab_rebal.slab_pos = slab_rebal.slab_start<span class="comment">;</span></div><div class="line">            slab_rebal.<span class="keyword">busy_items </span>= <span class="number">0</span><span class="comment">;</span></div><div class="line">        &#125; <span class="meta">else</span> &#123;</div><div class="line">            slab_rebal.done++<span class="comment">;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pthread_mutex_unlock(&amp;slabs_lock)<span class="comment">;</span></div><div class="line"></div><div class="line">    return was_busy<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要就是将源slabclass_t的item一个一个回收进slabclass[src]的第一个内存页，这样在slab_rebanlance_finish函数中才可以把这个内存页迁移到slabclass[dst]中
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">static void slab_rebalance_finish(void) &#123;</div><div class="line">    slabclass_t *s_cls;</div><div class="line">    slabclass_t *d_cls;</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;slabs_lock);</div><div class="line"></div><div class="line">    s_cls = &amp;slabclass[slab_rebal.s_clsid];</div><div class="line">    d_cls   = &amp;slabclass[slab_rebal.d_clsid];</div><div class="line"></div><div class="line">    <span class="comment">/* 因为第一个内存页被取走了，所以把这个源slabclass_t的最后一个内存页赋给第一个内存页*/</span></div><div class="line">    <span class="function"><span class="title">s_cls</span>-&gt;</span><span class="function"><span class="title">slab_list</span>[s_cls-&gt;</span>killing - <span class="number">1</span>] =</div><div class="line">        <span class="function"><span class="title">s_cls</span>-&gt;</span><span class="function"><span class="title">slab_list</span>[s_cls-&gt;</span>slabs - <span class="number">1</span>];</div><div class="line">    <span class="function"><span class="title">s_cls</span>-&gt;</span>slabs--;</div><div class="line">    <span class="function"><span class="title">s_cls</span>-&gt;</span>killing = <span class="number">0</span>;</div><div class="line">    <span class="comment">//初始化这个迁移的内存页</span></div><div class="line">    memset(slab_rebal.slab_start, <span class="number">0</span>, (size_t)settings.item_size_max);</div><div class="line">    <span class="comment">//slabclass_t[dst]接收这个内存页</span></div><div class="line">    <span class="function"><span class="title">d_cls</span>-&gt;</span><span class="function"><span class="title">slab_list</span>[d_cls-&gt;</span>slabs++] = slab_rebal.slab_start;</div><div class="line">    <span class="comment">//将这个迁移的内存页按slabclass_t[dst]的item大小分割这个内存页</span></div><div class="line">    split_slab_page_into_freelist(slab_rebal.slab_start,</div><div class="line">        slab_rebal.d_clsid);</div><div class="line"></div><div class="line">    <span class="comment">//还原slab_rebal这个全局变量，</span></div><div class="line">    slab_rebal.done       = <span class="number">0</span>;</div><div class="line">    slab_rebal.s_clsid    = <span class="number">0</span>;</div><div class="line">    slab_rebal.d_clsid    = <span class="number">0</span>;</div><div class="line">    slab_rebal.slab_start = NULL;</div><div class="line">    slab_rebal.slab_end   = NULL;</div><div class="line">    slab_rebal.slab_pos   = NULL;</div><div class="line">    <span class="comment">//内存页迁移结束</span></div><div class="line">    slab_rebalance_signal = <span class="number">0</span>;</div><div class="line"></div><div class="line">    pthread_mutex_unlock(&amp;slabs_lock);</div><div class="line"></div><div class="line">    STATS_LOCK();</div><div class="line">    stats.slab_reassign_running = <span class="literal">false</span>;</div><div class="line">    stats.slabs_moved++;</div><div class="line">    STATS_UNLOCK();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</div><div class="line">        fprintf(stderr, <span class="string">"finished a slab move\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一次内存页迁移就结束了，rebalance线程重新睡眠在pthread_cond_wait函数中，等待下一次被唤醒。</p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码分析之哈希表维护线程]]></title>
      <url>http://luodw.cc/2016/01/13/memcache-assoc-maintenance/</url>
      <content type="html"><![CDATA[<p>上篇文章主要分析了客户端向memcache发送一条命令之后，服务器的执行过程。在memcache服务器中，除了有一个主线程和四个（默认）四个子线程之外，还有四个辅助线程，分别为哈希表维护线程，LRU队列抓取和维护线程，以及slab内存池维护线程。在主线程main函数中，初始化子线程之后再分别进行初始化。调用函数分别如下</p>
<ol>
<li>start_assoc_maintenance_thread()</li>
<li>start_item_crawler_thread()</li>
<li>start_lru_maintainer_thread()</li>
<li>start_slab_maintenance_thread()
其中只有第一个是默认开启的，其他三个线程需要开启memcache时设置-o设置开启。</li>
</ol>
<h1>哈希表维护线程</h1>
<hr>
<p>memcache的哈希表使用链表来解决冲突，如果数据量较小而且分布均匀，则可以达到常量时间访问。但是如果数据分布不均匀，集中在一个桶中，则会降低哈希表的查找效率。所以使用哈希表的应用程序中，都要必要的时候进行哈希表扩容，例如当哈希表中的元素个数等于哈希表大小时，进程扩容。memcache采取的扩容策略为当哈希表中元素个数大于哈希表长度*1.5时，进行扩容，每次向哈希表插入时都要进行判断。</p>
<p>当主线程调用start_assoc_maintenance_thread时，此时初始化hash_bulk_move全局变量，然后创建线程，执行线程函数assoc_maintenance_thread：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">tatic <span class="keyword">void</span> *<span class="title">assoc_maintenance_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line"></div><div class="line">    mutex_lock(&amp;maintenance_lock);</div><div class="line">    <span class="keyword">while</span> (do_run_maintenance_thread) &#123;</div><div class="line">        <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* There is only one expansion thread, so no need to global lock. */</span></div><div class="line">        <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; hash_bulk_move &amp;&amp; expanding; ++ii) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         第一次执行时，由于expanding为初始值false，所以不执行for循环内部</div><div class="line">        */</div><div class="line">        <span class="keyword">if</span> (!expanding) &#123;</div><div class="line">            <span class="comment">/* We are done expanding.. just wait for next invocation */</span></div><div class="line">            started_expanding = <span class="literal">false</span>;</div><div class="line">            pthread_cond_wait(&amp;maintenance_cond, &amp;maintenance_lock);</div><div class="line">            pause_threads(PAUSE_ALL_THREADS);</div><div class="line">            assoc_expand();</div><div class="line">            pause_threads(RESUME_ALL_THREADS);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刚初始化时，由于expanding为false，所以此时维护线程睡眠在if语句中。当向哈希表插入数据时，将会判断是否需要进行扩容，如果是，则唤醒维护线程：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">assoc_insert</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</div><div class="line">    <span class="comment">//。。。。</span></div><div class="line">    <span class="keyword">if</span> (! expanding &amp;&amp; hash_items &gt; (hashsize(hashpower) * <span class="number">3</span>) / <span class="number">2</span>) &#123;</div><div class="line">        assoc_start_expand();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//。。。。</span></div></pre></td></tr></table></figure></p>
<p>hash_items为这个哈希表中存储元素的个数，所以这个if语句就是判断哈希表中数据是否大于哈希表长度*1.5,如果是，则调用assoc_start_expand开始扩容。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assoc_start_expand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (started_expanding)</div><div class="line">        <span class="keyword">return</span>;<span class="comment">//先判断是否已经开始扩容，如果是，则直接返回。</span></div><div class="line"></div><div class="line">    started_expanding = <span class="literal">true</span>;</div><div class="line">    pthread_cond_signal(&amp;maintenance_cond);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数很简单将start_expanding设置为true，防止开启第二个扩容线程。然后唤醒这个扩容线程。有上述代码知，线程唤醒之后，先停止其他辅助线程，然后调用assoc_expand:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assoc_expand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    old_hashtable = primary_hashtable;<span class="comment">//保存原来的哈希表</span></div><div class="line">    <span class="comment">//为新的哈希表分配空间</span></div><div class="line">    primary_hashtable = <span class="built_in">calloc</span>(hashsize(hashpower + <span class="number">1</span>), <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</div><div class="line">    <span class="keyword">if</span> (primary_hashtable) &#123;</div><div class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>)</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hash table expansion starting\n"</span>);</div><div class="line">        hashpower++;<span class="comment">//更新hashpower</span></div><div class="line">        expanding = <span class="literal">true</span>;<span class="comment">//设置expanding，表示正在进行扩容</span></div><div class="line">        expand_bucket = <span class="number">0</span>;<span class="comment">//从第0个桶开始迁移</span></div><div class="line">        STATS_LOCK();</div><div class="line">        <span class="comment">//更新全局状态信息</span></div><div class="line">        stats.hash_power_level = hashpower;</div><div class="line">        stats.hash_bytes += hashsize(hashpower) * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">        stats.hash_is_expanding = <span class="number">1</span>;</div><div class="line">        STATS_UNLOCK();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        primary_hashtable = old_hashtable;</div><div class="line">        <span class="comment">/* 如果分配内存失败，继续用原来的哈希表. */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>assoc_expand函数为新的哈希表分配内存空间，然后更新一些全局变量，这个函数结束之后，最后回到assoc_maintenance_thread线程函数中的while循环。这时由于设置了expanding，所以进入扩容步骤代码:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">assoc_maintenance_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line"></div><div class="line">    mutex_lock(&amp;maintenance_lock);</div><div class="line">    <span class="keyword">while</span> (do_run_maintenance_thread) &#123;</div><div class="line">        <span class="keyword">int</span> ii = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* 因为只有一个扩容线程，所以没必要锁住这个哈希表 */</span></div><div class="line">        <span class="comment">//这个hash_bulk_move表示一次将old哈希中的一个链表迁移到新的哈希表中，主要是给工作</span></div><div class="line">        <span class="comment">//线程腾出锁</span></div><div class="line">        <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; hash_bulk_move &amp;&amp; expanding; ++ii) &#123;</div><div class="line">            item *it, *next;</div><div class="line">            <span class="keyword">int</span> bucket;</div><div class="line">            <span class="keyword">void</span> *item_lock = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ((item_lock = item_trylock(expand_bucket))) &#123;<span class="comment">//获取第expand_bucket个链表的锁</span></div><div class="line">                    <span class="keyword">for</span> (it = old_hashtable[expand_bucket]; <span class="literal">NULL</span> != it; it = next) &#123;</div><div class="line">                        next = it-&gt;h_next;<span class="comment">//迭代链表</span></div><div class="line">                        <span class="comment">//这个item在新哈希表中的桶</span></div><div class="line">                        bucket = hash(ITEM_key(it), it-&gt;nkey) &amp; hashmask(hashpower);</div><div class="line">                        it-&gt;h_next = primary_hashtable[bucket];<span class="comment">//这个item存入新的哈希表</span></div><div class="line">                        primary_hashtable[bucket] = it;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//old哈希表第expand_bucket个桶置空</span></div><div class="line">                    old_hashtable[expand_bucket] = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">                    expand_bucket++;<span class="comment">//更新expand_bucket，指向下一个迁移的桶</span></div><div class="line">                    <span class="keyword">if</span> (expand_bucket == hashsize(hashpower - <span class="number">1</span>)) &#123;<span class="comment">//如果最后一个桶已迁移完毕</span></div><div class="line">                        expanding = <span class="literal">false</span>;<span class="comment">//取消扩容标识</span></div><div class="line">                        <span class="built_in">free</span>(old_hashtable);<span class="comment">//回收old哈希表空间</span></div><div class="line">                        STATS_LOCK();<span class="comment">//更新全局信息</span></div><div class="line">                        stats.hash_bytes -= hashsize(hashpower - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</div><div class="line">                        stats.hash_is_expanding = <span class="number">0</span>;</div><div class="line">                        STATS_UNLOCK();</div><div class="line">                        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>)</div><div class="line">                            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Hash table expansion done\n"</span>);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//未获取锁，则休息10秒，等待工作线程释放</span></div><div class="line">                usleep(<span class="number">10</span>*<span class="number">1000</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (item_lock) &#123;</div><div class="line">                item_trylock_unlock(item_lock);</div><div class="line">                item_lock = <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!expanding) &#123;</div></pre></td></tr></table></figure></p>
<p>看到这个扩容线程，我深深体会到哈希表可以这么支持高并发。</p>
<ol>
<li>首先在哈希表上加锁时，是加在每个桶上，而不是整个哈希表，这样可以支持多个线程操作一个哈希表中的不同桶；</li>
<li>其次在扩容时，并不是一次性将所有数据从旧的哈希表迁移到新的哈希表，而是一次性迁移一个桶，这样可以避免锁住整个哈希表，导致工作线程阻塞；当迁移时，加锁，释放锁，这样其他工作线程在释放锁的瞬间还可以获取锁，操作哈希表。
当最后一个桶迁移之后，重新进入while循环，此时expanding被置为false，所以此时和线程初始化时是一模一样的，重新睡眠在pthread_cond_wait(&amp;maintenance_cond, &amp;maintenance_lock);中。等待被唤醒，执行下一次扩容。</li>
</ol>
<p>memcache哈希表维护线程主要做的就是当哈希表元素数量和哈希表大小达到一定比例时，进行哈希表扩容。下篇将介绍slab平衡线程。</p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码分析之状态机]]></title>
      <url>http://luodw.cc/2016/01/12/memcache-drive-machine/</url>
      <content type="html"><![CDATA[<p>上一篇文章分析了memcache的启动过程以及线程模型。稍微回顾下，首先主线程的libevent实例负责监听服务器listenfd，当有客户端connect时，主线程调用listenfd事件监听回调函数dispatch_conn_new将这个clientfd发送给空闲的子线程，子线程则调用管道读端的回调函数thread_libevent_process将这个clientfd放进自己的libevent事件循环中，之后这个子线程就负责这个clientfd的事务处理。</p>
<p>接来主要是分析客户端发送命令之后，服务器是如何处理这个命令，这就涉及到服务器端的状态机，状态机就是一个巨大的switch，针对客户端不同的状态，执行不同的程序。先来看下都有哪些状态了：
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">conn_states</span> &#123;</span></div><div class="line">    conn_listening,  <span class="regexp">/**&lt; the socket which listens for connections */</span></div><div class="line">    conn_new_cmd,    <span class="regexp">/**&lt; Prepare connection for next command */</span></div><div class="line">    conn_waiting,    <span class="regexp">/**&lt; waiting for a readable socket */</span></div><div class="line">    conn_read,       <span class="regexp">/**&lt; reading in a command line */</span></div><div class="line">    conn_parse_cmd,  <span class="regexp">/**&lt; try to parse a command from the input buffer */</span></div><div class="line">    conn_write,      <span class="regexp">/**&lt; writing out a simple response */</span></div><div class="line">    conn_nread,      <span class="regexp">/**&lt; reading in a fixed number of bytes */</span></div><div class="line">    conn_swallow,    <span class="regexp">/**&lt; swallowing unnecessary bytes w/o</span> storing *<span class="regexp">/</span></div><div class="line">    conn_closing,    /**&lt; closing this connection *<span class="regexp">/</span></div><div class="line">    conn_mwrite,     /**&lt; writing <span class="keyword">out</span> many items sequentially *<span class="regexp">/</span></div><div class="line">    conn_closed,     /**&lt; connection is closed *<span class="regexp">/</span></div><div class="line">    conn_max_state   /**&lt; Max state value (used <span class="keyword">for</span> assertion) *<span class="regexp">/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这些状态中主线程的listenfd永远处于conn_listening中，用于接收客户端请求；刚连上的客户端总是conn_new_cmd状态，等待接收用户命令。其他状态很多是从conn_new_cmd开始演变的。先来看下conn_listening状态下的执行：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">case</span> conn_listening:</div><div class="line">            addrlen = <span class="keyword">sizeof</span>(addr);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_ACCEPT4</span></div><div class="line">            <span class="keyword">if</span> (use_accept4) &#123;<span class="comment">//accept4这个版本主要可以设置套接字非阻塞</span></div><div class="line">                sfd = accept4(c-&gt;sfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrlen, SOCK_NONBLOCK);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                sfd = accept(c-&gt;sfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrlen);</div><div class="line">            &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">            <span class="comment">//接受客户端请求</span></div><div class="line">            sfd = accept(c-&gt;sfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;addrlen);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;<span class="comment">//accept接收错误，返回-1</span></div><div class="line">                <span class="keyword">if</span> (use_accept4 &amp;&amp; errno == ENOSYS) &#123;</div><div class="line">                    use_accept4 = <span class="number">0</span>;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;<span class="comment">//如果是因为调用accept4出错，则从头开始继续执行conn_listening,第二次调用accept版本</span></div><div class="line">                perror(use_accept4 ? <span class="string">"accept4()"</span> : <span class="string">"accept()"</span>);<span class="comment">//判断是哪个版本的accept</span></div><div class="line">                <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</div><div class="line">                    <span class="comment">/* these are transient, so don't log anything */</span></div><div class="line">                    stop = <span class="literal">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EMFILE) &#123;</div><div class="line">                    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</div><div class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Too many open connections\n"</span>);</div><div class="line">                    accept_new_conns(<span class="literal">false</span>);<span class="comment">//如果连接的客户端太多，则把所有listenfd的监听事件清空，</span></div><div class="line"><span class="comment">//也就是不再接受请求</span></div><div class="line">                    stop = <span class="literal">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    perror(<span class="string">"accept()"</span>);</div><div class="line">                    stop = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!use_accept4) &#123;<span class="comment">//如果调用的是accept，则将套接字设为非阻塞</span></div><div class="line">                <span class="keyword">if</span> (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) &lt; <span class="number">0</span>) &#123;</div><div class="line">                    perror(<span class="string">"setting O_NONBLOCK"</span>);</div><div class="line">                    close(sfd);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//如果接收了客户端套接字，发现套接字过多，则把刚接收的客户端关闭</span></div><div class="line">            <span class="keyword">if</span> (settings.maxconns_fast &amp;&amp;</div><div class="line">                stats.curr_conns + stats.reserved_fds &gt;= settings.maxconns - <span class="number">1</span>) &#123;</div><div class="line">                str = <span class="string">"ERROR Too many open connections\r\n"</span>;</div><div class="line">                res = write(sfd, str, <span class="built_in">strlen</span>(str));</div><div class="line">                close(sfd);</div><div class="line">                STATS_LOCK();</div><div class="line">                stats.rejected_conns++;</div><div class="line">                STATS_UNLOCK();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//最终没问题的话，将这个客户端分配一个空闲的子线程</span></div><div class="line">                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,</div><div class="line">                                     DATA_BUFFER_SIZE, tcp_transport);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            stop = <span class="literal">true</span>;<span class="comment">//设置退出while循环</span></div><div class="line">            <span class="keyword">break</span>;<span class="comment">//退出状态机</span></div></pre></td></tr></table></figure></p>
<p>这个conn_listening状态下，主要是先接收客户端的套接字，然后判断函数调用是否出错以及这个进程的文件描述符是否过多，并做相应的处理。最后都没有问题后，再将客户端的套接字发给空闲的子线程。</p>
<p>接下来看子线程如何处理客户发来的请求，首先进入的是状态conn_new_cmd
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">conn_new_cmd:</span></div><div class="line">           <span class="comment">/* 客户端每一次执行命令，最多可执行nreqs个命令，防止其他命令饥饿 */</span></div><div class="line">           --nreqs;</div><div class="line">           <span class="keyword">if</span> (nreqs &gt;= <span class="number">0</span>) &#123;</div><div class="line">               reset_cmd_handler(c);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">           </div><div class="line">          &#125;</div><div class="line">           <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>因为首次进入这个状态，nreqs肯定大于0，所以就把else后面给删了。因为客户端一次连接可能有多条命令执行，为了防止其他连接得不到处理机会，所以限制一个客户端最多可以执行nreqs个命令。默认20条，可以通过-R设置。接下来看下reset_cmd_handler函数:
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> void reset_cmd_handler(conn *<span class="built_in">c</span>) &#123;</div><div class="line">    <span class="built_in">c</span>-&gt;cmd = -<span class="number">1</span>;</div><div class="line">    <span class="built_in">c</span>-&gt;substate = bin_no_state;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">c</span>-&gt;item != <span class="type">NULL</span>) &#123;<span class="comment">//这个item主要是用来存放set/add/replace命令生成的item结构</span></div><div class="line">        item_remove(<span class="built_in">c</span>-&gt;item);<span class="comment">//所以先清空，给下一个命令</span></div><div class="line">        <span class="built_in">c</span>-&gt;item = <span class="type">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    conn_shrink(<span class="built_in">c</span>);<span class="comment">//判断这个客户端连接缓冲区是否过大，是，则要缩小缓冲区</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;rbytes &gt; <span class="number">0</span>) &#123;</div><div class="line">        conn_set_state(<span class="built_in">c</span>, conn_parse_cmd);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">//因为一开始时，没有读取客户端数据，所以c-&gt;rbytes为0</span></div><div class="line">        conn_set_state(<span class="built_in">c</span>, conn_waiting);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>c-&gt;rbytes为客户端缓冲区中还没有被解析的缓冲区空间，除了在conn_new中被设置为0 外，就没有被设置，所以接下来执行的是conn_set_state(c,conn_waiting)，这函数就是简单的把状态改为了conn_waiting，好，接下来看下conn_waiting执行过程。
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> conn_waiting:</div><div class="line">    <span class="keyword">if</span> (!update_event(<span class="built_in">c</span>, <span class="type">EV_READ</span> | <span class="type">EV_PERSIST</span>)) &#123;</div><div class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</div><div class="line">            fprintf(stderr, <span class="string">"Couldn't update event\n"</span>);</div><div class="line">        conn_set_state(<span class="built_in">c</span>, conn_closing);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;<span class="comment">//将这个客户端更新为可读事件</span></div><div class="line">    conn_set_state(<span class="built_in">c</span>, conn_read);<span class="comment">//状态更新为conn_read</span></div><div class="line">    stop = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">break</span>;<span class="comment">//退出状态机</span></div></pre></td></tr></table></figure></p>
<p>很多奇怪，都没读取客户端的数据，怎么退出这个状态机了。到底是怎么回事了？原来是libevent的epoll默认使用的是“水平触发”，即只要有数据在接收缓冲区中，就会通知读事件。所以在下一个libevent事件轮询中，这个clientfd又触发可读事件，这时的状态为conn_read，来看下这个conn_read是怎么执行的。
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="string">conn_read:</span></div><div class="line">         res = IS_UDP(c-&gt;transport) ? try_read_udp(c) : try_read_network(c);</div><div class="line"></div><div class="line">         <span class="keyword">switch</span> (res) &#123;</div><div class="line">         <span class="keyword">case</span> <span class="string">READ_NO_DATA_RECEIVED:</span></div><div class="line">             conn_set_state(c, conn_waiting);</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">         <span class="keyword">case</span> <span class="string">READ_DATA_RECEIVED:</span></div><div class="line">             conn_set_state(c, conn_parse_cmd);</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">         <span class="keyword">case</span> <span class="string">READ_ERROR:</span></div><div class="line">             conn_set_state(c, conn_closing);</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">         <span class="keyword">case</span> <span class="string">READ_MEMORY_ERROR:</span> <span class="comment">/* Failed to allocate more memory */</span></div><div class="line">             <span class="comment">/* State already set by try_read_network */</span></div><div class="line">             <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>进入conn_read之后才开始从套接字读取set xxx\r\n。
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">static enum try_read_result try_read_network(conn *c) &#123;</div><div class="line">    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;<span class="comment">//默认返回的状态为没有取到数据</span></div><div class="line">    int res;</div><div class="line">    int num_allocs = <span class="number">0</span>;</div><div class="line">    assert(c != NULL);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">rcurr</span> != c-&gt;</span>rbuf) &#123;</div><div class="line">        <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">rbytes</span> != 0) /* c-&gt;</span>rbuf中还有数据未处理 */</div><div class="line">            <span class="function"><span class="title">memmove</span>(c-&gt;</span><span class="function"><span class="title">rbuf</span>, c-&gt;</span><span class="function"><span class="title">rcurr</span>, c-&gt;</span><span class="function"><span class="title">rbytes</span>);//将未处理数据移至c-&gt;</span>rbuf起始处</div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">rcurr</span> = c-&gt;</span>rbuf;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">rbytes</span> &gt;= c-&gt;</span>rsize) &#123;<span class="comment">//读buffer空间扩充</span></div><div class="line">            <span class="keyword">if</span> (num_allocs == <span class="number">4</span>) &#123;</div><div class="line">                return gotdata;</div><div class="line">            &#125;</div><div class="line">            ++num_allocs;</div><div class="line">            <span class="function"><span class="title">char</span> *new_rbuf = realloc(c-&gt;</span><span class="function"><span class="title">rbuf</span>, c-&gt;</span>rsize * <span class="number">2</span>);</div><div class="line">            <span class="keyword">if</span> (!new_rbuf) &#123;</div><div class="line">                STATS_LOCK();</div><div class="line">                stats.malloc_fails++;</div><div class="line">                STATS_UNLOCK();</div><div class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>) &#123;</div><div class="line">                    fprintf(stderr, <span class="string">"Couldn't realloc input buffer\n"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="function"><span class="title">c</span>-&gt;</span>rbytes = <span class="number">0</span>; <span class="comment">/* ignore what we read */</span></div><div class="line">                out_of_memory(c, <span class="string">"SERVER_ERROR out of memory reading request"</span>);</div><div class="line">                <span class="function"><span class="title">c</span>-&gt;</span>write_and_go = conn_closing;</div><div class="line">                return READ_MEMORY_ERROR;</div><div class="line">            &#125;</div><div class="line">            <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">rcurr</span> = c-&gt;</span>rbuf = new_rbuf;<span class="comment">//指向新的缓存空间</span></div><div class="line">            <span class="function"><span class="title">c</span>-&gt;</span>rsize *= <span class="number">2</span>;<span class="comment">//缓存大小翻倍</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">int</span> avail = c-&gt;</span><span class="function"><span class="title">rsize</span> - c-&gt;</span>rbytes;<span class="comment">//读buffer中可用的空间</span></div><div class="line">        <span class="function"><span class="title">res</span> = read(c-&gt;</span><span class="function"><span class="title">sfd</span>, c-&gt;</span><span class="function"><span class="title">rbuf</span> + c-&gt;</span>rbytes, avail);<span class="comment">//读取数据</span></div><div class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="function"><span class="title">pthread_mutex_lock</span>(&amp;c-&gt;</span><span class="function"><span class="title">thread</span>-&gt;</span>stats.mutex);</div><div class="line">            <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">thread</span>-&gt;</span>stats.bytes_read += res;</div><div class="line">            <span class="function"><span class="title">pthread_mutex_unlock</span>(&amp;c-&gt;</span><span class="function"><span class="title">thread</span>-&gt;</span>stats.mutex);</div><div class="line">            gotdata = READ_DATA_RECEIVED;</div><div class="line">            <span class="function"><span class="title">c</span>-&gt;</span>rbytes += res;<span class="comment">//已分配使用的内存+res</span></div><div class="line">            <span class="keyword">if</span> (res == avail) &#123;</div><div class="line">                continue;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</div><div class="line">            return READ_ERROR;<span class="comment">//表明客户端断开连接，所以服务器将关闭这个客户端连接</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (res == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            return READ_ERROR;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return gotdata;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个读取数据函数，如果c-rbytes&gt;=r-&gt;rsize，说明客户端的读buffer缓存已满，这时要进行buffer扩充，然后再读取数据。读取数据之后，还有判断是否还有数据可读，即判断读buffer是否已满，如果是，则还要进行第二次读buffer扩容，最多执行4次扩容。好，假设数据已经读取到读buffer里了，接来返回的是READ_DATA_RECEIVED，这个值所处的代码区将客户端状态改为conn_parse_cmd：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> conn_parse_cmd :</div><div class="line">          <span class="keyword">if</span> (try_read_command(c) == 0) &#123;</div><div class="line">              <span class="comment">/* wee need more data! */</span></div><div class="line">              conn_set_state(c, conn_waiting);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>因为客户端读buffer中数据可能还不是一条完整的命令，所以这里也只是try_read_command,如果真的返回0，则重新进入conn_waiting状态，等待下一次轮询中读取数据。假设读buffer中已经有一条完整的命令，接下来看下是如何读取这个命令的。这里把主要代码摘过来
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static int try_read_command(conn *c) &#123;</div><div class="line">         char *el, *cont;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">if</span> (c-&gt;</span>rbytes == <span class="number">0</span>)<span class="comment">//没有数据，则直接返回0退出</span></div><div class="line">            return <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">el</span> = memchr(c-&gt;</span><span class="function"><span class="title">rcurr</span>, '\n', c-&gt;</span>rbytes);<span class="comment">//找到第一条命令结尾，'\n'</span></div><div class="line">        <span class="keyword">if</span> (!el) &#123;</div><div class="line">           <span class="comment">//.....</span></div><div class="line">           <span class="comment">/*</span></div><div class="line">           如没有没有找到换行符，则说明读buffer中还不是一条完整的命令，则返回0</div><div class="line">           */</div><div class="line">            return <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        cont = el + <span class="number">1</span>;<span class="comment">//cont为下一条命令第一个字节</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">        下面这个if的作用就是把命令中的\r换成'\0'，这样在读取c-&gt;rcurr时，就</div><div class="line">        可以读取完整的一条命令</div><div class="line">        */</div><div class="line">        <span class="function"><span class="title">if</span> ((el - c-&gt;</span>rcurr) &gt; <span class="number">1</span> &amp;&amp; *(el - <span class="number">1</span>) == <span class="string">'\r'</span>) &#123;</div><div class="line">            el--;</div><div class="line">        &#125;</div><div class="line">        *el = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="title">assert</span>(cont &lt;= (c-&gt;</span><span class="function"><span class="title">rcurr</span> + c-&gt;</span>rbytes));</div><div class="line"></div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>last_cmd_time = current_time;</div><div class="line">        <span class="function"><span class="title">process_command</span>(c, c-&gt;</span>rcurr);<span class="comment">//执行命令，详见process_command函数</span></div><div class="line"></div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">rbytes</span> -= (cont - c-&gt;</span>rcurr);<span class="comment">//读buffer还没被解析的字节数</span></div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">rcurr</span> = cont;//把c-&gt;</span>rcurr指向下一个命令开头</div><div class="line"></div><div class="line">        <span class="function"><span class="title">assert</span>(c-&gt;</span><span class="function"><span class="title">rcurr</span> &lt;= (c-&gt;</span><span class="function"><span class="title">rbuf</span> + c-&gt;</span>rsize));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数先将命令的的\r替换成\0，这样在读取c-&gt;rcurr时，可以整体命令，然后调用process_command处理命令，最后更新c-&gt;rbytes和c-&gt;rcurr指向下一条命令。</p>
<p>这里科普下memcache的set命令协议，一条完整的set命令需要两行，也就是需要按两次回车换行“\r\n”，第一行叫“命令行”，格式是SET key flags exptime bytes\r\n，如SET name 0 0 5\r\n， 键为name，flags标志位可暂时不管，超时设为0，value的字节长度是4。然后才有第二行叫“数据行”，格式为：value\r\n，例如：calix\r\n。这两行分别敲下去，SET命令才算完成。</p>
<p>下面看下process_command是如何处理命令的。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_command</span><span class="params">(conn *c, <span class="keyword">char</span> *command)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">token_t</span> tokens[MAX_TOKENS];</div><div class="line">    <span class="keyword">size_t</span> ntokens;</div><div class="line">    <span class="keyword">int</span> comm;</div><div class="line">    assert(c != <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">//将命令行分割成一个一个字符串</span></div><div class="line">    ntokens = tokenize_command(command, tokens, MAX_TOKENS);</div><div class="line">    <span class="keyword">if</span> (ntokens &gt;= <span class="number">3</span> &amp;&amp;</div><div class="line">        ((<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"get"</span>) == <span class="number">0</span>) ||</div><div class="line">         (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"bget"</span>) == <span class="number">0</span>))) &#123;</div><div class="line">        <span class="comment">//执行get命令函数</span></div><div class="line">        process_get_command(c, tokens, ntokens, <span class="literal">false</span>);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((ntokens == <span class="number">6</span> || ntokens == <span class="number">7</span>) &amp;&amp;</div><div class="line">               ((<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"add"</span>) == <span class="number">0</span> &amp;&amp; (comm = NREAD_ADD)) ||</div><div class="line">                (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"set"</span>) == <span class="number">0</span> &amp;&amp; (comm = NREAD_SET)) ||</div><div class="line">                (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"replace"</span>) == <span class="number">0</span> &amp;&amp; (comm = NREAD_REPLACE)) ||</div><div class="line">                (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"prepend"</span>) == <span class="number">0</span> &amp;&amp; (comm = NREAD_PREPEND)) ||</div><div class="line">                (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"append"</span>) == <span class="number">0</span> &amp;&amp; (comm = NREAD_APPEND)) )) &#123;</div><div class="line">        <span class="comment">//执行set命令函数</span></div><div class="line">        process_update_command(c, tokens, ntokens, comm, <span class="literal">false</span>);</div><div class="line">        <span class="keyword">return</span>;</div></pre></td></tr></table></figure></p>
<p>这个process_command这个函数就是根据不同的命令执行不同的函数，我们针对set命令，介绍下procee_update_command函数：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) &#123;</div><div class="line">    <span class="comment">//分配一个item结构，存储数据</span></div><div class="line">    it = item_alloc(key, nkey, flags, realtime(exptime), vlen);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (it == <span class="number">0</span>) &#123;<span class="comment">//没有分配到item</span></div><div class="line">        <span class="keyword">if</span> (! item_size_ok(nkey, flags, vlen))<span class="comment">//item数据太大</span></div><div class="line">            out_string(c, <span class="string">"SERVER_ERROR object too large for cache"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            out_of_memory(c, <span class="string">"SERVER_ERROR out of memory storing object"</span>);</div><div class="line">        <span class="comment">/* swallow the data line */</span></div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>write_and_go = conn_swallow;</div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>sbytes = vlen;</div><div class="line"></div><div class="line">        <span class="comment">/* Avoid stale data persisting in cache because we failed alloc.</span></div><div class="line">         * Unacceptable for SET. Anywhere else too? */</div><div class="line">        <span class="keyword">if</span> (comm == NREAD_SET) &#123;</div><div class="line">            it = item_get(key, nkey);</div><div class="line">            <span class="keyword">if</span> (it) &#123;</div><div class="line">                item_unlink(it);</div><div class="line">                item_remove(it);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ITEM_set_cas(it, req_cas_id);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span>item = it;<span class="comment">//item指向这个It</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span>ritem = ITEM_data(it);<span class="comment">//ritem指向it的数据部分</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">rlbytes</span> = it-&gt;</span>nbytes;<span class="comment">//这个item数据长度</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span>cmd = comm;<span class="comment">//命令类型</span></div><div class="line">    conn_set_state(c, conn_nread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要是调用调用item_alloc分配内存，这时的item还是由client的conn管理，而且此时还未存入数据，并把ritem指向这个item的数据部分，等有读取数据之后，再将数据拷贝到ritem。接来下，看下conn_nread读取数据行部分
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">case conn_nread:</div><div class="line">          <span class="function"><span class="title">if</span> (c-&gt;</span>rlbytes == <span class="number">0</span>) &#123;</div><div class="line">              complete_nread(c);</div><div class="line">              break;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">/*</span></div><div class="line">   因为conn中的读buffer还不一定保存有所有数据行需要的数据，所以</div><div class="line">          读取rbytes(读buffer还未解析的数据长度)和rlbytes(这个item的数据</div><div class="line">          部分长度)的最小值。           </div><div class="line">    */</div><div class="line">           <span class="function"><span class="title">if</span> (c-&gt;</span>rbytes &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="function"><span class="title">int</span> tocopy = c-&gt;</span><span class="function"><span class="title">rbytes</span> &gt; c-&gt;</span><span class="function"><span class="title">rlbytes</span> ? c-&gt;</span><span class="function"><span class="title">rlbytes</span> : c-&gt;</span>rbytes;</div><div class="line">              <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">ritem</span> != c-&gt;</span>rcurr) &#123;</div><div class="line">                  <span class="function"><span class="title">memmove</span>(c-&gt;</span><span class="function"><span class="title">ritem</span>, c-&gt;</span>rcurr, tocopy);<span class="comment">//将数据拷贝之item数据部分</span></div><div class="line">              &#125;</div><div class="line">              <span class="function"><span class="title">c</span>-&gt;</span>ritem += tocopy;</div><div class="line">              <span class="function"><span class="title">c</span>-&gt;</span>rlbytes -= tocopy;</div><div class="line">              <span class="function"><span class="title">c</span>-&gt;</span>rcurr += tocopy;</div><div class="line">              <span class="function"><span class="title">c</span>-&gt;</span>rbytes -= tocopy;</div><div class="line">              <span class="function"><span class="title">if</span> (c-&gt;</span>rlbytes == <span class="number">0</span>) &#123;<span class="comment">//数据部分全部读取完毕，则退出这个状态</span></div><div class="line">                  break;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">/*  now try reading from the socket */</span></div><div class="line">          <span class="function"><span class="title">res</span> = read(c-&gt;</span><span class="function"><span class="title">sfd</span>, c-&gt;</span><span class="function"><span class="title">ritem</span>, c-&gt;</span>rlbytes);<span class="comment">//从socket缓冲区中读取数据剩余部分</span></div><div class="line">          <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="function"><span class="title">pthread_mutex_lock</span>(&amp;c-&gt;</span><span class="function"><span class="title">thread</span>-&gt;</span>stats.mutex);</div><div class="line">              <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">thread</span>-&gt;</span>stats.bytes_read += res;</div><div class="line">              <span class="function"><span class="title">pthread_mutex_unlock</span>(&amp;c-&gt;</span><span class="function"><span class="title">thread</span>-&gt;</span>stats.mutex);</div><div class="line">              <span class="function"><span class="title">if</span> (c-&gt;</span><span class="function"><span class="title">rcurr</span> == c-&gt;</span>ritem) &#123;</div><div class="line">                  <span class="function"><span class="title">c</span>-&gt;</span>rcurr += res;</div><div class="line">              &#125;</div><div class="line">              <span class="function"><span class="title">c</span>-&gt;</span>ritem += res;</div><div class="line">              <span class="function"><span class="title">c</span>-&gt;</span>rlbytes -= res;</div><div class="line">              break;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (res == <span class="number">0</span>) &#123; <span class="comment">/* end of stream */</span></div><div class="line">              conn_set_state(c, conn_closing);</div><div class="line">              break;</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>当把数据行部分全部读进item的数据部分之后，则调用complete_nread执行一些扫尾工作
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> void complete_nread(conn *<span class="built_in">c</span>) &#123;</div><div class="line">    <span class="built_in">assert</span>(<span class="built_in">c</span> != <span class="type">NULL</span>);</div><div class="line">    <span class="built_in">assert</span>(<span class="built_in">c</span>-&gt;<span class="class"><span class="keyword">protocol</span> == <span class="title">ascii_prot</span></span></div><div class="line">           || <span class="title">c</span>-&gt;<span class="title">protocol</span> == <span class="title">binary_prot</span>);</div><div class="line"></div><div class="line">    <span class="title">if</span> (<span class="title">c</span>-&gt;<span class="title">protocol</span> == <span class="title">ascii_prot</span>) &#123;</div><div class="line">        complete_nread_ascii(<span class="built_in">c</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">c</span>-&gt;<span class="class"><span class="keyword">protocol</span> == <span class="title">binary_prot</span>) </span>&#123;</div><div class="line">        complete_nread_binary(<span class="built_in">c</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们调用的是ascii协议，所以接下来执行的是complete_nread_ascii函数：
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static void complete_nread_ascii(conn *c) &#123;</div><div class="line">    assert(c != NULL);</div><div class="line"></div><div class="line">    item *it = c-&gt;item;</div><div class="line">    int comm = c-&gt;cmd;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">store_item_type</span> <span class="title">ret</span>;</span></div><div class="line">    ret = store_item(it, comm, c);</div><div class="line">    <span class="regexp">//</span>。。。。</div><div class="line">	 switch (ret) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="symbol">STORED:</span></div><div class="line">          out_string(c, <span class="string">"STORED"</span>);</div><div class="line">          <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>这个函数主要是将conn上的item存入LRU和哈希表中，然后判断返回的存储结果，并向客户端输出结果
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> void out_string(conn *c, <span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span>) &#123;</div><div class="line">    size_t len;</div><div class="line">    c-&gt;msgused = <span class="number">0</span>;</div><div class="line">    c-&gt;iovused = <span class="number">0</span>;</div><div class="line">    add_msghdr(c);</div><div class="line"></div><div class="line">    len = strlen(<span class="built_in">str</span>);</div><div class="line">    <span class="keyword">if</span> ((len + <span class="number">2</span>) &gt; c-&gt;wsize) &#123;</div><div class="line">        <span class="comment">/* ought to be always enough. just fail for simplicity */</span></div><div class="line">        <span class="built_in">str</span> = <span class="string">"SERVER_ERROR output line too long"</span>;</div><div class="line">        len = strlen(<span class="built_in">str</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    memcpy(c-&gt;wbuf, <span class="built_in">str</span>, len);<span class="comment">//将输出字符串存入wbuf中，</span></div><div class="line">    memcpy(c-&gt;wbuf + len, <span class="string">"\r\n"</span>, <span class="number">2</span>);<span class="comment">//输出字符串结尾加回车换行</span></div><div class="line">    c-&gt;wbytes = len + <span class="number">2</span>;</div><div class="line">    c-&gt;wcurr = c-&gt;wbuf;</div><div class="line"></div><div class="line">    conn_set_state(c, conn_write);<span class="comment">//设置状态为conn_write</span></div><div class="line">    c-&gt;write_and_go = conn_new_cmd;<span class="comment">//conn_write处理之后的状态</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数将需要返回给客户端的数据存入wbuf中，然后将状态改为conn_write,准备输出
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">case</span> <span class="string">conn_write:</span></div><div class="line">&#123;</div><div class="line">         <span class="comment">//....</span></div><div class="line">        &#125;</div><div class="line">    <span class="keyword">case</span> <span class="string">conn_mwrite:</span></div><div class="line">      <span class="comment">//。。。。</span></div><div class="line">      <span class="keyword">switch</span> (transmit(c)) </div><div class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">transmit_result</span> <span class="title">transmit</span>(<span class="title">conn</span> *<span class="title">c</span>) &#123;</span></div><div class="line">           <span class="comment">//。。。。</span></div><div class="line">           res = sendmsg(c-&gt;sfd, m, <span class="number">0</span>);</div><div class="line">           <span class="comment">//。。。</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>最后先是在conn_write程序段中，将返回消息封装称msghdr，然后在transmit函数中调用sendmsg将消息发送给客户端。最后给张状态机的状态转换图，图片来自<a href="http://calixwu.com/2014/11/memcached-yuanmafenxi-qingqiuchuli-zhuangtaiji.html" target="_blank" rel="external">Calix 善于总结</a>
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_053.png" alt="状态机转换">。</p>
<p>总结下，本文章，分析了服务器接收一个客户端发送的命令，处理命令以及返回给客户端信息的整个过程，本过程以set命令为例，其他命令类似，只要跟着状态机状态变化走即可，单要注意libevent的epoll是水平触发的，所以状态机在没有读取客户端数据时可以先退出，然后重新得到通知。</p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache启动过程以及线程模型]]></title>
      <url>http://luodw.cc/2016/01/11/memcache-startup/</url>
      <content type="html"><![CDATA[<p>前两篇文章，我分析了slab内存分配和item数据存储。接下来这篇文章，先分析下memcache的启动流程，这也是一个软件的整体框架。然后主要分析下memcache的线程模型。</p>
<h1>memcache的启动过程</h1>
<hr>
<p>memcache是用纯c语言开发的，所以要查看启动过程，首先要找到main函数，然后一步一步往下执行。memcache的启动过程大致如下：</p>
<ol>
<li>初始化全局变量setting。memcache没有配置文件，所有的设置都是通过启动时跟在memcache后面的参数设置的。</li>
<li>设置系统的参数信息，例如设置产生的core文件以及core文件的最大值。设置memcache能打开的最大文件描述符个数，也就是memcache并发的连接数。</li>
<li>设置用户。 如果是普通用户执行，则无需设置用户选项，如果是root用户，必须设置用户选项。</li>
<li>先忽略SIGHUP信号，然后开启守护进程的设置。这里解释下为什么要忽略SIGHUP信号。因为在daeonize函数里面，父进程先fork一个子进程p1，然后设置setsid。此时p1为会话头进程。因为这个会话头进程可能再次分配到一个控制终端，所以p1也执行一次fork，产生p1的子进程p2，然后p1退出，此时的p2不是会话的头进程，也就不会获取终端。但是之前的p1是会话头进程，他的退出会给他的子进程p2发送SIGHUP信号，而SIGHUP信号默认是退出程序，所以必须捕获忽略。而一开始fork时，子进程和父进程的信号处理函数指针是一样的，所以在父进程设置SIGHUP信号处理程序，子进程也是有影响的。</li>
<li>通过stats_init,assoc_init,conn_init,slabs_init分别初始化memcache的状态信息，哈希表，连接数和slab内存分配信息。</li>
<li>忽略SIGPIPE信号 因为当客户端向服务器发送FIN时，此时服务器缓冲区为空时，read调用将返回0，表示对端连接关闭。如果发送缓冲区没问题，第一次调用write会正确发送，但会导致客户端发送一个重置报文RST。第二次再调用writw(假设在收到RST之后)，则会产生SIGPIPE信号，导致进程退出。所以为了以防万一，必须忽略SIGPIPE信号。</li>
<li>开启工作线程，后面详细介绍这个。</li>
<li>接下来就是开启四个辅助线程，维护哈希表，slab,item四个公共管理数据的部分。但是这个四个线程会阻塞在一个条件变量上。</li>
<li>初始化时钟事件 libevent也可以一个时钟事件。</li>
<li>然后是网络模块  即设置监听TCP，UDP,UNIX域套接字。</li>
<li>开启主线程循环  即开始轮询监听服务器端套接字，等待客户端的连接到来。</li>
</ol>
<h1>开启多线程</h1>
<hr>
<p>接下来，我们看下memcache是如何执行工作线程初始化的，首先还是先给出先模型：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/20150114093937432.jpeg" alt="线程模型">
先介绍下memcache接收到一个客户请求之后，是如何传递给子线程的。</p>
<ol>
<li>主线程主要是监听服务器端套接字，等待客户端的连接到来，子线程已经完成初始化，并且处于loop中，监听的套接字有与主线程通信管道的读端。</li>
<li>假如此时来了一个客户端，主线程将选择一个空闲的子线程，并将这个fd封装成一个CQ_ITEM，然后将这个CQ_ITEM插入这个子线程的CQ_ITEM链表，最后给这个子线程的管道写端写入一个字符'c'；</li>
<li>子线程在一次轮询中，得知管道可读，于是读取管道，如果读取的是字符'c'，则为这个客户端新建一个conn,并将这个客户端的套接字加入libevent事件循环中。之后，这个客户端就由这个子线程负责通信了。
在memcache.c文件main函数中，通过调用memcached_thread_init函数来初始化工作线程
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">void memcached_thread_init(int nthreads, struct event_base *main_base) &#123;</div><div class="line">    int         i;</div><div class="line">    int         power;</div><div class="line">    <span class="regexp">/* 对多线程中使用到的锁和条件变量初始化  */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; POWER_LARGEST; i++) &#123;</div><div class="line">        pthread_mutex_init(&amp;lru_locks[i], NULL);<span class="regexp">//</span>lru链表锁</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_init(&amp;worker_hang_lock, NULL);<span class="regexp">//</span>可以让工作线程挂起</div><div class="line"></div><div class="line">    pthread_mutex_init(&amp;init_lock, NULL);<span class="regexp">//</span>工作线程初始化锁</div><div class="line">    pthread_cond_init(&amp;init_cond, NULL);<span class="regexp">//</span>初始化条件变量，用于主线程等待子线程完成初始化</div><div class="line"></div><div class="line">    pthread_mutex_init(&amp;cqi_freelist_lock, NULL);<span class="regexp">//</span>消息队列锁</div><div class="line">    cqi_freelist = NULL;<span class="regexp">//</span>这个为消息队列</div><div class="line"></div><div class="line">    <span class="regexp">/* 用于控制哈希表锁 */</span></div><div class="line">    <span class="keyword">if</span> (nthreads &lt; <span class="number">3</span>) &#123;</div><div class="line">        power = <span class="number">10</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads &lt; <span class="number">4</span>) &#123;</div><div class="line">        power = <span class="number">11</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads &lt; <span class="number">5</span>) &#123;</div><div class="line">        power = <span class="number">12</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="regexp">/* 8192 buckets, and central locks don't scale much past 5 threads */</span></div><div class="line">        power = <span class="number">13</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (power &gt;= hashpower) &#123;</div><div class="line">        fprintf(stderr, <span class="string">"Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n"</span>, hashpower, power);</div><div class="line">        fprintf(stderr, <span class="string">"Item lock table grows with `-t N` (worker threadcount)\n"</span>);</div><div class="line">        fprintf(stderr, <span class="string">"Hash table grows with `-o hashpower=N` \n"</span>);</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    item_lock_count = hashsize(power);</div><div class="line">    item_lock_hashpower = power;</div><div class="line">   <span class="regexp">//</span>为哈希表分配锁数组空间</div><div class="line">    item_locks = calloc(item_lock_count, sizeof(pthread_mutex_t));</div><div class="line">    <span class="keyword">if</span> (! item_locks) &#123;</div><div class="line">        perror(<span class="string">"Can't allocate item locks"</span>);</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; item_lock_count; i++) &#123;</div><div class="line">        pthread_mutex_init(&amp;item_locks[i], NULL);</div><div class="line">    &#125;</div><div class="line">    <span class="regexp">//</span>给工作线程分配空间，并初始化</div><div class="line">    threads = calloc(nthreads, sizeof(LIBEVENT_THREAD));</div><div class="line">    <span class="keyword">if</span> (! threads) &#123;</div><div class="line">        perror(<span class="string">"Can't allocate thread descriptors"</span>);</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispatcher_thread.base = main_base;</div><div class="line">    dispatcher_thread.thread_id = pthread_self();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</div><div class="line">        int fds[<span class="number">2</span>];</div><div class="line">        <span class="keyword">if</span> (pipe(fds)) &#123;</div><div class="line">            perror(<span class="string">"Can't create notify pipe"</span>);</div><div class="line">            <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="regexp">//</span>主线程和子线程通信用的管道</div><div class="line">        threads[i].notify_receive_fd = fds[<span class="number">0</span>];</div><div class="line">        threads[i].notify_send_fd = fds[<span class="number">1</span>];</div><div class="line"></div><div class="line">        setup_thread(&amp;threads[i]);<span class="regexp">//</span>建立线程，即为初始化子线程的libevent,并监听管道的</div><div class="line">      <span class="regexp">//</span> 读端，初始化子线程的消息队列等待</div><div class="line">        <span class="regexp">/* Reserve three fds for the libevent base, and two for the pipe */</span></div><div class="line">        stats.reserved_fds += <span class="number">5</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="regexp">/* Create threads after we've done all the libevent setup. */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</div><div class="line">        create_worker(worker_libevent, &amp;threads[i]);<span class="regexp">//</span>开启子线程执行</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="regexp">/* 下面中间那个函数作用是等待子线程初始化完毕 */</span></div><div class="line">    pthread_mutex_lock(&amp;init_lock);</div><div class="line">    wait_for_thread_registration(nthreads);</div><div class="line">    pthread_mutex_unlock(&amp;init_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>这个函数主要是完成n个子线程的初始化以及开启执行。其中setup_thread函数完成线程结构体LIBEVENT_THREAD成员初始化，</p>
<ol>
<li>首先将给子线程分配一个libevent实例，然后将notify_receive_fd加入这个libevent的可读事件。</li>
<li>接着为了这个子线程的消息队列分配内存，并初始化。</li>
<li>最后为这个子线程创建后缀缓存，暂时还不知道这缓存的用处。</li>
</ol>
<p>create_worker函数用于开启子线程，第一个参数为回调函数，第二个参数为回调函数的参数。回调函数即线程执行函数。在这个回调函数worker_libevent又调用了register_thread_initialized这个函数，注册这个子线程。最后调用libevent的event_base_loop函数开启子线程的事件循环。
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> void setup_thread(LIBEVENT_THREAD *me) &#123;</div><div class="line">    me-&gt;base = event_init();<span class="comment">//分配一个libevent实例</span></div><div class="line">    <span class="keyword">if</span> (! me-&gt;base) &#123;</div><div class="line">        fprintf(stderr, <span class="string">"Can't allocate event base\n"</span>);</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Listen for notifications from other threads */</span></div><div class="line">    event_set(&amp;me-&gt;notify_event, me-&gt;notify_receive_fd,</div><div class="line">              EV_READ | EV_PERSIST, thread_libevent_process, me);</div><div class="line">    event_base_set(me-&gt;base, &amp;me-&gt;notify_event);</div><div class="line">    <span class="comment">//将管道添加libevent事件循环中</span></div><div class="line">    <span class="keyword">if</span> (event_add(&amp;me-&gt;notify_event, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</div><div class="line">        fprintf(stderr, <span class="string">"Can't monitor libevent notify pipe\n"</span>);</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//给消息队列分配内存</span></div><div class="line">    me-&gt;new_conn_queue = malloc(sizeof(struct conn_queue));</div><div class="line">    <span class="keyword">if</span> (me-&gt;new_conn_queue == <span class="keyword">NULL</span>) &#123;</div><div class="line">        perror(<span class="string">"Failed to allocate memory for connection queue"</span>);</div><div class="line">        <span class="keyword">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化消息队列，将head和tail初始化为NULL</span></div><div class="line">    cq_init(me-&gt;new_conn_queue);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;me-&gt;stats.mutex, <span class="keyword">NULL</span>) != <span class="number">0</span>) &#123;</div><div class="line">        perror(<span class="string">"Failed to initialize mutex"</span>);</div><div class="line">        <span class="keyword">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//分配缓存</span></div><div class="line">    me-&gt;suffix_cache = cache_create(<span class="string">"suffix"</span>, SUFFIX_SIZE, sizeof(<span class="keyword">char</span>*),</div><div class="line">                                    <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (me-&gt;suffix_cache == <span class="keyword">NULL</span>) &#123;</div><div class="line">        fprintf(stderr, <span class="string">"Failed to create suffix cache\n"</span>);</div><div class="line">        <span class="keyword">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/</span></div><div class="line"><span class="keyword">static</span> void create_worker(void *(*func)(void *), void *arg) &#123;</div><div class="line">    pthread_t       thread;</div><div class="line">    pthread_attr_t  attr;</div><div class="line">    <span class="keyword">int</span>             ret;</div><div class="line"></div><div class="line">    pthread_attr_init(&amp;attr);</div><div class="line">    <span class="comment">//开启子线程执行，子线程函数为回调函数func</span></div><div class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;thread, &amp;attr, func, arg)) != <span class="number">0</span>) &#123;</div><div class="line">        fprintf(stderr, <span class="string">"Can't create thread: %s\n"</span>,</div><div class="line">                strerror(ret));</div><div class="line">        <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/</span></div><div class="line"><span class="keyword">static</span> void *worker_libevent(void *arg) &#123;</div><div class="line">    LIBEVENT_THREAD *me = arg;</div><div class="line"></div><div class="line">    <span class="comment">/* Any per-thread setup can happen here; memcached_thread_init() will block until</span></div><div class="line">     * all threads have finished initializing.</div><div class="line">     */</div><div class="line"></div><div class="line">    register_thread_initialized();</div><div class="line">    <span class="comment">//开启事件循环</span></div><div class="line">    event_base_loop(me-&gt;base, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>困扰我的一个问题</h1>
<hr>
<p>在看线程这部分源码的过程中，有一个地方困惑了我好久。先来看下源码，涉及以下两个函数：
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">memcached_thread_init</span>函数最后三行：</div><div class="line">    <span class="selector-tag">pthread_mutex_lock</span>(&amp;init_lock);</div><div class="line">    <span class="selector-tag">wait_for_thread_registration</span>(nthreads);</div><div class="line">    <span class="selector-tag">pthread_mutex_unlock</span>(&amp;init_lock);</div><div class="line"><span class="comment">/* ++++++++++++++++++++++++++++++++++++++++++++++++++ */</span></div><div class="line"><span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">wait_for_thread_registration</span>(int nthreads) &#123;</div><div class="line">    <span class="selector-tag">while</span> (init_count &lt; nthreads) &#123;</div><div class="line">        <span class="selector-tag">pthread_cond_wait</span>(&amp;init_cond, &amp;init_lock);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* +++++++++++++++++++++++++++++++++++++++++++++++++++ */</span></div><div class="line"><span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">register_thread_initialized</span>(void) &#123;</div><div class="line">    <span class="selector-tag">pthread_mutex_lock</span>(&amp;init_lock);</div><div class="line">    <span class="selector-tag">init_count</span>++;</div><div class="line">    <span class="selector-tag">pthread_cond_signal</span>(&amp;init_cond);</div><div class="line">    <span class="selector-tag">pthread_mutex_unlock</span>(&amp;init_lock);</div><div class="line">    <span class="comment">/* Force worker threads to pile up if someone wants us to */</span></div><div class="line">    <span class="selector-tag">pthread_mutex_lock</span>(&amp;worker_hang_lock);</div><div class="line">    <span class="selector-tag">pthread_mutex_unlock</span>(&amp;worker_hang_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在memcached_thread_init函数中调用wait_for_thread_registration等待所有的子线程建立完毕。我之前的困惑是，因为主线程有调用pthread_mutex_lock(&amp;init_lock)然后睡眠在wait_for_thread_registration函数里面的pthread_cond_wait中。如果主线执行更快，而且占有init_lock这把锁，那么在执行redister_thread_initialized函数中，没有一个子线程可以获取init_lock了，这样的话，主线程在等待init_count的值增长到5，子线程在等待被主线程占有的init_lock，那么程序就卡死，无法继续往下执行了。</p>
<p>后来，我查阅资料，发现是我不了解pthread_cond_wait这个函数。pthread_cond_wait函数在调用时，会先将锁给释放了，然后才投入睡眠；当收到pthread_cond_signal发送的消息时，这时线程从pthread_cond_wait总被唤醒，并且重新获取锁。这样就可以解释之前的问题了。主线程调用pthread_cond_wait投入睡眠，释放锁，然后子线程在redister_thread_initialized中获得锁，将init_count值+1，接着调用pthread_cond_signal唤醒主线程，主线程重新获得锁，再判断init_count&lt;nthreads，这样的好处是除了在子线程保护init_count操作原子性，在主线程在判断init_count时，也是原子的。</p>
<p>到此为止，子线程就建立完毕，此时，子线程都已经处于libevent的事件循环当中，而且只有管道的可读一个事件。接下来，主线调用网络模块，监听套接字，最后主线程的libevent实例也处于事件循环中，此时的套接字有服务器端监听的TCP和域套接字，UDP套接字已经分配给子线程负责了，因为udp无需建立连接。接来看来一个客户端达到之后，是如何传递给子线程，子线程是如何接收的。</p>
<h1>主线程给子线程传递套接字</h1>
<hr>
<p>要查看主线程是如何给子线程传递套接字，只需要找到tcp套接字的回调函数；查看子线程是如何接收套接字，只需要查看管道的读端的回调函数即可。</p>
<p>当服务器到达一个客户端，服务器端调用dispatch_conn_new函数来将客户端的套接字分配给子线程：
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void dispatch_conn_new(int sfd, <span class="class"><span class="keyword">enum</span> <span class="title">conn_states</span> <span class="title">init_state</span>, <span class="title">int</span> <span class="title">event_flags</span>,</span></div><div class="line">                       int read_buffer_size, <span class="class"><span class="keyword">enum</span> <span class="title">network_transport</span> <span class="title">transport</span>) &#123;</span></div><div class="line">    CQ_ITEM *item = cqi_new();<span class="regexp">//</span>新建一个消息实例</div><div class="line">    char buf[<span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span> (item == NULL) &#123;</div><div class="line">        close(sfd);</div><div class="line">        <span class="regexp">/* given that malloc failed this may also fail, but let's try */</span></div><div class="line">        fprintf(stderr, <span class="string">"Failed to allocate memory for connection object\n"</span>);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">    /<span class="regexp">/选择子线程</span></div><div class="line">    int tid = (last_thread + 1) % settings.num_threads;</div><div class="line"></div><div class="line">    LIBEVENT_THREAD *thread = threads + tid;</div><div class="line"></div><div class="line">    last_thread = tid;</div><div class="line">    /<span class="regexp">/初始化消息实例</span></div><div class="line">    item-&gt;sfd = sfd;</div><div class="line">    item-&gt;init_state = init_state;</div><div class="line">    item-&gt;event_flags = event_flags;</div><div class="line">    item-&gt;read_buffer_size = read_buffer_size;</div><div class="line">    item-&gt;transport = transport;</div><div class="line">    /<span class="regexp">/将消息实例插入选择的子线程的消息队列中</span></div><div class="line">    cq_push(thread-&gt;new_conn_queue, item);</div><div class="line"></div><div class="line">    MEMCACHED_CONN_DISPATCH(sfd, thread-&gt;thread_id);</div><div class="line">    buf[0] = 'c';</div><div class="line">    /<span class="regexp">/给这个子线程发送一个字符，激活管道可读事件。</span></div><div class="line">    if (write(thread-&gt;notify_send_fd, buf, 1) != 1) &#123;</div><div class="line">        perror("Writing to thread notify pipe");</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>memcache的消息是预先分配的，默认先分配64个CQ_ITEM消息实例，这样可以避免较多的内存碎片产生。所以CQ_ITEM *item = cqi_new()如果是第一次调用，则先分配64个CQ_ITEM实例，然后返回第一个；之后再次调用这个函数时，则是直接从预先分配的CQ_ITEM链表中获取。</p>
<p>子线程的选择是采用轮询的方式，每次选择的线程总是上次选择线程的下一个线程。</p>
<h1>子线程接收套接字</h1>
<hr>
<p>子线程接收父进程的套接字，管道的可读事件的回调函数为thread_libevent_process:
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> void thread_libevent_process(<span class="keyword">int</span> fd, short which, void *arg) &#123;</div><div class="line">    LIBEVENT_THREAD *me = arg;</div><div class="line">    CQ_ITEM *item;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">1</span>) != <span class="number">1</span>)</div><div class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</div><div class="line">            fprintf(stderr, <span class="string">"Can't read from libevent pipe\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (buf[<span class="number">0</span>]) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</div><div class="line">    item = cq_pop(me-&gt;new_conn_queue);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">NULL</span> != item) &#123;</div><div class="line">        conn *c = conn_new(item-&gt;sfd, item-&gt;init_state, item-&gt;event_flags,</div><div class="line">                           item-&gt;read_buffer_size, item-&gt;transport, me-&gt;base);</div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">NULL</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (IS_UDP(item-&gt;transport)) &#123;</div><div class="line">                fprintf(stderr, <span class="string">"Can't listen for events on UDP socket\n"</span>);</div><div class="line">                <span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>) &#123;</div><div class="line">                    fprintf(stderr, <span class="string">"Can't listen for events on fd %d\n"</span>,</div><div class="line">                        item-&gt;sfd);</div><div class="line">                &#125;</div><div class="line">                close(item-&gt;sfd);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            c-&gt;thread = me;<span class="comment">//这个'c'出现的很诡异</span></div><div class="line">        &#125;</div><div class="line">        cqi_free(item);</div><div class="line">    &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="comment">/* we were told to pause and report in */</span></div><div class="line">    <span class="keyword">case</span> <span class="string">'p'</span>:</div><div class="line">    register_thread_initialized();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数简单地将消息从消息队列取出，并且调用conn_new函数，获取一个conn实例，这个实例主要是用于存储客户端发来的消息以及存储发往客户端的消息。conn_new函数还将这个客户端的fd添加进这个子线程的Libevent事件循环中。</p>
<p>接下来就是等待客户端发送命令，处理业务。这部分很复杂，涉及memcache状态机，下篇文章在好好分析。。。</p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码分析之item]]></title>
      <url>http://luodw.cc/2016/01/10/memcache-item/</url>
      <content type="html"><![CDATA[<p>上篇文章分析了memcache的内存管理模块，作为一个内存数据库，内存的管理是至关重要的，例如内存的分配，内存的回收，内存重复利用等等。有了内存之后，这篇文章主要分析下item的一些操作。item.c文件还有几个和维护LRU队列的线程函数相关，最后在统一整理。</p>
<h1>item定义</h1>
<hr>
<p>先来看下item是如何定义的，在memcached.h文件中
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _stritem &#123;</div><div class="line">    <span class="comment">/* 受LRU locks保护 */</span></div><div class="line">    <span class="keyword">struct</span> _stritem *next;<span class="comment">//LRU队列的下一个item</span></div><div class="line">    <span class="keyword">struct</span> _stritem *prev;<span class="comment">//LRU队列的前一个item</span></div><div class="line">    <span class="comment">/* 剩下其他的受item lock保护 */</span></div><div class="line">    <span class="keyword">struct</span> _stritem *h_next;    <span class="comment">/* 哈希链中的下一个item */</span></div><div class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* 上一次访问的时间 */</span></div><div class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* 过期时间 */</span></div><div class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* 数据的大小 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  refcount;   <span class="comment">/* 这个item引用的次数 */</span></div><div class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* flag和val_lenth的长度 */</span></div><div class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_*标识 */</span></div><div class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* 位于哪个slabclass中 */</span></div><div class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key的长度*/</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">uint64_t</span> cas;</div><div class="line">        <span class="keyword">char</span> end;</div><div class="line">    &#125; data[];</div><div class="line">    <span class="comment">/* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */</span></div><div class="line">    <span class="comment">/* then null-terminated key */</span></div><div class="line">    <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></div><div class="line">    <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></div><div class="line">&#125; item;</div></pre></td></tr></table></figure></p>
<p>其他都很好理解，关键是最后那个union data[]。当初在看STL源码的时候，内存分配器也有用到这中结构。这可以理解为柔性数组。因为data[]数组并没有显示指出数组的大小，所以这个数组是不分配内存的，但是data指针始终指向nkey属性的下一个地址。当需要nbytes字节内存时，直接在data上分配内存即可。可以看下我之前文章<a href="http://luodw.cc/2015/10/22/Cplus6/">柔性数组</a>。最后英文注释的意思是如果设置了cas验证，则data指向的内容为CAS（8bytes)+key+&quot;flags length\r\n&quot;+data\r\n 。下图是这个item的示意图，图片来自网络:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_052.png" alt="item示意图"></p>
<h1>items分配内存</h1>
<hr>
<p>memcache上任何的键值对，都需要封装成item的形式，然后才存储到slab的管理的内存中。所以当有个set命令到达时，首先要做的是先给这个键值对分配一块chunk来存储这个键值对item。申请内存函数如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">item_make_header</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> nkey, <span class="keyword">const</span> <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></div><div class="line">                     <span class="keyword">char</span> *suffix, <span class="keyword">uint8_t</span> *nsuffix) &#123;</div><div class="line">    <span class="comment">/* suffix 是do_item_alloc函数中定义的40字节数组 */</span></div><div class="line">    *nsuffix = (<span class="keyword">uint8_t</span>) <span class="built_in">snprintf</span>(suffix, <span class="number">40</span>, <span class="string">" %d %d\r\n"</span>, flags, nbytes - <span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(item) + nkey + *nsuffix + nbytes;</div><div class="line">&#125;<span class="comment">//这个函数先计算出这个item头的长度</span></div><div class="line"><span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></div><div class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">int</span> flags,</span></span></div><div class="line">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv) &#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">uint8_t</span> nsuffix;</div><div class="line">    item *it = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">char</span> suffix[<span class="number">40</span>];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> total_chunks;</div><div class="line">    <span class="keyword">size_t</span> ntotal = item_make_header(nkey + <span class="number">1</span>, flags, nbytes, suffix, &amp;nsuffix);</div><div class="line">    <span class="keyword">if</span> (settings.use_cas) &#123;<span class="comment">//如果有使用cas，则还要加上8字节</span></div><div class="line">        ntotal += <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal);<span class="comment">//选择slabclass</span></div><div class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="comment">/* Try to reclaim memory first */</span></div><div class="line">        <span class="keyword">if</span> (!settings.lru_maintainer_thread) &#123;</div><div class="line">            lru_pull_tail(id, COLD_LRU, <span class="number">0</span>, <span class="literal">false</span>, cur_hv);</div><div class="line">        &#125;</div><div class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks);</div><div class="line">        <span class="keyword">if</span> (settings.expirezero_does_not_evict)</div><div class="line">            total_chunks -= noexp_lru_size(id);</div><div class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123;</div><div class="line">                lru_pull_tail(id, HOT_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</div><div class="line">                lru_pull_tail(id, WARM_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</div><div class="line">                lru_pull_tail(id, COLD_LRU, total_chunks, <span class="literal">true</span>, cur_hv);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                lru_pull_tail(id, COLD_LRU, <span class="number">0</span>, <span class="literal">true</span>, cur_hv);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    assert(it-&gt;slabs_clsid == <span class="number">0</span>);</div><div class="line">    <span class="comment">//assert(it != heads[id]);</span></div><div class="line"></div><div class="line">    <span class="comment">//初始化item各部分信息</span></div><div class="line">    it-&gt;next = it-&gt;prev = it-&gt;h_next = <span class="number">0</span>;</div><div class="line">    it-&gt;slabs_clsid = id;</div><div class="line">    DEBUG_REFCNT(it, <span class="string">'*'</span>);</div><div class="line">    it-&gt;it_flags = settings.use_cas ? ITEM_CAS : <span class="number">0</span>;</div><div class="line">    it-&gt;nkey = nkey;</div><div class="line">    it-&gt;nbytes = nbytes;</div><div class="line">    <span class="built_in">memcpy</span>(ITEM_key(it), key, nkey);</div><div class="line">    it-&gt;exptime = exptime;</div><div class="line">    <span class="built_in">memcpy</span>(ITEM_suffix(it), suffix, (<span class="keyword">size_t</span>)nsuffix);</div><div class="line">    it-&gt;nsuffix = nsuffix;</div><div class="line">    <span class="keyword">return</span> it;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要是为item分配内存使用的，slab可能内存已经使用完了，这时需要从LRU队列中删除item，以至于腾出内存，这之后研究LRU平衡线程时再分析，这里假设分配到内存了。接下来就是初始化分配到的item。这里并没有把value值复制到item中，而是调用这个do_item_alloc函数之后再赋值。</p>
<h1>item内存回收</h1>
<hr>
<p>item内存回收很简单。当某个Item的引用计数变为0时，这时线程会调用item_free函数回收item这块内存，但不是将内存还给系统，而是将内存还给slab。即将这个item插入链表slots中。
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">void</span> <span class="keyword">item_free(item </span>*<span class="keyword">it) </span>&#123;</div><div class="line">    size_t ntotal = <span class="keyword">ITEM_ntotal(it);</span></div><div class="line">    unsigned int clsid<span class="comment">;</span></div><div class="line">    <span class="meta">assert</span>((<span class="keyword">it-&gt;it_flags </span>&amp; <span class="keyword">ITEM_LINKED) </span>== <span class="number">0</span>)<span class="comment">;</span></div><div class="line">    <span class="meta">assert</span>(<span class="keyword">it </span>!= heads[<span class="keyword">it-&gt;slabs_clsid]);</span></div><div class="line">    <span class="meta">assert</span>(<span class="keyword">it </span>!= tails[<span class="keyword">it-&gt;slabs_clsid]);</span></div><div class="line">    <span class="meta">assert</span>(<span class="keyword">it-&gt;refcount </span>== <span class="number">0</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">    <span class="comment">/* so slab size changer can tell later if item is already free or not */</span></div><div class="line">    clsid = <span class="keyword">ITEM_clsid(it);</span></div><div class="line">    DEBUG_REFCNT(<span class="keyword">it, </span><span class="string">'F'</span>)<span class="comment">;</span></div><div class="line">    slabs_free(<span class="keyword">it, </span>ntotal, clsid)<span class="comment">;//slab回收内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>item插入和删除LRU队列</h1>
<hr>
<p>接来下函数是将item插入和删除LRU队列
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static void do_item_link_q(item *it) &#123; <span class="comment">/* item is the new head */</span></div><div class="line">    item **head, **tail;</div><div class="line">    <span class="function"><span class="title">assert</span>((it-&gt;</span>it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">head</span> = &amp;heads[it-&gt;</span>slabs_clsid];</div><div class="line">    <span class="function"><span class="title">tail</span> = &amp;tails[it-&gt;</span>slabs_clsid];</div><div class="line">    assert(it != *head);</div><div class="line">    assert((*head &amp;&amp; *tail) || (*head == <span class="number">0</span> &amp;&amp; *tail == <span class="number">0</span>));</div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span>prev = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span>next = *head;</div><div class="line">    <span class="function"><span class="title">if</span> (it-&gt;</span><span class="function"><span class="title">next</span>) it-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>prev = it;</div><div class="line">    *head = it;</div><div class="line">    <span class="keyword">if</span> (*tail == <span class="number">0</span>) *tail = it;</div><div class="line">    <span class="function"><span class="title">sizes</span>[it-&gt;</span>slabs_clsid]++;<span class="comment">//sizes保存这个id的slabclass的Item数量</span></div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void item_link_q(item *it) &#123;<span class="comment">//插入LRU队列的有锁版本</span></div><div class="line">    <span class="function"><span class="title">pthread_mutex_lock</span>(&amp;lru_locks[it-&gt;</span>slabs_clsid]);</div><div class="line">    do_item_link_q(it);</div><div class="line">    <span class="function"><span class="title">pthread_mutex_unlock</span>(&amp;lru_locks[it-&gt;</span>slabs_clsid]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void do_item_unlink_q(item *it) &#123;</div><div class="line">    item **head, **tail;</div><div class="line">    <span class="function"><span class="title">head</span> = &amp;heads[it-&gt;</span>slabs_clsid];</div><div class="line">    <span class="function"><span class="title">tail</span> = &amp;tails[it-&gt;</span>slabs_clsid];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (*head == it) &#123;</div><div class="line">        <span class="function"><span class="title">assert</span>(it-&gt;</span>prev == <span class="number">0</span>);</div><div class="line">        *<span class="function"><span class="title">head</span> = it-&gt;</span>next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (*tail == it) &#123;</div><div class="line">        <span class="function"><span class="title">assert</span>(it-&gt;</span>next == <span class="number">0</span>);</div><div class="line">        *<span class="function"><span class="title">tail</span> = it-&gt;</span>prev;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">assert</span>(it-&gt;</span>next != it);</div><div class="line">    <span class="function"><span class="title">assert</span>(it-&gt;</span>prev != it);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">if</span> (it-&gt;</span><span class="function"><span class="title">next</span>) it-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">prev</span> = it-&gt;</span>prev;</div><div class="line">    <span class="function"><span class="title">if</span> (it-&gt;</span><span class="function"><span class="title">prev</span>) it-&gt;</span><span class="function"><span class="title">prev</span>-&gt;</span><span class="function"><span class="title">next</span> = it-&gt;</span>next;</div><div class="line">    <span class="function"><span class="title">sizes</span>[it-&gt;</span>slabs_clsid]--;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void item_unlink_q(item *it) &#123;<span class="comment">//LRU删除item有锁版本</span></div><div class="line">    <span class="function"><span class="title">pthread_mutex_lock</span>(&amp;lru_locks[it-&gt;</span>slabs_clsid]);</div><div class="line">    do_item_unlink_q(it);</div><div class="line">    <span class="function"><span class="title">pthread_mutex_unlock</span>(&amp;lru_locks[it-&gt;</span>slabs_clsid]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就是链表插入和删除操作，没什么好解释的。</p>
<h1>item插入和删除LRU和哈希表</h1>
<hr>
<p>item插入和删除LRU和哈希表其实就是在一个函数中先调用哈希表的插入函数，然后在调用LRU插入函数。
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">int do_item_link(item *it, const uint32_t hv) &#123;</div><div class="line">    MEMCACHED_ITEM_LINK(ITEM_<span class="function"><span class="title">key</span>(it), it-&gt;</span><span class="function"><span class="title">nkey</span>, it-&gt;</span>nbytes);</div><div class="line">    <span class="function"><span class="title">assert</span>((it-&gt;</span>it_flags &amp; (ITEM_LINKED|ITEM_SLABBED)) == <span class="number">0</span>);</div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span>it_flags |= ITEM_LINKED;<span class="comment">//表示这个item在链表中</span></div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span><span class="built_in">time</span> = current_time;</div><div class="line"></div><div class="line">    STATS_LOCK();<span class="comment">//更新状态信息</span></div><div class="line">    stats.curr_bytes += ITEM_ntotal(it);</div><div class="line">    stats.curr_items += <span class="number">1</span>;</div><div class="line">    stats.total_items += <span class="number">1</span>;</div><div class="line">    STATS_UNLOCK();</div><div class="line"></div><div class="line">    <span class="comment">/* Allocate a new CAS ID on link. */</span></div><div class="line">    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : <span class="number">0</span>);</div><div class="line">    assoc_insert(it, hv);<span class="comment">//哈希表插入</span></div><div class="line">    item_link_q(it);<span class="comment">//LRU链表插入</span></div><div class="line">    <span class="function"><span class="title">refcount_incr</span>(&amp;it-&gt;</span>refcount);<span class="comment">//引用数加1</span></div><div class="line"></div><div class="line">    return <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void do_item_unlink(item *it, const uint32_t hv) &#123;</div><div class="line">    MEMCACHED_ITEM_UNLINK(ITEM_<span class="function"><span class="title">key</span>(it), it-&gt;</span><span class="function"><span class="title">nkey</span>, it-&gt;</span>nbytes);</div><div class="line">    <span class="function"><span class="title">if</span> ((it-&gt;</span>it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="function"><span class="title">it</span>-&gt;</span>it_flags &amp;= ~ITEM_LINKED;<span class="comment">//关闭标识</span></div><div class="line">        STATS_LOCK();</div><div class="line">        stats.curr_bytes -= ITEM_ntotal(it);</div><div class="line">        stats.curr_items -= <span class="number">1</span>;</div><div class="line">        STATS_UNLOCK();</div><div class="line">        <span class="function"><span class="title">assoc_delete</span>(ITEM_key(it), it-&gt;</span>nkey, hv);<span class="comment">//哈希表删除</span></div><div class="line">        item_unlink_q(it);<span class="comment">//LRU链表删除</span></div><div class="line">        do_item_remove(it);<span class="comment">//当it引用数为0时，回收item。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void do_item_remove(item *it) &#123;</div><div class="line">    MEMCACHED_ITEM_REMOVE(ITEM_<span class="function"><span class="title">key</span>(it), it-&gt;</span><span class="function"><span class="title">nkey</span>, it-&gt;</span>nbytes);</div><div class="line">    <span class="function"><span class="title">assert</span>((it-&gt;</span>it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</div><div class="line">    <span class="function"><span class="title">assert</span>(it-&gt;</span>refcount &gt; <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">if</span> (refcount_decr(&amp;it-&gt;</span>refcount) == <span class="number">0</span>) &#123;</div><div class="line">        item_free(it);<span class="comment">//先将引用数减1，然后再判断是否为0.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>item更新替换</h1>
<hr>
<p>LRU为最近最少使用策略，所以每次访问LRU列表中的某个item时，需要将这个item移到LRU最新的位置。反应到代码操作上就是先删除这个item,然后再重新插入LRU链表即可
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">void</span> do_item_update(<span class="keyword">item </span>*<span class="keyword">it) </span>&#123;</div><div class="line">    MEMCACHED_ITEM_UPDATE(<span class="keyword">ITEM_key(it), </span><span class="keyword">it-&gt;nkey, </span><span class="keyword">it-&gt;nbytes);</span></div><div class="line">    <span class="meta">if</span> (<span class="keyword">it-&gt;time </span>&lt; current_time - <span class="keyword">ITEM_UPDATE_INTERVAL) </span>&#123;</div><div class="line">        <span class="meta">assert</span>((<span class="keyword">it-&gt;it_flags </span>&amp; <span class="keyword">ITEM_SLABBED) </span>== <span class="number">0</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">        <span class="meta">if</span> ((<span class="keyword">it-&gt;it_flags </span>&amp; <span class="keyword">ITEM_LINKED) </span>!= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">it-&gt;time </span>= current_time<span class="comment">;</span></div><div class="line">            <span class="meta">if</span> (!settings.lru_maintainer_thread) &#123;</div><div class="line">                <span class="keyword">item_unlink_q(it);</span></div><div class="line">                <span class="keyword">item_link_q(it);</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>item的替换意思就是如果有更新键值对，则需要将原先的键值对删除，然后再将最新的键值对插入LRU和哈希表。
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">int</span> do_item_replace(<span class="keyword">item </span>*<span class="keyword">it, </span><span class="keyword">item </span>*new_it, const uint32_t hv) &#123;</div><div class="line">    MEMCACHED_ITEM_REPLACE(<span class="keyword">ITEM_key(it), </span><span class="keyword">it-&gt;nkey, </span><span class="keyword">it-&gt;nbytes,</span></div><div class="line">                           <span class="keyword">ITEM_key(new_it), </span>new_it-&gt;nkey, new_it-&gt;nbytes)<span class="comment">;</span></div><div class="line">    <span class="meta">assert</span>((<span class="keyword">it-&gt;it_flags </span>&amp; <span class="keyword">ITEM_SLABBED) </span>== <span class="number">0</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">    do_item_unlink(<span class="keyword">it, </span>hv)<span class="comment">;</span></div><div class="line">    return do_item_link(new_it, hv)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>item查询</h1>
<hr>
<p>memcache采取lazy expiration逻辑，即使用flush命令时，并不是真正的删除Item节点，而是在查询时，再来判断这个item是否有效，如果无效，则要回收item。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function">item *<span class="title">do_item_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</div><div class="line">    item *it = assoc_find(key, nkey, hv);</div><div class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</div><div class="line">        refcount_incr(&amp;it-&gt;refcount);<span class="comment">//引用数+1</span></div><div class="line"> &#125;</div><div class="line">    <span class="keyword">int</span> was_found = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">int</span> ii;</div><div class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"&gt; NOT FOUND "</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"&gt; FOUND KEY "</span>);</div><div class="line">            was_found++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; nkey; ++ii) &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%c"</span>, key[ii]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (is_flushed(it)) &#123;<span class="comment">//判断item是否过期，包括flush时间点过期和cas过期</span></div><div class="line">            do_item_unlink(it, hv);<span class="comment">//过期则从LRU和哈希表中删除</span></div><div class="line">            do_item_remove(it);<span class="comment">//引用数为1时，回收item</span></div><div class="line">            it = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">if</span> (was_found) &#123;</div><div class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" -nuked by flush"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;exptime != <span class="number">0</span> &amp;&amp; it-&gt;exptime &lt;= current_time) &#123;<span class="comment">//判断item节点是否生命到期</span></div><div class="line">            do_item_unlink(it, hv);</div><div class="line">            do_item_remove(it);</div><div class="line">            it = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">if</span> (was_found) &#123;</div><div class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">" -nuked by expire"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            it-&gt;it_flags |= ITEM_FETCHED|ITEM_ACTIVE;<span class="comment">//这里表示这个节点没有到期，可以正常使用</span></div><div class="line">            DEBUG_REFCNT(it, <span class="string">'+'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">2</span>)</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> it;</div><div class="line">&#125;</div><div class="line"><span class="comment">//下面是更新item过期时间函数</span></div><div class="line"><span class="function">item *<span class="title">do_item_touch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">size_t</span> nkey, <span class="keyword">uint32_t</span> exptime,</span></span></div><div class="line">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv) &#123;</div><div class="line">    item *it = do_item_get(key, nkey, hv);</div><div class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</div><div class="line">        it-&gt;exptime = exptime;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> it;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>item的其他函数和平衡LRU和平衡哈希表相关，之后统一分析。</p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
            <tag> item </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码分析之slab内存分配]]></title>
      <url>http://luodw.cc/2016/01/09/memcache-slab/</url>
      <content type="html"><![CDATA[<p>昨天分析了memcache的整体软件架构，主要是线程模型和内存模型，今天主要分析下memcache的内存分配组件slab。slab是memcache的内存池结构，它将内存分为一系列固定大小内存的内存块chunk，线程每次申请内存时，选择和所需的内存大小最接近(大于等于)的内存即可。把slab的内存模型再次献上:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/1345021404_1576.png" alt="slab内存模型">;</p>
<p>memcache事先会分配一大块内存，通过-m来设置，然后slab每次申请内存都从大块内存中分配，这样可以减少malloc的调用。slab支持预先分配内存，即一开始就给每个slabclass分配一块内存页，需要开始时输入-k选项，默认情况下是不预先分配内存的。下面还是分析源码来解释slab。</p>
<h1>slab定义</h1>
<hr>
<p>先来看下关于slab的一些定义：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;      <span class="comment">/*这个slabclass的chunk大小*/</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> perslab;   <span class="comment">/* 每个内存页有多少个chunk */</span></div><div class="line"></div><div class="line">    <span class="keyword">void</span> *slots;           <span class="comment">/* 回收来的item内存块 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sl_curr;   <span class="comment">/* slots链表中有多少个item内存块*/</span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slabs;     <span class="comment">/* 这个slabclass分配了多少个内存页*/</span></div><div class="line"></div><div class="line">    <span class="keyword">void</span> **slab_list;       <span class="comment">/* 每个内存页指针数组*/</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> list_size; <span class="comment">/* 这个内存页指针数组的大小*/</span></div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> killing;  <span class="comment">/* index+1 of dying slab, or zero if none*/</span></div><div class="line">    <span class="keyword">size_t</span> requested; <span class="comment">/* 这个slabclass已经被申请走的内存*/</span></div><div class="line">&#125; <span class="keyword">slabclass_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">slabclass_t</span> slabclass[MAX_NUMBER_OF_SLAB_CLASSES];<span class="comment">//slabclass数组，默认大小为64</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> mem_limit = <span class="number">0</span>;<span class="comment">//预先分配内存大小，即内存池的大小</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> mem_malloced = <span class="number">0</span>;<span class="comment">//到目前位置已经被分配出去的内存大小，可以统计memcache数据</span></div><div class="line">占有的内存大小</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> mem_limit_reached = <span class="literal">false</span>;<span class="comment">//是否已经达到内存池大小，如果是，则要执行LRU策略</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> power_largest;<span class="comment">//真实slaclass数组的最大值。</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *mem_base = <span class="literal">NULL</span>;<span class="comment">//内存池的首地址</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *mem_current = <span class="literal">NULL</span>;<span class="comment">//指向可用内存的第一个字节</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> mem_avail = <span class="number">0</span>;<span class="comment">//可用的内存块大小。</span></div></pre></td></tr></table></figure></p>
<p>这些都是slab.c文件中定义的数据结构和变量。关键要理解slabclass属性表示什么，属性中，slots和slab_list最为重要。</p>
<h1>slab初始化</h1>
<hr>
<p>memcache一开始会初始化slab，然后在item.c文件中，当需要申请内存时，就调用slabs_alloc分配内存，当需要回收内存时，就调用slabs_free函数。先来看下slabs_init函数：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = POWER_SMALLEST - <span class="number">1</span>;<span class="comment">//POWER_SMALLEST为slabclass数组索引最小值，为1.</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(item) + settings.chunk_size;<span class="comment">//chunk的最小值，默认为96</span></div><div class="line"></div><div class="line">    mem_limit = limit;<span class="comment">//内存池的大小，默认是64M</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prealloc) &#123;</div><div class="line">        <span class="comment">/* 如果预先分配内存 */</span></div><div class="line">        mem_base = <span class="built_in">malloc</span>(mem_limit);<span class="comment">//分配内存池</span></div><div class="line">        <span class="keyword">if</span> (mem_base != <span class="literal">NULL</span>) &#123;</div><div class="line">            mem_current = mem_base;</div><div class="line">            mem_avail = mem_limit;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Warning: Failed to allocate requested memory in"</span></div><div class="line">                    <span class="string">" one large chunk.\nWill allocate in smaller chunks\n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">memset</span>(slabclass, <span class="number">0</span>, <span class="keyword">sizeof</span>(slabclass));<span class="comment">//初始化slabclass数组</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (++i &lt; MAX_NUMBER_OF_SLAB_CLASSES<span class="number">-1</span> &amp;&amp; size &lt;= settings.item_size_max / factor) &#123;</div><div class="line">        <span class="comment">/* 保证每个chunk是8字节对齐 */</span></div><div class="line">        <span class="keyword">if</span> (size % CHUNK_ALIGN_BYTES)</div><div class="line">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</div><div class="line"></div><div class="line">        slabclass[i].size = size;<span class="comment">//第i个slabclass负责的chunk大小</span></div><div class="line">        slabclass[i].perslab = settings.item_size_max / slabclass[i].size;<span class="comment">//第i个slabclass,每</span></div><div class="line">每个内存页chunk的个数</div><div class="line">        size *= factor;<span class="comment">//下个slabclass的chunk大小</span></div><div class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"slab class %3d: chunk size %9u perslab %7u\n"</span>,</div><div class="line">                    i, slabclass[i].size, slabclass[i].perslab);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    power_largest = i;<span class="comment">//最后一个slabclass，chunk为1M，且只有一个chunk。</span></div><div class="line">    slabclass[power_largest].size = settings.item_size_max;</div><div class="line">    slabclass[power_largest].perslab = <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"slab class %3d: chunk size %9u perslab %7u\n"</span>,</div><div class="line">                i, slabclass[i].size, slabclass[i].perslab);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* for the test suite:  faking of how much we've already malloc'd */</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">char</span> *t_initial_malloc = getenv(<span class="string">"T_MEMD_INITIAL_MALLOC"</span>);</div><div class="line">        <span class="keyword">if</span> (t_initial_malloc) &#123;</div><div class="line">            mem_malloced = (<span class="keyword">size_t</span>)atol(t_initial_malloc);</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="comment">//调试用，可以不理</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prealloc) &#123;</div><div class="line">        slabs_preallocate(power_largest);<span class="comment">//预先为每一个slabclass分配一个内存页</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>slabs_init函数做的工作主要是初始化slabclass，然后如果有设置预先分配内存，则先分配一大块内存作为内存池，然后在为每一个slabclass分配一个内存页，接下来看下slabs_preallocate函数，是如何分配内存页的。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slabs_preallocate</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> maxslabs)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prealloc = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = POWER_SMALLEST; i &lt; MAX_NUMBER_OF_SLAB_CLASSES; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (++prealloc &gt; maxslabs)</div><div class="line">            <span class="keyword">return</span>;<span class="comment">//如果大于最大slab索引，则返回</span></div><div class="line">        <span class="keyword">if</span> (do_slabs_newslab(i) == <span class="number">0</span>) &#123;<span class="comment">//为第i个slabclass分配一个内存页</span></div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error while preallocating slab memory!\n"</span></div><div class="line">                <span class="string">"If using -L or other prealloc options, max memory must be "</span></div><div class="line">                <span class="string">"at least %d megabytes.\n"</span>, power_largest);</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数只是简单的给个for循环，从slabclass最小索引1到最大索引maxslab，分别调用do_slabs_newslab来分配一块内存页。</p>
<p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> do_slabs_newslab(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">id</span>) &#123;</div><div class="line">    slabclass_t *p = &amp;slabclass[<span class="keyword">id</span>];</div><div class="line">    <span class="keyword">int</span> len = settings.slab_reassign ? settings.item_size_max</div><div class="line">        : p-&gt;size * p-&gt;perslab;<span class="comment">//这句主要是判断新分配的内存页是1M了，还是p-&gt;size*p-&gt;perslab，</span></div><div class="line"><span class="comment">//因为后者不一定等于1M。</span></div><div class="line">    <span class="keyword">char</span> *ptr;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((mem_limit &amp;&amp; mem_malloced + len &gt; mem_limit &amp;&amp; p-&gt;slabs &gt; <span class="number">0</span>)) &#123;</div><div class="line">        mem_limit_reached = <span class="literal">true</span>;</div><div class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(<span class="keyword">id</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;<span class="comment">//如果有设置内存使用最大值而且已近分配的内存加上即将分配的内存大于mem_limit而且</span></div><div class="line">这个slabclass内存页不为空，则说明内存使用已经达到最大值。</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((grow_slab_list(<span class="keyword">id</span>) == <span class="number">0</span>) ||</div><div class="line">        ((ptr = memory_allocate((size_t)len)) == <span class="number">0</span>)) &#123;<span class="comment">//先将内存页数组的id加1，然后分配内存页</span></div><div class="line"></div><div class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(<span class="keyword">id</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    memset(ptr, <span class="number">0</span>, (size_t)len);</div><div class="line">    split_slab_page_into_freelist(ptr, <span class="keyword">id</span>);<span class="comment">//将内存页分割成一定数量的chunk</span></div><div class="line"></div><div class="line">    p-&gt;slab_list[p-&gt;slabs++] = ptr;<span class="comment">//slab_list数组索引加1，将内存页首地址赋给这个数组元素</span></div><div class="line">    mem_malloced += len;<span class="comment">//已分配内存加上len</span></div><div class="line">    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(<span class="keyword">id</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要是用于分配一块内存页，接着将这块内存页分割成chunk，并把每个chunk的首地址指针串接在p-&gt;slots上，表示可用的chunk。最后将内存页赋给slab_list数组元素。接下来看下其中的几个小函数。
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">static int grow_slab_list (const unsigned int id) &#123;</div><div class="line">    slabclass_t *p = &amp;slabclass[id];</div><div class="line">    <span class="function"><span class="title">if</span> (p-&gt;</span><span class="function"><span class="title">slabs</span> == p-&gt;</span>list_size) &#123;</div><div class="line">    <span class="comment">/*如果slab_list元素已满，(1)如果是初始化时，直接数组大小设为16，如果p-list_size!=0,</span></div><div class="line">    则数组大小翻倍*/</div><div class="line">        <span class="function"><span class="title">size_t</span> new_size =  (p-&gt;</span><span class="function"><span class="title">list_size</span> != 0) ? p-&gt;</span>list_size * <span class="number">2</span> : <span class="number">16</span>;</div><div class="line">        <span class="comment">//给slab_list重新分配内存</span></div><div class="line">        <span class="function"><span class="title">void</span> *new_list = realloc(p-&gt;</span>slab_list, new_size * sizeof(void *));</div><div class="line">        <span class="keyword">if</span> (new_list == <span class="number">0</span>) return <span class="number">0</span>;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span>list_size = new_size;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span>slab_list = new_list;</div><div class="line">    &#125;</div><div class="line">    return <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/</span></div><div class="line">tatic void split_slab_page_into_freelist(char *ptr, const unsigned int id) &#123;</div><div class="line">    slabclass_t *p = &amp;slabclass[id];</div><div class="line">    int x;</div><div class="line">    <span class="function"><span class="title">for</span> (x = 0; x &lt; p-&gt;</span>perslab; x++) &#123;</div><div class="line">	    <span class="function"><span class="title">do_slabs_free</span>(ptr, 0, id);//调用do_slabs_free将新分配的内存页回收，即挂到p-&gt;</span>slots</div><div class="line">	    <span class="function"><span class="title">ptr</span> += p-&gt;</span>size;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/</span></div><div class="line">static void do_slabs_free(void *ptr, const size_t size, unsigned int id) &#123;</div><div class="line">    slabclass_t *p;</div><div class="line">    item *it;</div><div class="line"></div><div class="line">    assert(id &gt;= POWER_SMALLEST &amp;&amp; id &lt;= power_largest);</div><div class="line">    <span class="keyword">if</span> (id &lt; POWER_SMALLEST || id &gt; power_largest)</div><div class="line">        return;</div><div class="line"></div><div class="line">    MEMCACHED_SLABS_FREE(size, id, ptr);</div><div class="line">    p = &amp;slabclass[id];</div><div class="line"></div><div class="line">    it = (item *)ptr;将Ptr指针指向的内存强制转化为item指针</div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span>it_flags |= ITEM_SLABBED;</div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span>slabs_clsid = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span>prev = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">it</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span><span class="function"><span class="title">slots</span>;//添加到p-&gt;</span>slots</div><div class="line">    <span class="function"><span class="title">if</span> (it-&gt;</span><span class="function"><span class="title">next</span>) it-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>prev = it;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>slots = it;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>sl_curr++;<span class="comment">//可用的item加1</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>requested -= size;<span class="comment">//已经分配的内存减size</span></div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，每个slabclass预先分配一个内存页，然后每个内存页都切割成相应的大小，并且指针挂到p-&gt;slots中，表示可用的item。需要说下几点:</p>
<ol>
<li>一开始时，slab默认分配的slab_list数组大小为16,之后数组存满时，再把数组大小翻倍；</li>
<li>将刚分配的内存页指针挂到p-&gt;slots上，其实就相当于回收刚分配的内存，变为可用，所以调用do_slabs_free。</li>
</ol>
<h1>slab申请内存</h1>
<hr>
<p>当slab初始化好内存之后，当线程执行插入操作时，需要将键值对封装成item结构，而item结构就需要到slab内存池申请内存，这时就调用slabs_alloc函数
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">void *slabs_alloc(size_t size, unsigned int id, unsigned int *total_chunks) &#123;</div><div class="line">    void *ret;</div><div class="line">    <span class="comment">//因为memcache是多线程模型，而slab是一种共享资源，所以必须加锁</span></div><div class="line">    pthread_mutex_lock(&amp;slabs_lock);</div><div class="line">    ret = do_slabs_alloc(size, id, total_chunks);</div><div class="line">    pthread_mutex_unlock(&amp;slabs_lock);</div><div class="line">    return ret;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/</span></div><div class="line">static void *do_slabs_alloc(const size_t size, unsigned int id, unsigned int *total_chunks) &#123;</div><div class="line">    slabclass_t *p;</div><div class="line">    void *ret = NULL;</div><div class="line">    item *it = NULL;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (id &lt; POWER_SMALLEST || id &gt; power_largest) &#123;</div><div class="line">        MEMCACHED_SLABS_ALLOCATE_FAILED(size, <span class="number">0</span>);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    p = &amp;slabclass[id];</div><div class="line">    <span class="function"><span class="title">assert</span>(p-&gt;</span><span class="function"><span class="title">sl_curr</span> == 0 || ((item *)p-&gt;</span><span class="function"><span class="title">slots</span>)-&gt;</span>slabs_clsid == <span class="number">0</span>);</div><div class="line"></div><div class="line">    *<span class="function"><span class="title">total_chunks</span> = p-&gt;</span><span class="function"><span class="title">slabs</span> * p-&gt;</span>perslab;<span class="comment">//这个slabclass所有chunk个数</span></div><div class="line">    <span class="comment">/* fail unless we have space at the end of a recently allocated page,</span></div><div class="line">       we have something on our freelist, or we could allocate a new page */</div><div class="line">    <span class="function"><span class="title">if</span> (! (p-&gt;</span>sl_curr != <span class="number">0</span> || do_slabs_newslab(id) != <span class="number">0</span>)) &#123;</div><div class="line">        <span class="comment">/* 没有更多的内存了*/</span></div><div class="line">        ret = NULL;</div><div class="line">    &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (p-&gt;</span>sl_curr != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/* p-&gt;slots还有可用的item内存块 */</span></div><div class="line">        <span class="function"><span class="title">it</span> = (item *)p-&gt;</span>slots;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">slots</span> = it-&gt;</span>next;</div><div class="line">        <span class="function"><span class="title">if</span> (it-&gt;</span><span class="function"><span class="title">next</span>) it-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>prev = <span class="number">0</span>;</div><div class="line">        <span class="comment">/* Kill flag and initialize refcount here for lock safety in slab</span></div><div class="line">         * mover's freeness detection. */</div><div class="line">        <span class="function"><span class="title">it</span>-&gt;</span>it_flags &amp;= ~ITEM_SLABBED;<span class="comment">//关闭这个标识，表示被分配出去了</span></div><div class="line">        <span class="function"><span class="title">it</span>-&gt;</span>refcount = <span class="number">1</span>;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span>sl_curr--;</div><div class="line">        ret = (void *)it;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (ret) &#123;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span>requested += size;</div><div class="line">        MEMCACHED_SLABS_ALLOCATE(<span class="function"><span class="title">size</span>, id, p-&gt;</span>size, ret);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数相对较好理解，多线程执行时，先锁住全局slab，然后将p-&gt;slots第一个指针指向的内存分配出去。接下来看下内存释放操作</p>
<h1>slab回收内存</h1>
<hr>
<p>slab并没有真正的释放item的内存，而是这块内存的指针插入p-&gt;slots的链表表头，这样下次需要时，即可重复利用这块内存。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">    pthread_mutex_lock(&amp;slabs_lock);</div><div class="line">    do_slabs_free(ptr, size, id);</div><div class="line">    pthread_mutex_unlock(&amp;slabs_lock);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/</span></div></pre></td></tr></table></figure></p>
<p>这调用之前的那个do_slab_free函数，回收ptr指向的大小为size的内存块。</p>
<h1>查询slab状态信息</h1>
<hr>
<p>slab还有一个函数用于查询slab的状态信息，比如分配了多少个内存页，内存申请了多少等等。代码如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_stats</span><span class="params">(ADD_STAT add_stats, <span class="keyword">void</span> *c)</span> </span>&#123;</div><div class="line">    pthread_mutex_lock(&amp;slabs_lock);</div><div class="line">    do_slabs_stats(add_stats, c);</div><div class="line">    pthread_mutex_unlock(&amp;slabs_lock);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_slabs_stats</span><span class="params">(ADD_STAT add_stats, <span class="keyword">void</span> *c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i, total;</div><div class="line">    <span class="comment">/* Get the per-thread stats which contain some interesting aggregates */</span></div><div class="line">    <span class="keyword">struct</span> thread_stats thread_stats;</div><div class="line">    threadlocal_stats_aggregate(&amp;thread_stats);</div><div class="line"></div><div class="line">    total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = POWER_SMALLEST; i &lt;= power_largest; i++) &#123;</div><div class="line">        <span class="keyword">slabclass_t</span> *p = &amp;slabclass[i];</div><div class="line">        <span class="keyword">if</span> (p-&gt;slabs != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">uint32_t</span> perslab, slabs;</div><div class="line">            slabs = p-&gt;slabs;</div><div class="line">            perslab = p-&gt;perslab;</div><div class="line"></div><div class="line">            <span class="keyword">char</span> key_str[STAT_KEY_LEN];</div><div class="line">            <span class="keyword">char</span> val_str[STAT_VAL_LEN];</div><div class="line">            <span class="keyword">int</span> klen = <span class="number">0</span>, vlen = <span class="number">0</span>;</div><div class="line"></div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"chunk_size"</span>, <span class="string">"%u"</span>, p-&gt;size);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"chunks_per_page"</span>, <span class="string">"%u"</span>, perslab);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"total_pages"</span>, <span class="string">"%u"</span>, slabs);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"total_chunks"</span>, <span class="string">"%u"</span>, slabs * perslab);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"used_chunks"</span>, <span class="string">"%u"</span>,</div><div class="line">                            slabs*perslab - p-&gt;sl_curr);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"free_chunks"</span>, <span class="string">"%u"</span>, p-&gt;sl_curr);</div><div class="line">            <span class="comment">/* Stat is dead, but displaying zero instead of removing it. */</span></div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"free_chunks_end"</span>, <span class="string">"%u"</span>, <span class="number">0</span>);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"mem_requested"</span>, <span class="string">"%llu"</span>,</div><div class="line">                            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)p-&gt;requested);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"get_hits"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].get_hits);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"cmd_set"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].set_cmds);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"delete_hits"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].delete_hits);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"incr_hits"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].incr_hits);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"decr_hits"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].decr_hits);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"cas_hits"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].cas_hits);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"cas_badval"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].cas_badval);</div><div class="line">            APPEND_NUM_STAT(i, <span class="string">"touch_hits"</span>, <span class="string">"%llu"</span>,</div><div class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)thread_stats.slab_stats[i].touch_hits);</div><div class="line">            total++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数主要做的事就是将这些信息存放到一个这个连接的buf输出字符数组中，然后将在一个epoll轮询时，把数据输出给客户端。</p>
<p>最后几个函数是和平衡slab的线程相关的，之后统一在分析这些辅助线程。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_slab_maintenance_thread</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_slab_maintenance_thread</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_rebalancer_pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_rebalancer_resume</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
            <tag> slab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[memcache源码分析之软件架构]]></title>
      <url>http://luodw.cc/2016/01/08/memcache-01/</url>
      <content type="html"><![CDATA[<p>学习开源框架的源码是学习软件开发的有效途径，可以了解到之前学习的linux进程，线程和网络知识是怎么运用的，以及巩固编程语言，最后掌握一门技术。之前在看leveldb源码时，学习到了好多知识，内存池的设计，缓冲池的设计以及C++如何开发一个开源框架；看redis时（有时间要补上redis源码总结），因为是我第一个看的开源框架，给我感受最深的是服务器端事件驱动，也就是mainae模块，可以由一个线程，监听所有的套接字描述符，实现并发。redis代码也很优美，看起来比较轻松。这次看的memcache,区别与redis，memcache使用的多线程模型，主线程accept客户端连接，工作线程处理客户端的请求。</p>
<p>接下来，先介绍下常见的服务器端软件架构，之后在介绍memcache软件架构。</p>
<h1>常见的服务端软件架构</h1>
<hr>
<p>目前在服务器端常见的软件架构有单进程，多进程和多线程。具体展开细分，又可以分为以下10种:</p>
<ol>
<li>单进程 即服务器端阻塞在accept等待客户端请求，来一个客户端请求，服务器端处理这个请求，这个请求处理之后，才能接下去处理其他客户端请求，这种设计也称为迭代式服务器。这种单进程模型不适合现在服务器设计了，因为现在的服务器连接数都已经上万，几十万，百万，可能还更多，单进程会导致很多连接延迟。</li>
<li>单进程的IO多路复用 即redis的服务器进程模型。这种模型进程阻塞在select,epoll等io多路系统调用上，然后在一个一个串行处理客户端请求。这种模型在每个客户端的请求都占用较短时间的情况下，还是很高效的。</li>
<li>一个客户一个子进程模型  服务器父进程阻塞在accept调用中，每接收一个客户端，就fork一个子进程处理这个客户端。</li>
<li>预先派生子进程，accept无上锁 即程序在一开始运行时，先fork出一定数量的子进程，然后每个子进程分别accept。子进程由于继承了监听的套接字，所以当有一个客户端连接时，每个子进程均可以被通知有客户端到达，接着调用accept接受连接，但是只有最快的那个子进程接收这个客户端，这种现象也叫作惊群。所以有下面两种加锁方式避免惊群。</li>
<li>预先派生子进程，accept使用文件锁  每个子进程在调用accept之前，必须先获取文件锁，然后才能调用accept，最后在把文件锁给释放了，然后才处理客户端请求。可以用fcntl锁住一个文件。</li>
<li>预先派生多个子进程，accept使用线程锁保护 当在进程间使用线程锁时，必须将线程锁存储在共享内存区，然后将线程锁的属性设置为PTHREAD_PROCESS_SHARED即可。</li>
<li>预先派生多个子进程，传递描述符  现在父进程和子进程之间建立通信管道或者域套接字，当主进程接受一个客户端连接时，用管道传递给子进程，子进程处理之后，再向父进程发送一个字符，表示子进程又可用。</li>
<li>一个客户，一个线程 这种主线程接收客户端请求，子线程处理客户请求。</li>
<li>预先创建多个线程，每个线程accept  这个和第三个类似，需要加线程锁锁住accept调用。</li>
<li>预先创建多个线程，主线程统一accept 主线程主要为accept客户端请求，并把接收到的描述符放进一个队列；然后子线程在分别从队列提取描述符处理。</li>
</ol>
<p>在这么多服务器端软件设计模型中，我比较喜欢的是单进程IO多路复用(redis)；预先派生多个子进程，进程池中的accept加锁（nginx）；线程池，主线程统一accept，放进队列，工作线程提取任务（memcache)。nginx也是一款很优秀的开源软件，也在我学习计划中。</p>
<h1>memcache在服务端的作用</h1>
<hr>
<p>memcache和redis都是缓存数据库，在大型网址中作为cache。当服务器程序要访问mysql时，首先访问缓存数据库，如果缓存数据库中有需要的数据，则之前从缓存数据库中返回；如果没有，则从mysql数据库中获取数据，并存入缓存数据库中，最后从缓存数据库返回给服务器程序。因为缓存数据库运行在内存中，所以获取数据的速度比Mysql获取高效。所以在大型网站的架构中，缓存数据库可以说是举足轻重。下面图说明了服务器访问关系性数据库和NoSQL的关系，图片来自网上：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/20140324225107859.png" alt="服务器访问数据库"></p>
<h1>memcache线程模型</h1>
<hr>
<p>memcache使用了libevent开源事件驱动框架，libvent底层封装了select,epoll,/dev/poll,kqueue等各平台的IO多路复用，接口简单，效率高。总体框架如下图所示：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/20150114093937432.jpeg" alt="memceche软件线程模型">
memcache采用的是线程池模型，首先在进程运行时，产生一定数量的子线程，主线程和子线程利用管道进行通信。主线程调用libevent接口，监听客户端的请求，当接收到一个客户端请求之后，选择一个空闲的线程，将客户端的套接字放入队列中，并向这个子线程管道发送一个字符。这个被选中的子线程接收到字符之后，就从队列中获取客户端的描述符，然后调用libevent接口，监听这个客户端是否有业务需要执行。</p>
<p>所以总结为：主线和子线程各有一个libevent，主线程监听服务器端套接字，接收客户请求，子线程处理客户请求。</p>
<h1>memcache内存池</h1>
<hr>
<p>当客户端与memcache服务器建立连接之后，接着并向服务器发送命令set,get等等，存储数据或者取数据。那么这时就设计到memcache内存池设计。memcache利用slab来管理内存分配。slab模型图如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/1345021404_1576.png" alt="slab内存池模型">
memcache分配了n个slabclass数组，每个数组负责固定大小的内存请求，相邻的slabclass负责的内存大小成等比数列。例如slabclass[0]负责88bytes，假设比例为1.25，则slabclas[1]负责110bytes。slabclass每次分配一个内存页，大小为1M，然后将这1M内存分为88bytes字节的chunk，用于每个item存储，（item为存储键值对的数据结构）。slab_list存储的是内存页列表，每个内存页为1M，由一定数量的chunk组成。slots为一个item指针列表，存储回收的内存item内存块指针。
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ee3e8c9db4afebad6f3057e56e844a81.png" alt="chunk模型">;
当需要存储一个键值对时，线程会将键值对封装成item结构，然后到slab中请求内存。slab分配给这个item的内存大小为大于sizeof(item)的最小内存chunk。如下图所示：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/2033581_137843557732cq.png" alt="slab给item分配内存"></p>
<p>memcache作为一款缓存数据库，它维护着一个哈希表和为每一个slabclass分配了一个LRU队列。LRU队列用于存储管理数据，哈希表用于查询数据。这也是缓存设计经典数据结构组合：队列+哈希表。当某个item分配到一块chunk之后，这个chunk就从slab内存池脱离，然后绑定到这个LRU队列tail中。同时也插入到哈希表中，便于查询。memcache没有真正的删除键值对，而是当要删除元素时，先删除LRU队列的head指针，然后在删除哈希表中的指针，最后将存储这个item的chunk回收到slabclass的slots中，当重新利用这个chunk时，直接覆盖旧数据即可。</p>
<p>memcache还创建了一些爬虫线程用于平衡内存分配，LRU队列等等，等分析源码时，再细究。所以对于一款内存数据库而言，主要由网络，内存管理和线程组成。</p>
<p>以上就是memcache的整体框架，接下来，我对主要部分将进行源码分析。注：这篇文章的图片均来自网络。</p>
]]></content>
      
        <categories>
            
            <category> memcache </category>
            
        </categories>
        
        
        <tags>
            
            <tag> memcache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下非阻塞I/O]]></title>
      <url>http://luodw.cc/2016/01/06/nonblock/</url>
      <content type="html"><![CDATA[<p>平时在使用socket时，经常要把文件描述符设置为非阻塞，这样当没有数据到达时，就不会使进程阻塞，而是直接返回一个错误。在linux网络方面，有四个函数会涉及阻塞与非阻塞IO流，即读取操作，写入操作，接受外来连接,发起外出连接。接下来，就把网络编程书本上的知识点总结下。</p>
<h1>读取操作</h1>
<hr>
<p>在linux系统中，磁盘文件可以使用read和readv函数，而网络socket则可以使用read,readv,recv,recvfrom和recvmsg五个。如果某个进程对阻塞TCP套接字读取数据，而内核缓冲区没有的数据，则进程会阻塞，知道缓冲区有数据达到，即使只有一个字节也可以唤醒tcp读取。如果是UDP数据协议，如果一个阻塞的UDP套接字接收缓冲区为空，对他调用读取操作，进程将睡眠，直到UDP数据报达到。</p>
<p>对于非阻塞的套接字，如果输入操作不能满足（TCP套接字至少有一个字节数据可读，UDP套接字即有一个完整的数据报可读），相应的调用将立即返回一个EWOULDBLOCK错误。</p>
<h1>写入操作</h1>
<hr>
<p>linux对于磁盘的写入操作，有write和writev，而对于网络socket则可以使用write,writev,send,sendto和sendmesg。对于一个TCP写操作，其实就是将用户程序的数据拷贝到套接字缓冲区中，如果TCP套接字缓冲区没有空间，则进程将投入睡眠，直到有空间为止。</p>
<p>对于非阻塞的TCP套接字，如果缓冲区根本就没空间，则返回一个EWOULDBLOCK错误。如果缓冲区有一些空间，返回值是内核能够复制到该缓冲区的字节数。这个字节数也叫作不足计数。</p>
<p>UDP不存在真正的发送缓冲区。内核只是复制用户程序的数据，并把它沿着协议栈往下传送。因此对于一个阻塞的UDP套接字输出函数不会因和TCP套接字一样的原因阻塞，可能因为其他原因阻塞。</p>
<h1>接受外来连接</h1>
<hr>
<p>接受外来连接，即accept函数。如果对于一个阻塞的套接字调用accept函数，并且尚无新的连接达到，调用进程将投入睡眠；</p>
<p>如果对于一个非阻塞的套接字调用accept函数，并且尚无新的连接到达，accept函数将立即返回一个EWOULDBLOCK错误。</p>
<h1>发起外出连接</h1>
<hr>
<p>对于阻塞TCP套接字，connect调用将会阻塞，直到内核三次握手成功才可返回。而对于udp套接字而言，connect并没有三次握手的过程，只是使内核保存对端的IP地址和端口号。</p>
<p>对于非阻塞的TCP套接字，调用connect函数，如果返回0，则表示连接建立；如果返回小于0且errno为EINPROGRESS，则可能是正在三次握手的过程中，如果errno不是EINPROGRESS，则连接出错。</p>
<p>对于都是返回小于0的情况，我们可以用select函数来判断是否连接成功还是连接失败。</p>
<ol>
<li>如果连接建立好了，对方没有数据到达，那么sockfd是可写的</li>
<li>如果select之前，连接就建立好了，而且对方的数据已到达，那么sockfd是可读和可写的。</li>
<li>如果连接发生错误，sockfd也是可读和可写的。</li>
</ol>
<p>判断connect是否成功，就是区别第二和第三中情况，两者sockfd都是可读和可写，区分的方法是调用getsockopt检查是否错误。</p>
<p>如果发生错误，getsockopt 源自 Berkeley 的实现将在变量 error 中
返回错误，getsockopt 本身返回0；然而 Solaris 却让 getsockopt 返回 -1，
并把错误保存在 errno 变量中。所以在判断是否有错误的时候，要处理这两种情况。</p>
<p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">int conn_nonb(int sockfd, const <span class="keyword">struct</span> sockaddr_in *saptr, socklen_t salen, int nsec)     </div><div class="line">&#123;     </div><div class="line">    int flags, n, <span class="built_in">error</span>, <span class="built_in">code</span>;     </div><div class="line">    socklen_t len;     </div><div class="line">    fd_set wset;     </div><div class="line">    <span class="keyword">struct</span> timeval tval;     </div><div class="line">    </div><div class="line">    flags = fcntl(sockfd, F_GETFL, <span class="number">0</span>);     </div><div class="line">    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);     </div><div class="line">    </div><div class="line">    <span class="built_in">error</span> = <span class="number">0</span>;     </div><div class="line">    <span class="keyword">if</span> ((n == connect(sockfd, saptr, salen)) == <span class="number">0</span>) &#123;     </div><div class="line">        <span class="keyword">goto</span> done;     </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno != EINPROGRESS)&#123;     </div><div class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);     </div><div class="line">    &#125;     </div><div class="line">    </div><div class="line">    <span class="comment">/* Do whatever we want while the connect is taking place */</span>    </div><div class="line">    </div><div class="line">    FD_ZERO(&amp;wset);     </div><div class="line">    FD_SET(sockfd, &amp;wset);     </div><div class="line">    tval.tv_sec = nsec;     </div><div class="line">    tval.tv_usec = <span class="number">0</span>;     </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((n = <span class="built_in">select</span>(sockfd+<span class="number">1</span>, <span class="built_in">NULL</span>, &amp;wset,      </div><div class="line">                    <span class="built_in">NULL</span>, nsec ? &amp;tval : <span class="built_in">NULL</span>)) == <span class="number">0</span>) &#123;     </div><div class="line">        <span class="built_in">close</span>(sockfd);  <span class="comment">/* timeout */</span>    </div><div class="line">        errno = ETIMEDOUT;     </div><div class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);     </div><div class="line">    &#125;     </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;wset)) &#123;     </div><div class="line">        len = sizeof(<span class="built_in">error</span>);     </div><div class="line">        <span class="built_in">code</span> = getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;<span class="built_in">error</span>, &amp;len);     </div><div class="line">        <span class="comment">/* 如果发生错误，Solaris实现的getsockopt返回-1，   </span></div><div class="line">         * 把pending error设置给errno. Berkeley实现的   </div><div class="line">         * getsockopt返回0, pending error返回给error.    </div><div class="line">         * 我们需要处理这两种情况 */    </div><div class="line">        <span class="keyword">if</span> (<span class="built_in">code</span> &lt; <span class="number">0</span> || <span class="built_in">error</span>) &#123;     </div><div class="line">            <span class="built_in">close</span>(sockfd);     </div><div class="line">            <span class="keyword">if</span> (<span class="built_in">error</span>)      </div><div class="line">                errno = <span class="built_in">error</span>;     </div><div class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);     </div><div class="line">        &#125;     </div><div class="line">    &#125; <span class="keyword">else</span> &#123;     </div><div class="line">        fprintf(stderr, <span class="string">"select error: sockfd not set"</span>);     </div><div class="line">        exit(<span class="number">0</span>);     </div><div class="line">    &#125;     </div><div class="line">    </div><div class="line">done:     </div><div class="line">    fcntl(sockfd, F_SETFL, flags);  <span class="comment">/* restore file status flags */</span>    </div><div class="line">    <span class="keyword">return</span> (<span class="number">0</span>);     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码有助于理解是怎么解决这些问题冲突的。</p>
]]></content>
      
        <categories>
            
            <category> socket </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linxu </tag>
            
            <tag> nonblock </tag>
            
            <tag> I/O </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命令netstat,trace和tcpdump]]></title>
      <url>http://luodw.cc/2015/12/30/network-command/</url>
      <content type="html"><![CDATA[<p>最近在学网络，特别是在用tcpdump命令捕获数据包时，发现网络的几个命令是那么强大，特此，上网搜索了相关资料，总结下这几个命令的用法。从网络接口到tcp层，有ifconfig,route和routetrace,netstat.还有一个抓包命令tcpdump。</p>
<h1>netstat命令</h1>
<hr>
<p>netstat命令主要是用于显示各种网络相关信息，如网络连接，路由表，接口状态，多播成员等等。命令用法比较多，初学记住几个常用的就行了。</p>
<p>首先是默认情况下，netstat命令输出所有的连接情况，默认情况下，netstat输出的是所有已连接的tcp,udp和unix域套接字。如下：
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">root@charles-Lenovo:/home/charles<span class="comment"># netstat | more</span></div><div class="line">激活Internet连接 (w/o 服务器)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>localhost:49558         localhost:36329         ESTABLISHED</div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>localhost:49558         localhost:36377         ESTABLISHED</div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>localhost:36377         localhost:49558         ESTABLISHED</div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>localhost:36329         localhost:49558         ESTABLISHED</div><div class="line">tcp6      <span class="number"> 1 </span>    <span class="number"> 0 </span>ip6-localhost:46135     ip6-localhost:ipp       CLOSE_WAIT </div><div class="line">活跃的UNIX域套接字 (w/o 服务器)</div><div class="line">Proto RefCnt Flags       Type       State         I-Node   路径</div><div class="line">unix <span class="number"> 20 </span>    [ ]         数据报               <span class="number"> 11336 </span>   /dev/log</div><div class="line">unix <span class="number"> 3 </span>     [ ]         流        已连接    <span class="number"> 17634 </span>   </div><div class="line">unix <span class="number"> 3 </span>     [ ]         流        已连接    <span class="number"> 14118 </span>   </div><div class="line">unix <span class="number"> 3 </span>     [ ]         流        已连接    <span class="number"> 14812 </span>   /run/user/1000/pulse/nati</div><div class="line">ve</div><div class="line">unix <span class="number"> 3 </span>     [ ]         流        已连接    <span class="number"> 16987 </span>   </div><div class="line">unix <span class="number"> 3 </span>     [ ]         流        已连接    <span class="number"> 14188 </span>   </div><div class="line">unix <span class="number"> 3 </span>     [ ]         流        已连接    <span class="number"> 17596 </span>   </div><div class="line">unix <span class="number"> 3 </span>     [ ]         流        已连接     17482</div></pre></td></tr></table></figure></p>
<p>从输出可以看出，netstat主要就是显示各种连接的状态，包括tcp,udp和unix。这个输出没有udp，因为我没有开启udp程序，当我开启一个udp程序和浏览器时，这时就会显示两个udp连接，一个是我udp程序的连接，一个是浏览器向本地域名服务器解析域名的udp连接：
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">udp</span>        0      0 <span class="selector-tag">localhost</span><span class="selector-pseudo">:59634</span>         <span class="selector-tag">localhost</span><span class="selector-pseudo">:8888</span>          <span class="selector-tag">ESTABLISHED</span></div><div class="line"><span class="selector-tag">udp</span>        0      0 <span class="selector-tag">localhost</span><span class="selector-pseudo">:52440</span>         <span class="selector-tag">charles-Lenovo</span><span class="selector-pseudo">:domain</span>   <span class="selector-tag">ESTABLISHED</span></div></pre></td></tr></table></figure></p>
<p>第一个是我的udp程序调用connect函数之后，出现的连接状态，如果没有connect函数，那么是不会显示udp连接状态的，因为udp是面向无连接。第二个是浏览器向dnsmasq建立udp连接，用于解析域名。当调用getaddinfo函数时，也是会有第二条连接的。linux系统unix域套接字用的比较多，主要是因为性能比tcp/udp好。</p>
<ol>
<li>
<p>列出所有的端口（包括监听和未监听的）
netstat -a
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@charles-Lenovo:/home/charles<span class="comment"># netstat -a | more</span></div><div class="line">激活Internet连接 (服务器和已建立连接的)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State     </div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>localhost:mysql         *:*                     LISTEN     </div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>charles-Lenovo:domain   *:*                     LISTEN     </div><div class="line">udp       <span class="number"> 0 </span>    <span class="number"> 0 </span>charles-Lenovo:domain   *:*                                </div><div class="line">udp       <span class="number"> 0 </span>    <span class="number"> 0 </span>*:bootpc                *:* </div><div class="line">活跃的UNIX域套接字 (服务器和已建立连接的)</div><div class="line">Proto RefCnt Flags       Type       State         I-Node   路径</div><div class="line">unix <span class="number"> 2 </span>     [ ACC ]     流        LISTENING    <span class="number"> 11264 </span>   /run/user/1000/pulse/native</div><div class="line">unix <span class="number"> 2 </span>     [ ACC ]     流        LISTENING    <span class="number"> 12805 </span>   /var/run/mysqld/mysqld.sock</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>只列出所有的tcp连接
netstat -at</p>
</li>
<li>
<p>只列出所有的udp连接
netstat -au</p>
</li>
<li>
<p>列出所有处于监听的连接，包括tcp,udp和unix域套接字
netstat -l
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@charles-Lenovo:/home/charles<span class="comment"># netstat -l</span></div><div class="line">激活Internet连接 (仅服务器)</div><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>localhost:mysql         *:*                     LISTEN     </div><div class="line">tcp       <span class="number"> 0 </span>    <span class="number"> 0 </span>charles-Lenovo:domain   *:*                     LISTEN   </div><div class="line">udp       <span class="number"> 0 </span>    <span class="number"> 0 </span>charles-Lenovo:domain   *:*                                </div><div class="line">udp       <span class="number"> 0 </span>    <span class="number"> 0 </span>*:bootpc                *:*                            </div><div class="line">活跃的UNIX域套接字 (仅服务器)</div><div class="line">Proto RefCnt Flags       Type       State         I-Node   路径</div><div class="line">unix <span class="number"> 2 </span>     [ ACC ]     流        LISTENING    <span class="number"> 11264 </span>   /run/user/1000/pulse/native</div><div class="line">unix <span class="number"> 2 </span>     [ ACC ]     流        LISTENING    <span class="number"> 12805 </span>   /var/run/mysqld/mysqld.sock</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>只列出tcp监听端口
netstat -lt</p>
</li>
<li>
<p>只列出udp监听端口
netstat -lu</p>
</li>
<li>
<p>只列出unix域套接字监听端口
netstat -lx</p>
</li>
<li>
<p>查看路由表信息
netstat -r
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@charles-Lenovo:/home/charles# netstat -r</div><div class="line">内核 <span class="built_in">IP</span> 路由表</div><div class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</div><div class="line"><span class="meta">default</span>         <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.1</span>     <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>         UG        <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> eth0</div><div class="line"><span class="number">192.168</span><span class="meta">.1</span><span class="meta">.0</span>     *               <span class="number">255.255</span><span class="meta">.255</span><span class="meta">.0</span>   U         <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> eth0</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>一般有两条路由信息，一个是默认路由，即目的地地址不在本网络时，通过网络接口eth0，传到网关192.168.1.1这个也就是第一跳路由器的地址；如果目的地地址是在同一个局域网中，即与子网掩码255.255.255.0与之后=192.168.1.0，则没有网关，通过eth0广播询问即可。</p>
<ol start="9">
<li>
<p>查询网络接口列表
netstat -i
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@charles-Lenovo:/home/charles<span class="comment"># netstat -i</span></div><div class="line">Kernel Interface table</div><div class="line">Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</div><div class="line">eth0      <span class="number"> 1500 </span>0    <span class="number"> 57318 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>0        <span class="number"> 41328 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>BMRU</div><div class="line">lo       <span class="number"> 65536 </span>0    <span class="number"> 13239 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>0        <span class="number"> 13239 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>    <span class="number"> 0 </span>LRU</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>找出程序运行的端口
netstat -ap | grep ssh
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@charles-Lenovo:<span class="meta-keyword">/home/</span>charles<span class="meta"># netstat -ap | grep ssh</span></div><div class="line">unix  <span class="number">2</span>      [ ACC ]     流        LISTENING     <span class="number">13893</span>    <span class="number">1693</span>/gnome-keyring- </div><div class="line"><span class="meta-keyword">/run/</span>user/<span class="number">1000</span><span class="meta-keyword">/keyring-32r7ap/</span>ssh</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这里ssh服务器居然是建立unix套接字，这让我很费解，怎么实现远程连接的？</p>
<p>之后就是与一些命令组合，例如，awk,sed,grep等等，输出各个字段的信息，这后面在学习了。</p>
<h1>route命令</h1>
<hr>
<p>这个命令主要是用于查看路由表，添加路由信息，设置网关等等；默认输出的是路由表信息；
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@charles-Lenovo:/home/charles# route</div><div class="line">内核 <span class="built_in">IP</span> 路由表</div><div class="line">目标            网关            子网掩码        标志  跃点   引用  使用 接口</div><div class="line"><span class="meta">default</span>         <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.1</span>     <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>         UG    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span> eth0</div><div class="line"><span class="number">192.168</span><span class="meta">.1</span><span class="meta">.0</span>     *               <span class="number">255.255</span><span class="meta">.255</span><span class="meta">.0</span>   U     <span class="number">1</span>      <span class="number">0</span>        <span class="number">0</span> eth0</div></pre></td></tr></table></figure></p>
<p>route -n这个和route的区别就是：route显示的主机名称，而route -n显示的IP地址</p>
<p>下面说下主要几个标志的意义：</p>
<ul>
<li>U (route is up)：该路由是启动的；</li>
<li>H (target is a host)：目标是一部主机 (IP) 而非网域；</li>
<li>G (use gateway)：需要透过外部的主机 (gateway) 来转递封包；</li>
<li>R (reinstate route for dynamic routing)：使用动态路由时，恢复路由资讯的旗标；</li>
<li>D (dynamically installed by daemon or redirect)：已经由服务或转 port 功能设定为动态路由；</li>
<li>M (modified from routing daemon or redirect)：路由已经被修改了；</li>
<li>!  (reject route)：这个路由将不会被接受(用来抵挡不安全的网域！)</li>
</ul>
<ol>
<li>向路由表添加一个路由信息
一般来说，都是为了能访问别的子网才设置路由的，比如说，你的主机处于192.168.10.0/24，而你想访问192.168.20.0/24网的主机，当然你知道一个网关IP，例如192.168.10.1（必须和你主机处于同一子网），那么，你可以这样配置路由。</li>
</ol>
<p>添加路由
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">route</span> <span class="selector-tag">add</span> <span class="selector-tag">-net</span> 192<span class="selector-class">.168</span><span class="selector-class">.20</span><span class="selector-class">.0</span> <span class="selector-tag">netmask</span> 255<span class="selector-class">.255</span><span class="selector-class">.255</span><span class="selector-class">.0</span> <span class="selector-tag">gw</span> 192<span class="selector-class">.168</span><span class="selector-class">.10</span><span class="selector-class">.1</span></div></pre></td></tr></table></figure></p>
<p>删除路由
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">route</span> <span class="selector-tag">del</span> <span class="selector-tag">-net</span> 192<span class="selector-class">.168</span><span class="selector-class">.20</span><span class="selector-class">.0</span> <span class="selector-tag">netmask</span> 255<span class="selector-class">.255</span><span class="selector-class">.255</span><span class="selector-class">.0</span></div></pre></td></tr></table></figure></p>
<p>这个命令最主要的用法就是查看路由表，添加路由和删除路由器。</p>
<h1>ifconfig命令</h1>
<hr>
<p>这个命令平常使用最主要的功能就是，查看网络接口的信息，例如物理地址，ip地址，掩码等等。其他就是设置网络接口开关，设置mtu等等。
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">root</span>@<span class="selector-tag">charles-Lenovo</span>:/<span class="selector-tag">home</span>/<span class="selector-tag">charles</span># <span class="selector-tag">ifconfig</span></div><div class="line"><span class="selector-tag">eth0</span>      <span class="selector-tag">Link</span> <span class="selector-tag">encap</span>:以太网  硬件地址 <span class="selector-tag">44</span><span class="selector-pseudo">:37</span><span class="selector-pseudo">:e6</span><span class="selector-pseudo">:53</span><span class="selector-pseudo">:d7</span><span class="selector-pseudo">:8c</span>  </div><div class="line">          <span class="selector-tag">inet</span> 地址<span class="selector-pseudo">:192.168.1.151</span>  广播<span class="selector-pseudo">:192.168.1.255</span>  掩码<span class="selector-pseudo">:255.255.255.0</span></div><div class="line">          <span class="selector-tag">inet6</span> 地址: <span class="selector-tag">fe80</span><span class="selector-pseudo">::4637</span><span class="selector-pseudo">:e6ff</span><span class="selector-pseudo">:fe53</span><span class="selector-pseudo">:d78c</span>/<span class="selector-tag">64</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Link</span></div><div class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">BROADCAST</span> <span class="selector-tag">RUNNING</span> <span class="selector-tag">MULTICAST</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:1500</span>  跃点数<span class="selector-pseudo">:1</span></div><div class="line">          接收数据包<span class="selector-pseudo">:63010</span> 错误<span class="selector-pseudo">:0</span> 丢弃<span class="selector-pseudo">:0</span> 过载<span class="selector-pseudo">:0</span> 帧数<span class="selector-pseudo">:0</span></div><div class="line">          发送数据包<span class="selector-pseudo">:45853</span> 错误<span class="selector-pseudo">:0</span> 丢弃<span class="selector-pseudo">:0</span> 过载<span class="selector-pseudo">:0</span> 载波<span class="selector-pseudo">:0</span></div><div class="line">          碰撞<span class="selector-pseudo">:0</span> 发送队列长度<span class="selector-pseudo">:1000</span> </div><div class="line">          接收字节<span class="selector-pseudo">:54436715</span> (<span class="number">54.4</span> MB)  发送字节<span class="selector-pseudo">:6200233</span> (<span class="number">6.2</span> MB)</div><div class="line">          中断<span class="selector-pseudo">:20</span> <span class="selector-tag">Memory</span><span class="selector-pseudo">:fe400000-fe420000</span> </div><div class="line"></div><div class="line"><span class="selector-tag">lo</span>        <span class="selector-tag">Link</span> <span class="selector-tag">encap</span>:本地环回  </div><div class="line">          <span class="selector-tag">inet</span> 地址<span class="selector-pseudo">:127.0.0.1</span>  掩码<span class="selector-pseudo">:255.0.0.0</span></div><div class="line">          <span class="selector-tag">inet6</span> 地址: <span class="selector-pseudo">::1</span>/<span class="selector-tag">128</span> <span class="selector-tag">Scope</span><span class="selector-pseudo">:Host</span></div><div class="line">          <span class="selector-tag">UP</span> <span class="selector-tag">LOOPBACK</span> <span class="selector-tag">RUNNING</span>  <span class="selector-tag">MTU</span><span class="selector-pseudo">:65536</span>  跃点数<span class="selector-pseudo">:1</span></div><div class="line">          接收数据包<span class="selector-pseudo">:15778</span> 错误<span class="selector-pseudo">:0</span> 丢弃<span class="selector-pseudo">:0</span> 过载<span class="selector-pseudo">:0</span> 帧数<span class="selector-pseudo">:0</span></div><div class="line">          发送数据包<span class="selector-pseudo">:15778</span> 错误<span class="selector-pseudo">:0</span> 丢弃<span class="selector-pseudo">:0</span> 过载<span class="selector-pseudo">:0</span> 载波<span class="selector-pseudo">:0</span></div><div class="line">          碰撞<span class="selector-pseudo">:0</span> 发送队列长度<span class="selector-pseudo">:0</span> </div><div class="line">          接收字节<span class="selector-pseudo">:13352760</span> (<span class="number">13.3</span> MB)  发送字节<span class="selector-pseudo">:13352760</span> (<span class="number">13.3</span> MB)</div></pre></td></tr></table></figure></p>
<ol>
<li>启动关闭指定网卡
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 <span class="meta">up</span></div><div class="line">ifconfig eth0 <span class="meta">down</span></div></pre></td></tr></table></figure></li>
</ol>
<p>第一个为启动eth0网卡，第二个为关闭eth0网卡，但是如果是ssh登陆linux，则要小心了，因为关闭之后，就连不上了，除非有两个网卡。</p>
<ol start="2">
<li>为网卡配置和删除IPv6地址
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ifconfig</span> <span class="selector-tag">eth0</span> <span class="selector-tag">add</span> <span class="selector-tag">33ffe</span><span class="selector-pseudo">:3240</span><span class="selector-pseudo">:800</span><span class="selector-pseudo">:1005</span><span class="selector-pseudo">::2</span>/<span class="selector-tag">64</span> 为网卡<span class="selector-tag">eth0</span>配置<span class="selector-tag">IPv6</span>地址；</div><div class="line"><span class="selector-tag">ifconfig</span> <span class="selector-tag">eth0</span> <span class="selector-tag">add</span> <span class="selector-tag">33ffe</span><span class="selector-pseudo">:3240</span><span class="selector-pseudo">:800</span><span class="selector-pseudo">:1005</span><span class="selector-pseudo">::2</span>/<span class="selector-tag">64</span> 为网卡<span class="selector-tag">eth0</span>删除<span class="selector-tag">IPv6</span>地址；</div></pre></td></tr></table></figure></li>
</ol>
<p>练习的时候，ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。</p>
<ol start="3">
<li>
<p>用ifconfig修改MAC地址
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ifconfig</span> <span class="selector-tag">eth0</span> <span class="selector-tag">hw</span> <span class="selector-tag">ether</span> 00<span class="selector-pseudo">:AA</span><span class="selector-pseudo">:BB</span><span class="selector-pseudo">:CC</span><span class="selector-pseudo">:DD</span><span class="selector-pseudo">:EE</span></div></pre></td></tr></table></figure></p>
</li>
<li>
<p>配置ip地址
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.120</span><span class="number">.56</span> </div><div class="line">给eth0网卡配置IP地：<span class="number">192.168</span><span class="number">.120</span><span class="number">.56</span></div><div class="line"> ifconfig eth0 <span class="number">192.168</span><span class="number">.120</span><span class="number">.56</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> </div><div class="line">给eth0网卡配置IP地址：<span class="number">192.168</span><span class="number">.120</span><span class="number">.56</span> ，并加上子掩码：<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></div><div class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.120</span><span class="number">.56</span> netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> broadcast <span class="number">192.168</span><span class="number">.120</span><span class="number">.255</span></div><div class="line">/给eth0网卡配置IP地址：<span class="number">192.168</span><span class="number">.120</span><span class="number">.56</span>，加上子掩码：<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>，加上个广播地址：</div><div class="line"><span class="number">192.168</span><span class="number">.120</span><span class="number">.255</span></div></pre></td></tr></table></figure></p>
</li>
<li>
<p>启用和关闭ARP协议
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ifconfig</span> eth0 arp 开启网卡eth0 的arp协议；</div><div class="line">ifconfig eth0 -arp 关闭网卡eth0 的arp协议；</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>设置最大传输单元
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig eth0 mtu <span class="number">1500</span></div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>ifconfig后面这些命令选项平常使用用得少，记得如何查看自己的ip地址是最关键。</p>
<h1>tcpdump命令</h1>
<hr>
<p>这个命令主要用于抓包，这也是我最喜欢的 命令之一，太强大了.当udp程序收到icmp不可达数据包时，用户程序是不会知道的，所以用tcpdump看到，因为tcpdump可以解析所有到大网络层的数据包，包括icmp，arp等等。当然还有udp,tcp。</p>
<ol>
<li>默认启动
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">tcpdump</span></div></pre></td></tr></table></figure></li>
</ol>
<p>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。</p>
<ol start="2">
<li>监视指定网络接口的数据包
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tcpdump -i lo</div><div class="line">charles@charles-Lenovo:~/mydir/mycode$ sudo tcpdump -i lo </div><div class="line">tcpdump: verbose output suppressed, <span class="keyword">use</span> -v <span class="keyword">or</span> -vv <span class="keyword">for</span> <span class="keyword">full</span> protocol <span class="keyword">decode</span></div><div class="line">listening <span class="keyword">on</span> lo, <span class="keyword">link</span>-<span class="keyword">type</span> EN10MB (Ethernet), capture <span class="keyword">size</span> <span class="number">65535</span> <span class="keyword">bytes</span></div><div class="line"><span class="number">11</span>:<span class="number">16</span>:<span class="number">16.541533</span> IP localhost<span class="number">.44530</span> &gt; localhost<span class="number">.8888</span>: UDP, <span class="keyword">length</span> <span class="number">6</span></div><div class="line"><span class="number">11</span>:<span class="number">16</span>:<span class="number">16.541558</span> IP localhost &gt; localhost: ICMP localhost udp port <span class="number">8888</span> unreachable, <span class="keyword">length</span> <span class="number">42</span></div></pre></td></tr></table></figure></li>
</ol>
<p>这是我当初在线测试connect函数时写的程序，不开启服务器，开启客户端，然后输入数据，之后服务器会返回不可达的ICMP包文消息。默认监听eth0，我们可以指定tcpdump监听回环接口。</p>
<ol start="3">
<li>
<p>指定监听tcp或者udp
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">tcpdump tcp</span></div><div class="line">tcpdump udp</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>指定监听的主机，可以是主机名或者ip
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">tcpdump</span> <span class="selector-tag">host</span> <span class="selector-tag">Charles</span></div><div class="line"><span class="selector-tag">tcpdump</span> <span class="selector-tag">host</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.151</span></div></pre></td></tr></table></figure></p>
</li>
<li>
<p>指定监听的端口
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">tcpdump</span> <span class="keyword">port</span> 8888</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>截获主机hostname发送或接收的所有消息
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">截获主机hostname发送的所有数据</div><div class="line">tcpdump -<span class="selector-tag">i</span> eth0 src host hostname</div><div class="line">监视所有送到主机hostname的数据包</div><div class="line">tcpdump -<span class="selector-tag">i</span> eth0 dst host hostname</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>监视指定主机和端口的数据包
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">如果想要获取主机<span class="number">210.27</span><span class="number">.48</span><span class="number">.1</span>接收或发出的telnet包，使用如下命令</div><div class="line">tcpdump tcp port <span class="number">23</span> and host <span class="number">210.27</span><span class="number">.48</span><span class="number">.1</span></div><div class="line">对本机的udp <span class="number">123</span> 端口进行监视 <span class="number">123</span> 为ntp的服务端口</div><div class="line">tcpdump udp port <span class="number">123</span></div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>初学阶段先了解这么多，就够了。后面有需要，在深入学习。</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> network </tag>
            
            <tag> netstat </tag>
            
            <tag> trace </tag>
            
            <tag> tcpdump </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[域名解析之dig,host,nslookup命令]]></title>
      <url>http://luodw.cc/2015/12/27/dns03/</url>
      <content type="html"><![CDATA[<p>上篇博客稍微介绍了域名服务器和和getaddrinfo等函数,这篇文章想好好总结下关于域名解析命令的使用,主要有以下三个命令:dig,host和nslookup。这三个命令主要是用于本地域名查询。原理就是当调用这个三个命令时，内核会向本地域名服务器查询，即dnsmasq这个守护进程。当dnsmasq有缓存所需要查询的域名时，直接返回，如果没有，则递归向外界的域名服务器查询。</p>
<h1>dig命令</h1>
<hr>
<p>dig命令的使用方法很简单,主要就是dig +域名.</p>
<ol>
<li>dig baidu.com即可输出baidu.com这个域名的ip地址,所在的域名服务器以及域名服务器的地址;如下;
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">:charles@charles-Lenovo:~/mydir/Hexo/source/_posts$ dig baidu.com</div><div class="line"></div><div class="line"><span class="comment">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.6-Ubuntu &lt;&lt;&gt;&gt; baidu.com</span></div><div class="line">dig这个程序的版本号和要查询的域名</div><div class="line"><span class="comment">;; global options: +cmd</span></div><div class="line">表示可以在命令后面加选项</div><div class="line"><span class="comment">;; Got answer:</span></div><div class="line">以下是获取信息的内容</div><div class="line"><span class="comment">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 60954</span></div><div class="line"><span class="comment">;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 5, ADDITIONAL: 6</span></div><div class="line">这个是返回信息的头部:</div><div class="line">opcode: 操作码,QUERY,代表是查询操作<span class="comment">;</span></div><div class="line">status: 状态,NOERROR,代表没有错误<span class="comment">;</span></div><div class="line">id: 编号,<span class="number">60954</span>,<span class="number">16</span>bit数字,在dns协议中,通过编号匹配返回和查询.</div><div class="line">flags: 标志,如果出现就表示有标志,如果不出现,就表示为设置标志:</div><div class="line">qr query,查询标志,代表是查询操作</div><div class="line">rd recursion desired,代表希望进行递归查询操作<span class="comment">;</span></div><div class="line">ra recursive available在返回中设置,代表查询的服务器支持递归查询操作<span class="comment">;</span></div><div class="line">aa Authoritative Answer权威回复,如果查询结果由管理域名的域名服务器而不是缓存服务器提供的,则</div><div class="line">称为权威回复<span class="comment">;</span></div><div class="line">QUERY 查询数,<span class="number">1</span>代表一个查询,对应下面QUESTION SECTION的记录数</div><div class="line">ANSWER 结果数,<span class="number">4</span>代表有<span class="number">4</span>个结果,对应下面的ANSWER SECTION中的记录数</div><div class="line">AUTHORITY 权威域名服务器记录数，<span class="number">5</span>代表该域名有<span class="number">5</span>个权威域名服务器，可供域名解析用。对应</div><div class="line">下面AUTHORITY SECTION</div><div class="line">ADDITIONAL 格外记录数，<span class="number">6</span>代表有<span class="number">6</span>项格外记录。对应下面 ADDITIONAL SECTION。</div><div class="line"><span class="comment">;; OPT PSEUDOSECTION:</span></div><div class="line"><span class="comment">; EDNS: version: 0, flags:; udp: 4096</span></div><div class="line">这个不知道啥意思</div><div class="line"><span class="comment">;; QUESTION SECTION:</span></div><div class="line"><span class="comment">;baidu.com.			IN	A</span></div><div class="line">查询部分,从做到右部分意义如下:</div><div class="line"><span class="number">1</span>、要查询的域名，这里是baidu.com.，'.'代表根域名，com顶级域名，baidu二级域名</div><div class="line"><span class="number">2</span>、class，要查询信息的类别，<span class="keyword">IN</span>代表类别为IP协议，即Internet。还有其它类别，比如chaos等，由于</div><div class="line">现在都是互联网，所以其它基本不用。</div><div class="line"><span class="number">3</span>、type，要查询的记录类型，<span class="keyword">A</span>记录(Address)，代表要查询ipv4地址。<span class="keyword">AAAA</span>记录，代表要查询ipv6地址。</div><div class="line"><span class="comment">;; ANSWER SECTION:</span></div><div class="line">baidu.com.		<span class="number">211</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">123.125.114.144</span></div><div class="line">baidu.com.		<span class="number">211</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">111.13.101.208</span></div><div class="line">baidu.com.		<span class="number">211</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">220.181.57.217</span></div><div class="line">baidu.com.		<span class="number">211</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">180.149.132.47</span></div><div class="line">回应部分，回应都是<span class="keyword">A</span>记录，<span class="keyword">A</span>记录从左到右各部分意义：</div><div class="line"><span class="number">1</span>、对应的域名，这里是baidu.com.，'.'代表根域名，com顶级域名，baidu二级域名</div><div class="line"><span class="number">2</span>、TTL，time ro live，缓存时间，单位秒。<span class="number">76</span>，代表缓存域名服务器，可以在缓存中保存<span class="number">76</span>秒该记录。</div><div class="line"><span class="number">3</span>、class，要查询信息的类别，<span class="keyword">IN</span>代表类别为IP协议，即Internet。还有其它类别，比如chaos等由于现在都是互联网，所以其它基本不用。</div><div class="line"><span class="number">4</span>、type，要查询的记录类型，<span class="keyword">A</span>记录，代表要查询ipv4地址。<span class="keyword">AAAA</span>记录，代表要查询ipv6地址。</div><div class="line"><span class="number">5</span>、域名对应的ip地址。</div><div class="line"></div><div class="line"><span class="comment">;; AUTHORITY SECTION:</span></div><div class="line">baidu.com.		<span class="number">52340</span>	<span class="keyword">IN</span>	<span class="keyword">NS</span>	dns.baidu.com.</div><div class="line">baidu.com.		<span class="number">52340</span>	<span class="keyword">IN</span>	<span class="keyword">NS</span>	ns3.baidu.com.</div><div class="line">baidu.com.		<span class="number">52340</span>	<span class="keyword">IN</span>	<span class="keyword">NS</span>	ns2.baidu.com.</div><div class="line">baidu.com.		<span class="number">52340</span>	<span class="keyword">IN</span>	<span class="keyword">NS</span>	ns7.baidu.com.</div><div class="line">baidu.com.		<span class="number">52340</span>	<span class="keyword">IN</span>	<span class="keyword">NS</span>	ns4.baidu.com.</div><div class="line">权威域名部分，回应都是<span class="keyword">NS</span>记录(Name Server)，<span class="keyword">NS</span>记录从左到右各部分意义：</div><div class="line"><span class="number">1</span>、对应的域名，这里是baidu.com.，'.'代表根域名，com顶级域名，baidu二级域名</div><div class="line"><span class="number">2</span>、TTL，time ro live，缓存时间，单位秒。<span class="number">63948</span>，代表缓存域名服务器，可以在缓存中保存<span class="number">63948</span>秒</div><div class="line">该记录。</div><div class="line"><span class="number">3</span>、class，要查询信息的类别，<span class="keyword">IN</span>代表类别为IP协议，即Internet。还有其它类别，比如chaos等，由于</div><div class="line">现在都是互联网，所以其它基本不用。</div><div class="line"><span class="number">4</span>、type，要查询的记录类型，<span class="keyword">NS</span>，Name Server，<span class="keyword">NS</span>记录，代表该记录描述了域名对应的权威域名</div><div class="line">解析服务器</div><div class="line"><span class="number">5</span>、域名对应域名对应的权威域名解析服务器。由于ns2.baidu.com.是baidu.com.的子域名，而解析子</div><div class="line">域名，又需要主域名的信息，为了打破这个死循环，需要在下面的额外记录中提供该服务器的ip地址。</div><div class="line"></div><div class="line"><span class="comment">;; ADDITIONAL SECTION:</span></div><div class="line">dns.baidu.com.		<span class="number">55285</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">202.108.22.220</span></div><div class="line">ns2.baidu.com.		<span class="number">60825</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">61.135.165.235</span></div><div class="line">ns3.baidu.com.		<span class="number">79196</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">220.181.37.10</span></div><div class="line">ns4.baidu.com.		<span class="number">79196</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">220.181.38.10</span></div><div class="line">ns7.baidu.com.		<span class="number">55194</span>	<span class="keyword">IN</span>	<span class="keyword">A</span>	<span class="number">119.75.219.82</span></div><div class="line">额外记录部分，这里都是<span class="keyword">A</span>记录，<span class="keyword">A</span>记录从左到右各部分意义：</div><div class="line"><span class="number">1</span>、对应的域名，这里是dns.baidu.com.，'.'代表根域名，com顶级域名，baidu二级域名，dns是三级域名。</div><div class="line"><span class="number">2</span>、TTL，time ro live，缓存时间，单位秒。<span class="number">13284</span>，代表缓存域名服务器可以在缓存中保存<span class="number">13284</span>秒该记录。</div><div class="line"><span class="number">3</span>、class，要查询信息的类别，<span class="keyword">IN</span>代表类别为IP协议，即Internet。还有其它类别，比如chaos等，由于</div><div class="line">现在都是互联网，所以其它基本不用。</div><div class="line"><span class="number">4</span>、type，要查询的记录类型，<span class="keyword">A</span>记录，代表要查询ipv4地址。<span class="keyword">AAAA</span>记录，代表要查询ipv6地址。</div><div class="line"><span class="number">5</span>、域名对应的ip地址。</div><div class="line"></div><div class="line"><span class="comment">;; Query time: 2 msec</span></div><div class="line">查询耗时</div><div class="line"><span class="comment">;; SERVER: 127.0.1.1#53(127.0.1.1)</span></div><div class="line">查询使用的服务器地址和端口,其实就是本地DNS域名服务器</div><div class="line"><span class="comment">;; WHEN: Sun Dec 27 19:27:16 CST 2015</span></div><div class="line">查询的时间</div><div class="line"><span class="comment">;; MSG SIZE  rcvd: 272</span></div><div class="line">回应的大小。收到(rcve, recieved)<span class="number">256</span>字节。</div></pre></td></tr></table></figure></li>
</ol>
<p>从以上dig结果中熟悉了2种DNS记录,A记录和NS记录.了解了dig的收到消息的各部分意义之后,接下来就可以看看dig命令的一些其他用法.</p>
<ol start="2">
<li>
<p>dig baidu.com
这个默认就是查询A记录,由以上可知,还有NS记录</p>
</li>
<li>
<p>dig baidu.com ns
这个是只查询NS记录,输出和dig baidu.com几乎一样,除了没有baidu.com的A记录.</p>
</li>
<li>
<p>dig baidu.com soa
查询SOA记录,SOA资源记录表明,此DNS服务器是为该DNS域中的数据的信息的最佳来源,这个命令的输出,比dig baidu.com ns命令多出一行,表示最佳的DNS域名服务器:
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; ANSWER SECTION:</span></div><div class="line">baidu.com.		<span class="number">7200</span>	<span class="keyword">IN</span>	<span class="keyword">SOA</span>	dns.baidu.com. sa.baidu.com. <span class="number">2012128552</span> <span class="number">300</span> </div><div class="line"><span class="number">300</span> <span class="number">2592000</span> <span class="number">7200</span></div><div class="line">各项意义如下:</div><div class="line"><span class="number">1</span>、<span class="keyword">SOA</span> <span class="keyword">SOA</span>记录</div><div class="line"><span class="number">2</span>、dns.baidu.com.  Nameserver，该域名解析使用的服务器</div><div class="line"><span class="number">3</span>、dns.baidu.com  Email address，该域名管理者的电子邮件地址，第一个'.'代表电子邮件中的'@'，</div><div class="line">所以对应的邮件地址为:sa@baidu.com</div><div class="line"><span class="number">4、2012128552</span> Serial number，反映域名信息变化的序列号。每次域名信息变化该项数值需要增大。</div><div class="line">格式没有要求，但一般习惯使用YYYYMMDDnn的格式，表示在某年(YYYY)、月(MM)、日(DD)进行了第几</div><div class="line">次(nn)修改。</div><div class="line"><span class="number">5</span>、<span class="number">300</span> Refresh，备用DNS服务器隔一定时间会查询主DNS服务器中的序列号是否增加，即域文件是否有</div><div class="line">变化。这项内容就代表这个间隔的时间，单位为秒。</div><div class="line"><span class="number">6</span>、<span class="number">300</span> Retry，这项内容表示如果备用服务器无法连上主服务器，过多久再重试，单位为秒。通常小于</div><div class="line">刷新时间。</div><div class="line"><span class="number">7、2592000</span> Expiry，当备用DNS服务器无法联系上主DNS服务器时，备用DNS服务器可以在多长时间内</div><div class="line">认为其缓存是有效的，并供用户查询。单位为秒。<span class="number">1209600</span>秒为<span class="number">2</span>周。</div><div class="line"><span class="number">8</span>、<span class="number">7200</span> Minimum，缓存DNS服务器可以缓存记录多长时间，单位为秒。这个时间比较重要，太短会增加主</div><div class="line">DNS服务器负载。如果太长，在域名信息改变时，需要更长的时间才能各地的缓存DNS服务器才能得到变化</div><div class="line">信息。</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>dig baidu.com mx
查询mx记录,表示发送到此域名的邮件将被解析到的服务器IP地址.</p>
</li>
<li>
<p>dig baidu.com +trace
这个很有用,可以看到dig程序是怎么一步一步的解析出域名的IP地址.原理就是DNS递归查询.先从本地域名服务器获取所有的&quot;.&quot;根域名服务器,然后从某个根域名服务器获取所有一级域名com服务器,接着从某个一级域名com服务器获取所有的二级域名baidu.com的所有域名服务器,最后从某个二级域名baidu.com服务器获取所有的记录.就是A记录和NS记录.</p>
</li>
</ol>
<h1>nslookup命令</h1>
<hr>
<p>了解了dig命令获取的消息结构之后,nslookup会好理解的多.nslookup支持交互模式和非交互模式,进入交互模式有如下方法:</p>
<ol>
<li>直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。</li>
<li>是支持选定不同域名服务器的。需要设置第一个参数为“-”，然后第二个参数是设置要连接的域名服务器主机名或IP地址。例如可以设置本机为域名服务器nslookup - 127.0.0.1</li>
</ol>
<p>进入非交互模式,即一次性执行一次查询操作就结束,如果你直接在nslookup命令后加上所要查询的IP或主机名，那么就进入了非交互模式。当然，这个时候你也可以在第二个参数位置设置所要连接的域名服务器。</p>
<p>但我们平时一般是使用在交互模式之下,主要是因为强大,nslookup默认情况下是执行查找A记录,如下:
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~<span class="meta-keyword">/mydir/</span>Hexo<span class="meta-keyword">/source/</span>_posts$ nslookup </div><div class="line">&gt; baidu.com</div><div class="line"><span class="symbol">Server:</span>		<span class="number">127.0</span><span class="number">.1</span><span class="number">.1</span></div><div class="line"><span class="symbol">Address:</span>	<span class="number">127.0</span><span class="number">.1</span><span class="number">.1</span><span class="meta">#53</span></div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line"><span class="symbol">Name:</span>	baidu.com</div><div class="line"><span class="symbol">Address:</span> <span class="number">220.181</span><span class="number">.57</span><span class="number">.217</span></div><div class="line"><span class="symbol">Name:</span>	baidu.com</div><div class="line"><span class="symbol">Address:</span> <span class="number">123.125</span><span class="number">.114</span><span class="number">.144</span></div><div class="line"><span class="symbol">Name:</span>	baidu.com</div><div class="line"><span class="symbol">Address:</span> <span class="number">180.149</span><span class="number">.132</span><span class="number">.47</span></div><div class="line"><span class="symbol">Name:</span>	baidu.com</div><div class="line"><span class="symbol">Address:</span> <span class="number">111.13</span><span class="number">.101</span><span class="number">.208</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>如果要设置查找不同查询信息,可以用set type=ns,a,mx等等</p>
<p>查询ns信息:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt; set type=ns</div><div class="line">&gt; baidu<span class="selector-class">.com</span></div><div class="line">Server:		<span class="number">127.0</span>.<span class="number">1.1</span></div><div class="line">Address:	<span class="number">127.0</span>.<span class="number">1.1</span>#<span class="number">53</span></div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">baidu<span class="selector-class">.com</span>	nameserver = ns7<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span>	nameserver = dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span>	nameserver = ns3<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span>	nameserver = ns2<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span>	nameserver = ns4<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line"></div><div class="line">Authoritative answers can be found from:</div><div class="line">dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>	internet <span class="selector-tag">address</span> = <span class="number">202.108</span>.<span class="number">22.220</span></div><div class="line">ns2<span class="selector-class">.baidu</span><span class="selector-class">.com</span>	internet <span class="selector-tag">address</span> = <span class="number">61.135</span>.<span class="number">165.235</span></div><div class="line">ns3<span class="selector-class">.baidu</span><span class="selector-class">.com</span>	internet <span class="selector-tag">address</span> = <span class="number">220.181</span>.<span class="number">37.10</span></div><div class="line">ns4<span class="selector-class">.baidu</span><span class="selector-class">.com</span>	internet <span class="selector-tag">address</span> = <span class="number">220.181</span>.<span class="number">38.10</span></div><div class="line">ns7<span class="selector-class">.baidu</span><span class="selector-class">.com</span>	internet <span class="selector-tag">address</span> = <span class="number">119.75</span>.<span class="number">219.82</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>查询mx信息:set type=mx,输出比ns的输出多出mx的信息:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Non-authoritative answer:</div><div class="line">baidu<span class="selector-class">.com</span>	mail exchanger = <span class="number">20</span> mx1<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span>	mail exchanger = <span class="number">20</span> jpmx<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span>	mail exchanger = <span class="number">10</span> mx<span class="selector-class">.n</span><span class="selector-class">.shifen</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span>	mail exchanger = <span class="number">20</span> mx50<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div></pre></td></tr></table></figure></p>
<h1>host命令</h1>
<hr>
<p>host命令也很简单,默认输出只有A和MX记录:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~/mydir/Hexo/source/_posts$ host baidu<span class="selector-class">.com</span></div><div class="line">baidu<span class="selector-class">.com</span> has <span class="selector-tag">address</span> <span class="number">123.125</span>.<span class="number">114.144</span></div><div class="line">baidu<span class="selector-class">.com</span> has <span class="selector-tag">address</span> <span class="number">111.13</span>.<span class="number">101.208</span></div><div class="line">baidu<span class="selector-class">.com</span> has <span class="selector-tag">address</span> <span class="number">220.181</span>.<span class="number">57.217</span></div><div class="line">baidu<span class="selector-class">.com</span> has <span class="selector-tag">address</span> <span class="number">180.149</span>.<span class="number">132.47</span></div><div class="line">baidu<span class="selector-class">.com</span> mail is handled by <span class="number">20</span> jpmx<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span> mail is handled by <span class="number">20</span> mx1<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span> mail is handled by <span class="number">10</span> mx<span class="selector-class">.n</span><span class="selector-class">.shifen</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span> mail is handled by <span class="number">20</span> mx50<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div></pre></td></tr></table></figure></p>
<p>如果想输出详细信息,即全部信息,可以用host -a baidu.com,输出和dig baidu.com一样,信息详细.</p>
<p>平常使用过程中使用最多的还是查询各种的消息记录,host查询各种消息类型用如下命令:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">host -t ns baidu<span class="selector-class">.com</span></div><div class="line">charles@charles-Lenovo:~/mydir/Hexo/source/_posts$ host -t ns  baidu<span class="selector-class">.com</span></div><div class="line">baidu<span class="selector-class">.com</span> name server ns7<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span> name server ns4<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span> name server ns3<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span> name server ns2<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div><div class="line">baidu<span class="selector-class">.com</span> name server dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>.</div></pre></td></tr></table></figure></p>
<p>还有一个查询SOA权威域名服务器的选项:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~/mydir/Hexo/source/_posts$ host -C  baidu<span class="selector-class">.com</span></div><div class="line">Nameserver <span class="number">220.181</span>.<span class="number">38.10</span>:</div><div class="line">	baidu<span class="selector-class">.com</span> has SOA record dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. sa<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. <span class="number">2012128552</span> <span class="number">300</span> <span class="number">300</span> <span class="number">2592000</span> <span class="number">7200</span></div><div class="line">Nameserver <span class="number">119.75</span>.<span class="number">219.82</span>:</div><div class="line">	baidu<span class="selector-class">.com</span> has SOA record dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. sa<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. <span class="number">2012128552</span> <span class="number">300</span> <span class="number">300</span> <span class="number">2592000</span> <span class="number">7200</span></div><div class="line">Nameserver <span class="number">202.108</span>.<span class="number">22.220</span>:</div><div class="line">	baidu<span class="selector-class">.com</span> has SOA record dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. sa<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. <span class="number">2012128552</span> <span class="number">300</span> <span class="number">300</span> <span class="number">2592000</span> <span class="number">7200</span></div><div class="line">Nameserver <span class="number">61.135</span>.<span class="number">165.235</span>:</div><div class="line">	baidu<span class="selector-class">.com</span> has SOA record dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. sa<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. <span class="number">2012128552</span> <span class="number">300</span> <span class="number">300</span> <span class="number">2592000</span> <span class="number">7200</span></div><div class="line">Nameserver <span class="number">220.181</span>.<span class="number">37.10</span>:</div><div class="line">	baidu<span class="selector-class">.com</span> has SOA record dns<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. sa<span class="selector-class">.baidu</span><span class="selector-class">.com</span>. <span class="number">2012128552</span> <span class="number">300</span> <span class="number">300</span> <span class="number">2592000</span> <span class="number">7200</span></div></pre></td></tr></table></figure></p>
<p>学习这三个命令,初级阶段主要了解了解基本用法即可,即查询域名的A,AAAA,NS,MX,PTR,SOA记录等等即可．</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从getaddinfo谈谈域名服务器]]></title>
      <url>http://luodw.cc/2015/12/27/dns02/</url>
      <content type="html"><![CDATA[<p>最近在看<strong>UNIX网络编程</strong>第十一章名字与地址转换,之前在环境编程也有看到这章提到的函数,但是似懂非懂,而且压根不知道为什么建立服务器不直接用sockt直接绑定到一个struct sockaddr,而是用getaddrinfo获取服务器的ip,然后一个一个绑定监听.看了这章之后,我就像打通了任督二脉,知识之间连在一起了.</p>
<p>其实gethostbyname和getaddrinfo这些函数没啥好说的,因为书本上都有,自己去好好看书,好好理解足矣.这里我要总结的是关于这两个函数之后的东西:域名解析.</p>
<h1>域名服务器</h1>
<hr>
<p>有点计算机常识的都知道,当我们访问一个网站的时候,需要先到域名服务器获取这个域名的IP地址,然后在向这个IP地址(通常是一个服务器的地址)获取网页.这里我先谈谈这个域名服务器,可以先看这个网址<a href="http://www.cnblogs.com/cobbliu/archive/2013/04/02/2996333.htm" target="_blank" rel="external">DNS消息格式</a>,了解DNS域名服务器的消息格式,至少要知道以下几个:</p>
<ol>
<li>
<p>A  A记录是把一个主机名映射成一个32位的IPv4地址,书本上有个例子,表示freebsd这个主机对应的IPv4地址为12.106.32.254
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">freebsd</span> <span class="selector-tag">IN</span> <span class="selector-tag">A</span>      12<span class="selector-class">.106</span><span class="selector-class">.32</span><span class="selector-class">.254</span></div><div class="line">	<span class="selector-tag">IN</span> <span class="selector-tag">AAAA</span>   3<span class="selector-tag">ffe</span><span class="selector-pseudo">:b80</span><span class="selector-pseudo">:1f8d</span><span class="selector-pseudo">:1</span><span class="selector-pseudo">:a00</span><span class="selector-pseudo">:20ff</span><span class="selector-pseudo">:fea7</span><span class="selector-pseudo">:686b</span></div><div class="line">	<span class="selector-tag">IN</span> <span class="selector-tag">MAX</span>    5  <span class="selector-tag">freebsd</span><span class="selector-class">.unpbook</span><span class="selector-class">.com</span></div><div class="line">	<span class="selector-tag">IN</span> <span class="selector-tag">MAX</span>    10 <span class="selector-tag">mailhost</span><span class="selector-class">.unpbook</span><span class="selector-class">.com</span></div></pre></td></tr></table></figure></p>
</li>
<li>
<p>AAAA  称为&quot;四A&quot;,AAAA记录是把一个主机名映射称一个128位的IPv6地址.</p>
</li>
<li>
<p>PTR   称为&quot;指针记录&quot;,表示把IP地址映射成主机名对于IPv4地址,32位地址的4个字节先反转顺序,每个字节都转换成各自的十进制ASCLL值(0~255)后,再天使in-addr.arpa.结果字符串用于PTR查询.对于IPv6地址,128位地址中的32个四位组反转顺序,每个四位组都被转换成相应的十六禁止的ASCII值(0~9,a~f)后再添上ip6.arpa.上例主机freebsd的两个PTR为:254.32.106.12.in-addr.arpa和b.6.8.6.7.a.e.f.f.f.0.2.2.0.0.a.0.1.0.0.0.d.8.f.1.0.8.b.0.e.f.f.3.ip6.arpa</p>
</li>
<li>
<p>MX  MX记录把一个主机指定作为给定主机的&quot;邮件交换器&quot;,例如，当Internet上的某用户要发一封信给 user@mydomain.com 时，该用户的邮件系统通过DNS查找mydomain.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。</p>
</li>
<li>
<p>CNAME  CNAME代表&quot;canonical name&quot;(规范名字),它的常见用法就是为常见的服务(如ftp和www)指派CNAME记录,其实就是别名.例如一台linux的主机有以下两个CNAME记录:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ftp  IN  CNAME  linux<span class="selector-class">.unpbook</span><span class="selector-class">.com</span></div><div class="line">www  IN  CNAME  linux<span class="selector-class">.unpbook</span><span class="selector-class">.com</span></div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>那么当查询主机名ftp或者www的ip地址,会直接获取linux.unpbook.com的A记录</p>
<h1>dnsmasq守护进程</h1>
<hr>
<p>书本提到gethostbyname,gethostbyaddr和getaddrinfo三个函数无非就是在内核执行了一次域名解析过程,解析过程如下:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_051.png" alt="客户,解析器和域名服务器的关系">
图中解析器代码就是指上述提到的三个函数内核执行的代码.当调用gethostbyname函数时,在内执行这段代码时,会先到配置文件/etc/resolv.conf文件查到本地的dns服务器ip地址,然后向本地dns服务器建立udp请求信息,获取信息.</p>
<p>ubuntu默认的本地dns服务器地址是127.0.1.1,也就是本地的dnsmasq守护进程,即服务.我们可以打开/etc/resolv.conf文件,内容如下:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Dynamic resolv.<span class="keyword">conf</span>(5) <span class="keyword">file</span> <span class="keyword">for</span> glibc resolver(3) generated <span class="keyword">by</span> resolvconf(8)</div><div class="line">#     <span class="keyword">DO</span> NOT <span class="keyword">EDIT</span> THIS <span class="keyword">FILE</span> <span class="keyword">BY</span> HAND -- YOUR CHANGES WILL BE OVERWRITTEN</div><div class="line">nameserver 127.0.1.1</div></pre></td></tr></table></figure></p>
<p>127.0.1.1也是一个本地回环地址,而dnsmasq进程监听的正是这个地址以及53端口号.我们也可以配置其他计算机为本地DNS域名服务器.</p>
<p>可以通过ps -ef | grep dnsmasq来查看这个进程:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ~  ps -ef | grep dnsmasq</div><div class="line">nobody    1134   867  0 15:22 ?        00:00:00 /usr/sbin/dnsmasq --<span class="keyword">no</span>-resolv --<span class="keyword">keep</span>-<span class="keyword">in</span>-foreground --<span class="keyword">no</span>-hosts --bind-interfaces --pid-<span class="keyword">file</span>=/<span class="keyword">run</span>/sendsigs.omit.<span class="keyword">d</span>/network-manager.dnsmasq.pid --listen-address=127.0.1.1 --<span class="keyword">conf</span>-<span class="keyword">file</span>=/<span class="keyword">var</span>/<span class="keyword">run</span>/NetworkManager/dnsmasq.<span class="keyword">conf</span> --cache-size=0 --proxy-dnssec --enable-dbus=org.freedesktop.NetworkManager.dnsmasq --<span class="keyword">conf</span>-<span class="keyword">dir</span>=/etc/NetworkManager/dnsmasq.<span class="built_in">d</span></div><div class="line">charles  28729  2728  0 17:32 pts/12   00:00:00 grep --color=auto --exclude-<span class="keyword">dir</span>=.bzr --exclude-<span class="keyword">dir</span>=CVS --exclude-<span class="keyword">dir</span>=.git --exclude-<span class="keyword">dir</span>=.hg --exclude-<span class="keyword">dir</span>=.svn dnsmasq</div></pre></td></tr></table></figure></p>
<p>所以gethostbyname,gethostbyaddr和getaddrinfo这三个函数执行原理就是在内核通过udp向dnsmasq查询地址,如果dnsmasq没有相关的ip地址,那么dnsmasq会向其他域名服务器查询,最后返回到本地域名服务器缓存中.</p>
<p>gethostbyname主要是获取A记录,所以只能返回IPv4地址
gethostbyaddr主要是在in_addr.arpa域中向一个域名服务器查询PTR记录.
getaddrinfo函数很强大,最新的程序几乎都用这个函数,因为</p>
<ol>
<li>他既可以查询IPv4地址,也可以查询IPv6地址.</li>
<li>当在建立服务器时,用这个函数可以获取服务器的所有ip地址(包括tcp和udp以及raw),监听所有接口.很多服务器是多宿的,即有很多网络接口,支持多个ip地址.</li>
<li>当客户端要连接这个服务器时,可以调用获取这个服务器的所有tcp地址,然后一个一个connect,当在某个ip地址成功之后,就停止connect.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> dns </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[空洞文件的作用]]></title>
      <url>http://luodw.cc/2015/12/27/emptyfile/</url>
      <content type="html"><![CDATA[<p>今天被一个学弟提问空洞文件有什么用?我第一反应是没啥用,当初在学习这个时,根本也想不出空洞文件的作用后来通过查资料,发现空洞文件还是挺有用的,我对空洞文件的认知就刷新了.</p>
<h1>空洞文件作用一</h1>
<hr>
<p>在共享内存的时候有用到.共享内存的机制是两个进程都调用mmap函数,然后将同一个文件fd映射到各自虚拟内存中,虽然这两个进程有各自的映射内存,但是这两个虚拟内存对应的是同一块物理内存,这才实现了共享内存.</p>
<p>当两个文件需要共享内存时,由于不知道需要共享内存的大小,所以需要在文件创建好之后来设置文件的大小.这时就需要用到空洞文件了.一开始文件的大小为0,如果要设置文件的大小为filesize,那么这时就可以调用lseek函数来设置
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lseek(<span class="name">fd</span>,filesize-1,SEEK_SET)</div><div class="line">write(<span class="name">fd</span>,<span class="string">""</span>,<span class="number">1</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>先调用lseek定位到最后一个字符,然后写一个空字符,这时[0,filesize-2]范围内都是0,这就是一个空洞文件,文件大小为filesize.</p>
<h1>空洞文件作用二</h1>
<hr>
<p>还有我们在用迅雷下载文件时,还未下载完成时,就已经占据了全部文件大小的空间,这也是空洞文件爱你.下载时如果没有空洞文件,多线程下载时文件就只能从一个地方写入,这就不能发挥多线程的作用了.如果有了空洞文件,可以从不同的地址写入,就完成了多线程的优势.</p>
<p>在开发过程中有时候需要为某个文件迅速地分配固定大小的磁盘空间</p>
<ol>
<li>可以让文件尽可能的占用连续的磁盘扇区,减少后续写入和读取文件时的磁盘寻道开销;</li>
<li>迅速占用磁盘空间,防止使用过程中所需要空间不足;</li>
<li>后面追加数据的话,不会需要改变文件大小,所以后面将部设计metadata的修改.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux网络编程udp学习读书笔记]]></title>
      <url>http://luodw.cc/2015/12/18/socket02/</url>
      <content type="html"><![CDATA[<p>linux下网络编程主要就是tcp/udp协议,虽然还有个sctp,但是用的并不多,所以这里就先不写了.tcp为面向连接,可靠传输协议,为了实现可靠,指定了一些重要的机制,例如三次握手,拥塞控制,发送确认机制等等.而udp是无连接不可靠传输协议,所以对于udp而言,服务器和客户端并没有连接的概念,而是二者之间的读写就是一次性结束.先来看下udp传输模型.</p>
<h1>udp传输模型</h1>
<hr>
<p>udp传输模型如下图所示,图来自<strong>UNIX网络编程卷1:套接字联网API</strong>,
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_048.png" alt="udp传输模型">
如图所示,对于服务器端,由以下步骤:</p>
<ol>
<li>调用socket函数获得套接字Serverfd;</li>
<li>调用bind函数绑定服务器端本地地址和端口,一般情况下绑定地址为ANY_INADDR,即绑定到所有地址,如果是多宿主服务器,则有ip1,ip2,...,127.0.0.1个ip地址.</li>
<li>调用recvfrom函数并阻塞等待用户数据到达.</li>
<li>处理客户端的数据,并调用sendto函数返回给用户.</li>
</ol>
<p>对于udp客户端而言,主要有以下几个步骤:</p>
<ol>
<li>调用socket获得套接字Clientfd;</li>
<li>调用sendto向服务器端发送数据;</li>
<li>调用recvfrom阻塞等待服务端返回的数据;</li>
<li>调用close关闭这个Clientfd套接字;</li>
</ol>
<p>由于udp面向无连接,所以每次发送数据都要指定目的地的ip地址和端口,所以必须调用sendto函数.</p>
<p>当客户端向服务器发送一个数据报,然后数据报在网络中迷路走丢了,这时客户端就会一直阻塞在recvfrom上,永远阻塞;但是服务器是有给客户端回应的,只是没有传到用户态.我们可以通过tcpdump查看,服务给客户端发送了ICMP报文,如下:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_049.png" alt="ICMP报文">;
这个也叫异步错误,因为这错误是sendto犯下,却在recvfrom收到ICMP报文.</p>
<p>tcp服务器是并发服务器,udp是迭代服务器,之所以为迭代服务器,是因为udp服务器只有一个udp套接字,然后这个套接字有个缓冲区,任何客户端发送给这个套接字的数据都缓存在那个缓冲区,然后用户进程以FIFO从缓存区读取数据报.</p>
<p>如果udp客户端是多宿的,那么如果客户端没有绑定到哪个具体的ip地址,则端口是由第一次sendto时确定的临时端口,而且之后不变,这原因应该就是一个进程确定一个端口.然后ip地址会随着每次发送数据报而变化.这种变化主要是查找路由时决定的.</p>
<h1>udp调用connect函数</h1>
<hr>
<p>udp编程主要两种模式,一种是不调用connect,一种是调用connect函数.当调用connect函数之后,这时udp就分为如下两种:</p>
<ol>
<li>未连接UDP套接字,新创建的UDP套接字默认如此;</li>
<li>已连接UDP套接字,对UDP套接字调用connect函数的结果;</li>
</ol>
<p>已连接的套接字比未连接的套接字,发生了三个变化:</p>
<ol>
<li>
<p>我们没必要在输出函数上指定ip地址和端口.即我们不用sendto,而是改用write或send,写到套接字上的任何内容都发送到connect指定的协议地址.注意:sendto也是可以用的.</p>
</li>
<li>
<p>我们没必要调用recvfrom函数以获得数据报的发送者,而改用read,recv或recvmsg;这样这个ip地址只接收connect地址中的数据报,即这个udp套接字仅仅与一个ip地址交换数据报.</p>
</li>
<li>
<p>已连接UDP套接字引发的异步错误会返回给它们所在的进程,而未连接udp套接字不会接收任何异步错误,这个后面例子程序有说明.</p>
</li>
</ol>
<p>如果给一个udp多次调用connect,则有两个作用:</p>
<ol>
<li>指定新的ip地址和端口号;</li>
<li>断开套接字;</li>
</ol>
<p>对于第一点,TCP是只能调用一次connect函数,而udp是可以多次的,这样就可以指定新的ip地址和端口号;</p>
<p>对于第二点,如果想关闭套接字,需要将地址族改为AF_UNSPEC.</p>
<p>调用connect性能的影响:当没调用connect时,如果要发送两个数据报,则需要以下步骤:</p>
<ul>
<li>连接套接字;</li>
<li>输出第一个数据报;</li>
<li>断开套接字连接;</li>
<li>连接套接字;</li>
<li>输出第二个数据报;</li>
<li>断开套接字连接;</li>
</ul>
<p>其实当第二次发送数据时,因为ip地址已经在高速缓存中,所以第二次就没必要查找路由表了.</p>
<p>当调用connect函数之后,</p>
<ul>
<li>连接套接字,</li>
<li>输出第一个数据报;</li>
<li>输出第二个数据报;</li>
</ul>
<p>这种情况下,内核只复制一次含有目的地址的ip地址和端口号的套接字地址结构,而调用两次sendto时需要两次复制.</p>
<h1>我的测试程序</h1>
<hr>
<p>下面是我写的测试程序,客户端带connect函数,所以可以返回异步通知.服务器端如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">socklen_t</span> len;</div><div class="line">	<span class="keyword">char</span> mesg[MAXLINE],sendline[MAXLINE],strip[MAXLINE];</div><div class="line">	<span class="keyword">char</span> *ptr;</div><div class="line">	<span class="keyword">struct</span> sockaddr_in servaddr,cliaddr;</div><div class="line">	<span class="keyword">int</span> sockfd;</div><div class="line">	sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</div><div class="line">	<span class="keyword">if</span>(sockfd==<span class="number">-1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>,<span class="string">"socket  error!\n"</span> );</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line">	bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</div><div class="line">	servaddr.sin_family=AF_INET;</div><div class="line">	servaddr.sin_addr.s_addr=htonl(INADDR_ANY);</div><div class="line">	servaddr.sin_port=htons(<span class="number">8888</span>);</div><div class="line"></div><div class="line">	bind(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(;;)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">memset</span>(sendline,<span class="number">0</span>,<span class="keyword">sizeof</span>(sendline));</div><div class="line">		<span class="built_in">snprintf</span>(sendline, MAXLINE,<span class="string">"Come from the server:"</span>);</div><div class="line">		len=<span class="keyword">sizeof</span>(cliaddr);</div><div class="line">		n=recvfrom(sockfd,mesg,MAXLINE,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);</div><div class="line">		mesg[n]=<span class="string">'\0'</span>;</div><div class="line">		ptr=sendline+<span class="built_in">strlen</span>(sendline);</div><div class="line">		<span class="built_in">memcpy</span>(ptr,mesg,n+<span class="number">1</span>);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"receive from client %s ,port is %d  mesg  is %s"</span>,inet_ntop(AF_INET ,&amp;cliaddr.sin_addr,strip,len),ntohs(cliaddr.sin_port) ,mesg );</div><div class="line">		sendto(sockfd,sendline ,<span class="built_in">strlen</span>(sendline),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,len);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端程序如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">char</span> mesg[MAXLINE],readline[MAXLINE+<span class="number">1</span>];</div><div class="line">	<span class="keyword">struct</span> sockaddr_in cliaddr2;</div><div class="line">	<span class="keyword">int</span> sockfd;</div><div class="line">	sockfd=socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);</div><div class="line">	<span class="keyword">if</span>(sockfd==<span class="number">-1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>,<span class="string">"socket  error!\n"</span> );</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line">	bzero(&amp;cliaddr2,<span class="keyword">sizeof</span>(cliaddr2));</div><div class="line">	cliaddr2.sin_family=AF_INET;</div><div class="line">	inet_aton(argv[<span class="number">1</span>], &amp;cliaddr2.sin_addr);</div><div class="line">	cliaddr2.sin_port=htons(<span class="number">8888</span>);</div><div class="line">	connect(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr2,<span class="keyword">sizeof</span>(cliaddr2));</div><div class="line">	<span class="keyword">while</span>(fgets(mesg,MAXLINE,<span class="built_in">stdin</span>)!=<span class="literal">NULL</span>)</div><div class="line">	&#123;</div><div class="line">		write(sockfd,mesg,<span class="built_in">strlen</span>(mesg));</div><div class="line">		n=read(sockfd,readline,MAXLINE);</div><div class="line">		<span class="keyword">if</span>(n&lt;<span class="number">0</span>)</div><div class="line">		&#123;</div><div class="line">			perror(<span class="string">"read error"</span>);</div><div class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">		&#125;</div><div class="line">		readline[n]=<span class="string">'\0'</span>;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>,readline);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序输出如下:服务端
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  mycode  ./udpServer                 </div><div class="line">receive from client <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> ,port is <span class="number">54956</span>  mesg  is hello world!</div><div class="line">receive from client <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> ,port is <span class="number">54956</span>  mesg  is nice to meet you!</div></pre></td></tr></table></figure></p>
<p>客户端如下:
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  mycode  ./udpClient <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line">hello world!</div><div class="line">Come <span class="built_in">from</span> <span class="keyword">the</span> server:hello world!</div><div class="line">nice <span class="built_in">to</span> meet you!</div><div class="line">Come <span class="built_in">from</span> <span class="keyword">the</span> server:nice <span class="built_in">to</span> meet you!</div></pre></td></tr></table></figure></p>
<p>当服务器没开启时,这时客户端向服务器发送请求,recvfrom将返回一个错误:
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  mycode  ./udpClient <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line">see you again!</div><div class="line"><span class="built_in">read</span> <span class="keyword">error</span>: Connection refused</div><div class="line">➜  mycode</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> socket </category>
            
        </categories>
        
        
        <tags>
            
            <tag> socket </tag>
            
            <tag> udp </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux网络学习前五章读书笔记]]></title>
      <url>http://luodw.cc/2015/11/28/socket01/</url>
      <content type="html"><![CDATA[<p>linux系统最重要的两块知识:进程(线程)间的通信与同步和网络编程.之前暑期已看了一遍<strong>进程间的通信</strong>,从今天开始,打算好好看下<strong>网络编程</strong>.</p>
<p>因为已经看过<strong>unix环境高级编程</strong>和redis的源码,所以对网络编程的基础api大概都懂,但是对于原理性的东西,啥都不知道.所以打算看<strong>网络编程</strong>这本书,以及后期看libevent和memchached源码实现,巩固下所学知识.我看了前五章,发现这本书的知识正是我需要的,所以对一些知识点,做个总结.</p>
<h1>TCP连接的建立</h1>
<hr>
<p>两台计算机网络的建立,一定经过三次握手过程,先上示意图,来自<strong>网络编程卷1</strong>
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_041.png" alt="TCP连接建立和断开">
首先要说明的是,客户端通过建立socket并调用connect连接服务器为主动打开,而服务器通过调用socket,bind,listen准备客户连接为被动过程.</p>
<ol>
<li>首先服务器端通过调用socket,bind,listen监听服务器端的套接字,然后调用accept并阻塞在accept,等待客户连接.</li>
<li>客户端先调用socket创建套接字,然后阻塞在connect调用.这时内核将自动执行三次握手过程.当客户端向服务器端发送一个syn时，这时客户端处于SYN_SENT状态；当服务器收到客户发来的syn时，处于SYN_RECV状态，并返回ack和syn；</li>
<li>当客户端收到服务器端发来的syn和ack时,返回一个ack并从connect返回,表明已连上服务器.此时客户端为ESTABLISHED状态；</li>
<li>服务器端收到客户端的ack之后,从accept返回一个服务器套接字,这个套接字与客户端已建立连接,此时服务器处于ESTABLISHED状态，接着客户端一般情况下就阻塞在read调用.</li>
</ol>
<h1>TCP连接终止</h1>
<hr>
<p>四次挥手过程示意图如上．
对于连接终止过程，可以由客户端或服务器端任何一端先发起，先发起断开的一端为主动关闭，则另一端为被动关闭．假设由先客户发起</p>
<ol>
<li>客户端调用close关闭套接字时，内核会向服务器端发生一个fin分节，此时客户端处于FIN_WAIT_1状态；</li>
<li>服务器端收到客户端的fin分节之后，服务端反馈一个ack，并从read返回0字节，此时服务器处于CLOSE_WAIT；</li>
<li>当客户端收到服务器端返回的ack时，客户端处于FIN_WAIT_2状态；</li>
<li>当服务器端也调用close时，向客户发送一个fin，客户接收到fin之后，处于TIME_WAIT状态，等待2MSL，客户端就关闭了</li>
<li>服务器端收到收到客户端的ack之后，立即处于CLOSED状态，即关闭连接．</li>
</ol>
<p>服务器端在CLOSE_WAIT和LAST_ACK状态之间还是可以发送数据的,但是客户端都已调用close函数,接下来也不会对这个数据进行处理,所以没啥意义.</p>
<p>为什么主动关闭的那端会有TIME_WAIT状态了?</p>
<ol>
<li>可靠地实现TCP全双工连接的终止;</li>
<li>允许老的重复分节在网络中消逝.</li>
</ol>
<p>对于第一点,我们可以假设最后那个ack丢失的情况.当最后ack丢失之后,服务器端因为没有收到ack,所以必须重发fin,这就导致客户端必须重发ack.从客户端发第一个ack到重发ack刚好是两倍的包存活最长时间MSL.(一个是第一个ack存活时间,一个是重传的fin包)</p>
<p>对于第二点,有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。</p>
<h1>TCP基础知识</h1>
<hr>
<ol>
<li>MSS:MSS 最大分节大小.在数据链路层,有MTU这个概念,解释为某个信道最大的通信量.所以如果IP层,数据量太大的话,必须将ip包进行分片传输,然后在接收端进行包重组,这样以来,会影响到效率问题.所以linux内核就在TCP阶段,将传给IP层的数据限制在一定大小,防止分片.而TCP这个数据量的大小就是MSS,即TCP层最大传输数据段大小.这个大小一般等于MTU-20(IP包头)-20(TCP包头),这样就可以防止IP层分片了.</li>
</ol>
<ul>
<li>
<p>当在连接建立开始阶段,双方会互相发送各自MSS的大小,最后通过协商,选择二者较小的数值作为双方的MSS</p>
</li>
<li>
<p>当前以太网的MTU=1500,所以ipv4的MSS=1460,ipv6的MSS=1440(ipv6的首部为40字节).而在ipv4和ipv6都定义了最小重组缓冲区的大小,即ipv4和ipv6任何实现都必须保证支持的最小数据报的大小.ipv4最小重组缓冲区为576,ipv6为1500,这时的MSS分别为536和1440.</p>
</li>
</ul>
<ol start="2">
<li>
<p>ipv4首部有个&quot;不分片位(DF)&quot;,如果被设置了,则不管是主机还是路由器都不准对这个数据报分片,那么当传到数据链路层时,如果大于MTU,则会产生一个ICMP&quot;目的地不可达,需要分片但是DF位已设置&quot;的错误消息.</p>
</li>
<li>
<p>TCP分片还有一个窗口选项,用于向对端通知从ack序列号+1开始,还可以接收多少数据量.</p>
</li>
<li>
<p>TCP为了拥塞避免,设置了一个拥塞窗口,拥塞窗口的大小为此时可以发送的数据量,以tcp报文为单位,则可以用MSS的个数来表示可以发送的数据量.TCP用慢启动和快重传来避免网络拥塞.</p>
</li>
<li>
<p>判断系统大小端,可以用如下联合体来判断:
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">union</span> &#123;</span></div><div class="line">	short s;</div><div class="line">	char c[<span class="keyword">sizeof</span>(short)];</div><div class="line">&#125;un</div></pre></td></tr></table></figure></p>
</li>
</ol>
<h1>socket相关函数解释</h1>
<hr>
<h2>connect函数</h2>
<p>当客户端调用socket获取一个套接字时,即可调用connect连接服务器.在调用connect之前,其实是可以调用bind绑定本地ip地址和端口,但是没必要,因为内核会自己选择一个ip地址和临时端口.</p>
<p>当调用connect时,用户进程则会阻塞,内核则会触发三次握手过程,并且只有在建立成功或者出错时才返回,出错时,有以下情况:</p>
<ol>
<li>若TCP客户没有收到SYN分节的响应,则返回ETIMEDOUT错误.例如此时服务端还没开启时.</li>
<li>若对客户的SYN的响应是RST(表示复位),则表明该服务器主机在我们指定的端口没有进程在与之连接,返回ECONNREFUCED错误.</li>
</ol>
<p>RST是TCP发生错误时发送的一种TCP分节.产生RST的三个条件是:目的地的目的端口SYN到达,但却没有服务器监听这个端口;TCP想取消一个已有连接;TCP接收到一个根本不存在的连接上的分节.
3.若客户发出的SYN在中间某个路由器上引发了一个&quot;destination unreachable&quot;的ICMP错误,为软错误,则ICMP错误会作为EHOSTUNREACH或ENETUNREACH错误返回给进程.</p>
<p>对于错误原因的研究非常重要,因为在服务器出现问题时,可以分析错误的根源,便于快速定位到错误.</p>
<h2>bind函数</h2>
<p>bind函数用于将ip地址和端口绑定到一个套接字上,可以指定一个ip地址,或者指定一个端口,或者两个都指定,或者两个都不指定.</p>
<p>对于客户端而言,一般情况下不绑定ip地址和端口,调用connnect时,由内核选择.
对于服务端而言,我们可以设置ip地址和端口,有如下组合:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_042.png" alt="bind函数ip地址和端口设置组合"></p>
<p>ip地址的通配地址为INADDR_ANY,其值一般全为0,它告诉内核自己选择ip地址,一般就是回环地址127.0.0.1和本机局域网地址.</p>
<p>实际开发中,服务器端口肯定是固定的,用于客户端连接,ip地址可以用通配符的格式,这样即可以本机连接,也可以其他机子连接.</p>
<h2>listen函数</h2>
<p>通过看这本书,我对listen函数从只会调用,到理解内核原理跨越.当socket创建套接字时,它默认被设置为主动套接字,也就是说它是一个调用connect发起主动连接的客户套接字.listen函数将这个套接字转换为一个被动套接字,指示内核应该接受指向该套接字的连接请求.</p>
<p>listen函数的第二个参数是规定了内核应该为相应套接字排队的最大连接个数.内核为每个监听套接字维护两个队列:</p>
<ol>
<li>未完成连接队列 每个SYN分节对应其中一项:已由某个客户发出并达到服务器,而服务器正在等待完成相应的TCP三路握手过程,这些套接字处于SYN_RCVD状态.</li>
<li>已完成连接队列 每个已完成TCP三路握手过程的客户对应其中一项,这些套接字处于ESTABLISHED状态.</li>
</ol>
<p>下图描绘了监听套接字的两个队列:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_043.png" alt="TCP为套接字维护的两个队列"></p>
<p>当进程调用accept时,已完成队列的队头项将返回给进程;如果该队列为空,则进程将阻塞在accept函数中.</p>
<p>listen函数的第二参数backlog参数为这两个队列的总和的最大值或者增加一个模糊因子:乘以1.5,例如通常backlog设为5,所以最大套接字排队为1.5*5=8个.</p>
<p>在正常情况下(没有丢失,没有重传),未完成队列的每一项在其中的存活时间为RTT,如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_044.png" alt="分节RTT存活时间"></p>
<p>当一个客户SYN达到时,若队列是满的,TCP就忽略该分节,客户会重新发送SYN分节.因为这只是暂时的,很快队列就会腾出空位.如果一开始就返回一个RST错误,那么客户不知道这个RST是表示&quot;该端口没有服务器监听&quot;,还是意味着&quot;该端口有服务器在监听,不过他的队列满了&quot;.</p>
<p>在三次握手完成后,但在调用accept之前达到的数据应由服务器TCP排队,最大数据量为相应已连接套接字的接收缓冲区大小.</p>
<h2>accept函数</h2>
<p>accept函数由TCP服务器调用,用于从以完成连接队列对头返回下一个已完成的连接,如果队列为空,则阻塞.</p>
<p>accept后两个参数分别为客户端的地址以及该地址的大小,如果不感兴趣,可以同时设置为NULL.</p>
<h1>并发服务器</h1>
<hr>
<p>现在并发程序的设计框架无非就是单进程(IO多路复用),多进程和多线程,网络编程这本书一开始先介绍了多进程编程.</p>
<p>并发多进程的实现主要是通过fork来实现的.</p>
<p>在多进程编程时,还需要考虑一个问题,即子进程结束时,避免成为僵尸进程.避免僵尸进程有三种方法:</p>
<ol>
<li>调用wait或者waitpid函数来等待子进程结束,并回收资源</li>
<li>调用两次fork函数,即由父进程派生子进程,子进程派生孙进程,接着子进程结束.这样能避免僵尸进程主要原因是当子进程派生孙进程而结束时,子进程可以由父进程回收资源,然后孙进程由与子进程结束,就被过继给init进程,init进程会在孙进程结束时回收资源.</li>
<li>设置SIG_CHID处理函数为SIG_IGN
但是为了可移植性,在多进程程序中,避免僵尸进程的主要方法是在父进程捕获SIG_CHID信号,然后在处理函数中调用wait函数.</li>
</ol>
<p>在调用wait函数时,又出现了问题,这里就不介绍wait和waitpid函数的使用方法,主要讲下书本为什么调用waitpid而不是wait.</p>
<p>在处理函数中,如果调用wait函数时为
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pid=<span class="built_in">wait</span>(&amp;<span class="built_in">stat</span>);</div></pre></td></tr></table></figure></p>
<p>如果为waitpid函数时为:
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while( (<span class="name">pid=waitpid</span>(<span class="name">-1</span>,<span class="symbol">&amp;stat</span>,WNOHANG)) &gt; <span class="number">0</span>)</div><div class="line">    printf(<span class="string">"child %d terminated\n"</span>,pid)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>书中例子,在客户端产生了5个套接字连接服务器,这导致服务器产生5个进程来处理这5个客户端.当客户终止时,这时几乎同时产生5个FIN发到服务器,服务器对于第一个结束的子进程,此时服务器执行于SIG_CHID处理函数中,后面达到的SIG_CHID信号则排队,因为SIG_CHID是不可靠信号,是不会一个一个执行的,最终只会处理调用两次信号处理函数,说明还有三个僵尸进程为处理.</p>
<p>如果调用的是wait函数,就是上述描述的情况,会产生三个僵尸进程;</p>
<p>如果是调用waitpid函数,-1表示等待第一个结束的进程,WNOHANG告诉内核在没有已终止子进程时不要阻塞,所以对于同时产生的5个SIG_CHID信号,则可以调用一次信号处理函数,在while循环中把5个子进程资源都回收了.如果把while循环调用的是wait,也不行,因为没办法防止wait在正运行的子进程尚有未终止时阻塞.</p>
<p>如果信号是一个一个到达,也就是一个信号处理函数结束,再产生第二个SIG_CHID信号,上述两个都可以,但是对于同时产生信号而言,只能在while循环中调用waitpid函数.</p>
<p>:wq</p>
<p>未完待续...</p>
]]></content>
      
        <categories>
            
            <category> Socket </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STL分析之map和set]]></title>
      <url>http://luodw.cc/2015/11/19/STL-map/</url>
      <content type="html"><![CDATA[<p>之前分析二叉搜索树和平衡二叉树时，真心感觉树的实现真是难，特别是平衡二叉树，不平衡之后需要调整，还要考虑各种情况，累感不爱．今天看到这个红黑树，发现比平衡二叉树还难，但是红黑树比平衡二叉树使用的场景更多，所以平常使用时，我们需要了解红黑树的实现原理，如果有能力，可以自己实现，但是如果实在做不出来，也没关系，因为STL和linux内核都有现成的红黑树实现，拿来用即可，前提是了解红黑树原理．</p>
<h1>红黑树原理</h1>
<hr>
<p>红黑树和平衡二叉树一样，本质上都是二叉搜索树，但是二者的搜索效率都能实现平均效率logn，比二叉搜索树性能好．平衡二叉树实现原理是判断每个节点的左右子树的高度差是否等于2，如果等于2，则要通过旋转来实现树的左右子树高度差平衡．而红黑树实现原理是节点的颜色和旋转来实现的，实现较复杂，先看下红黑树的满足条件:</p>
<ol>
<li>每个结点要么是红的，要么是黑的。</li>
<li>根结点是黑的。</li>
<li>每个叶结点，即空结点（NIL）是黑的。</li>
<li>如果一个结点是红的，那么它的俩个儿子都是黑的。</li>
<li>对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。
如果某棵二叉搜索树满足上述条件，则为红黑树．为什么满足上述条件可以实现平衡了？主要是第４条和第５条，由第５条可以得出，某个到所有叶子节点最长路径是最短路径的两倍.即一条路径为一黑一红和一条路径为全黑,大体上红黑树是平衡的,只是没有AVL树要求那么严格.</li>
</ol>
<p>我不推荐直接看STL源码剖析这本书中的红黑树,而是先到网上博客先看看大家是怎么写,因为这本书STL实现的红黑树比较复杂,不好看懂.我推荐博客<a href="http://blog.chinaunix.net/uid-26575352-id-3061918.html" target="_blank" rel="external">michael</a>,因为这篇博客一步一步讲解很好,图做的也很好理解.</p>
<h1>红黑树节点和迭代器</h1>
<hr>
<p>红黑树节点和迭代器的设计和slist原理一样,将结构和数据分离.原理如下:
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</div><div class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</div><div class="line"></div><div class="line">  color_type color; 	<span class="comment">// 红黑树的颜色</span></div><div class="line">  base_ptr parent;  	<span class="comment">// 父节点</span></div><div class="line">  base_ptr left;	  	<span class="comment">// 指左节点</span></div><div class="line">  base_ptr right;   	<span class="comment">// 指向右节点</span></div><div class="line">&#125;</div><div class="line">template &lt;class Value&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node</span> : public __rb_tree_node_base</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</div><div class="line">  Value value_field;	<span class="comment">// 存储数据</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>红黑树的基础迭代器为struct __rb_tree_base_iterator,主要成员就是一个__rb_tree_node_base节点,指向树中某个节点,作为迭代器与树的连接关系,还有两个方法,用于将当前迭代器指向前一个节点decrement()和下一个节点increment().下面看下正式迭代器的源码:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr&gt;</div><div class="line"><span class="keyword">struct</span> __rb_tree_iterator : <span class="keyword">public</span> __rb_tree_base_iterator</div><div class="line">&#123;</div><div class="line">  <span class="keyword">typedef</span> Value value_type;</div><div class="line">  <span class="keyword">typedef</span> Ref reference;</div><div class="line">  <span class="keyword">typedef</span> Ptr pointer;</div><div class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;     iterator;</div><div class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="keyword">const</span> Value&amp;, <span class="keyword">const</span> Value*&gt; const_iterator;</div><div class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt;   self;</div><div class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</div><div class="line"></div><div class="line">  __rb_tree_iterator() &#123;&#125;<span class="comment">//迭代器默认构造函数</span></div><div class="line">  __rb_tree_iterator(link_type x) &#123; node = x; &#125;<span class="comment">//由一个节点来初始化迭代器</span></div><div class="line">  __rb_tree_iterator(<span class="keyword">const</span> iterator&amp; it) &#123; node = it.node; &#125;<span class="comment">//迭代器复制构造函数</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//迭代器解引用,即返回这个节点存储的数值</span></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> link_type(node)-&gt;value_field; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  <span class="comment">//返回这个节点数值值域的指针</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line">  <span class="comment">//迭代器++运算</span></div><div class="line">  self&amp; <span class="keyword">operator</span>++() &#123; increment(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</div><div class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</div><div class="line">    self tmp = *<span class="keyword">this</span>;</div><div class="line">    increment();</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//迭代器--运算</span></div><div class="line">  self&amp; <span class="keyword">operator</span>--() &#123; decrement(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</div><div class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</div><div class="line">    self tmp = *<span class="keyword">this</span>;</div><div class="line">    decrement();</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> __rb_tree_base_iterator&amp; x,</div><div class="line">                       <span class="keyword">const</span> __rb_tree_base_iterator&amp; y) &#123;</div><div class="line">  <span class="keyword">return</span> x.node == y.node;</div><div class="line">  <span class="comment">// 两个迭代器相等,指这两个迭代器指向的节点相等</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> __rb_tree_base_iterator&amp; x,</div><div class="line">                       <span class="keyword">const</span> __rb_tree_base_iterator&amp; y) &#123;</div><div class="line">  <span class="keyword">return</span> x.node != y.node;</div><div class="line">  <span class="comment">// 两个节点不相等,指这两个迭代器指向的节点不等</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>迭代器的解引用运算,返回的是这个节点的值域.所以对于set来说,返回的就是set存储的值,对于map来说,返回的就是pair&lt;key,value&gt;键值对.</p>
<h1>红黑树</h1>
<hr>
<p>为了实现红黑树的插入和删除平衡,STL树实现了几个旋转以及平衡函数:
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">inline void</div><div class="line"><span class="variable">__rb_tree_rotate_left</span>(<span class="variable">__rb_tree_node_base</span>* x, <span class="variable">__rb_tree_node_base</span>*&amp; root)</div><div class="line"></div><div class="line">inline void</div><div class="line"><span class="variable">__rb_tree_rotate_right</span>(<span class="variable">__rb_tree_node_base</span>* x, <span class="variable">__rb_tree_node_base</span>*&amp; root)</div><div class="line"></div><div class="line">inline void</div><div class="line"><span class="variable">__rb_tree_rebalance</span>(<span class="variable">__rb_tree_node_base</span>* x, <span class="variable">__rb_tree_node_base</span>*&amp; root)</div><div class="line"></div><div class="line">inline <span class="variable">__rb_tree_node_base</span>*</div><div class="line"><span class="variable">__rb_tree_rebalance_for_erase</span>(<span class="variable">__rb_tree_node_base</span>* z,</div><div class="line">                              <span class="variable">__rb_tree_node_base</span>*&amp; root,</div><div class="line">                              <span class="variable">__rb_tree_node_base</span>*&amp; leftmost,</div><div class="line">                              <span class="variable">__rb_tree_node_base</span>*&amp; rightmost)</div></pre></td></tr></table></figure></p>
<p>这几个函数是实现红黑树平衡的重要操作,左旋转,右旋转,插入一个节点之后的平衡操作,删除一个节点的平衡操作.这几个函数较为复杂,我就不分析了,但是我觉得看网上的博客会比较好理解.</p>
<p>下面看下rb_tree真正的定义.先是创建节点和销毁节点:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//分配节点存储空间</span></div><div class="line">link_type get_node() &#123; return rb_tree_node_allocator::allocate(); &#125;</div><div class="line"> <span class="comment">//回收一个节点的空间</span></div><div class="line"> void put_node(link_type p) &#123; rb_tree_node_allocator::deallocate(p); &#125;</div><div class="line"></div><div class="line"> <span class="comment">//创建一个节点</span></div><div class="line"> link_type create_node(const value_type&amp; x) &#123;</div><div class="line">   link_type tmp = get_node();			<span class="comment">// 配置空间</span></div><div class="line">   __STL_TRY &#123;</div><div class="line">     <span class="function"><span class="title">construct</span>(&amp;tmp-&gt;</span>value_field, x);	<span class="comment">// 建造内容</span></div><div class="line">   &#125;</div><div class="line">   __STL_UNWIND(put_node(tmp));</div><div class="line">   return tmp;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> link_type clone_node(link_type x) &#123;	<span class="comment">// 复制一个节点(主要是是颜色)</span></div><div class="line">   <span class="function"><span class="title">link_type</span> tmp = create_node(x-&gt;</span>value_field);</div><div class="line">   <span class="function"><span class="title">tmp</span>-&gt;</span><span class="function"><span class="title">color</span> = x-&gt;</span><span class="built_in">color</span>;</div><div class="line">   <span class="function"><span class="title">tmp</span>-&gt;</span>left = <span class="number">0</span>;</div><div class="line">   <span class="function"><span class="title">tmp</span>-&gt;</span>right = <span class="number">0</span>;</div><div class="line">   return tmp;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> void destroy_node(link_type p) &#123;</div><div class="line">   <span class="function"><span class="title">destroy</span>(&amp;p-&gt;</span>value_field);		<span class="comment">// 解析内容</span></div><div class="line">   put_node(p);					<span class="comment">// 回收节点空间</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>红黑树的成员主要有3个,
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">size_type node_count<span class="comment">; // 记录树的大小(节点的个数)</span></div><div class="line"> link_type header<span class="comment">;    </span></div><div class="line"> <span class="built_in">Compare</span> key_compare<span class="comment">;	 // 节点间的比较器,应该是个函数对象</span></div></pre></td></tr></table></figure></p>
<p>对于header,其实相当与链表中的头节点,不存储数据,可用于红黑树的入口.header的设计可以说的STL红黑树设计的一个亮点,header和root互为父节点,header的左节点指向最小的值,header的右节点指向最大的值,所以header也可以作为end()迭代器指向的值.图示如下:<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_038.png" alt="header图示">;</p>
<p>接下来就是一些小函数,都是实现获取节点成员变量的函数,有一个需要提下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> KeyOfValue()(value(x)); &#125;</div></pre></td></tr></table></figure></p>
<p>KeyOfValue这是个函数对象,对于set和map的实现是不一样的,主要功能就是从一个节点中获取这个节点存储的键值,对于set而言,这个函数对象为 identity&lt;value_type&gt;,这个函数对象返回的就是这个set存储的值,而对于map而言,这个函数对象为  select1st&lt;value_type&gt;,map的值域为pair对象,所以select1st就是获取这个pair的第一个成员.</p>
<p>接下就对重要函数做个简单的介绍,因为太复杂了,而且这篇文章主要是讲解set和map.</p>
<ol>
<li>
<p>对于set和multiset,map和multimap而言,最大的区别就是是否允许键值重复,而反应在红黑树上,则为插入函数的不同.set和map用的是insert_unique,而multiset和multimap用的是insert_equal函数.具体源码,我也是一知半解,所以就不分析了,误人子弟就不好了.</p>
</li>
<li>
<p>有插入就有删除函数,红黑树提供的是erase函数,但是使用这个函数之后,可能导致红黑树不满足那5个条件,所以要调用 __rb_tree_rebalance_for_erase来维持树的平衡.</p>
</li>
<li>
<p>对于multiset和multimap而言,红黑树还提供了查询与某个键值相等的节点迭代器范围,
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pair&lt;<span class="keyword">iterator</span>,<span class="keyword">iterator</span>&gt; equal_range(<span class="keyword">const</span> key_type&amp; x);</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这个函数返回二叉树中和键值x相等的迭代器范围.而set和map都是不允许键值重复的,所以就不要用这个函数,直接用find函数即可.</p>
<ol start="4">
<li>红黑树还提供了查询不小于和大于某个键值的函数:
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回不小于k的第一个节点迭代器</span></div><div class="line">typename rb_tree&lt;<span class="built_in">Key</span>, Value, KeyOfValue, Compare, Alloc&gt;::iterator</div><div class="line">rb_tree&lt;<span class="built_in">Key</span>, Value, KeyOfValue, Compare, Alloc&gt;::lower_bound(const <span class="built_in">Key</span>&amp; k)</div><div class="line"><span class="comment">//返回大于k的第一个节点迭代器</span></div><div class="line">typename rb_tree&lt;<span class="built_in">Key</span>, Value, KeyOfValue, Compare, Alloc&gt;::iterator</div><div class="line">rb_tree&lt;<span class="built_in">Key</span>, Value, KeyOfValue, Compare, Alloc&gt;::upper_bound(const <span class="built_in">Key</span>&amp; k)</div></pre></td></tr></table></figure></li>
</ol>
<h1>map实现</h1>
<hr>
<p>map底层用的是红黑树,所以map只是在红黑树上加了一层封装,map中用的用的红黑树定义如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> Key key_type;	<span class="comment">//键值类型 </span></div><div class="line"><span class="keyword">typedef</span> T data_type;		<span class="comment">// 值类型</span></div><div class="line"><span class="keyword">typedef</span> T mapped_type;	<span class="comment">//值类型</span></div><div class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type;	<span class="comment">// 值类型,map存储pair键值对</span></div><div class="line"><span class="keyword">typedef</span> Compare key_compare;	<span class="comment">// 键值函数对象</span></div><div class="line"></div><div class="line"> <span class="keyword">class</span> value_compare<span class="comment">//值域比较器,其实也是比较键值</span></div><div class="line">   : <span class="keyword">public</span> binary_function&lt;value_type, value_type, <span class="keyword">bool</span>&gt; &#123;</div><div class="line"> <span class="keyword">friend</span> <span class="keyword">class</span> <span class="built_in">map</span>&lt;Key, T, Compare, Alloc&gt;;</div><div class="line"> <span class="keyword">protected</span> :</div><div class="line">   Compare comp;</div><div class="line">   value_compare(Compare c) : comp(c) &#123;&#125;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> value_type&amp; x, <span class="keyword">const</span> value_type&amp; y)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> comp(x.first, y.first);</div><div class="line">   &#125;</div><div class="line"> &#125;;</div><div class="line"> <span class="comment">//map中红黑树的定义</span></div><div class="line"> <span class="keyword">typedef</span> rb_tree&lt;key_type, value_type, </div><div class="line">                 select1st&lt;value_type&gt;, key_compare, Alloc&gt; rep_type;</div><div class="line">  rep_type t;</div></pre></td></tr></table></figure></p>
<p>可以看到在map中,传入红黑树的KeyOfValue函数对象是select1st&lt;value_type&gt;,而value_type为pair类型,这个函数对象就是获取pair第一个键值,为了键值比较排序.</p>
<h2>map构造函数</h2>
<p>map构造函数有分为默认构造函数和带比较函数对象的构造的构造函数,一个是用默认的比较对象less&lt;key&gt;,另一个是可以自己定义比较对象的构造函数
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>() : t(Compare()) &#123;&#125;</div><div class="line"><span class="keyword">explicit</span> <span class="built_in">map</span>(<span class="keyword">const</span> Compare&amp; comp) : t(comp) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>map还支持用一对输入迭代器来初始化,迭代器之间即为要插入map的数据,所以可以将vector首尾迭代器作为参数传入map构造函数来初始化
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template &lt;<span class="built_in">class</span> InputIterator&gt;</div><div class="line"> map(InputIterator <span class="keyword">first</span>, InputIterator <span class="keyword">last</span>)</div><div class="line">   : t(Compare()) &#123; t.insert_unique(<span class="keyword">first</span>, <span class="keyword">last</span>); &#125;</div><div class="line"></div><div class="line"> template &lt;<span class="built_in">class</span> InputIterator&gt;</div><div class="line"> map(InputIterator <span class="keyword">first</span>, InputIterator <span class="keyword">last</span>, const Compare&amp; comp)</div><div class="line">   : t(comp) &#123; t.insert_unique(<span class="keyword">first</span>, <span class="keyword">last</span>); &#125;</div></pre></td></tr></table></figure></p>
<p>map还支持值类型的数组指针范围来初始化map,例如pair&lt;string,int&gt; parr[10],然后用这个数组的首尾指针来初始化map.
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>(const value_type* <span class="built_in">first</span>, const value_type* <span class="built_in">last</span>)</div><div class="line">  : t(Compare()) &#123; t.insert_unique(<span class="built_in">first</span>, <span class="built_in">last</span>); &#125;</div><div class="line"><span class="built_in">map</span>(const value_type* <span class="built_in">first</span>, const value_type* <span class="built_in">last</span>, const Compare&amp; comp)</div><div class="line">  : t(comp) &#123; t.insert_unique(<span class="built_in">first</span>, <span class="built_in">last</span>); &#125;</div></pre></td></tr></table></figure></p>
<h2>map插入操作</h2>
<p>map插入分为单个值插入,在某个节点插入以及插入一对迭代器范围内的元素.
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pair&lt;iterator,bool&gt; <span class="keyword">insert</span>(const value_type&amp; x) &#123; <span class="keyword">return</span> t.insert_unique(x); &#125;</div><div class="line">iterator <span class="keyword">insert</span>(iterator <span class="built_in">position</span>, const value_type&amp; x) &#123;</div><div class="line">  <span class="keyword">return</span> t.insert_unique(<span class="built_in">position</span>, x);</div><div class="line">&#125;</div><div class="line">void <span class="keyword">insert</span>(const value_type* <span class="keyword">first</span>, const value_type* <span class="keyword">last</span>) &#123;</div><div class="line">  t.insert_unique(<span class="keyword">first</span>, <span class="keyword">last</span>);</div><div class="line">&#125;</div><div class="line">void <span class="keyword">insert</span>(const_iterator <span class="keyword">first</span>, const_iterator <span class="keyword">last</span>) &#123;</div><div class="line">  t.insert_unique(<span class="keyword">first</span>, <span class="keyword">last</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于第一个迭代器,返回的是一个pair&lt;iterator,bool&gt;,迭代器指向插入节点的位置,布尔值为插入是否成功.其他都是简单的调用红黑树的方法.</p>
<h2>map删除操作</h2>
<p>map删除操作提供删除某个迭代器指向的节点,某个键指向的节点,以及一对迭代器指向的元素:
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123; t.erase(position); &#125;</div><div class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="function"><span class="keyword">return</span> t.<span class="title">erase</span><span class="params">(x)</span></span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123; t.erase(first, last); &#125;</div></pre></td></tr></table></figure></p>
<h2>map查找函数</h2>
<p>map查找函数有查找某个键值的find函数,查找某个键值个数的count函数,两个限界函数,最后查找范围的函数
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查找某个键值对应的节点迭代器</span></div><div class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123; <span class="function"><span class="keyword">return</span> t.<span class="title">find</span><span class="params">(x)</span></span>; &#125;</div><div class="line"><span class="comment">//查找某个键值的个数</span></div><div class="line">size_type count(<span class="keyword">const</span> key_type&amp; x) <span class="keyword">const</span> &#123; <span class="function"><span class="keyword">return</span> t.<span class="title">count</span><span class="params">(x)</span></span>; &#125;</div><div class="line"><span class="comment">//查找不小于,即大于等于键值x的节点迭代器,</span></div><div class="line"><span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="function"><span class="keyword">return</span> t.<span class="title">lower_bound</span><span class="params">(x)</span></span>; &#125;</div><div class="line"><span class="comment">//查找大于键值x的节点迭代器</span></div><div class="line"><span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> </span>&#123;<span class="function"><span class="keyword">return</span> t.<span class="title">upper_bound</span><span class="params">(x)</span></span>; &#125;</div><div class="line"><span class="comment">//返回lower_bound和upper_bound迭代器对.</span></div><div class="line">pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) &#123;</div><div class="line">   <span class="function"><span class="keyword">return</span> t.<span class="title">equal_range</span><span class="params">(x)</span></span>;</div></pre></td></tr></table></figure></p>
<p>map一定要提到的函数是重载下标注运算符,这个函数也算是查找某个键所对应的值,但是如果某个键不存在的话,则会插入pair对,键值为k,值为data_type类型的默认值.
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">T</span>&amp; operator[](const key_<span class="keyword">type</span>&amp; k) &#123;</div><div class="line">   return (*((insert(value_type(k, <span class="type">T</span>()))).first)).second;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数有点复杂,insert(value_type(k, T()))先返回pair&lt;iterator,bool&gt;第一个iterator,即这个键所对应节点的迭代器,然后取这个键所对应的值pair&lt;key_type,value_type&gt;,最后取出第二个元素即可.</p>
<p>所以要查找某个元素不能用这个下标表示法,应该用find函数,因为前者会将不存在的键插入到map中.</p>
<h1>set的实现</h1>
<hr>
<p>先来看下set中红黑树的定义:
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef <span class="type">Key</span> key_type;</div><div class="line">typedef <span class="type">Key</span> value_type;</div><div class="line">// 键值和值域比较器是一样的,因为set存储的就是一个值,而不是键值对</div><div class="line">typedef <span class="type">Compare</span> key_compare;</div><div class="line">typedef <span class="type">Compare</span> value_compare;</div><div class="line">typedef rb_tree&lt;key_type, value_type, </div><div class="line">                   identity&lt;value_<span class="keyword">type</span>&gt;, key_compare, <span class="type">Alloc</span>&gt; rep_type;</div><div class="line"> rep_<span class="keyword">type</span> t;</div></pre></td></tr></table></figure></p>
<p>这里面最重要的就是identity&lt;value_type&gt;函数对象了.这个就是获取set存储的value的键值部分.也是标准模板库的一部分.</p>
<p>看到这我才发现,set的接口和map的接口几乎一模一样...</p>
]]></content>
      
        <categories>
            
            <category> STL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
            <tag> rb_tree </tag>
            
            <tag> set </tag>
            
            <tag> map </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[平衡二叉树(avl)分析与实现]]></title>
      <url>http://luodw.cc/2015/11/14/avl/</url>
      <content type="html"><![CDATA[<p>继上次二叉搜索树分析之后，今天分析下平衡二叉树．平衡二叉树是二叉搜索树进化而来的，因为二叉搜索树的期望高度为log2n，各项操作的时间复杂度的期望也是log2n，但是在极端情况下，二叉搜索树将退化为链表（有序插入时），这时的时间复杂度将退化为n，所以二叉搜索树实际用的并不是很多，实际中用的较多的是平衡二叉树和红黑树．例如C++STL中的map,set,mutilset,mutilmap的底层都是用红黑树实现的．</p>
<p>平衡二叉树的主要性质：它是一棵空树或者它的左右子树的高度差的绝对值不超过１，并且左右两棵子树都是平衡二叉树．</p>
<p>平衡二叉树的实现:平衡二叉树本质上也是一棵二叉搜索树，所以如果只是读取的话，是不会改变平衡二叉树的，所以二叉搜索树的读取方法可以直接用在平衡二叉树上，但是插入和删除会改变平衡二叉树的左右子树的高度，导致左右子树的高度差大于等于２，这时树就不平衡．AVL树是通过旋转来实现插入和删除之后的平衡．</p>
<p>对于子树的旋转网上有很多博客讲解，我就不多说了，我这里引用其中一篇博客的图片，因为我觉得那篇博客的图片画的很好，图片来自<a href="http://www.cppblog.com/cxiaojia/archive/2012/08/20/187776.html" target="_blank" rel="external">C小加的博客</a>
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_035.png" alt="avl旋转四种情况"></p>
<ol>
<li>6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。</li>
<li>6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。</li>
<li>2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。</li>
<li>2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。</li>
</ol>
<p>从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。</p>
<p>AVL树就这四种旋转情况，具体怎么旋转，就百度了．我主要是分析下如何实现．</p>
<h1>AVL树定义</h1>
<hr>
<p>AVL树节点主要由值，高度，左子树，右子树组成，我之前加了父亲成员，但是发现难度加大了，而且经常错误，所以以上属性足够了．
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ValueType;</div><div class="line"><span class="keyword">struct</span> avl_node</div><div class="line">&#123;</div><div class="line">	ValueType data;</div><div class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;</div><div class="line">	<span class="keyword">struct</span> avl_node *left;</div><div class="line">	<span class="keyword">struct</span> avl_node *right;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> avl_node* node;</div></pre></td></tr></table></figure></p>
<h1>两个辅助函数</h1>
<hr>
<p>这里定义两个函数，用于求子树的高度和取两个子树高度的最大值．
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Height</span><span class="params">(node p)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">return</span> p-&gt;height;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> lhs,<span class="keyword">int</span> rhs)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> lhs&gt;rhs?lhs:rhs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里定义NULL节点的高度为-1，这样以来，叶子节点的高度就为0．</p>
<h1>四种情况下的旋转函数</h1>
<hr>
<p>再次从C小加的博客中拿了两张图，用于说明旋转函数实现:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_036.png" alt="左左情况下旋转示意图">
如上图，k2的左子树比右子树高２，所以不平衡，我们需要把k1提到k2的位置，然后k2下降到k1的右子树，最后还有把k1的右子树放到k2的左子树即可．至于y为什么要放到k2的左子树了？因为y大于k1小于k2，当k1升到k2位置时，k1已经有右子树k2，所以只能把y放到k2的左子树，符合二叉搜索树性质．代码如下:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static node SingleRotateLeft(node &amp;p1)</div><div class="line">&#123;</div><div class="line">	<span class="function"><span class="title">node</span> p2=p1-&gt;</span>left;<span class="comment">//找到p1的左子树</span></div><div class="line">	<span class="function"><span class="title">p1</span>-&gt;</span><span class="function"><span class="title">left</span>=p2-&gt;</span>right;<span class="comment">//将p2的右子树移至p1的左子树</span></div><div class="line">	<span class="function"><span class="title">p2</span>-&gt;</span>right=p1;<span class="comment">//建立p2和p1的关系</span></div><div class="line">	<span class="comment">//更新p1和p2的高度，因为p2高度依赖p1，所以先更新p1</span></div><div class="line">	<span class="function"><span class="title">p1</span>-&gt;</span><span class="function"><span class="title">height</span>=Max(Height(p1-&gt;</span><span class="function"><span class="title">left</span>),Height(p1-&gt;</span>right))+<span class="number">1</span>;</div><div class="line">	<span class="function"><span class="title">p2</span>-&gt;</span><span class="function"><span class="title">height</span>=Max(Height(p2-&gt;</span><span class="function"><span class="title">left</span>),Height(p2-&gt;</span>right))+<span class="number">1</span>;</div><div class="line">	return p2;</div><div class="line">&#125;</div><div class="line"><span class="comment">//右右情况的旋转和左左的对称，所以原理类似</span></div><div class="line">static node SingleRotateRight(node &amp;p1)</div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="title">node</span> p2=p1-&gt;</span>right;</div><div class="line">	<span class="function"><span class="title">p1</span>-&gt;</span><span class="function"><span class="title">right</span>=p2-&gt;</span>left;</div><div class="line">	<span class="function"><span class="title">p2</span>-&gt;</span>left=p1;</div><div class="line">	<span class="function"><span class="title">p1</span>-&gt;</span><span class="function"><span class="title">height</span>=Max(Height(p1-&gt;</span><span class="function"><span class="title">left</span>),Height(p1-&gt;</span>right))+<span class="number">1</span>;</div><div class="line">	<span class="function"><span class="title">p2</span>-&gt;</span><span class="function"><span class="title">height</span>=Max(Height(p2-&gt;</span><span class="function"><span class="title">left</span>),Height(p2-&gt;</span>right))+<span class="number">1</span>;</div><div class="line">	return p2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有左右和右左旋转情况，图示如下:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_037.png" alt="左右情况下的旋转"></p>
<p>左右情况下的旋转，先以k3的左子树为根节点执行一次左左旋转，然后以k3的根节点，执行一次右右旋转即可．右左情况和左右对称．
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static <span class="keyword">node</span> <span class="title">DoubleRotateLR</span>(<span class="keyword">node</span> <span class="title">&amp;p1</span>)</div><div class="line">&#123;</div><div class="line">	p1-&gt;<span class="attr">left=</span>SingleRotateRight(p1-&gt;left);</div><div class="line">	return SingleRotateLeft(p1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static <span class="keyword">node</span> <span class="title">DoubleRotateRL</span>(<span class="keyword">node</span> <span class="title">&amp;p1</span>)</div><div class="line">&#123;</div><div class="line">	p1-&gt;<span class="attr">right=</span>SingleRotateLeft(p1-&gt;right);</div><div class="line">	return SingleRotateRight(p1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>AVL树插入操作</h1>
<hr>
<p>AVL树插入时，会破坏平衡性，所以没当插入一个数据时，都要从插入点往上，一步一步检测是否出现两棵子树高度差等于2，如果等于2，则要做相应的旋转．
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">static node Insert(node root,node parent,ValueType x)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//判断是否为根节点，以及当判断是否为插入点</span></div><div class="line">	<span class="keyword">if</span>(root==NULL)</div><div class="line">	&#123;</div><div class="line">		root=(node)malloc(sizeof(struct avl_node));</div><div class="line">		<span class="function"><span class="title">root</span>-&gt;</span><span class="keyword">data</span>=x;</div><div class="line">		<span class="function"><span class="title">root</span>-&gt;</span>height=<span class="number">0</span>;</div><div class="line">		<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">left</span>=root-&gt;</span>right=NULL;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//当插入值比当前节点值小时，则往左子树插入</span></div><div class="line">	<span class="function"><span class="title">else</span> <span class="keyword">if</span>(x&lt;root-&gt;</span><span class="keyword">data</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">left</span>=Insert(root-&gt;</span>left,root,x);<span class="comment">//递归插入</span></div><div class="line">		<span class="function"><span class="title">if</span>(Height(root-&gt;</span><span class="function"><span class="title">left</span>)-Height(root-&gt;</span>right)==<span class="number">2</span>)<span class="comment">//判断子树是否平衡</span></div><div class="line">		&#123;</div><div class="line">			<span class="function"><span class="title">if</span>(x&lt;root-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="keyword">data</span>)<span class="comment">//插入值小于当前节点的左节点的值，则为左左情况</span></div><div class="line">				root=SingleRotateLeft(root);</div><div class="line">			<span class="keyword">else</span><span class="comment">//否则为左右情况</span></div><div class="line">				root=DoubleRotateLR(root);</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="function"><span class="title">else</span> <span class="keyword">if</span>(x&gt;root-&gt;</span><span class="keyword">data</span>)<span class="comment">//插入值比当前节点大时，往右子树插入</span></div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">right</span>=Insert(root-&gt;</span>right,root,x);</div><div class="line">		<span class="function"><span class="title">if</span>(Height(root-&gt;</span><span class="function"><span class="title">right</span>)-Height(root-&gt;</span>left)==<span class="number">2</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="function"><span class="title">if</span>(x&gt;root-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="keyword">data</span>)</div><div class="line">				root=SingleRotateRight(root);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				root=DoubleRotateRL(root);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//更新当前节点的高度</span></div><div class="line">	<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">height</span>=Max(Height(root-&gt;</span><span class="function"><span class="title">left</span>),Height(root-&gt;</span>right))+<span class="number">1</span>;</div><div class="line">	return root;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>AVL树的删除</h1>
<hr>
<p>AVL树插入操作相对较简单，但是AVL删除操作就相对复杂了．AVL树删除操作也要分为四种情况，</p>
<ol>
<li>删除节点两个子树都非空</li>
<li>删除节点左子树非空，右子树空</li>
<li>删除节点右子树非空，左子树空</li>
<li>删除节点左右子树都为空
但是真正要考虑的只有右子树为空和非空的情况，因为右子树非空的话，要找到后继几点；其他情况，直接指针更新即可．
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">node delete_node(node root,ValueType x)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(root==NULL)<span class="comment">//空树直接返回</span></div><div class="line">		return NULL;</div><div class="line">	<span class="function"><span class="title">if</span>(x&lt;root-&gt;</span><span class="keyword">data</span>)<span class="comment">//删除值小于当前节点，说明删除节点在当前节点左侧</span></div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">left</span>=delete_node(root-&gt;</span>left,x);</div><div class="line">		<span class="function"><span class="title">if</span>(Height(root-&gt;</span><span class="function"><span class="title">right</span>)-Height(root-&gt;</span>left)==<span class="number">2</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="function"><span class="title">if</span>(Height(root-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="function"><span class="title">left</span>)&gt;Height(root-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span>right))</div><div class="line">				root=DoubleRotateRL(root);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				root=SingleRotateRight(root);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="title">else</span> <span class="keyword">if</span>(x&gt;root-&gt;</span><span class="keyword">data</span>)<span class="comment">//删除节点在当前节点右侧</span></div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">right</span>=delete_node(root-&gt;</span>right,x);</div><div class="line">		<span class="function"><span class="title">if</span>(Height(root-&gt;</span><span class="function"><span class="title">left</span>)-Height(root-&gt;</span>right)==<span class="number">2</span>)</div><div class="line">		&#123;</div><div class="line">			<span class="function"><span class="title">if</span>(Height(root-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">right</span>)&gt;Height(root-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span>left))</div><div class="line">				root=DoubleRotateLR(root);</div><div class="line">			<span class="keyword">else</span></div><div class="line">				root=SingleRotateLeft(root);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span><span class="comment">//找到删除节点</span></div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">if</span>(root-&gt;</span>right)</div><div class="line">		&#123;<span class="comment">//右子树不为空的情况</span></div><div class="line">			<span class="function"><span class="title">node</span> temp=root-&gt;</span>right;</div><div class="line">			<span class="function"><span class="title">while</span>(temp-&gt;</span><span class="function"><span class="title">left</span>!=NULL) temp=temp-&gt;</span>left;</div><div class="line">			<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">data</span>=temp-&gt;</span><span class="keyword">data</span>;</div><div class="line">			<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">height</span>=temp-&gt;</span>height;</div><div class="line">			<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">right</span>=delete_node(root-&gt;</span><span class="function"><span class="title">right</span>,temp-&gt;</span><span class="keyword">data</span>);<span class="comment">//删除后继节点</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;<span class="comment">//右子树为空的情况，free节点，返回被删除节点的左节点</span></div><div class="line">		<span class="comment">//这也是真正删除节点的地方</span></div><div class="line">			node temp=root;</div><div class="line">			<span class="function"><span class="title">root</span>=root-&gt;</span>left;</div><div class="line">			free(temp);</div><div class="line">			return root;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//每次删除之后，都要更新节点的高度</span></div><div class="line">	<span class="function"><span class="title">root</span>-&gt;</span><span class="function"><span class="title">height</span>=Max(Height(root-&gt;</span><span class="function"><span class="title">left</span>),Height(root-&gt;</span>right))+<span class="number">1</span>;</div><div class="line">	return root;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>这几天研究平衡二叉树的体会就是，插入和删除函数一定要返回当前节点，因为不返回当前节点的话，删除时就要加入父亲成员，而加入父亲成员，程序的复杂度又加大了，所以这个程序的实现应该是最简单了．</p>
<p>平衡二叉树的其他操作和二叉搜索树一样，像查找，遍历，前驱和后继等等，因为这些操作都不改变二叉树，所以可以直接拿来用．</p>
<p>下面是我写的检测程序:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	int arr[<span class="number">10</span>]=&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</div><div class="line">	int i=<span class="number">0</span>;</div><div class="line">	node root=NULL;</div><div class="line">	for(;i&lt;<span class="number">10</span>;i++)</div><div class="line">		root=Insert(root,NULL,arr[i]);</div><div class="line">	print_avl(root);</div><div class="line">	printf(<span class="string">"input delete node key:  "</span>);</div><div class="line">	while((scanf(<span class="string">"%d"</span>,&amp;i))!=<span class="literal">EOF</span>)</div><div class="line">	&#123;</div><div class="line">		delete_node(root,i);</div><div class="line">		print_avl(root);</div><div class="line">		printf(<span class="string">"input delete node key:  "</span>);</div><div class="line">	&#125;</div><div class="line">	printf(<span class="string">"<span class="subst">\n</span>"</span>);</div><div class="line">	return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设删除程序删除９，则可得到如下结果:
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~/mydir/algorithm$ ./avl</div><div class="line"><span class="attr">data=0</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=1</span>  <span class="attr">height=2:</span> left <span class="attr">child=0,right</span> <span class="attr">child=3</span></div><div class="line"><span class="attr">data=2</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=3</span>  <span class="attr">height=1:</span> left <span class="attr">child=2,right</span> <span class="attr">child=4</span></div><div class="line"><span class="attr">data=4</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=5</span>  <span class="attr">height=3:</span> left <span class="attr">child=1,right</span> <span class="attr">child=8</span></div><div class="line"><span class="attr">data=6</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=7</span>  <span class="attr">height=1:</span> left <span class="attr">child=6,</span></div><div class="line"><span class="attr">data=8</span>  <span class="attr">height=2:</span> left <span class="attr">child=7,right</span> <span class="attr">child=9</span></div><div class="line"><span class="attr">data=9</span>  <span class="attr">height=0:</span> </div><div class="line">input delete node key:  <span class="number">9</span></div><div class="line"><span class="attr">data=0</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=1</span>  <span class="attr">height=2:</span> left <span class="attr">child=0,right</span> <span class="attr">child=3</span></div><div class="line"><span class="attr">data=2</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=3</span>  <span class="attr">height=1:</span> left <span class="attr">child=2,right</span> <span class="attr">child=4</span></div><div class="line"><span class="attr">data=4</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=5</span>  <span class="attr">height=3:</span> left <span class="attr">child=1,right</span> <span class="attr">child=7</span></div><div class="line"><span class="attr">data=6</span>  <span class="attr">height=0:</span> </div><div class="line"><span class="attr">data=7</span>  <span class="attr">height=1:</span> left <span class="attr">child=6,right</span> <span class="attr">child=8</span></div><div class="line"><span class="attr">data=8</span>  <span class="attr">height=0:</span></div></pre></td></tr></table></figure></p>
<p>删除9之后，8节点左子树比右子树高2，所以要进行左左旋转．示意图如下:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-123.jpg" alt="删除节点之后"></p>
<p>平衡二叉树先研究到这吧，下篇文章最后把红黑树研究下...</p>
]]></content>
      
        <categories>
            
            <category> data_structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> avl </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉搜索树分析与实现]]></title>
      <url>http://luodw.cc/2015/11/12/bst/</url>
      <content type="html"><![CDATA[<p>最近在看STL源码分析，看到关联容器时，被红黑树的复杂给卡住了，所以打算这几天好好学习下树这个数据结构．当初学数据结构时，对树也是一知半解，所以趁这个机会，好好掌握树，找工作时，也是经常被到，学好树还是很有必要的．</p>
<p>平常使用的树就属二叉搜索树，更上一级的就是二叉搜索树的升级版平衡二叉树(AVL)和红黑树(rbtree)，如果有研究mysql存储，可能还需对B-tree有一定的了解．这篇文章就对最简单的二叉搜索树做个介绍．</p>
<h1>二叉搜索树节点</h1>
<hr>
<p>二叉搜索树的节点有数据域，父节点，左节点和右节点组成，这也是一颗完整二叉树节点拥有的成员变量，定义如下:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//树存储的数据类型</span></div><div class="line">typedef int ValueType;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bst_node</span></span></div><div class="line">&#123;</div><div class="line">	ValueType value;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bst_node</span></span> *parent;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bst_node</span></span> *left;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bst_node</span></span> *right;</div><div class="line">&#125;;<span class="comment">//树节点类型</span></div><div class="line">typedef <span class="class"><span class="keyword">struct</span> <span class="title">bst_node</span></span>* node;</div></pre></td></tr></table></figure></p>
<p>如果要定义成能存储多种数据类型，可以将数据域定义为void*类型，然后在插入数据时，然后可以定义一个比较器，用于插入数据时，判断数据大小．</p>
<h1>二叉树的插入</h1>
<hr>
<p>二叉树插入时，需要考虑树是否为空，如果是，则插入的节点则为根节点；如果不是，则先找到插入节点的父节点，再将插入值和这个父节点比较:</p>
<ol>
<li>如果插入值比父节点的值小，则插入值插入父节点的左子节点；</li>
<li>如果插入值比父节点的值大，则插入值插入父节点的右子节点；</li>
</ol>
<p>我的实现如下:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">void insert_node(node *root,ValueType <span class="keyword">data</span>)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//初始化节点</span></div><div class="line">	node p=(node)malloc(sizeof(struct bst_node));</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>value=<span class="keyword">data</span>;</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>parent=NULL;</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>left=NULL;</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>right=NULL;</div><div class="line">	<span class="comment">//如果是空树，则新插入的节点为根节点</span></div><div class="line">	<span class="keyword">if</span>((*root)==NULL)</div><div class="line">	&#123;</div><div class="line">		*root=p;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	node parent=(*root);</div><div class="line">	node tmp=(*root);</div><div class="line">	<span class="comment">//迭代找打要插入的位置</span></div><div class="line">	<span class="keyword">while</span>(tmp!=NULL)</div><div class="line">	&#123;</div><div class="line">		parent=tmp;</div><div class="line">		<span class="function"><span class="title">if</span>(<span class="keyword">data</span>==tmp-&gt;</span>value)</div><div class="line">			return;</div><div class="line">		<span class="function"><span class="title">if</span>(<span class="keyword">data</span>&lt;tmp-&gt;</span>value)</div><div class="line">			<span class="function"><span class="title">tmp</span>=tmp-&gt;</span>left;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="function"><span class="title">tmp</span>=tmp-&gt;</span>right;</div><div class="line">	&#125;</div><div class="line">　　　　<span class="comment">//插入节点</span></div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>parent=parent;</div><div class="line">	<span class="function"><span class="title">if</span>(<span class="keyword">data</span>&lt;parent-&gt;</span>value)</div><div class="line">		<span class="function"><span class="title">parent</span>-&gt;</span>left=p;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="function"><span class="title">parent</span>-&gt;</span>right=p;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于树的实现有递归和迭代两种方法，我的建议是除了输出时用递归，其他用迭代，毕竟迭代思路更清晰，递归思路曲折．</p>
<h1>查找最大最小值</h1>
<hr>
<ol>
<li>当查找某个节点的最大值时，只需要从这个节点开始，一直往右即可．</li>
<li>当查找某个节点的最小值时，只需要从这个节点开始，一直往左即可．
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">node</span> <span class="title">max_node</span>(<span class="keyword">node</span> <span class="title">root</span>)</div><div class="line">&#123;</div><div class="line">	if(<span class="attr">root=</span>=NULL)</div><div class="line">		return root;</div><div class="line">	while(root-&gt;right!=NULL)</div><div class="line">		<span class="attr">root=</span>root-&gt;right;</div><div class="line">	return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">node</span> <span class="title">min_node</span>(<span class="keyword">node</span> <span class="title">root</span>)</div><div class="line">&#123;</div><div class="line">	if(<span class="attr">root=</span>=NULL)</div><div class="line">		return root;</div><div class="line">	while(root-&gt;left!=NULL)</div><div class="line">		<span class="attr">root=</span>root-&gt;left;</div><div class="line">	return root;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<h1>查找某个给定值的节点</h1>
<hr>
<p>查找某个给定值的节点时，思路和插入时类似，根据数值和根节点的比较，如果查找数值比根节点数值小，则往左迭代，否则往右迭代．
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">node find_node(node root,ValueType data)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(root==<span class="keyword">NULL</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">	node <span class="keyword">parent</span>=root,tmp=root;</div><div class="line">	<span class="keyword">while</span>(tmp!=<span class="keyword">NULL</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">parent</span>=tmp;</div><div class="line">		<span class="keyword">if</span>(tmp-&gt;value==data)</div><div class="line">			<span class="keyword">return</span> tmp;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(data&lt;tmp-&gt;value)</div><div class="line">				tmp=tmp-&gt;left;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				tmp=tmp-&gt;right;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果找到该节点，则返回该节点，否则返回NULL，用于调用判断是否有这个节点</p>
<h1>某个节点的前驱</h1>
<hr>
<p>当查找某个节点的前驱节点时，如果是空树，则返回空；如果有左子树，则返回左子树的最大值作为前驱；如果没有左子树，又要分为两种情况</p>
<ol>
<li>如果删除的是根节点，则没有前驱；</li>
<li>如果普通内部节点，往上找到某个节点是其父节点的右节点时，则这个节点的父节点就是这个节点的前驱
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">node predecessor(node p)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(p==<span class="keyword">NULL</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">	<span class="keyword">if</span>(p-&gt;left)</div><div class="line">		<span class="keyword">return</span> max_node(p-&gt;left);</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(p-&gt;parent==<span class="keyword">NULL</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">		<span class="keyword">while</span>(p)&#123;</div><div class="line">			<span class="keyword">if</span>(p-&gt;parent-&gt;right==p)</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			p=p-&gt;parent;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> p-&gt;parent;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>后继节点思路和前驱节点类似．</p>
<h1>删除某个节点</h1>
<hr>
<p>删除某个节点时，情况比较复杂，首先判断是否为空树，如果是，则返回0，表示删除失败；如果不为空，则有以下４中情况:</p>
<ol>
<li>删除节点两个子节点都为空，即为叶子节点．先要判断是否为根节点，如果是，则回收这个节点，并且根节点指针为空；如果不是根节点，则直接把这个删除节点的父节点相应子树设为空，再删除这个节点</li>
<li>删除节点只有左节点，先要判断删除节点是否为根节点，如果是，则删除这个节点，并且把这个节点的左子树设为根节点；如果不是，则把这个节点用其左子树代替</li>
<li>删除节点只有右节点，先要判断删除节点是否为根节点，如果是，则删除这个节点，并且把这个节点的右子树设为根节点；如果不是，则把这个节点用其右子树代替</li>
<li>删除节点两个子节点都不为空，先删除这个删除节点的后继节点，然后把后继节点的值赋给删除节点即可．</li>
</ol>
<p>对于第四点，主要因为是这个节点的后继节点肯定没有左子树，如果有左子树，则删除节点的后继节点就是左子树了，则删除这个后继节点只需要执行上述一种情况．</p>
<p>代码如下:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">int delete_node(node *root,ValueType <span class="keyword">data</span>)</div><div class="line">&#123;</div><div class="line">	node p=find_node((*root),<span class="keyword">data</span>);</div><div class="line">	<span class="comment">//如果没找到，返回空节点</span></div><div class="line">	<span class="keyword">if</span>(p==NULL)</div><div class="line">		return <span class="number">0</span>;</div><div class="line">	ValueType temp;</div><div class="line">	<span class="comment">//case1  删除节点的两个子树同时为空</span></div><div class="line">	<span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">left</span>==NULL &amp;&amp; p-&gt;</span>right==NULL)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//如果只有一个节点，即根节点</span></div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">		&#123;</div><div class="line">			free(p);</div><div class="line">			(*root)=NULL;</div><div class="line">		&#125;<span class="keyword">else</span><span class="comment">//普通叶子节点</span></div><div class="line">		&#123;</div><div class="line">			<span class="comment">//删除节点是父节点的左孩子</span></div><div class="line">			<span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">value</span>&lt;p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>value)</div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>left=NULL;</div><div class="line">			<span class="keyword">else</span><span class="comment">//删除节点是父节点的右孩子</span></div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>right=NULL;</div><div class="line">			free(p);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//case2  删除节点只有右孩子</span></div><div class="line">	<span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">left</span>==NULL &amp;&amp; p-&gt;</span>right)</div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">			*<span class="function"><span class="title">root</span>=p-&gt;</span>right;</div><div class="line">		<span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">value</span> &lt; p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>value)</div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">left</span>=p-&gt;</span>right;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">right</span>=p-&gt;</span>right;</div><div class="line">		free(p);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//case3  删除节点只有左孩子</span></div><div class="line">	<span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">left</span> &amp;&amp; p-&gt;</span>right==NULL)</div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">			*<span class="function"><span class="title">root</span>=p-&gt;</span>left;</div><div class="line">		<span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">value</span> &lt; p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>value)</div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">left</span>=p-&gt;</span>left;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">right</span>=p-&gt;</span>left;</div><div class="line">		free(p);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//case4  删除节点两个子节点都不为空</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		node q=successor(p);</div><div class="line">		<span class="function"><span class="title">temp</span>=q-&gt;</span>value;</div><div class="line">		delete_node(root,temp);</div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span>value=temp;</div><div class="line">	&#125;</div><div class="line">	return <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>实现代码</h1>
<hr>
<p>本来，我只实现了二叉搜索树存储整型值，后来为了拓展用二叉树来存储一个对象，所以将节点值域改为void*类型，这样就可以存储任何类型数据．但是对象类必须实现重载&lt;和+符号，因为代码有比较两个对象的大小．本来打算写个仿函数，但是这样要修改更多的代码．实现代码如下:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;string&gt;</div><div class="line"></div><div class="line">using std::string;</div><div class="line"><span class="comment">//树存储的数据类型</span></div><div class="line"><span class="comment">//typedef int ValueType;</span></div><div class="line"></div><div class="line">struct people&#123;</div><div class="line">	string <span class="keyword">name</span>;</div><div class="line">	int age;</div><div class="line">	bool operator&lt; (struct people &amp;peo)</div><div class="line">	&#123;</div><div class="line">		return age&lt;peo.age;</div><div class="line">	&#125;</div><div class="line">	bool operator== (struct people &amp;peo)</div><div class="line">	&#123;</div><div class="line">		return age==peo.age;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">typedef struct people peo;</div><div class="line">typedef peo* ValueType;</div><div class="line"></div><div class="line">struct bst_node</div><div class="line">&#123;</div><div class="line">	void* value;</div><div class="line">	struct bst_node *parent;</div><div class="line">	struct bst_node *left;</div><div class="line">	struct bst_node *right;</div><div class="line">&#125;;<span class="comment">//树节点类型</span></div><div class="line">typedef struct bst_node* node;</div><div class="line"></div><div class="line">void insert_node(node *root,ValueType <span class="keyword">data</span>)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//初始化节点</span></div><div class="line">	node p=(node)malloc(sizeof(struct bst_node));</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>value=<span class="keyword">data</span>;</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>parent=NULL;</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>left=NULL;</div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>right=NULL;</div><div class="line">	<span class="comment">//如果是空树，则新插入的节点为根节点</span></div><div class="line">	<span class="keyword">if</span>((*root)==NULL)</div><div class="line">	&#123;</div><div class="line">		*root=p;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	node parent=(*root);</div><div class="line">	node tmp=(*root);</div><div class="line">	<span class="comment">//迭代找打要插入的位置</span></div><div class="line">	<span class="keyword">while</span>(tmp!=NULL)</div><div class="line">	&#123;</div><div class="line">		parent=tmp;</div><div class="line">		<span class="function"><span class="title">if</span>((*<span class="keyword">data</span>)==*(ValueType)(tmp-&gt;</span>value))</div><div class="line">			return;</div><div class="line">		<span class="function"><span class="title">if</span>( (*<span class="keyword">data</span>) &lt; *(ValueType)(tmp-&gt;</span>value))</div><div class="line">			<span class="function"><span class="title">tmp</span>=tmp-&gt;</span>left;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="function"><span class="title">tmp</span>=tmp-&gt;</span>right;</div><div class="line">	&#125;</div><div class="line">             <span class="comment">//插入节点</span></div><div class="line">	<span class="function"><span class="title">p</span>-&gt;</span>parent=parent;</div><div class="line">	<span class="function"><span class="title">if</span>(*<span class="keyword">data</span>&lt;*(ValueType)(parent-&gt;</span>value) )</div><div class="line">		<span class="function"><span class="title">parent</span>-&gt;</span>left=p;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="function"><span class="title">parent</span>-&gt;</span>right=p;</div><div class="line"></div><div class="line">&#125;</div><div class="line">node max_node(node root)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(root==NULL)</div><div class="line">		return root;</div><div class="line">	<span class="function"><span class="title">while</span>(root-&gt;</span>right!=NULL)</div><div class="line">		<span class="function"><span class="title">root</span>=root-&gt;</span>right;</div><div class="line">	return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">node min_node(node root)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(root==NULL)</div><div class="line">		return root;</div><div class="line">	<span class="function"><span class="title">while</span>(root-&gt;</span>left!=NULL)</div><div class="line">		<span class="function"><span class="title">root</span>=root-&gt;</span>left;</div><div class="line">	return root;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print_bst(node root)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(root==NULL)</div><div class="line">		return;</div><div class="line">	<span class="function"><span class="title">print_bst</span>(root-&gt;</span>left);</div><div class="line">	V<span class="function"><span class="title">alueType</span> p=(struct people*)root-&gt;</span>value;</div><div class="line">	<span class="function"><span class="title">printf</span>("%s \t %d \n ",(p-&gt;</span><span class="function"><span class="title">name</span>).c_str(),p-&gt;</span>age);</div><div class="line">	<span class="function"><span class="title">print_bst</span>(root-&gt;</span>right);</div><div class="line">&#125;</div><div class="line"></div><div class="line">node find_node(node root,ValueType <span class="keyword">data</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(root==NULL)</div><div class="line">		return NULL;</div><div class="line">	node parent=root,tmp=root;</div><div class="line">	<span class="keyword">while</span>(tmp!=NULL)</div><div class="line">	&#123;</div><div class="line">		parent=tmp;</div><div class="line">		<span class="function"><span class="title">if</span>((*<span class="keyword">data</span>)==*(ValueType)(tmp-&gt;</span>value))</div><div class="line">			return tmp;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="function"><span class="title">if</span>( (*<span class="keyword">data</span>) &lt; *(ValueType)(tmp-&gt;</span>value))</div><div class="line">				<span class="function"><span class="title">tmp</span>=tmp-&gt;</span>left;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				<span class="function"><span class="title">tmp</span>=tmp-&gt;</span>right;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">node predecessor(node p)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(p==NULL)</div><div class="line">		return NULL;</div><div class="line">	<span class="function"><span class="title">if</span>(p-&gt;</span>left)</div><div class="line">		<span class="function"><span class="title">return</span> max_node(p-&gt;</span>left);</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">			return NULL;</div><div class="line">		<span class="keyword">while</span>(p)&#123;</div><div class="line">			<span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>right==p)</div><div class="line">				break;</div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>parent;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="title">return</span> p-&gt;</span>parent;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">node successor(node p)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(p==NULL)</div><div class="line">		return NULL;</div><div class="line">	<span class="function"><span class="title">if</span>(p-&gt;</span>right)</div><div class="line">		<span class="function"><span class="title">return</span> min_node(p-&gt;</span>right);</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">			return NULL;</div><div class="line">		<span class="keyword">while</span>(p)&#123;</div><div class="line">			<span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>left==p)</div><div class="line">				break;</div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>parent;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="title">return</span> p-&gt;</span>parent;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int delete_node(node *root,ValueType <span class="keyword">data</span>)</div><div class="line">&#123;</div><div class="line">	node p=find_node((*root),<span class="keyword">data</span>);</div><div class="line">	<span class="comment">//如果没找到，返回空节点</span></div><div class="line">	<span class="keyword">if</span>(p==NULL)</div><div class="line">		return <span class="number">0</span>;</div><div class="line">	<span class="comment">//case1  删除节点的两个子树同时为空</span></div><div class="line">	<span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">left</span>==NULL &amp;&amp; p-&gt;</span>right==NULL)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">//如果只有一个节点，即根节点</span></div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">		&#123;</div><div class="line">			free(p);</div><div class="line">			(*root)=NULL;</div><div class="line">		&#125;<span class="keyword">else</span><span class="comment">//普通叶子节点</span></div><div class="line">		&#123;</div><div class="line">			<span class="comment">//删除节点是父节点的左孩子</span></div><div class="line">			<span class="function"><span class="title">if</span>(*(ValueType)(p-&gt;</span><span class="function"><span class="title">value</span>)&lt;*(ValueType)(p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>value))</div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>left=NULL;</div><div class="line">			<span class="keyword">else</span><span class="comment">//删除节点是父节点的右孩子</span></div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>right=NULL;</div><div class="line">			free(p);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//case2  删除节点只有右孩子</span></div><div class="line">	<span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">left</span>==NULL &amp;&amp; p-&gt;</span>right)</div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">right</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">			*<span class="function"><span class="title">root</span>=p-&gt;</span>right;</div><div class="line">		<span class="function"><span class="title">else</span> <span class="keyword">if</span>(*(ValueType)(p-&gt;</span><span class="function"><span class="title">value</span>)&lt;*(ValueType)(p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>value))</div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">left</span>=p-&gt;</span>right;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">right</span>=p-&gt;</span>right;</div><div class="line">		free(p);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//case3  删除节点只有左孩子</span></div><div class="line">	<span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">left</span> &amp;&amp; p-&gt;</span>right==NULL)</div><div class="line">	&#123;</div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">left</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">		<span class="function"><span class="title">if</span>(p-&gt;</span>parent==NULL)</div><div class="line">			*<span class="function"><span class="title">root</span>=p-&gt;</span>left;</div><div class="line">		<span class="function"><span class="title">else</span> <span class="keyword">if</span>(*(ValueType)(p-&gt;</span><span class="function"><span class="title">value</span>)&lt;*(ValueType)(p-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span>value))</div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">left</span>=p-&gt;</span>left;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">parent</span>-&gt;</span><span class="function"><span class="title">right</span>=p-&gt;</span>left;</div><div class="line">		free(p);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//case4  删除节点两个子节点都不为空</span></div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		node q=successor(p);</div><div class="line">		V<span class="function"><span class="title">alueType</span> temp=(ValueType)q-&gt;</span>value;</div><div class="line">		delete_node(root,temp);</div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span>value=temp;</div><div class="line">	&#125;</div><div class="line">	return <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	int i=<span class="number">0</span>;</div><div class="line">	node root=NULL,tmp=NULL;</div><div class="line">	peo arr[<span class="number">5</span>]=&#123;&#123;<span class="string">"jason"</span>,<span class="number">8</span>&#125;,&#123;<span class="string">"tom"</span>,<span class="number">3</span>&#125;,&#123;<span class="string">"bob"</span>,<span class="number">5</span>&#125;,&#123;<span class="string">"helly"</span>,<span class="number">7</span>&#125;,&#123;<span class="string">"Lily"</span>,<span class="number">1</span>&#125;&#125;;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">		insert_node(&amp;root,arr+i);</div><div class="line">	print_bst(root);</div><div class="line">	printf(<span class="string">"\n"</span>);</div><div class="line">              <span class="function"><span class="title">printf</span>("The max node <span class="keyword">is</span>=%s\n",(ValueType(max_node(root)-&gt;</span><span class="function"><span class="title">value</span>))-&gt;</span><span class="keyword">name</span>.c_str());</div><div class="line">	<span class="function"><span class="title">printf</span>("The min node <span class="keyword">is</span>=%s \n",(ValueType(min_node(root)-&gt;</span><span class="function"><span class="title">value</span>))-&gt;</span><span class="keyword">name</span>.c_str());</div><div class="line">              peo v=&#123;<span class="string">"tom"</span>,<span class="number">3</span>&#125;;</div><div class="line">	node p=find_node(root,&amp;v);</div><div class="line">	tmp=predecessor(p);</div><div class="line">	<span class="keyword">if</span>(tmp==NULL)</div><div class="line">		printf(<span class="string">"The node has no predecessor!\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="function"><span class="title">printf</span>("The predecessor of 3 <span class="keyword">is</span>=%s\n",( (ValueType)(tmp-&gt;</span><span class="function"><span class="title">value</span>) )-&gt;</span><span class="keyword">name</span>.c_str());</div><div class="line">	tmp=successor(p);</div><div class="line">	<span class="keyword">if</span>(tmp==NULL)</div><div class="line">		printf(<span class="string">"The node has no successor!\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="function"><span class="title">printf</span>("The successor of 3 <span class="keyword">is</span>=%s\n",( (ValueType)(tmp-&gt;</span><span class="function"><span class="title">value</span>) )-&gt;</span><span class="keyword">name</span>.c_str());</div><div class="line">	int flag=delete_node(&amp;root,&amp;v);</div><div class="line">	<span class="keyword">if</span>(!flag)</div><div class="line">		printf(<span class="string">"There is no node of 3!\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		print_bst(root);</div><div class="line">	return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下:
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~/mydir/algorithm$ g++ bst2.cc -o bst2</div><div class="line">charles@charles-Lenovo:~/mydir/algorithm$ ./bst2</div><div class="line">Lily 	<span class="number"> 1 </span></div><div class="line">tom 	<span class="number"> 3 </span></div><div class="line">bob 	<span class="number"> 5 </span></div><div class="line">helly 	<span class="number"> 7 </span></div><div class="line">jason 	<span class="number"> 8 </span></div><div class="line"></div><div class="line">The max node is=jason</div><div class="line">The min node is=Lily </div><div class="line">The predecessor of<span class="number"> 3 </span>is=Lily</div><div class="line">The successor of<span class="number"> 3 </span>is=bob</div><div class="line">Lily 	<span class="number"> 1 </span></div><div class="line">bob 	<span class="number"> 5 </span></div><div class="line">helly 	<span class="number"> 7 </span></div><div class="line">jason 	<span class="number"> 8 </span></div><div class="line">charles@charles-Lenovo:~/mydir/algorithm$</div></pre></td></tr></table></figure></p>
<p>可以看到二叉树是按年龄从小到大输出这些对象，以及其他操作也是和普通整型时，输出的一样．</p>
]]></content>
      
        <categories>
            
            <category> data_structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> bst </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STL源码分析之deque]]></title>
      <url>http://luodw.cc/2015/11/04/STL-deque/</url>
      <content type="html"><![CDATA[<p>在C++标准模板库序列式容器中,使用最少的估计就是deque,因为平常使用最多的就是用一个可增长的空间来保存数据,而vector,list几乎都可以实现这些功能,所以就很少使用deque如何使用.但是deque这种双端队列,特别是了解这种数据结构的底层实现是很有帮助的.stack和queue这两种容器,不对,正确叫法应该是容器适配器,因为这两种容器底层是调用其他容器,他俩只是提供先进后出和先进先出的接口而已.这两种容器底层实现默认就是用deque.</p>
<p>deque底层实现相对vector和list更难.deque底层实现一个中控器,即一个指针数组,用于存储所有缓冲区的首地址.迭代器由四个部分组成cur|first|last|node:</p>
<ol>
<li>cur指向缓冲区当前元素.</li>
<li>first指向缓冲区的第一个位置.</li>
<li>last指向末节点,即最后一个元素的下一个位置</li>
<li>node指向主控器相应的索引位置.</li>
</ol>
<p>可以看下deque示意图,取自<strong>STL源码剖析</strong>
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_034.png" alt="deque示意图"></p>
<h1>deque 迭代器</h1>
<hr>
<p>deque迭代器也是一种Ramdon Access Iterator,但是它并不是普通指针,而是实现了迭代器+n式的移动.因为迭代器自增运算时,可能夸缓冲区,所以迭代器实现++运算时,还需判断是否跨缓冲区.</p>
<p>来看下迭代器:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr, <span class="keyword">size_t</span> BufSiz&gt;</div><div class="line"><span class="keyword">struct</span> __deque_iterator &#123; 	<span class="comment">// 未继承 std::iterator</span></div><div class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;      iterator;</div><div class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</div><div class="line">  <span class="function"><span class="keyword">static</span> size_t <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(T)); &#125;</div><div class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></div><div class="line">  <span class="comment">//因为为random_access_iterator,所以必须实现+n运算</span></div><div class="line">  <span class="keyword">typedef</span> T value_type; 				<span class="comment">// (2)</span></div><div class="line">  <span class="keyword">typedef</span> Ptr pointer; 				<span class="comment">// (3)</span></div><div class="line">  <span class="keyword">typedef</span> Ref reference; 				<span class="comment">// (4)</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; 	<span class="comment">// (5)</span></div><div class="line">  <span class="keyword">typedef</span> T** map_pointer;<span class="comment">//指向主控器的指针</span></div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> __deque_iterator self;<span class="comment">//泛型编程时,内部无需添加泛型参数</span></div><div class="line"></div><div class="line">  <span class="comment">// 以下四个就是一个迭代器对象的成员</span></div><div class="line">  T* cur;	<span class="comment">// 此迭代器所指之缓冲区的现行（current）元素</span></div><div class="line">  T* first;	<span class="comment">// 此迭代器所指之缓冲区的头</span></div><div class="line">  T* last;	<span class="comment">// 此迭代器所指之缓冲区的尾（含备用空间）</span></div><div class="line">  map_pointer node;</div></pre></td></tr></table></figure></p>
<p>以上就是跌迭代器内嵌型别和成员声明.关键是迭代器的类型random_access_iterator,以及四个成员变量.来看下迭代器的构造函数:</p>
<p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用一个T类型数据和指向主控器的指针来初始化一个迭代器</span></div><div class="line"><span class="selector-tag">__deque_iterator</span>(T* x, map_pointer y) </div><div class="line">  : <span class="selector-tag">cur</span>(x), <span class="selector-tag">first</span>(*y), <span class="selector-tag">last</span>(*y + buffer_size()), <span class="selector-tag">node</span>(y) &#123;&#125;</div><div class="line"><span class="comment">//创建一个空的迭代器</span></div><div class="line"><span class="selector-tag">__deque_iterator</span>() : <span class="selector-tag">cur</span>(<span class="number">0</span>), <span class="selector-tag">first</span>(<span class="number">0</span>), <span class="selector-tag">last</span>(<span class="number">0</span>), <span class="selector-tag">node</span>(<span class="number">0</span>) &#123;&#125;</div><div class="line"><span class="comment">//迭代器的复制构造函数</span></div><div class="line"><span class="selector-tag">__deque_iterator</span>(const iterator&amp; x)</div><div class="line">  : <span class="selector-tag">cur</span>(x.cur), <span class="selector-tag">first</span>(x.first), <span class="selector-tag">last</span>(x.last), <span class="selector-tag">node</span>(x.node) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>接下来看下迭代器各个重载运算算子:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//迭代器解引用运算,返回迭代器目前指向的元素</span></div><div class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</div><div class="line"><span class="comment">//重载指针运算符,返回当前元素的地址指针</span></div><div class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</div><div class="line"><span class="comment">//返回两个迭代器的距离</span></div><div class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +</div><div class="line">    (cur - first) + (x.last - x.cur);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三个计算迭代器间的距离时,一定要注意不是简单的迭代器相减,因为迭代器间的距离是指两个迭代器间所有元素的个数,所以计算要把两个迭代器间所有数据都计算出来.</p>
<p>接下来是迭代器的一些++,--,+n,-n,==,!=重载运算,举几个例子:
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">self&amp; <span class="keyword">operator</span>++() &#123;</div><div class="line">    ++cur;				</div><div class="line">    <span class="keyword">if</span> (cur == last) &#123;		</div><div class="line">      set_node(node + <span class="number">1</span>);	</div><div class="line">      cur = first;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </div><div class="line">  &#125;</div><div class="line">  self <span class="keyword">operator</span>++(int)  &#123;</div><div class="line">    self tmp = *<span class="keyword">this</span>;</div><div class="line">    ++*<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如果当前迭代器cur!=last,则直接++cur即可.如果++cur之后,cur==last,说明这是这个缓存区的最后一个元素,则这个迭代器要跳到下一个缓存区的第一个元素.第二个函数是后++式标准写法,返回++之前的元素.</p>
<p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">self&amp; operator+=(difference_type n) &#123;</div><div class="line">   difference_type <span class="keyword">offset</span> = n + (cur - first);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">offset</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">offset</span> &lt; difference_type(buffer_size()))</div><div class="line">     <span class="comment">// 目标在同一个缓存区内,直接cur指针+n即可</span></div><div class="line">     cur += n;</div><div class="line">   <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">// 目标位置不在同一个缓存区内</span></div><div class="line">     difference_type node_offset =</div><div class="line">       <span class="keyword">offset</span> &gt; <span class="number">0</span> ? <span class="keyword">offset</span> / difference_type(buffer_size())</div><div class="line">                  : -difference_type((-<span class="keyword">offset</span> - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;</div><div class="line">     <span class="comment">// 切换至正确的节点）</span></div><div class="line">     set_node(node + node_offset);</div><div class="line">     <span class="comment">// 切换到正确的元素</span></div><div class="line">     cur = first + (<span class="keyword">offset</span> - node_offset * difference_type(buffer_size()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> *this;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>+=n运算关键是要判断+n之后的索引是否还在当前缓冲区内,如果在,cur简单+n即可.如果不在,则要计算正确的缓存节点和正确的元素位置.其他+n,-=n,-运算都可以通过+=运算得出.</p>
<p>还有三个迭代器等式运算:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>从[]号运算符的函数定义可以看出,[n]是相对于当前迭代器的位置.</p>
<h1>deque类</h1>
<hr>
<p>deque标准模板库有成员有一个主控器和两个迭代器,一个指向第一个缓冲区,一个指向最后一个缓冲区.定义如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">typedef</span> pointer* map_pointer;	</div><div class="line">  <span class="comment">// 专属配置器,一次分配一个元素</span></div><div class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</div><div class="line">  <span class="comment">// 专属配置器,一次分配一个指标大小</span></div><div class="line">  <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</div><div class="line">  <span class="comment">//获得缓存区的大小</span></div><div class="line">  <span class="function"><span class="keyword">static</span> size_type <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="keyword">sizeof</span>(value_type));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;<span class="comment">//默认map的大小,即指针个数</span></div><div class="line"></div><div class="line"><span class="keyword">protected</span>:                      </div><div class="line">  iterator start;		<span class="comment">// 表示第一个迭代器</span></div><div class="line">  iterator finish;	<span class="comment">// 表示最后一个迭代器</span></div><div class="line"></div><div class="line">  map_pointer <span class="built_in">map</span>;	<span class="comment">// 指向主控器,即缓冲区的首地址指针数组</span></div><div class="line">                          </div><div class="line">  size_type map_size;	<span class="comment">// map容纳指针的个数</span></div></pre></td></tr></table></figure></p>
<h2>默认构造函数</h2>
<p>分析一个类,首先从构造函数开始,因为这是用户使用这个类的最开始的步骤.
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">deque</span>()</div><div class="line">  : <span class="selector-tag">start</span>(), <span class="selector-tag">finish</span>(), <span class="selector-tag">map</span>(<span class="number">0</span>), <span class="selector-tag">map_size</span>(<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">  <span class="selector-tag">create_map_and_nodes</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认构造函数先初始化两个迭代器为空迭代器,然后map和map_size为0,接着调用 create_map_and_nodes(size_type num_elements)来初始化一块内存.如下:</p>
<ol>
<li>先根据num_elements来确定主控器节点的个数num_nodes,节点的个数是(初始化的8和num_nodes的最大值.</li>
<li>调用map_allocator分配节点个数(初始化为8),并将指针赋值给map.</li>
<li>然后设置nstart,nfinish为主控器中间节点(即第4个节点).</li>
<li>然后为[nstart,nfinish]之间的节点分配缓冲区,即调用allocate_node.</li>
<li>将first和finish设置为nstart和nfinish.</li>
<li>设置start.cur和finish.cur</li>
</ol>
<p>调用默认构造函数时,生成长度为8的缓冲区地址数组,然后start和finish指向第4个节点,并为第4个节点分配缓冲区.接下来就可以插入数据了.</p>
<h2>由n个value初始化的构造函数</h2>
<p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">deque</span>(size_type n, const value_type&amp; value)</div><div class="line">   : <span class="selector-tag">start</span>(), <span class="selector-tag">finish</span>(), <span class="selector-tag">map</span>(<span class="number">0</span>), <span class="selector-tag">map_size</span>(<span class="number">0</span>)</div><div class="line"> &#123;</div><div class="line">   <span class="selector-tag">fill_initialize</span>(n, value);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这个构造函数调用fill_initialize函数来初始化deque,在fill_initialize(size_type n,
const value_type&amp; value)函数中,</p>
<ol>
<li>先调用函数create_map_and_nodes(n)分配好需要的缓冲区</li>
<li>然后调用unitialized_fii来初始后缓冲区.</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</div><div class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::fill_initialize(size_type n,</div><div class="line">                                               <span class="keyword">const</span> value_type&amp; value) &#123;</div><div class="line">  create_map_and_nodes(n);	 <span class="comment">// 先分配好缓冲区</span></div><div class="line">  map_pointer cur;</div><div class="line">  __STL_TRY &#123;</div><div class="line">    <span class="comment">// 为每个节点的缓冲区设定初值</span></div><div class="line">    <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</div><div class="line">      uninitialized_fill(*cur, *cur + buffer_size(), value);</div><div class="line">    <span class="comment">// 最后一个节点区别对待,因为最后一个节点不一定满元素</span></div><div class="line">    uninitialized_fill(finish.first, finish.cur, value);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2>两队迭代器初始化的构造函数</h2>
<p>较为典型,还有一种是用一对迭代器来初始化deque:
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;<span class="built_in">class</span> InputIterator&gt;</div><div class="line">deque(InputIterator <span class="keyword">first</span>, InputIterator <span class="keyword">last</span>)</div><div class="line">  : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">  range_initialize(<span class="keyword">first</span>, <span class="keyword">last</span>, iterator_category(<span class="keyword">first</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个构造函数调用range_initialize来用迭代器范围内的元素初始化deque.range_initialize,根据迭代器类型,调用相应的版本,random_access_iterator调用的是如下版本:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator&gt;</div><div class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::range_initialize(ForwardIterator first,</div><div class="line">                                                ForwardIterator last,</div><div class="line">                                                forward_iterator_tag) &#123;</div><div class="line">  size_type n = <span class="number">0</span>;</div><div class="line">  distance(first, last, n);<span class="comment">//n个元素</span></div><div class="line">  create_map_and_nodes(n);<span class="comment">//创建缓冲区空间</span></div><div class="line">  __STL_TRY &#123;</div><div class="line">    uninitialized_copy(first, last, start);<span class="comment">//初始化缓冲区</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1>析构函数</h1>
<p>析构函数先是调用destroy函数析构缓冲区的数据,然后调用destroy_map_and_nodes函数析构缓冲区和主控器内存
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">~<span class="selector-tag">deque</span>() &#123;</div><div class="line">  <span class="selector-tag">destroy</span>(start, finish);</div><div class="line">  <span class="selector-tag">destroy_map_and_nodes</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>push_back和pop_back函数</h1>
<p>以下是一些常用的函数,push_back,pop_back等等...
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123; </div><div class="line">     <span class="comment">// 最后缓冲区还有大于等于1个元素空间</span></div><div class="line">     construct(finish.cur, t);	<span class="comment">// 直接在备用空间上赋值</span></div><div class="line">     ++finish.cur;	<span class="comment">// 调整最后一个缓存区的cur</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span>  <span class="comment">// 最后缓冲区只有一个元素空间了</span></div><div class="line">     push_back_aux(t);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>该当插入数据时,</p>
<ol>
<li>要先判断是否为最后一个缓冲区的最后一个空间,如果是,需要调用push_back_aux来插入数据.</li>
<li>在push_back_aux函数中先要判断主控器是否还有空间,如果没有,则需要调用reserve_map_at_back()来重新开一块内存.</li>
<li>在reserver_map_at_back函数内,将就map数据拷贝到新map,接着还需要把旧map回收了.</li>
<li>为finish.node下一个节点分配缓冲区</li>
<li>赋值,更新finish,指向下一个节点</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</div><div class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::push_back_aux(<span class="keyword">const</span> value_type&amp; t) &#123;</div><div class="line">  value_type t_copy = t;</div><div class="line">  reserve_map_at_back();		<span class="comment">//符合某种条件必须换个map</span></div><div class="line">  *(finish.node + <span class="number">1</span>) = allocate_node();	<span class="comment">// 配置一个新节点</span></div><div class="line">  __STL_TRY &#123;</div><div class="line">    construct(finish.cur, t_copy);		<span class="comment">// 元素赋值</span></div><div class="line">    finish.set_node(finish.node + <span class="number">1</span>);	<span class="comment">// 改变finish,令其指向下一个节点</span></div><div class="line">    finish.cur = finish.first;			<span class="comment">// 设定finish状态</span></div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来看下pop_back函数,即从尾部弹出一个元素;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (finish.cur != finish.first) &#123;</div><div class="line">    <span class="comment">// 最后一个缓冲区还有一个或更多的元素</span></div><div class="line"></div><div class="line">    --finish.cur;		<span class="comment">// 调整指标,相当于删除最后一个元素</span></div><div class="line">    destroy(finish.cur);	<span class="comment">// 将最后一个元素析构</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="comment">// 最后缓冲区没有元素</span></div><div class="line">    pop_back_aux();		<span class="comment">// 这里将进行释放缓冲区操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>pop_back_aux函数中</p>
<ol>
<li>先是释放最后一个缓冲区的内存</li>
<li>更新finish指标,指向前一个节点</li>
<li>析构当前缓冲区最后一个元素</li>
</ol>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</div><div class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::pop_back_aux() &#123;</div><div class="line">  deallocate_node(finish.first);	<span class="comment">// 释放最后一个缓冲区</span></div><div class="line">  finish.set_node(finish.node - <span class="number">1</span>);	<span class="comment">// 调整finish指标,使其指向</span></div><div class="line">  finish.cur = finish.last - <span class="number">1</span>;		<span class="comment">//  上一个缓冲区的最后一个元素</span></div><div class="line">  destroy(finish.cur);				<span class="comment">// 析构最后那个元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有push_front和pop_front函数,思想和push_back和pop_back思想一样,都要判断是否要跨越缓冲区,这里不做介绍.</p>
<h1>earse函数</h1>
<p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">iterator erase(iterator pos) &#123;</div><div class="line">    iterator <span class="keyword">next</span> = pos;</div><div class="line">    ++<span class="keyword">next</span>;</div><div class="line">    difference_type index = pos - start;	<span class="regexp">//</span> 清除点之前的元素个数</div><div class="line">    <span class="keyword">if</span> (index &lt; (size() <span class="meta">&gt;&gt; </span><span class="number">1</span>)) &#123;			<span class="regexp">//</span> 如果清楚点之前的元素比较少，</div><div class="line">      copy_backward(start, pos, <span class="keyword">next</span>);	<span class="regexp">//</span> 就搬移清除点之前的元素</div><div class="line">      pop_front();				<span class="regexp">//</span> 搬移完毕,删除最后一个元素</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;					<span class="regexp">//</span> 清除点之后元素比较少</div><div class="line">      copy(<span class="keyword">next</span>, finish, pos);	<span class="regexp">//</span> 就搬移清除点之后的元素</div><div class="line">      pop_back();				<span class="regexp">//</span> 搬移完毕,删除最后一个元素</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start + index;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数可能难看懂,主要是因为迭代器不是普通指针,所以看的时候,要考虑到迭代器的运算.还有个  iterator erase(iterator first, iterator last);函数思想类似...</p>
<h1>insert函数</h1>
<p>最后再说下insert函数,insert函数有好几个版本,这里只介绍最简单的版本:
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">iterator insert(iterator <span class="built_in">position</span>, <span class="keyword">const</span> value_type&amp; x) &#123;</div><div class="line">  <span class="built_in">if</span> (<span class="built_in">position</span>.cur == start.cur) &#123;	<span class="comment">// 如果是安插在队列最前段</span></div><div class="line">    push_front(x);				<span class="comment">// 交给push_front 去做</span></div><div class="line">    <span class="built_in">return</span> start;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">else</span> <span class="built_in">if</span> (<span class="built_in">position</span>.cur == finish.cur) &#123; <span class="comment">// 如果安插点是deque 最尾端</span></div><div class="line">    push_back(x);					  <span class="comment">// 交给push_back 去做</span></div><div class="line">    iterator tmp = finish;</div><div class="line">    --tmp;</div><div class="line">    <span class="built_in">return</span> tmp;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">else</span> &#123;</div><div class="line">    <span class="built_in">return</span> insert_aux(<span class="built_in">position</span>, x);	 	<span class="comment">// 交给 insert_aux 去做</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来看下insert_aux,也是根据插入点前后元素个数比较来决定向前或向后移动.</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc, <span class="keyword">size_t</span> BufSize&gt;</div><div class="line"><span class="keyword">typename</span> <span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::iterator</div><div class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;</div><div class="line">  difference_type index = pos - start;	<span class="comment">// 安插点之前的元素个数</span></div><div class="line">  value_type x_copy = x;</div><div class="line">  <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;			<span class="comment">// 如果安插点之前元素个数较少</span></div><div class="line">    push_front(front());			<span class="comment">// 在最前端加入与第一元素同值的元素。</span></div><div class="line">    iterator front1 = start;		<span class="comment">// 以下标识记号,然后搬移元素</span></div><div class="line">    ++front1;</div><div class="line">    iterator front2 = front1;</div><div class="line">    ++front2;</div><div class="line">    pos = start + index;</div><div class="line">    iterator pos1 = pos;</div><div class="line">    ++pos1;</div><div class="line">    copy(front2, pos1, front1);		<span class="comment">// 元素搬移</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;						<span class="comment">// 安插点之后的元素个数比较少</span></div><div class="line">    push_back(back());			<span class="comment">// 在最尾端加入与最後元素同值的元素。</span></div><div class="line">    iterator back1 = finish;	<span class="comment">// 以下标识记号然后搬移元素...</span></div><div class="line">    --back1;</div><div class="line">    iterator back2 = back1;</div><div class="line">    --back2;</div><div class="line">    pos = start + index;</div><div class="line">    copy_backward(pos, back2, back1);	<span class="comment">// 元素搬移</span></div><div class="line">  &#125;</div><div class="line">  *pos = x_copy;	<span class="comment">// 在安插点设定新值</span></div><div class="line">  <span class="keyword">return</span> pos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>insert函数还有好几个版本</p>
<ol>
<li>
<p>iterator insert(iterator position) { return insert(position, value_type()); }</p>
</li>
<li>
<p>void insert(iterator pos, size_type n, const value_type&amp; x);</p>
</li>
<li>
<p>void insert(iterator pos, int n, const value_type&amp; x) {
insert(pos, (size_type) n, x);
}</p>
</li>
<li>
<p>void insert(iterator pos, long n, const value_type&amp; x) {
insert(pos, (size_type) n, x);
}</p>
</li>
<li>
<p>void insert(iterator pos, InputIterator first, InputIterator last) {
insert(pos, first, last, iterator_category(first));
}</p>
</li>
<li>
<p>void insert(iterator pos, const value_type* first, const value_type* last);</p>
</li>
<li>
<p>void insert(iterator pos, const_iterator first, const_iterator last);</p>
</li>
</ol>
<p>deque暂时说到这,基本用法大概都有说到了...</p>
]]></content>
      
        <categories>
            
            <category> STL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
            <tag> deque </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析补充之Compaction]]></title>
      <url>http://luodw.cc/2015/11/04/leveldb-20/</url>
      <content type="html"><![CDATA[<p>之前打算不看leveldb compaction部分,后来想想,都看了大部分,就差个compaction不看,感觉很不完整,所以还是打算把compaction大概流程写下,后面回头看时,也会有思路</p>
<p>leveldb有两种compaction,一个是minor compaction,就是将immemtable数据写回到磁盘的过程,一种是major compaction,即将某一层某个文件和上一层的几个文件合并的过程.</p>
<p>当向memtable插入数据时,首先会检查是否有空间插入数据,如果有,则继续插入,如果memtable的size达到事先定义好的阈值,则需要进行一次minor compaction;而每进行一次minor compaction时,又要进行一次是否需要major compaction的判断,因为产生一次minor compaction时,可能第0层文件超过8(系统定义,可以自定义),则就需要major compaction了.</p>
<p>在Write函数中,每次插入会进行一次空间需求是否满足的判断;
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Status status</span> = MakeRoomForWrite(my_batch == NULL);</div></pre></td></tr></table></figure></p>
<p>在MakeRoomForWrite函数中:</p>
<ol>
<li>先判断是否有后台合并错误,如果有,则啥都不做,如果没有,则执行2;</li>
<li>如果后台没错误,则判断mem_的大小是是否小于事先定义阈值,如果是,则啥都不做返回,继续插入数据,如果大于事先定义的阈值,则需要进行一次合并;</li>
<li>如果imm_不为空,所以后台有线程在执行合并,在此等待;</li>
<li>如果0层文件个数太多,则也需要等待;</li>
<li>如果都不是以上情况,则进程一次合并,调用MaybeScheduleCompaction()函数;</li>
</ol>
<p>说明下为什么会有第4点,因为没进行一次minor compaction,0层文件个数可能超过事先定义的值,所以会又进行一次major compcation,而这次major compaction,imm_是空的,所以才会有第4条判断.</p>
<p>在MaybeScheduleCompaction()函数中,也需要进行判断;</p>
<ol>
<li>后台是否有线程在合并,有,则啥都不做,没有的话,执行2</li>
<li>判断数据库是否为删除,后台合并是否出现错误等;</li>
<li>如果上述情况都没问题,就真正调度一个线程执行合并操作.</li>
</ol>
<p>源码如下;
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void DBImpl::MaybeScheduleCompaction() &#123;</div><div class="line">  mutex_.AssertHeld();</div><div class="line">  <span class="keyword">if</span> (bg_compaction_scheduled_) &#123;</div><div class="line">    <span class="comment">// Already scheduled</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.Acquire_Load()) &#123;</div><div class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</div><div class="line">    <span class="comment">// Already got an error; no more changes</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="keyword">NULL</span> &amp;&amp;</div><div class="line">             manual_compaction_ == <span class="keyword">NULL</span> &amp;&amp;</div><div class="line">             !versions_-&gt;NeedsCompaction()) &#123;</div><div class="line">    <span class="comment">// No work to be done</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    bg_compaction_scheduled_ = <span class="keyword">true</span>;</div><div class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, this);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>env_-&gt;Schedule这个函数是系统封装类,写的一个调用线程的函数,主要功能就是调用BGWork这个函数.BGWork这个函数最终调用的是BackgroundCall()
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DBImpl::BGWork(<span class="keyword">void</span>* db) &#123;</div><div class="line">  <span class="keyword">reinterpret_cast</span>&lt;DBImpl*&gt;(db)-&gt;BackgroundCall();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BackgroundCall()函数源码如下;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DBImpl::BackgroundCall() &#123;</div><div class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</div><div class="line">  assert(bg_compaction_scheduled_);</div><div class="line">  <span class="keyword">if</span> (shutting_down_.Acquire_Load()) &#123;</div><div class="line">    <span class="comment">// No more background work when shutting down.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</div><div class="line">    <span class="comment">// No more background work after a background error.</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    BackgroundCompaction();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  bg_compaction_scheduled_ = <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></div><div class="line">  <span class="comment">// so reschedule another compaction if needed.</span></div><div class="line">  MaybeScheduleCompaction();</div><div class="line">  bg_cv_.SignalAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个函数中,如果后台没有其他线程执行且没有后台错误,则执行BackgroundCompaction()函数做后台合并操作.然后将bg_compaction_scheduled_设为false,标识没有后台执行了,其他线程可以进行执行;因为执行一次合并操作之后,可能导致其他层文件个数过多,所以有可能再进行一次合并.最后唤醒所有在MakeRoomForWrite函数中等待的线程.</p>
<p>在BackgroundCompaction函数中,先判断是否为人工合并,即用户调用CompactRange函数.如果是则,则调用人工合并的函数,如果不是,则调用自动合并函数.</p>
<ol>
<li>对于人工合并,调用的是Version_set::CompactRange函数,</li>
</ol>
<ul>
<li>先获取在指定层内,与给定键范围[begin,end)有重叠的文件集合,</li>
<li>然后根据(大于0层)每一层文件最大的容量,设置合并文件的个数;</li>
<li>新建COmpaction类,设置合并文件集合,调用SetupOtherInputs函数;</li>
</ul>
<p>在SetupOtherInputs函数中,主要是扩展了合并键值范围,其实就是level+1层需要合并的文件,并设置了这次合并的最大键值</p>
<ol start="2">
<li>对于自动合并,则调用VersionSet::PickCompaction()函数,</li>
</ol>
<ul>
<li>根据size_compaction或者seek_compaction来设置需要合并的层数以及需要合并的文件</li>
<li>调用SetupOtherInputs()函数设置上一层需要合并的文件,设置这层合并最大键值,即 compact_pointer_[level] = largest.Encode().ToString();</li>
</ul>
<p>设置好compaction对象的level和level+1层需要合并的文件之后,先判断是否只需要移动一个文件即可,如果是,从level移动一个文件到level+1,否则执行真正的合并.真正合并调用的是DoCompactionWork(CompactionState*)函数.</p>
<h1>DoCompactionWork函数</h1>
<ol>
<li>在DoCompactionWork函数中,先将两个集合的文件合并称一个迭代器;</li>
<li>迭代每一个需要合并的文件,删除键值相同,较早时间那个键值对;</li>
<li>删除键类型为kTypeDelete类型的键值;</li>
<li>把除了2,3步涉及的键值之外的键值写入新生成的文件;</li>
<li>判断新生成的文件大小是否大于一定值,如果是,则将这个文件内容刷新到磁盘</li>
<li>等所有键值都写到文件,文件都刷新到磁盘后,调用函数DBImpl::InstallCompactionResults版本更新,因为文件个数,编号产生了变动,所以要新生成一个版本.</li>
</ol>
<h1>InstallCompactionResults函数</h1>
<p>在这个函数里面,主要操作是将用一个edit保存所有需要删除的文件(之前合并的文件),添加合并产生的文件,最后调用Version_set::LogAndApply函数新生成一个版本.</p>
<p>在DoCompactionWork函数结束之后,需要几个扫尾工作.</p>
<ol>
<li>CleanupCompaction(compact); 删除CompactionState这个合并状态对象占有的资源;</li>
<li>c-&gt;ReleaseInputs(); 删除上一个版本;</li>
<li>DeleteObsoleteFiles(); 删除磁盘上过期的文件.</li>
</ol>
<p>leveldb合并就暂且说到这,总结下:</p>
<blockquote>
<p>当memtable达到一定大小时,会将mem赋值给imm_,然后重新生成一个memtable用于重新插入数据,同时生成一个新的log文件.接着imm_会写入level0文件.如果因为这次写,导致level0文件数量过多,要进行一次磁盘文件合并.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> compaction </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析补充之布隆过滤器]]></title>
      <url>http://luodw.cc/2015/11/02/leveldb-19/</url>
      <content type="html"><![CDATA[<p>之前分析leveldb时,忘了分析过滤器.简单的说,leveldb的过滤器主要作用是当从磁盘数据时,可以通过过滤器先判断读取的键值是否在读取的data block中,如果在,则读取,如果不在,则直接空值返回,在一定程度上较少了磁盘IO.</p>
<p>再介绍布隆过滤器之前,先介绍下位开关,很有意思的位运算.</p>
<h1>位运算</h1>
<hr>
<p>假如有20个开关,控制着20掌灯.我们可以通过输入序号,来控制灯的开关,这就是位运算.编程时,最关键的操作就是要找到设置的位在哪,先看下这个小程序:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits[<span class="number">4</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_on</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_close</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	set_on(<span class="number">25</span>);</div><div class="line">	print(<span class="number">25</span>);</div><div class="line">	set_close(<span class="number">25</span>);</div><div class="line">	print(<span class="number">25</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_on</span><span class="params">(<span class="keyword">int</span> pos)</span></span></div><div class="line">&#123;</div><div class="line">	bits[pos/<span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (pos%<span class="number">8</span>) );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_close</span><span class="params">(<span class="keyword">int</span> pos)</span></span></div><div class="line">&#123;</div><div class="line">	bits[pos/<span class="number">8</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (pos%<span class="number">8</span>) );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> pos)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span>  b = ( bits[pos/<span class="number">8</span>]  &amp;  (<span class="number">1</span>&lt;&lt;(pos%<span class="number">8</span>) ) )&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个程序,用char bits[4]来表示32个位,然后打开某个位时,</p>
<ol>
<li>先通过pos/8找到在哪个字节;</li>
<li>通过pos%8找到在哪个位;</li>
<li>然后把相应的位设置为1.</li>
</ol>
<p>当关闭某个位时,直接把(1 &lt;&lt; (pos%8) ) 取反,再与那个字节与运算即可</p>
<h1>leveldb布隆过滤器</h1>
<hr>
<p>leveldb的布隆过滤器思想是,如果有某条过滤信息有n个键,则可以设置n*bits_per_key个位,然后对每个键进行n次运算,得到n个值,然后设置n个值为1即可.当验证时,则对查找的键也是进行n此运算,得到n各数,在判断n*bits_per_key中,这n个位是否为1,如果全部为1,则说明查找的键在过滤器中,如果有某个位不为1,则说明键值不在过滤器.</p>
<p>成员变量为:
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BloomFilterPolicy : <span class="keyword">public</span> FilterPolicy &#123;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  size_t bits_per_key_;</div><div class="line">  size_t k_;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> BloomFilterPolicy(<span class="keyword">int</span> bits_per_key)</div><div class="line">      : bits_per_key_(bits_per_key) &#123;</div><div class="line">    <span class="comment">// We intentionally round down to reduce probing cost a little bit</span></div><div class="line">    k_ = <span class="keyword">static_cast</span>&lt;size_t&gt;(bits_per_key * <span class="number">0.69</span>);  <span class="comment">// 0.69 =~ ln(2)</span></div><div class="line">    <span class="built_in">if</span> (k_ &lt; <span class="number">1</span>) k_ = <span class="number">1</span>;</div><div class="line">    <span class="built_in">if</span> (k_ &gt; <span class="number">30</span>) k_ = <span class="number">30</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>bits_per_key_为每个键值设置的比特位数,k_为每个键值需要计算的次数.当创建布隆过滤器,需要传入bits_per_key_,这也是唯一可设置的参数.</p>
<p>来看下布隆过滤器创建:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice* keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">  <span class="comment">// Compute bloom filter size (in both bits and bytes)</span></div><div class="line">  <span class="comment">//根据n个键,设置n个位</span></div><div class="line">  <span class="keyword">size_t</span> bits = n * bits_per_key_;</div><div class="line"></div><div class="line">  <span class="comment">// For small n, we can see a very high false positive rate.  Fix it</span></div><div class="line">  <span class="comment">// by enforcing a minimum bloom filter length.</span></div><div class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>) bits = <span class="number">64</span>;</div><div class="line">  <span class="comment">//向上取整,使bits位刚好是8的倍数,即整数个字节</span></div><div class="line">  <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</div><div class="line">  bits = bytes * <span class="number">8</span>;<span class="comment">//更新后的字节</span></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;size();</div><div class="line">  dst-&gt;resize(init_size + bytes, <span class="number">0</span>);<span class="comment">//将每条过滤器添加总过滤器之后</span></div><div class="line">  dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_));  <span class="comment">// Remember # of probes in filter</span></div><div class="line">  <span class="keyword">char</span>* <span class="built_in">array</span> = &amp;(*dst)[init_size];<span class="comment">//array指向dst未使用的首位置</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">    <span class="comment">//先算键值的哈希值</span></div><div class="line">    <span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</div><div class="line">    <span class="comment">//向右循环移位17位.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) &#123;</div><div class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</div><div class="line">      <span class="built_in">array</span>[bitpos/<span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));<span class="comment">//将相应位设为1</span></div><div class="line">      h += delta;<span class="comment">//重复计算哈希值,计算k_值</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接来下是对查询键值过滤器验证:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.size();<span class="comment">//一条Filter的大小</span></div><div class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();<span class="comment">//一条Filter的数据</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Use the encoded k so that we can read filters generated by</span></div><div class="line">  <span class="comment">// bloom filters created using different parameters.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len<span class="number">-1</span>];</div><div class="line">  <span class="keyword">if</span> (k &gt; <span class="number">30</span>) &#123;</div><div class="line">    <span class="comment">// Reserved for potentially new encodings for short bloom filters.</span></div><div class="line">    <span class="comment">// Consider it a match.</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">uint32_t</span> h = BloomHash(key);<span class="comment">//查询键值的哈希值</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);  <span class="comment">// Rotate right 17 bits</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</div><div class="line">    <span class="comment">//进行验证,必须k次数据都必须为1,否则出错</span></div><div class="line">    <span class="keyword">if</span> ((<span class="built_in">array</span>[bitpos/<span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    h += delta;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建过滤器是在dbformat.cc中的InternalFilterPolicy-&gt;CreateFilter,验证函数是在InternalFilterPolicy-&gt;KeyMayMatch中调用.在leveldb中,最终验证时,是在table.cc的Table-&gt;InternalGet中.</p>
<p>布隆过滤器使用挺广的,之前还了解过在推荐系统只能中也有使用,所以学学这个也是很有帮助的.</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> BloomFilter </tag>
            
            <tag> bits </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb阅读源码总结]]></title>
      <url>http://luodw.cc/2015/11/01/leveldb-18/</url>
      <content type="html"><![CDATA[<p>经过一个多月的源码阅读,总算是把leveldb的源码几乎阅读完了.leveldb不愧是一款非常优秀的数据库存储引擎框架,优秀的架构设计,优雅的代码编写,清晰的类与类之间的逻辑关系以及较高的执行效率等等.不敢想象leveldb是两个人编写出来的,真心膜拜谷歌两位大神.今天就把之前看的总结下~</p>
<h1>leveldb整体框架</h1>
<hr>
<p>leveldb总体上是由memtable,immemtable和sst文件组成,如下图所示,图片来自网络:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1360076329_9985.JPG" alt="leveldb框架图">;</p>
<h2>插入数据</h2>
<hr>
<ol>
<li>插入数据时,先是将数据插入日志文件,然后插入memtable.因为如果是相反的顺序插入,假设一种情况,当插入memtable后,突然断电,那么就来不及插入日志文件中,这样就会造成数据丢失.</li>
<li>当memtable数据量达到一定大小时,将mem_赋值给imm_,然后重新new 一个memtable;接着重新新建一个log文件.DBImpl::MakeRoomForWrite函数内执行</li>
<li>接着imm_会被Compaction到磁盘文件中</li>
</ol>
<h2>读取数据</h2>
<hr>
<p>leveldb读取数据总是先读取最新的数据,因为有可能插入键值一样的键值对,但是我们查询时,是想获取最近插入的数据,所以读取数据时的顺序为</p>
<blockquote>
<p>memtable-&gt;immemtable-&gt;sst文件</p>
</blockquote>
<h1>leveldb优秀设计</h1>
<h2>内存池的设计</h2>
<hr>
<p>在接触leveldb之前,我对内存池的认知只停留在存储一大块内存的地方,但是具体实现一无所知,看了leveldb的内存池Arana之后,以及还有后来STL内存池,我对内存池有个较完整的认识.</p>
<p>Arena实现原理是先像系统申请一大块内存,然程序需要内存时,直接从内存池中获取即可,这样可以减少系统分配内存次数,降低系统分配内存带来的消耗.但是当程序需要一大块内存时(&gt;=1024b)时,单独分配一块内存,这样也是为了减少系统分配内存的次数.</p>
<h2>缓存设计</h2>
<hr>
<p>在接触leveldb之前,我听说过缓存这个东西,是在看<strong>linux内核设计与实现时</strong>,当时只知道有这么一个东西,能够缓存数据,但是并不能想象得出是怎么实现的.leveldb的缓存设计弥补了我这方面的知识盲区,我大概就知道内核缓存区是如何实现了.</p>
<p>leveldb的cache是由16个缓存区构成,每一个缓冲区是由哈希表和环形双向链表构成.哈希表主要是用来加快查询速度.环形双向链表在leveldb用的比较多,快照链表,版本链表都是环形双向链表实现的.环形双向链表有一个傀儡节点Dummy,Cache的链表Dummy.prev是最新的数据,Dummy.next是最&quot;老'的数据.当有新数据时,往Dummy.prev插入,当要删除数据时,删除Dummy.next的数据.</p>
<h2>锁的设计</h2>
<hr>
<p>在看skiplist时,我发现skiplist没有使用锁,互斥量,信号量等同步机制,我很好奇,因为leveldb是多线程安全的.后来百度得知leveldb用的是<strong>内存屏障</strong>,内存屏障是更底层的锁,应用在CPU寄存器和Cache里.通过百度,对内存屏障有了初步了解,但是如何实现同步,还未知...</p>
<h2>迭代器的设计</h2>
<hr>
<p>我看完源码之后发现,leveldb到处都在用迭代器,也可以说从底层迭代器开始,一层一层往上封装.先是skiplist迭代器-&gt;memtable迭代器,然后是block迭代器和文件迭代器-&gt;table双层迭代器-&gt;table_cache迭代器-&gt;version迭代器.最后MergeIterator-&gt;DBIterator.迭代器的设计,最大的好处就是方便了底层数据的检索,只需要一个迭代器,即可屏蔽很多不需要的细节.</p>
<h2>对不同系统,实现不同的封装</h2>
<hr>
<p>leveldb把对系统调用封装在了env环境类中这样当在不同系统使用leveldb时,只需要实现当前系统的Env即可.leveldb默认实现的是posix_env,即linux操作系统系统调用.</p>
<h2>简单的接口设计</h2>
<hr>
<p>leveldb提供接口极其简单,而且数量少,用户简单的学习即可上手.主要原因是上层调用对下层调用实现极好的封装,例如迭代器,一个迭代器,即可迭代mem,imm,sst中所有数据.</p>
<h2>优雅的代码</h2>
<hr>
<p>leveldb使用C++开发,充分利用了C++多态的特性,提供的都头文件iterator.h,comparator.h,cache.h等都是为抽象类,真正操作的是这些抽象类的子类.</p>
<p>其次,看完源码之后,没有看到一个#define宏定义,看了Effective C++中有说明,C++尽量不要用宏定义,取而代之的是:</p>
<ol>
<li>常量用const和enum代替</li>
<li>宏操作用内联函数代替</li>
</ol>
<p>以上都是我目前的认知,可能还有一些很好的设计,我没提出来.</p>
<p>学习优秀的源码对自己编程的提高很有帮助,以及可以学到好多操作系统基础知识,leveldb主要是一些接口,而redis是一款完整的软件,redis的源码学习可以学到一款软件的方方面面,网络啊,命令执行过程,以及IO复用的Mainae模块,非常推荐~</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之leveldb执行过程]]></title>
      <url>http://luodw.cc/2015/11/01/leveldb-17/</url>
      <content type="html"><![CDATA[<p>经过一个月的源码阅读,leveldb源码除了compaction,我都看完了.今天这篇文章,想大概介绍下leveldb执行流程,包括打开数据库,插入数据,读取数据,读取快照等等.那就先从打开数据开始.</p>
<h1>打开数据库open函数</h1>
<p>leveldb打开数据库分两种情况,首先是数据库不存在情况下,则需要新建一个数据;如果是数据存在的情况下,则需要从数据库恢复数据等.接下来讨论下:</p>
<p>首先是open函数:
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Status DB::Open(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> std::string&amp; dbname,</div><div class="line">                DB** dbptr) &#123;</div><div class="line">  *dbptr = NULL;</div><div class="line"></div><div class="line">  DBImpl* <span class="keyword">impl</span> = new DBImpl(options, dbname);<span class="comment">//new一个DB实现类</span></div><div class="line">  <span class="keyword">impl</span>-&gt;mutex_.Lock();</div><div class="line">  VersionEdit edit;</div><div class="line">  Status s = <span class="keyword">impl</span>-&gt;Recover(&amp;edit); <span class="comment">// 这个函数处理的就是判断数据库是否存在</span></div><div class="line">  <span class="comment">//以及从磁盘恢复数据</span></div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    uint64_t new_log_number = <span class="keyword">impl</span>-&gt;versions_-&gt;NewFileNumber();</div><div class="line">    WritableFile* lfile;</div><div class="line">    <span class="comment">//新生成一个manifest文件</span></div><div class="line">    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</div><div class="line">                                     &amp;lfile);</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      edit.SetLogNumber(new_log_number);<span class="comment">//设置新的manifest文件编号,因为</span></div><div class="line">    <span class="comment">//impl-&gt;Recover函数改变了new_log_number</span></div><div class="line">      <span class="keyword">impl</span>-&gt;logfile_ = lfile;</div><div class="line">      <span class="keyword">impl</span>-&gt;logfile_number_ = new_log_number;</div><div class="line">      <span class="keyword">impl</span>-&gt;log_ = new log::Writer(lfile);</div><div class="line">      <span class="comment">//将磁盘数据恢复到内存之后又做了些改变重新写回磁盘,并设置当前版本</span></div><div class="line">      s = <span class="keyword">impl</span>-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;<span class="keyword">impl</span>-&gt;mutex_);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      <span class="keyword">impl</span>-&gt;DeleteObsoleteFiles();<span class="comment">//删除过期文件,也就是上个版本的文件</span></div><div class="line">      <span class="keyword">impl</span>-&gt;MaybeScheduleCompaction();<span class="comment">//可能执行合并</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">impl</span>-&gt;mutex_.Unlock();</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    *dbptr = <span class="keyword">impl</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    delete <span class="keyword">impl</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数,</p>
<ol>
<li>先是调用impl-&gt;Recover函数从磁盘恢复数据库或者新建一个数据库.</li>
<li>接着根据从日志回见恢复到memtable时,可能对log_number,sequence number做出了改变等等,再重新新建一个版本.</li>
<li>最后删除过期文件以及可能执行文件操作</li>
</ol>
<p>open函数很重要的函数impl-&gt;Recover函数执行流程是这样的:</p>
<ol>
<li>先查找指定的数据库是否存在,如果存在就打开,不存在就新建一个:
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Status DBImpl::Recover(VersionEdit* edit) &#123;</div><div class="line">mutex_.AssertHeld();</div><div class="line"></div><div class="line">  env_-&gt;CreateDir(dbname_);</div><div class="line">  assert(db_lock_ == <span class="keyword">NULL</span>);</div><div class="line">  <span class="comment">//锁住这个数据库目录</span></div><div class="line">  Status s = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//判断文件是否存在</span></div><div class="line">  <span class="keyword">if</span> (!env_-&gt;FileExists(CurrentFileName(dbname_))) &#123;</div><div class="line">    <span class="keyword">if</span> (options_.create_if_missing) &#123;<span class="comment">//不存在,且设置了create_if_missing=true,则新建一个</span></div><div class="line">      s = NewDB();</div><div class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> Status::InvalidArgument(</div><div class="line">          dbname_, <span class="string">"does not exist (create_if_missing is false)"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (options_.error_if_exists) &#123;<span class="comment">//如果存在,且设置error_if_exists,则报错</span></div><div class="line">      <span class="keyword">return</span> Status::InvalidArgument(</div><div class="line">          dbname_, <span class="string">"exists (error_if_exists is true)"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>这函数中出现的NewDB(),其实是新建一个初始化文件编号的Version_set,然后写进第一个manifest文件中.
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Status DBImpl::NewDB() &#123;</div><div class="line">  VersionEdit new_db;</div><div class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</div><div class="line">  new_db.SetLogNumber(<span class="number">0</span>);</div><div class="line">  new_db.SetNextFile(<span class="number">2</span>);</div><div class="line">  new_db.SetLastSequence(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);</div><div class="line">  WritableFile* file;</div><div class="line">  Status s = env_-&gt;NewWritableFile(manifest, &amp;file);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">log</span>::<span class="function">Writer <span class="title">log</span><span class="params">(file)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> record;</div><div class="line">    new_db.EncodeTo(&amp;record);</div><div class="line">    s = <span class="built_in">log</span>.AddRecord(record);</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      s = file-&gt;Close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span> file;</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></div><div class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    env_-&gt;DeleteFile(manifest);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的好处就是,数据库存在和不存在都可以执行执行version_set-&gt;Recover函数来初始化数据库.都是从manifest文件恢复版本信息.</p>
<ol start="2">
<li>当初始化版本信息之后,接来就是将log文件的数据恢复到memtable中,收集日志文件,然后按日志文件编号排序,最后调用RecoverLogFile恢复到memtable.
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::sort(logs.begin(), logs.end());</div><div class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</div><div class="line">  s = RecoverLogFile(logs[i], edit, &amp;max_sequence);</div><div class="line">  <span class="comment">//因为RecoverLogFile这个函数会改变版本的一些属性,所以需要从新</span></div><div class="line">  <span class="comment">//设定文件编号</span></div><div class="line">  versions_-&gt;MarkFileNumberUsed(logs[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>RecoverLogFile这个函数偏长,我就不粘代码了,大概执行流程:</p>
<ul>
<li>先从log文件将所有记录读取出来,并调用WriteBatchInternal::SetContents方法,将记录存入WriteBatch中;</li>
<li>如果mem为空,则创建一个memtable</li>
<li>调用WriteBatchInternal::InertInto方法,将记录插入memtable,更新最大序列号</li>
<li>如果memtable长度大于预先设定的最大值,就执行一次合并.</li>
</ul>
<ol start="3">
<li>
<p>当从log文件恢复数据到memtable之后,最后再更新一次版本信息.因为之前的步骤中改变了sequence number以及log number等等,所以需要将这个版本的edit写进manifest中,以及重新生成一个新的版本.</p>
</li>
<li>
<p>最后删除过期的文件,例如上个版本的log文件等,以及可能执行的合并操作.</p>
</li>
</ol>
<p>DB::OPEN函数执行结束之后,*dbptr保存了新创建的DBImpl对象,用于调用input,delete,write,get等操作.</p>
<h1>DB的析构操作</h1>
<p>删除数据库时,主要是把数据库中堆中分配的内存析构,memtable,version_set,table_cache等等.析构时,要先判断后台的合并操作有没结束,如果没有结束,必须等待信号通知后台操作结束了,才可析构
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">DBImpl::~DBImpl() &#123;</div><div class="line">  <span class="comment">// 等待后台合并操作完成</span></div><div class="line">  mutex_.Lock();</div><div class="line">  shutting_down_.Release_Store(<span class="keyword">this</span>);  <span class="comment">// Any non-NULL value is ok</span></div><div class="line">  <span class="keyword">while</span> (bg_compaction_scheduled_) &#123;</div><div class="line">    bg_cv_.Wait();</div><div class="line">  &#125;</div><div class="line">  mutex_.Unlock();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (db_lock_ != <span class="literal">NULL</span>) &#123;</div><div class="line">    env_-&gt;UnlockFile(db_lock_);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> versions_;</div><div class="line">  <span class="keyword">if</span> (mem_ != <span class="literal">NULL</span>) mem_-&gt;Unref();</div><div class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">NULL</span>) imm_-&gt;Unref();</div><div class="line">  <span class="keyword">delete</span> tmp_batch_;</div><div class="line">  <span class="keyword">delete</span> log_;</div><div class="line">  <span class="keyword">delete</span> logfile_;</div><div class="line">  <span class="keyword">delete</span> table_cache_;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (owns_info_log_) &#123;</div><div class="line">    <span class="keyword">delete</span> options_.info_log;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (owns_cache_) &#123;</div><div class="line">    <span class="keyword">delete</span> options_.block_cache;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之前在WriteBatch中已经分析过<a href="http://luodw.cc/2015/10/30/leveldb-14/">数据库写入操作</a>,
即db-&gt;Put,db-&gt;delete,db-&gt;Write函数调用.接来下分析下数据库db-&gt;Get操作.</p>
<h1>Get操作</h1>
<p>leveldb的Get操作,有以下几个几个步骤:</p>
<ol>
<li>先判断ReadOptions里是否设置快照,如果设置了,就用ReadOptions里的快照,如果没设置,则建立当前时间点的快照.</li>
<li>首先从memtable中查询数据,如果memtable里有需要的数据,则直接返回.如果没有,则到第3步;</li>
<li>从immemtable中查询,如果immemtable中查到了,则直接返回,否则到第4步;</li>
<li>从各层sst文件中查询,调用当前版本的Get方法即可.</li>
</ol>
<p>主要代码如下;
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  mutex_.Unlock()<span class="comment">;</span></div><div class="line">  // First look in the memtable, then in the immutable memtable (<span class="name"><span class="builtin-name">if</span></span> any).</div><div class="line">  LookupKey lkey(<span class="name"><span class="builtin-name">key</span></span>, snapshot)<span class="comment">;</span></div><div class="line">  if (<span class="name">mem-&gt;Get</span>(<span class="name">lkey</span>, value, &amp;s)) &#123;</div><div class="line">    // Done</div><div class="line">  &#125; else if (<span class="name">imm</span> != NULL &amp;&amp; imm-&gt;Get(<span class="name">lkey</span>, value, &amp;s)) &#123;</div><div class="line">    // Done</div><div class="line">  &#125; else &#123;</div><div class="line">    s = current-&gt;Get(<span class="name">options</span>, lkey, value, &amp;stats)<span class="comment">;</span></div><div class="line">    have_stat_update = <span class="literal">true</span><span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  mutex_.Lock()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>获取迭代器操作</h1>
<p>先来看下源码:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Iterator* DBImpl::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options) &#123;</div><div class="line">  SequenceNumber latest_snapshot;</div><div class="line">  <span class="keyword">uint32_t</span> seed;</div><div class="line">  Iterator* iter = NewInternalIterator(options, &amp;latest_snapshot, &amp;seed);</div><div class="line">  <span class="keyword">return</span> NewDBIterator(</div><div class="line">      <span class="keyword">this</span>, user_comparator(), iter,</div><div class="line">      (options.snapshot != <span class="literal">NULL</span></div><div class="line">       ? <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;number_</div><div class="line">       : latest_snapshot),</div><div class="line">      seed);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>db-&gt;DBImpl::NewIterator获取这个leveldb数据库的迭代器,可以用这个迭代器来迭代这个数据库的所有数据,包括在memtable,immemtable和sst文件中的数据库.在这个函数中先调用的是:
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Iterator* iter = NewInternalIterator(<span class="name">options</span>, <span class="symbol">&amp;latest_snapshot</span>, <span class="symbol">&amp;seed</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>这个函数将memtable,immemtable和sst文件的所有迭代器汇总到一个MergeIterator中,这也是一种封装,只要通过一个迭代器,即可迭代memtable,immemtable和sst文件中的所有数据.这个迭代器在table/merge里定义,源码容易看得懂.</p>
<p>最后在将MergeIterator封装成DBIterator.DBIterator的定义在db/db_iter.cc文件中.这个DBIterator主要是考虑了删除标记的问题.不一一分析.</p>
<p>leveldb源码分析暂且到此...</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之version、version_edit和version_set]]></title>
      <url>http://luodw.cc/2015/10/31/leveldb-16/</url>
      <content type="html"><![CDATA[<p>今天这篇文章主要讲解我之前很恐惧的leveldb版本控制，version,version_edit和version_set，主要原因吧，还是这三个是紧密联系在一起的，代码量大。这篇文章讲下我自己对版本控制的一知半解，也算自我总结。</p>
<h1>version_edit版本编辑</h1>
<p>version_edit这个类主要是两个版本之间的差量。形象点说，就是当前版本+version_edit即可成为新的版本，version0+version_edit=version1。对于leveldb来说，一个版本包括所有数据文件，log文件，manifest_file，current文件，LOG文件和LOCK文件，而文件是由文件编号来标识的，所以对于一个版本来说，会变化的变量有log文件编号，序列号，文件编号，所以version_edt主要就是来操作这个变量以及文件的增删，定义如下,先列出成员变量:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">friend</span> <span class="keyword">class</span> VersionSet;</div><div class="line"> <span class="comment">//定义删除文件集合，&lt;层次，文件编号&gt;</span></div><div class="line"> <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt; &gt; DeletedFileSet;</div><div class="line"></div><div class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> comparator_;<span class="comment">//比较器名称</span></div><div class="line"> <span class="keyword">uint64_t</span> log_number_;<span class="comment">//日志文件编号</span></div><div class="line"> <span class="keyword">uint64_t</span> prev_log_number_;<span class="comment">//上一个日志文件编号</span></div><div class="line"> <span class="keyword">uint64_t</span> next_file_number_;<span class="comment">//下一个文件编号</span></div><div class="line"> SequenceNumber last_sequence_;<span class="comment">//上一个序列号</span></div><div class="line"> <span class="keyword">bool</span> has_comparator_;<span class="comment">//是否有比较器</span></div><div class="line"> <span class="keyword">bool</span> has_log_number_;</div><div class="line"> <span class="keyword">bool</span> has_prev_log_number_;</div><div class="line"> <span class="keyword">bool</span> has_next_file_number_;</div><div class="line"> <span class="keyword">bool</span> has_last_sequence_;</div><div class="line"> <span class="comment">//压缩点&lt;层次，InternalKey键&gt;</span></div><div class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt; &gt; compact_pointers_;</div><div class="line"> <span class="comment">//删除文件集合</span></div><div class="line"> DeletedFileSet deleted_files_;</div><div class="line"> <span class="comment">//新添加的文件集合</span></div><div class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt; &gt; new_files_;</div></pre></td></tr></table></figure></p>
<p>这个version_edit保存了版本可能会变化的变量，这个类提供的接口包括设置这些变量的接口set方法，以及将上述成员序列化和反序列化的方法。当version_edit序列化时，图片来自博客<a href="http://blog.csdn.net/sparkliang/article/details/8776583" target="_blank" rel="external">sparkliang的专栏</a>格式如下:<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_023.png" alt="manifest文件格式">;</p>
<p>图中的数字表示为:
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Tag</span> &#123;</span></div><div class="line">  kComparator           = <span class="number">1</span>,</div><div class="line">  kLogNumber            = <span class="number">2</span>,</div><div class="line">  kNextFileNumber       = <span class="number">3</span>,</div><div class="line">  kLastSequence         = <span class="number">4</span>,</div><div class="line">  kCompactPointer       = <span class="number">5</span>,</div><div class="line">  kDeletedFile          = <span class="number">6</span>,</div><div class="line">  kNewFile              = <span class="number">7</span>,</div><div class="line">  <span class="regexp">//</span> <span class="number">8</span> was used <span class="keyword">for</span> large value refs</div><div class="line">  kPrevLogNumber        = <span class="number">9</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>因为version_edit序列化之后，会保存在manifest文件中，所以这张图既是version_edit序列化为字符串时的格式，也是manifest文件格式。</p>
<p>接下来看下如何序列化这个version_edit:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> VersionEdit::EncodeTo(<span class="built_in">std</span>::<span class="built_in">string</span>* dst) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="comment">//将比较器的标识和名称放入序列化字符串中</span></div><div class="line">  <span class="keyword">if</span> (has_comparator_) &#123;</div><div class="line">    PutVarint32(dst, kComparator);</div><div class="line">    PutLengthPrefixedSlice(dst, comparator_);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//将日志文件编号的标识和名称放入序列化字符串中</span></div><div class="line">  <span class="keyword">if</span> (has_log_number_) &#123;</div><div class="line">    PutVarint32(dst, kLogNumber);</div><div class="line">    PutVarint64(dst, log_number_);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//将前一个日志的标识和名称放入序列化字符串中</span></div><div class="line">  <span class="keyword">if</span> (has_prev_log_number_) &#123;</div><div class="line">    PutVarint32(dst, kPrevLogNumber);</div><div class="line">    PutVarint64(dst, prev_log_number_);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//将下一个文件的标识和名称放入序列化字符串中</span></div><div class="line">  <span class="keyword">if</span> (has_next_file_number_) &#123;</div><div class="line">    PutVarint32(dst, kNextFileNumber);</div><div class="line">    PutVarint64(dst, next_file_number_);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//将上一个序列号的标识和名称放入序列化字符串中</span></div><div class="line">  <span class="keyword">if</span> (has_last_sequence_) &#123;</div><div class="line">    PutVarint32(dst, kLastSequence);</div><div class="line">    PutVarint64(dst, last_sequence_);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//将每个压缩点的标识，层次和InternalKey放入序列化字符串</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact_pointers_.size(); i++) &#123;</div><div class="line">    PutVarint32(dst, kCompactPointer);</div><div class="line">    PutVarint32(dst, compact_pointers_[i].first);  <span class="comment">// level</span></div><div class="line">    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//将每个删除文件的标识,层次，文件编号放入序列化字符串中</span></div><div class="line">  <span class="keyword">for</span> (DeletedFileSet::const_iterator iter = deleted_files_.begin();</div><div class="line">       iter != deleted_files_.end();</div><div class="line">       ++iter) &#123;</div><div class="line">    PutVarint32(dst, kDeletedFile);</div><div class="line">    PutVarint32(dst, iter-&gt;first);   <span class="comment">// level</span></div><div class="line">    PutVarint64(dst, iter-&gt;second);  <span class="comment">// file number</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//将增加的字符串的标识以及f属性添加进序列化字符串中</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; new_files_.size(); i++) &#123;</div><div class="line">    <span class="keyword">const</span> FileMetaData&amp; f = new_files_[i].second;</div><div class="line">    PutVarint32(dst, kNewFile);</div><div class="line">    PutVarint32(dst, new_files_[i].first);  <span class="comment">// level</span></div><div class="line">    PutVarint64(dst, f.number);</div><div class="line">    PutVarint64(dst, f.file_size);</div><div class="line">    PutLengthPrefixedSlice(dst, f.smallest.Encode());</div><div class="line">    PutLengthPrefixedSlice(dst, f.largest.Encode());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述这个函数就是将version_edit序列化成字符串，然后存入manifest文件中，接下来看下，如何反序列化，将manifest反序列化为version_edit。
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">Status VersionEdit::DecodeFrom(<span class="keyword">const</span> Slice&amp; src) &#123;</div><div class="line">  Clear();<span class="comment">//先清空原有数据</span></div><div class="line">  Slice input = src;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* msg = NULL;</div><div class="line">  uint32_t tag;</div><div class="line"></div><div class="line">  <span class="comment">// 为了解析，临时定义的存储变量</span></div><div class="line">  <span class="keyword">int</span> level;</div><div class="line">  uint64_t number;</div><div class="line">  FileMetaData f;</div><div class="line">  Slice str;</div><div class="line">  InternalKey key;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (msg == NULL &amp;&amp; GetVarint32(&amp;input, &amp;tag)) &#123;</div><div class="line">    <span class="keyword">switch</span> (tag) &#123;<span class="comment">//根据tag，也就是标识，解析不同的变量</span></div><div class="line">      <span class="keyword">case</span> kComparator:</div><div class="line">        <span class="keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;str)) &#123;</div><div class="line">          comparator_ = str.ToString();</div><div class="line">          has_comparator_ = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"comparator name"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kLogNumber:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;log_number_)) &#123;</div><div class="line">          has_log_number_ = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"log number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kPrevLogNumber:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;prev_log_number_)) &#123;</div><div class="line">          has_prev_log_number_ = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"previous log number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kNextFileNumber:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;next_file_number_)) &#123;</div><div class="line">          has_next_file_number_ = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"next file number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kLastSequence:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;last_sequence_)) &#123;</div><div class="line">          has_last_sequence_ = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"last sequence number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kCompactPointer:</div><div class="line">        <span class="keyword">if</span> (GetLevel(&amp;input, &amp;level) &amp;&amp;</div><div class="line">            GetInternalKey(&amp;input, &amp;key)) &#123;</div><div class="line">          compact_pointers_.push_back(std::make_pair(level, key));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"compaction pointer"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kDeletedFile:</div><div class="line">        <span class="keyword">if</span> (GetLevel(&amp;input, &amp;level) &amp;&amp;</div><div class="line">            GetVarint64(&amp;input, &amp;number)) &#123;</div><div class="line">          deleted_files_.insert(std::make_pair(level, number));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"deleted file"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kNewFile:</div><div class="line">        <span class="keyword">if</span> (GetLevel(&amp;input, &amp;level) &amp;&amp;</div><div class="line">            GetVarint64(&amp;input, &amp;f.number) &amp;&amp;</div><div class="line">            GetVarint64(&amp;input, &amp;f.file_size) &amp;&amp;</div><div class="line">            GetInternalKey(&amp;input, &amp;f.smallest) &amp;&amp;</div><div class="line">            GetInternalKey(&amp;input, &amp;f.largest)) &#123;</div><div class="line">          new_files_.push_back(std::make_pair(level, f));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"new-file entry"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        msg = <span class="string">"unknown tag"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (msg == NULL &amp;&amp; !input.empty()) &#123;</div><div class="line">    msg = <span class="string">"invalid tag"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Status result;</div><div class="line">  <span class="keyword">if</span> (msg != NULL) &#123;</div><div class="line">    result = Status::Corruption(<span class="string">"VersionEdit"</span>, msg);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数也很简单，就是根据不同的标识，解析出不同的变量，最后再判断有没出错，如果没出错，则返回空的status，错误，则返回错误状态。</p>
<h1>Version版本类</h1>
<p>这个类主要功能，首先是提供了在当前版本搜索键值的Get方法，其次是为上层调用提供了收集当前版本所有文件的迭代器，最后是为合并文件提供了判断键值范围与文件是否有交集的辅助函数。</p>
<p>接下来先看下Version提供的收集文件迭代器的方法,对于第0层，直接从Table_cache中获取即可，因为当初每campaction时，都将文件添加进table_cache缓存；对于大于第0层的文件，创建是两层迭代器，后面分析，为了分析两层迭代器，需要先介绍下第一层迭代器，也就是迭代某一层文件的迭代器
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Version::LevelFileNumIterator : <span class="keyword">public</span> Iterator &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  LevelFileNumIterator(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</div><div class="line">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* flist)</div><div class="line">      : icmp_(icmp),<span class="comment">//比较器</span></div><div class="line">        flist_(flist),<span class="comment">//某一层文件集合</span></div><div class="line">        index_(flist-&gt;size()) &#123; <span class="comment">//某一层文件的编号，等于文件个数时，即为无效 </span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> index_ &lt; flist_-&gt;size();</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>&#123;</div><div class="line">    <span class="comment">//在这层查找键值大于等于target的文件索引</span></div><div class="line">    index_ = FindFile(icmp_, *flist_, target);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123; index_ = <span class="number">0</span>; &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    index_ = flist_-&gt;empty() ? <span class="number">0</span> : flist_-&gt;size() - <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</div><div class="line">    assert(Valid());</div><div class="line">    index_++;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>&#123;</div><div class="line">    assert(Valid());</div><div class="line">    <span class="keyword">if</span> (index_ == <span class="number">0</span>) &#123;</div><div class="line">      index_ = flist_-&gt;size();  <span class="comment">// Marks as invalid</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      index_--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    assert(Valid());</div><div class="line">    <span class="comment">//返回大于等于target文件的最大键值</span></div><div class="line">    <span class="keyword">return</span> (*flist_)[index_]-&gt;largest.Encode();</div><div class="line">  &#125;</div><div class="line">  <span class="function">Slice <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    assert(Valid());<span class="comment">//返回这个文件的文件编号和大小封装成的字符串</span></div><div class="line">    EncodeFixed64(value_buf_, (*flist_)[index_]-&gt;number);</div><div class="line">    EncodeFixed64(value_buf_+<span class="number">8</span>, (*flist_)[index_]-&gt;file_size);</div><div class="line">    <span class="keyword">return</span> Slice(value_buf_, <span class="keyword">sizeof</span>(value_buf_));</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Status::OK(); &#125;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</div><div class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* <span class="keyword">const</span> flist_;</div><div class="line">  <span class="keyword">uint32_t</span> index_;</div><div class="line"></div><div class="line">  <span class="comment">// Backing store for value().  Holds the file number and size.</span></div><div class="line">  <span class="keyword">mutable</span> <span class="keyword">char</span> value_buf_[<span class="number">16</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述这个迭代器就是迭代某一层内所有的文件，第二层迭代器就是迭代某一层某一个文件的迭代器，和Table的双层迭代器有点像，Table双层迭代器是首先迭代文件块，然后块内迭代器。下面是Version提供添加所有文件迭代器的接口
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void Version::AddIterators(const ReadOptions&amp; options,</div><div class="line">                           std::vector&lt;Iterator*&gt;* iters) &#123;</div><div class="line">  <span class="comment">// Merge all level zero files together since they may overlap</span></div><div class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].size(); i++) &#123;</div><div class="line">    <span class="function"><span class="title">iters</span>-&gt;</span>push_back(</div><div class="line">        <span class="function"><span class="title">vset_</span>-&gt;</span><span class="function"><span class="title">table_cache_</span>-&gt;</span>NewIterator(</div><div class="line">            <span class="function"><span class="title">options</span>, files_[0][i]-&gt;</span><span class="function"><span class="title">number</span>, files_[0][i]-&gt;</span>file_size));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// For levels &gt; 0, we can use a concatenating iterator that sequentially</span></div><div class="line">  <span class="comment">// walks through the non-overlapping files in the level, opening them</span></div><div class="line">  <span class="comment">// lazily.</span></div><div class="line">  <span class="keyword">for</span> (int level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</div><div class="line">    <span class="keyword">if</span> (!files_[level].empty()) &#123;</div><div class="line">      <span class="function"><span class="title">iters</span>-&gt;</span>push_back(NewConcatenatingIterator(options, level));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，接来看下创建两层迭代器的方法NewConcatenatingIterator
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Iterator* Version::NewConcatenatingIterator(<span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                                            <span class="keyword">int</span> level) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> NewTwoLevelIterator(</div><div class="line">      <span class="keyword">new</span> LevelFileNumIterator(vset_-&gt;icmp_, &amp;files_[level]),</div><div class="line">      &amp;GetFileIterator, vset_-&gt;table_cache_, options);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//传入的函数指针，就是为了将文件元数据添加进Table_cache</span></div><div class="line"><span class="function"><span class="keyword">static</span> Iterator* <span class="title">GetFileIterator</span><span class="params">(<span class="keyword">void</span>* arg,</span></span></div><div class="line">                                 <span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                                 <span class="keyword">const</span> Slice&amp; file_value) &#123;</div><div class="line">  TableCache* cache = <span class="keyword">reinterpret_cast</span>&lt;TableCache*&gt;(arg);</div><div class="line">  <span class="keyword">if</span> (file_value.size() != <span class="number">16</span>) &#123;</div><div class="line">    <span class="keyword">return</span> NewErrorIterator(</div><div class="line">        Status::Corruption(<span class="string">"FileReader invoked with unexpected value"</span>));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> cache-&gt;NewIterator(options,</div><div class="line">                              DecodeFixed64(file_value.data()),</div><div class="line">                              DecodeFixed64(file_value.data() + <span class="number">8</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个两层迭代器不分析了，因为之前在Table_cache有分析过。内部调用大概通过LevelFileNumIterator先迭代到具体的文件，然后再调用GetFileIterator回调函数创建创建这个文件的Table_cache迭代器，并添加进Table_cache。</p>
<p>leveldb这个两层迭代器设计非常巧妙，因为刚生成这两层迭代器时，迭代器不会将任何文件载入内存，而是当查询某个键值时，才会把具体的文件元数据添加进Table_cache，这中用法叫做open-lazily,即推迟打开文件。</p>
<p>接下来，看下Get函数，就是根据提供的键值，查询对应的value。原理如下:</p>
<ol>
<li>对于第0层文件，因为这些文件有可能相交，所以要迭代所有文件，把和查询键值有交集的文件添加进一个临时的集合中。</li>
<li>对于第1层以及以上文件，因为这些文件不相交，所以只要二分查找文件即可。</li>
<li>根据找到的文件，调用table_cache-&gt;Get方法获取具体的value值。对于第0层文件，因为获取到查询的文件不止一个，所以跟新状态保存的是第一个查找到的文件。</li>
<li>将找到的值存入传进的参数。</li>
</ol>
<p>代码偏长，我将重要片段贴出来:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Saver saver;</div><div class="line">saver.state = kNotFound;</div><div class="line">saver.ucmp = ucmp;</div><div class="line">saver.user_key = user_key;</div><div class="line">saver.value = value;</div><div class="line"><span class="function"><span class="title">s</span> = vset_-&gt;</span><span class="function"><span class="title">table_cache_</span>-&gt;</span>G<span class="function"><span class="title">et</span>(options, f-&gt;</span><span class="function"><span class="title">number</span>, f-&gt;</span>file_size,</div><div class="line">                             ikey, &amp;saver, SaveValue);</div></pre></td></tr></table></figure></p>
<p>这个Saver是定义的一个结构体，用于保存Get函数内部得到的值。我们来看下这个回调函数，也就是用于保存value值的函数:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveValue</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">const</span> Slice&amp; ikey, <span class="keyword">const</span> Slice&amp; v)</span> </span>&#123;</div><div class="line">  Saver* s = <span class="keyword">reinterpret_cast</span>&lt;Saver*&gt;(arg);</div><div class="line">  ParsedInternalKey parsed_key;</div><div class="line">  <span class="keyword">if</span> (!ParseInternalKey(ikey, &amp;parsed_key)) &#123;</div><div class="line">    s-&gt;state = kCorrupt;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (s-&gt;ucmp-&gt;Compare(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123;</div><div class="line">      s-&gt;state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;</div><div class="line">      <span class="keyword">if</span> (s-&gt;state == kFound) &#123;</div><div class="line">        s-&gt;value-&gt;assign(v.data(), v.size());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数是在Table::InternalGet函数中调用，此时传进函数的v已经是查找到的value值，根据键值对的类型，设置不同的state状态，如果是kDeleted，则value值为空，如果是kFound，将v赋值给value。第一次看这源码可能有个抑或，因为没有给version-&gt;Get函数传递的value赋值，version-&gt;Get函数返回时，可以从Value中获取值？这是因为value是一个指针，saver.value=value是指针赋值，也就是说这两个指针指向同一个地方，所以一个赋值，也就是对另一个赋值了。</p>
<p>Version其他函数都是和Campaction相关的，暂时不说了。接下来看下Version_set。</p>
<h1>Version_set版本集合类</h1>
<p>Version_set这个类不只是简单的Version集合，还操作着和版本变化的一些函数，例如将version_edit应用到新的版本，将新版本设为当前版本等等。</p>
<p>先来看下成员变量:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Env* <span class="keyword">const</span> env_;<span class="comment">//操作系统封装</span></div><div class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;<span class="comment">//数据库名称</span></div><div class="line"><span class="keyword">const</span> Options* <span class="keyword">const</span> options_;<span class="comment">//选项配置</span></div><div class="line">TableCache* <span class="keyword">const</span> table_cache_;<span class="comment">//用于version调用get时调用</span></div><div class="line"><span class="keyword">const</span> InternalKeyComparator icmp_;<span class="comment">//以下6个都是版本可变的</span></div><div class="line"><span class="keyword">uint64_t</span> next_file_number_;</div><div class="line"><span class="keyword">uint64_t</span> manifest_file_number_;</div><div class="line"><span class="keyword">uint64_t</span> last_sequence_;</div><div class="line"><span class="keyword">uint64_t</span> log_number_;</div><div class="line"><span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></div><div class="line"></div><div class="line"><span class="comment">// Opened lazily</span></div><div class="line">WritableFile* descriptor_file_;<span class="comment">//manifest文件</span></div><div class="line"><span class="built_in">log</span>::Writer* descriptor_log_;<span class="comment">//将Version_edit写进manifest</span></div><div class="line">Version dummy_versions_;  <span class="comment">// 环形双向链表的表头</span></div><div class="line">Version* current_;        <span class="comment">//当前版本界定 == dummy_versions_.prev_</span></div><div class="line"></div><div class="line"><span class="comment">// 每一层下次compaction的键值，空值或者一个有效的InternalKey</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[config::kNumLevels];</div></pre></td></tr></table></figure></p>
<h2>Builder类</h2>
<p>接下来先来看下Version_set的内部类Builder，这个类用于将manifest文件内容添加进当前版本，并将当前版本添加进版本链表，然后成员变量如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> VersionSet::Builder &#123;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Helper to sort by v-&gt;files_[file_number].smallest</span></div><div class="line">  <span class="keyword">struct</span> BySmallestKey &#123;</div><div class="line">    <span class="keyword">const</span> InternalKeyComparator* internal_comparator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FileMetaData* f1, FileMetaData* f2)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> r = internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);</div><div class="line">      <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> (r &lt; <span class="number">0</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Break ties by file number</span></div><div class="line">        <span class="keyword">return</span> (f1-&gt;number &lt; f2-&gt;number);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"><span class="comment">//定义一个用于排序文件元数据的函数对象，先是按最小键值排序，如果最小键值相等，就按文件编号从小到大排序。</span></div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;FileMetaData*, BySmallestKey&gt; FileSet;</div><div class="line">  <span class="comment">//定义文件集合类型，集合从小到大排序</span></div><div class="line">  <span class="keyword">struct</span> LevelState &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</div><div class="line">    FileSet* added_files;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  VersionSet* vset_;<span class="comment">//所属的版本链表</span></div><div class="line">  Version* base_;<span class="comment">//当前版本</span></div><div class="line">  <span class="comment">//每一层文件状态，添加或删除文件</span></div><div class="line">  LevelState levels_[config::kNumLevels];</div></pre></td></tr></table></figure></p>
<p>当打开一个已存在的数据库时，此时需要将磁盘的文件信息恢复到一个版本，也就是将manifest内的信息包装成Version_edit，并应用到当前版本，这时就需要调用Builder-&gt;Apply方法，这方法先是将edit里的信息解析到Builder中，接着再调用Builder-&gt;Saveto保存到当前版本中。先来看下Builder-&gt;Apply方法
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void Apply(VersionEdit* edit) &#123;</div><div class="line">    <span class="comment">// 将每层compaction节点添加进version_set</span></div><div class="line">    <span class="function"><span class="title">for</span> (size_t i = 0; i &lt; edit-&gt;</span>compact_pointers_.size(); i++) &#123;</div><div class="line">      <span class="function"><span class="title">const</span> int level = edit-&gt;</span>compact_pointers_[i].first;</div><div class="line">      <span class="function"><span class="title">vset_</span>-&gt;</span>compact_pointer_[level] =</div><div class="line">          <span class="function"><span class="title">edit</span>-&gt;</span>compact_pointers_[i].second.Encode().ToString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将删除文件添加进Builder</span></div><div class="line">    <span class="function"><span class="title">const</span> VersionEdit::DeletedFileSet&amp; del = edit-&gt;</span>deleted_files_;</div><div class="line">    <span class="keyword">for</span> (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();</div><div class="line">         iter != del.end();</div><div class="line">         ++iter) &#123;</div><div class="line">      <span class="function"><span class="title">const</span> int level = iter-&gt;</span>first;</div><div class="line">      <span class="function"><span class="title">const</span> uint64_t number = iter-&gt;</span>second;</div><div class="line">      levels_[level].deleted_files.insert(number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将增加的文件添加进Builder</span></div><div class="line">    <span class="function"><span class="title">for</span> (size_t i = 0; i &lt; edit-&gt;</span>new_files_.size(); i++) &#123;</div><div class="line">      <span class="function"><span class="title">const</span> int level = edit-&gt;</span>new_files_[i].first;</div><div class="line">      F<span class="function"><span class="title">ileMetaData</span>* f = new FileMetaData(edit-&gt;</span>new_files_[i].second);</div><div class="line">      <span class="function"><span class="title">f</span>-&gt;</span>refs = <span class="number">1</span>;</div><div class="line">      <span class="function"><span class="title">f</span>-&gt;</span><span class="function"><span class="title">allowed_seeks</span> = (f-&gt;</span>file_size / <span class="number">16384</span>);</div><div class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span><span class="function"><span class="title">allowed_seeks</span> &lt; 100) f-&gt;</span>allowed_seeks = <span class="number">100</span>;</div><div class="line"></div><div class="line">      <span class="function"><span class="title">levels_</span>[level].deleted_files.erase(f-&gt;</span>number);</div><div class="line">      <span class="function"><span class="title">levels_</span>[level].added_files-&gt;</span>insert(f);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>f-&gt;allowed_seeks 这个是当文件被查询几次之后，需要进行compaction，源码中有注释为何这样计算该值。接来下，看下如何把edit的信息应用到当前版本。</p>
<p>将edit应用到当前版本调用的函数是SaveTo。该函数将上一版本所有文件和新添加的文件按比较器定义的比较方法排序，存储到新版本中。如果是已经在删除文件集合中，则不添加进新版本中。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</div><div class="line">    <span class="comment">// 将新添加的文件和上个版本的文件合并</span></div><div class="line">    <span class="comment">// 删除掉deleted集合中的文件，把结果保存在新版本v中</span></div><div class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.begin();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.end();</div><div class="line">    <span class="keyword">const</span> FileSet* added = levels_[level].added_files;</div><div class="line">    v-&gt;files_[level].reserve(base_files.size() + added-&gt;size());</div><div class="line">    <span class="keyword">for</span> (FileSet::const_iterator added_iter = added-&gt;begin();</div><div class="line">         added_iter != added-&gt;end();</div><div class="line">         ++added_iter) &#123;</div><div class="line">      <span class="comment">// 这个循环是将比新添加的文件“小“的文件先添加进新版本中</span></div><div class="line">      <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos</div><div class="line">               = <span class="built_in">std</span>::upper_bound(base_iter, base_end, *added_iter, cmp);</div><div class="line">           base_iter != bpos;</div><div class="line">           ++base_iter) &#123;</div><div class="line">        MaybeAddFile(v, level, *base_iter);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//将新添加文件添加进新版本中</span></div><div class="line">      MaybeAddFile(v, level, *added_iter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 添加其他文件，其实也就是比新添加文件”大“的文件</span></div><div class="line">    <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</div><div class="line">      MaybeAddFile(v, level, *base_iter);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>删除deleted集合中文件的操作就在MaybeAddFile，这函数名字起的很好，可能添加，因为如果在deleted集合中，则不添加，源码如下；
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void MaybeAddFile(Version* v, int level, FileMetaData* f) &#123;</div><div class="line">  <span class="function"><span class="title">if</span> (levels_[level].deleted_files.count(f-&gt;</span>number) &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 如果文件f在deleted集合中，则啥都不做。</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="function"><span class="title">std</span>::vector&lt;FileMetaData*&gt;* files = &amp;v-&gt;</span>files_[level];</div><div class="line">    <span class="function"><span class="title">if</span> (level &gt; 0 &amp;&amp; !files-&gt;</span>empty()) &#123;</div><div class="line">      <span class="comment">// 如果是大于0层的文件，新添加的文件不能和集合中已存在的文件有交集</span></div><div class="line">      <span class="function"><span class="title">assert</span>(vset_-&gt;</span><span class="function"><span class="title">icmp_</span>.Compare((*files)[files-&gt;</span><span class="function"><span class="title">size</span>()-1]-&gt;</span>largest,</div><div class="line">                                  <span class="function"><span class="title">f</span>-&gt;</span>smallest) &lt; <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">f</span>-&gt;</span>refs++;<span class="comment">//文件引用加1</span></div><div class="line">    <span class="function"><span class="title">files</span>-&gt;</span>push_back(f);<span class="comment">//添加文件</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>Recover函数</h2>
<p>介绍完上述Builder类的成员函数之后，我们来看Recover函数，也就是当打开一个已存在的数据库时，将manifest内的edit信息应用到新建的版本中，然后日志文件恢复就留给dbimpl-&gt;Recover函数实现。</p>
<p>VersionSet-&gt;Recover方法实现原理如下，</p>
<ol>
<li>先从Current文件读取目前正在使用的manifest文件；</li>
<li>从manifest文件读取数据，并反序列化为Version_set类；</li>
<li>调用builder.Apply方法，将editcompaction点，增加文件集合，删除文件集合放进builder中，并从将edit内各个文件编号赋值给Version_set相应的变量；</li>
<li>新建一个版本v，将builder中信息应用到这个版本中，然后再将这个版本添加进版本链表中，并设置为当前版本。</li>
<li>最后更新Version_set内的文件编号。</li>
</ol>
<p>代码偏长，不黏贴了；</p>
<h2>LogAndApply函数</h2>
<p>这个函数主要是将edit信息写进manifest文件中，并应用到新版本中。经常在文件合并之后,会出现文件文件添加删除情况,所以需要保存日志以及新生成一个新版.</p>
<p>这个函数原理如下:</p>
<ol>
<li>将version_set内的文件内的文件编号保存进edit;</li>
<li>新建一个Version,然后调用Builder-&gt;apply和Builder-&gt;SaveTo方法将edit应用到新版本中.</li>
<li>将edit写进manifest文件中,并更新Current文件,指向最新manifest.</li>
<li>将新版本添加到版本链表中,并设置为当前链表.</li>
</ol>
<p>先看下前两步源码:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span> (edit-&gt;</span>has_log_number_) &#123;</div><div class="line">   <span class="function"><span class="title">assert</span>(edit-&gt;</span>log_number_ &gt;= log_number_);</div><div class="line">   <span class="function"><span class="title">assert</span>(edit-&gt;</span>log_number_ &lt; next_file_number_);</div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line">   <span class="function"><span class="title">edit</span>-&gt;</span>SetLogNumber(log_number_);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="title">if</span> (!edit-&gt;</span>has_prev_log_number_) &#123;</div><div class="line">   <span class="function"><span class="title">edit</span>-&gt;</span>SetPrevLogNumber(prev_log_number_);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="title">edit</span>-&gt;</span>SetNextFile(next_file_number_);</div><div class="line"> <span class="function"><span class="title">edit</span>-&gt;</span>SetLastSequence(last_sequence_);</div><div class="line"></div><div class="line"> Version* v = new Version(this);</div><div class="line"> &#123;</div><div class="line">   Builder builder(this, current_);</div><div class="line">   builder.Apply(edit);</div><div class="line">   builder.SaveTo(v);</div><div class="line"> &#125;</div><div class="line"> Finalize(v);<span class="comment">//这个函数主要是用来更新每一层文件合并分数.</span></div></pre></td></tr></table></figure></p>
<p>源码很简单,设置文件编号,将edit应用到新版本中.3,4步代码很简单,就不黏贴出来了.</p>
<p>Version_set类主要功能包括调用当前版本的Get方法和添加迭代器方法,以及从磁盘manifest文件恢复当新版本中,将edit信息写进manifest并应用到当前版本中,其他就和合并相关了,暂时不叙述~</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> version </tag>
            
            <tag> version_edit </tag>
            
            <tag> version_set </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之快照SnapShots]]></title>
      <url>http://luodw.cc/2015/10/31/leveldb-15/</url>
      <content type="html"><![CDATA[<p>之前在学习过程中，也有听过快照这个概念，但是根本不知为何物，更不要说实现原理了。看了leveldb快照实现之后，我对快照这个概念有个简单的认识，因为我百度之后，发现大型数据库的快照的实现和leveldb的快照实现是有区别的。我的理解是，leveldb的快照主要功能是用来读取某个时间点之前的数据，因为leveldb在插入数据时，键值是可以一样的，所以当查询这个键值时，系统返回的是最新的数据，也就是后面插入的数据。但是如果在第二次插入相同键值数据之前，建立一个快照，那么读取这个快照时，读取的就是这个快照时间点之前的数据。</p>
<p>好，接下来，就来分析下leveldb快照的实现原理。</p>
<h1>SnapShots类</h1>
<p>leveldb实现快照的原理关键就在于那个sequence number。每当插入一条记录时，都会插入一个独一无二的序列号，而且这个序列号是递增的。所以当插入两条记录的键值一样时，只能通过序列号来区分哪条记录是最新的，因为系统返回的是最新的。而快照SnapShot类的实现原理就是，当调用函数获取一个快照时，就获取目前的sequence number，当读取数据时，只读取小于等于这个序列号的记录，这样就可以读取这个快照时间点之前的数据了。</p>
<p>leveldb实现了保存多个快照的功能，用的是环形双向链表实现。链表保存一个傀儡节点dummy，也就是不存储有用数据的节点。dummy.prev是最新的节点，dummy.next为最“老”的节点。当插入快照时，往dummy之前插入，删除，则删除dummy.next节点。</p>
<p>SnapShots是一个抽象类，在db.h中有声明，真正的快照实现类为SnapshotImpl,在snapshot.h定义，源码如下:
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotImpl</span> : <span class="type">public Snapshot &#123;</span></span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  SequenceNumber number_;  <span class="comment">// 保存当前快照的序列号</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">SnapshotList</span>;</span></div><div class="line"></div><div class="line">  <span class="comment">// 用于插入链表时，更新前后关系</span></div><div class="line">  SnapshotImpl* prev_;</div><div class="line">  SnapshotImpl* next_;</div><div class="line"></div><div class="line">  SnapshotList* list_;   <span class="comment">//这个节点所属的链表，源码注释是“合理性检查”</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个是SnapShot实现类也就是dbimpl中操作的快照类，每生成一个快照时，要插入双向链表中，链表源码如下:
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotList</span> </span>&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  SnapshotList() &#123;</div><div class="line">    list_.prev_ = &amp;list_;<span class="comment">//初始dummy节点时，前后节点为自己</span></div><div class="line">    list_.next_ = &amp;list_;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">empty</span>() <span class="keyword">const</span> &#123; <span class="keyword">return</span> list_.next_ == &amp;list_; &#125;<span class="comment">//判断是否为空</span></div><div class="line">  <span class="comment">//取出最“老”的快照</span></div><div class="line">  SnapshotImpl* oldest() <span class="keyword">const</span> &#123; assert(!<span class="keyword">empty</span>()); <span class="keyword">return</span> list_.next_; &#125;</div><div class="line">  <span class="comment">//取出最新的快照</span></div><div class="line">  SnapshotImpl* newest() <span class="keyword">const</span> &#123; assert(!<span class="keyword">empty</span>()); <span class="keyword">return</span> list_.prev_; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> SnapshotImpl* <span class="keyword">New</span>(SequenceNumber seq) &#123;</div><div class="line">    SnapshotImpl* s = <span class="keyword">new</span> SnapshotImpl;</div><div class="line">    s-&gt;number_ = seq;</div><div class="line">    s-&gt;list_ = this;</div><div class="line">    s-&gt;next_ = &amp;list_;</div><div class="line">    s-&gt;prev_ = list_.prev_;</div><div class="line">    s-&gt;prev_-&gt;next_ = s;</div><div class="line">    s-&gt;next_-&gt;prev_ = s;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;<span class="comment">//新生成一个快照，并插入链表中</span></div><div class="line"></div><div class="line">  void Delete(<span class="keyword">const</span> SnapshotImpl* s) &#123;</div><div class="line">    assert(s-&gt;list_ == this);</div><div class="line">    s-&gt;prev_-&gt;next_ = s-&gt;next_;</div><div class="line">    s-&gt;next_-&gt;prev_ = s-&gt;prev_;</div><div class="line">    delete s;</div><div class="line">  &#125;<span class="comment">//删除一个快照</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Dummy head of doubly-linked list of snapshots</span></div><div class="line">  SnapshotImpl list_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1>上层调用实现</h1>
<p>在dbimpl类里，定义了一个SnapshotList成员变量，用来保存以及取出快照，当用户程序调用db-&gt;GetSnapshot()时，真实调用的是:
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Snapshot* DBImpl::GetSnapshot() &#123;</div><div class="line">  MutexLock l(&amp;mutex_);</div><div class="line">  <span class="keyword">return</span> snapshots_.<span class="keyword">New</span>(versions_-&gt;LastSequence());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用SnapshotList的new方法，用上一个序列号生成一个快照，并且插入快照链表里。当用户调用db-&gt;ReleaseSnapshot(readoptions.snapshot)时，真实调用的是:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DBImpl::ReleaseSnapshot(<span class="keyword">const</span> Snapshot* s) &#123;</div><div class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</div><div class="line">  snapshots_.Delete(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(s));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用SnapshotList的delete方法，将当前使用的快照删除。</p>
<p>因为写入记录时，不涉及快照的问题，只有读取时，才有快照的存在。所以当系统调用db-&gt;get和db-&gt;NewIterator时，才关系快照问题。当调用get时，</p>
<ol>
<li>首先判断是否定义了readoption.snapshot，如果定义了，那么就按这个快照读取数据;</li>
<li>如果没有定义，那么就用上一个序列号作为快照序列号来读取数据。</li>
</ol>
<h1>写个小程序展示快照的使用方法</h1>
<p>实例程序如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;leveldb/db.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	leveldb::DB *db;</div><div class="line">	leveldb::Options options;</div><div class="line">	options.create_if_missing=<span class="literal">true</span>;</div><div class="line">	leveldb::Status status=leveldb::DB::Open(options,<span class="string">"mydb2"</span>,&amp;db);</div><div class="line">	assert(status.ok());</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> key1=<span class="string">"fruit"</span>;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> value1=<span class="string">"apple"</span>;</div><div class="line">	status=db-&gt;Put(leveldb::WriteOptions(),key1,value1);</div><div class="line">	assert(status.ok());</div><div class="line">	leveldb::ReadOptions readoptions;</div><div class="line">	<span class="comment">//readoptions.snapshot=db-&gt;GetSnapshot();</span></div><div class="line">	 <span class="built_in">std</span>::<span class="built_in">string</span> value2=<span class="string">"orange"</span>;</div><div class="line">	 status=db-&gt;Put(leveldb::WriteOptions(),key1,value2);</div><div class="line">	 assert(status.ok());</div><div class="line">	 <span class="built_in">std</span>::<span class="built_in">string</span> value;</div><div class="line">	 status=db-&gt;Get(leveldb::ReadOptions(),key1,&amp;value);</div><div class="line">    	assert(status.ok());</div><div class="line">	 <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	 <span class="comment">//db-&gt;ReleaseSnapshot(readoptions.snapshot);</span></div><div class="line">	 <span class="keyword">delete</span> db;</div><div class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个程序很简单，一开始先往数据库插入一条键值对，接着再插入一条键值一样的记录，最后读出这个键值对应的value时，显示为最新的数据，也就是orange。</p>
<p>当我把两个注释去掉，并且把db-&gt;Get方法里的leveldb::ReadOptions()改成第一个注释中的readoptions时，这时输出为快照之前的数据，为apple。</p>
<p>在理解快照时，有参考博客<a href="http://blog.xiaoheshang.info/?p=339" target="_blank" rel="external">小和尚的藏经阁</a>;</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> levldb </tag>
            
            <tag> SnapShots </tag>
            
            <tag> 快照 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之WriteBatch]]></title>
      <url>http://luodw.cc/2015/10/30/leveldb-14/</url>
      <content type="html"><![CDATA[<p>leveldb提供的接口除了针对一条记录的插入和删除操作之外，还提供了批量更新的操作，即writebatch类。writebatch类只有一个成员变量，存储的是若干条记录的序列号字符串，这个字符串是按照一定格式生成，当要取出这些记录时，也要按照格式一条一条解析出来。</p>
<p>&lt;!--more--&gt;</p>
<h1>WriteBatch类</h1>
<p>先介绍下这个类的成员变量rep_，这个字符串用来存储这次批操作的所有记录，格式如下:
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">WriteBatch:</span>:rep_:=</div><div class="line"><span class="symbol">	sequence:</span> fixed64</div><div class="line"><span class="symbol">	count:</span> fixed32</div><div class="line"><span class="symbol">	data:</span> record[count]</div><div class="line"><span class="symbol">record:</span> kTypeValue varstring varstring</div><div class="line">        kTypeDeletion varstring</div><div class="line"><span class="symbol">varstring:</span></div><div class="line"><span class="symbol">       len:</span> varint32</div><div class="line"><span class="symbol">       data:</span> uint8[len]</div></pre></td></tr></table></figure></p>
<p>可以看到这个这个字符串首先有有8字节的序列号和4字节的记录数作为头，所以这个类定义了
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> KHeader=<span class="number">12</span></div></pre></td></tr></table></figure></p>
<p>作为这个这个字符串的最小长度。在头之后，紧接着就是一条一条的记录。</p>
<ol>
<li>对于插入的记录，由kTypeValue+key长度+key+value长度+value组成</li>
<li>对于删除记录，由kTypeDelete+key长度+key组成</li>
</ol>
<p>在介绍这个WriteBatch这个类的操作函数之前，需要先介绍操作WriteBatch这个类的WriteBatchInternal。</p>
<h1>WriteBatchInternal类</h1>
<p>这个类主要作用就是操作WriteBatch的字符串，比如取出/设置序列号，取出/设置记录数，将WriteBatch插入memtable等等。</p>
<p>来看下这个类的操作成员方法，全部声明为static方法:
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> WriteBatchInternal::Count(<span class="keyword">const</span> WriteBatch* b) &#123;</div><div class="line">  <span class="keyword">return</span> DecodeFixed32(b-&gt;rep_.data() + <span class="number">8</span>);</div><div class="line">&#125;<span class="comment">//获得这个WriteBatch的记录数</span></div><div class="line"></div><div class="line">void WriteBatchInternal::SetCount(WriteBatch* b, <span class="keyword">int</span> n) &#123;</div><div class="line">  EncodeFixed32(&amp;b-&gt;rep_[<span class="number">8</span>], n);</div><div class="line">&#125;<span class="comment">//设置这个WriteBatch的记录数</span></div><div class="line"></div><div class="line">SequenceNumber WriteBatchInternal::Sequence(<span class="keyword">const</span> WriteBatch* b) &#123;</div><div class="line">  <span class="keyword">return</span> SequenceNumber(DecodeFixed64(b-&gt;rep_.data()));</div><div class="line">&#125;<span class="comment">//设置这个WriteBatch的序列号</span></div><div class="line"></div><div class="line">void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) &#123;</div><div class="line">  EncodeFixed64(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</div><div class="line">&#125;<span class="comment">//设置这个WriteBatch的序列号</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> Slice Contents(<span class="keyword">const</span> WriteBatch* batch) &#123;</div><div class="line">  <span class="keyword">return</span> Slice(batch-&gt;rep_);</div><div class="line">&#125;<span class="comment">//获得这个WriteBatch的所有内容</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> size_t ByteSize(<span class="keyword">const</span> WriteBatch* batch) &#123;</div><div class="line">  <span class="keyword">return</span> batch-&gt;rep_.size();</div><div class="line">&#125;<span class="comment">//获得这个WriteBatch的记录总和大小</span></div><div class="line"></div><div class="line">Status WriteBatchInternal::InsertInto(<span class="keyword">const</span> WriteBatch* b,</div><div class="line">                                      MemTable* memtable) &#123;</div><div class="line">  MemTableInserter inserter;</div><div class="line">  inserter.sequence_ = WriteBatchInternal::Sequence(b);</div><div class="line">  inserter.mem_ = memtable;</div><div class="line">  <span class="keyword">return</span> b-&gt;Iterate(&amp;inserter);</div><div class="line">&#125;<span class="comment">//将这个WriteBatch的所有记录添加进memtable</span></div><div class="line"></div><div class="line">void WriteBatchInternal::SetContents(WriteBatch* b, <span class="keyword">const</span> Slice&amp; contents) &#123;</div><div class="line">  assert(contents.size() &gt;= kHeader);</div><div class="line">  b-&gt;rep_.assign(contents.data(), contents.size());</div><div class="line">&#125;<span class="comment">//设置这个WriteBatch的内容</span></div><div class="line"></div><div class="line">void WriteBatchInternal::Append(WriteBatch* dst, <span class="keyword">const</span> WriteBatch* src) &#123;</div><div class="line">  SetCount(dst, Count(dst) + Count(src));</div><div class="line">  assert(src-&gt;rep_.size() &gt;= kHeader);</div><div class="line">  dst-&gt;rep_.append(src-&gt;rep_.data() + kHeader, src-&gt;rep_.size() - kHeader);</div><div class="line">&#125;<span class="comment">//将src中的所有记录添加进dst中</span></div></pre></td></tr></table></figure></p>
<h1>WriteBatch接口</h1>
<p>介绍了上述这个操作WriteBatch类之后，接下来就来看下WriteBatch这类提供的接口，主要是将记录添加进rep_以及从rep_中解析出所有记录。</p>
<p>将记录添加到rep_接口为:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> WriteBatch::Put(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</div><div class="line">  <span class="comment">//先将记录数加1</span></div><div class="line">  WriteBatchInternal::SetCount(<span class="keyword">this</span>, WriteBatchInternal::Count(<span class="keyword">this</span>) + <span class="number">1</span>);</div><div class="line">  rep_.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kTypeValue));<span class="comment">//添加类型</span></div><div class="line">  PutLengthPrefixedSlice(&amp;rep_, key);<span class="comment">//添加key的长度和值</span></div><div class="line">  PutLengthPrefixedSlice(&amp;rep_, value);<span class="comment">//添加value的长度和值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> WriteBatch::Delete(<span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  <span class="comment">//设置记录数加1</span></div><div class="line">  WriteBatchInternal::SetCount(<span class="keyword">this</span>, WriteBatchInternal::Count(<span class="keyword">this</span>) + <span class="number">1</span>);</div><div class="line">  <span class="comment">//添加类型</span></div><div class="line">  rep_.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kTypeDeletion));</div><div class="line">  <span class="comment">//添加key以及key值</span></div><div class="line">  PutLengthPrefixedSlice(&amp;rep_, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在memtable是没有删除操作的，但是可以将记录分为正常的键值对和删除键类型。当搜索删除类型键值时，返回kNoFoun，表示memtable里面没有这条记录。等到compaction时才真正删除。</p>
<p>在介绍如何解析这个rep_成一条一条记录时，需要先介绍下MemTableInserter这个类，这个类继承自Handler这个抽象类，定义如下:</p>
<p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">MemTableInserter</span> : <span class="title">public</span> <span class="title">WriteBatch</span>::<span class="title">Handler</span> &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  SequenceNumber sequence_;</div><div class="line">  MemTable* mem_;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Put</span>(<span class="params"><span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">    mem_-&gt;Add(sequence_, kTypeValue, key, <span class="keyword">value</span>);</div><div class="line">    sequence_++;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params"><span class="keyword">const</span> Slice&amp; key</span>) </span>&#123;</div><div class="line">    mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());</div><div class="line">    sequence_++;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个类很简单，通过memtable将正常的键值对和删除类型的键值对添加进memtable。这个类将作为参数，传入rep_解析函数，如下；</p>
<p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">Status WriteBatch::Iterate(Handler* <span class="keyword">handler</span>) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="function">Slice <span class="title">input</span><span class="params">(rep_)</span></span>;</div><div class="line">  <span class="keyword">if</span> (input.size() &lt; kHeader) &#123;<span class="comment">//字符串至少等于12</span></div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"malformed WriteBatch (too small)"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  input.remove_prefix(kHeader);移除头<span class="number">12</span>个字节</div><div class="line">  Slice key, value;</div><div class="line">  <span class="keyword">int</span> found = <span class="number">0</span>;<span class="comment">//代表记录数</span></div><div class="line">  <span class="keyword">while</span> (!input.empty()) &#123;</div><div class="line">    found++;</div><div class="line">    <span class="keyword">char</span> tag = input[<span class="number">0</span>];<span class="comment">//获取类型</span></div><div class="line">    input.remove_prefix(<span class="number">1</span>);<span class="comment">//移除一字节</span></div><div class="line">    <span class="keyword">switch</span> (tag) &#123;</div><div class="line">      <span class="keyword">case</span> kTypeValue://正常键值对</div><div class="line">        <span class="keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key) &amp;&amp;</div><div class="line">            GetLengthPrefixedSlice(&amp;input, &amp;value)) &#123;<span class="comment">//解析出key和value</span></div><div class="line">          <span class="keyword">handler</span>-&gt;Put(key, value);<span class="comment">//通过上述类添加进memtable中</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> Status::Corruption(<span class="string">"bad WriteBatch Put"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> kTypeDeletion://删除类型</div><div class="line">        <span class="keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key)) &#123;</div><div class="line">          <span class="keyword">handler</span>-&gt;Delete(key);<span class="comment">//将删除类型键值添加进memtable</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> Status::Corruption(<span class="string">"bad WriteBatch Delete"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"unknown WriteBatch tag"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (found != WriteBatchInternal::Count(<span class="keyword">this</span>)) &#123;<span class="comment">//判断添加的记录数是否等于WriteBatch中持有的记录数</span></div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"WriteBatch has wrong count"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> Status::OK();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法解析出一条记录，然后判断记录的类型，根据不同的类型，调用Hander不同的方法将记录插入memtable中。这个方法最后由WriteBatchInternal这个类的InsertInto调用；</p>
<p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Status WriteBatchInternal::<span class="keyword">InsertInto(const </span>WriteBatch* <span class="keyword">b,</span></div><div class="line">                                      MemTable* memtable) &#123;</div><div class="line">  MemTableInserter <span class="keyword">inserter;</span></div><div class="line">  <span class="keyword">inserter.sequence_ </span>= WriteBatchInternal::Sequence(<span class="keyword">b);//公有成员，直接赋值</span></div><div class="line">  <span class="keyword">inserter.mem_ </span>= memtable<span class="comment">;//公有成员，直接赋值</span></div><div class="line">  return <span class="keyword">b-&gt;Iterate(&amp;inserter);//调用WriteBatch的解析方法，将所有记录插入memtable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>上层方法调用</h1>
<p>在DBImpl最上层类中，当插入数据时，先是调用WriteBatch的put和delete方法将记录添加进rep_，然后调用WriteBatchInternal:InsertInto方法:</p>
<p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Status DBImpl::Put(<span class="keyword">const</span> WriteOptions&amp; o, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; val) &#123;</div><div class="line">  <span class="keyword">return</span> DB::Put(o, key, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DBImpl::Delete(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  <span class="keyword">return</span> DB::Delete(options, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DB::Put(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</div><div class="line">  WriteBatch batch;</div><div class="line">  batch.Put(key, value);</div><div class="line">  <span class="function"><span class="keyword">return</span> <span class="title">Write</span><span class="params">(opt, &amp;batch)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DB::Delete(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  WriteBatch batch;</div><div class="line">  batch.Delete(key);</div><div class="line">  <span class="function"><span class="keyword">return</span> <span class="title">Write</span><span class="params">(opt, &amp;batch)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先是调用DB:Put和DB:Delete方法，这两个方法再调用Write将数据写到memtable。Write最终是先将rep_中的记录先添加进log文件，最后调用WriteBatchInternal:InsertInto方法，将记录添加进memtable。</p>
<h1>写个小程序</h1>
<p>我写个小程序来介绍下WriteBatch这个类是怎么用的。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;leveldb/db.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;leveldb/write_batch.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	leveldb::DB *db;</div><div class="line">	leveldb::Options options;</div><div class="line">	options.create_if_missing=<span class="literal">true</span>;</div><div class="line">	leveldb::Status status=leveldb::DB::Open(options,<span class="string">"mydb"</span>,&amp;db);</div><div class="line">	assert(status.ok());</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> key1=<span class="string">"book"</span>;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> value1=<span class="string">"algorithm"</span>;</div><div class="line">	status=db-&gt;Put(leveldb::WriteOptions(),key1,value1);</div><div class="line">	assert(status.ok());</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> value;</div><div class="line">        status=db-&gt;Get(leveldb::ReadOptions(),key1,&amp;value);</div><div class="line">	assert(status.ok());</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"book:"</span>&lt;&lt;value&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	leveldb::WriteBatch batch;</div><div class="line">	batch.Delete(key1);</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> key2=<span class="string">"fruit"</span>;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> value2=<span class="string">"apple"</span>;</div><div class="line">	batch.Put(key2,value2);</div><div class="line">	status=db-&gt;Write(leveldb::WriteOptions(),&amp;batch);</div><div class="line">	assert(status.ok());</div><div class="line">	leveldb::Iterator *iter=db-&gt;NewIterator(leveldb::ReadOptions());</div><div class="line">	<span class="keyword">for</span>(iter-&gt;SeekToFirst();iter-&gt;Valid();iter-&gt;Next())</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;iter-&gt;key().ToString()&lt;&lt;<span class="string">":"</span>&lt;&lt;iter-&gt;value().ToString()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">delete</span> db;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个程序先是添加一个键值对，book:algorithm，然后用WriteBatch进行批量操作，先是删除book:键值对，然后添加fruit::apple键值对，最后输出结果如下:</p>
<p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">book:</span>algorithm</div><div class="line"><span class="symbol">fruit:</span>apple</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> WriteBatch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STL源码分析之list]]></title>
      <url>http://luodw.cc/2015/10/28/STL-list/</url>
      <content type="html"><![CDATA[<p>上篇文章分析了vector的实现原理，今天就来来看看list的源码实现。STL用环状双向链表来实现list，方法和leveldb的缓存环状链表一样，链表持有一个傀儡节点，不存储数据，只为这个链表的入口。迭代链表时，首先通过链表获得这个这个傀儡节点，然后通过next迭代所有数据。</p>
<p>STL将链表的傀儡节点作为链表的end节点，傀儡节点的next为begin节点，这样以来，就可以用[begin,end)这种左闭右开的形式来表示迭代器范围，和其他容器保持一致。</p>
<h1>list节点结构</h1>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> __list_node &#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</div><div class="line">  void_pointer next;  <span class="comment">// 为void*类型，其实可以是__list_node&lt;T&gt;*</span></div><div class="line">  void_pointer prev;</div><div class="line">  T data;<span class="comment">//存储数据</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>因为是双向链表，所以有两个指针，分别指向前向指针和后向指针。</p>
<h1>迭代器类型</h1>
<p>因为list数据不是存储在连续的内存内，所以不能通过指针的加１减一来实现迭代器。list数据是通过指针链表结合在一起的，所以为了迭代所有数据，必须通过上个节点找到下个节点的地址，进而访问下个节点。list迭代器就是用这个原理，实现如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Ref, <span class="keyword">class</span> Ptr&gt;</div><div class="line"><span class="keyword">struct</span> __list_iterator &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</div><div class="line"></div><div class="line">  link_type node;  <span class="comment">// 这个迭代器指向的节点</span></div><div class="line"></div><div class="line">  <span class="comment">// 迭代器构造函数</span></div><div class="line">  __list_iterator(link_type x) : node(x) &#123;&#125;</div><div class="line">  __list_iterator() &#123;&#125;</div><div class="line">  __list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代器必要的行为实现</span></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</div><div class="line">  <span class="comment">//迭起器取值，取得是节点的值</span></div><div class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;	</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></div><div class="line">  <span class="comment">//成员调用操作符</span></div><div class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></div><div class="line"></div><div class="line">  <span class="comment">// 先加１，再返回，类似与++i</span></div><div class="line">  self&amp; <span class="keyword">operator</span>++() &#123; </div><div class="line">    node = (link_type)((*node).next);  	</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//先加１，然后返回加１前的数据，类似与i++</span></div><div class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </div><div class="line">    self tmp = *<span class="keyword">this</span>;</div><div class="line">    ++*<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 先减１，再返回，类似于--i</span></div><div class="line">  self&amp; <span class="keyword">operator</span>--() &#123; </div><div class="line">    node = (link_type)((*node).prev); 	</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//先减１，再返回减１前的数据，类似于i--</span></div><div class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </div><div class="line">    self tmp = *<span class="keyword">this</span>;</div><div class="line">    --*<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> tmp;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>以上就是list的迭代器实现，只实现了迭代器的++,--，取值，成员调用四个基本操作，并没有像vector迭代器那样的+n操作，主要是因为地址不连续。</p>
<h1>list实现</h1>
<p>接下来看下list实现，list只有一个成员变量，就是那个傀儡节点，也是end节点。</p>
<p>先来看构造函数:
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">list() &#123; empty_initialize(); &#125; </div><div class="line">void empty_initialize() &#123; </div><div class="line">  <span class="keyword">node</span> <span class="title">= get_node</span>();	//创建一个节点，就是调用配置器分配内存 </div><div class="line">  <span class="keyword">node</span><span class="title">-&gt;next</span> = <span class="keyword">node</span><span class="title">;	//傀儡节点的前后都指向自己，形成一个环</span></div><div class="line">  node-&gt;prev = <span class="keyword">node</span><span class="title">;　</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个构造函数为默认构造函数，就是创建一个节点，然后前后指向自己而已。说到配置器，由于list用的是自己定义节点结构体，所以也定义了相应类型的配置器。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</div></pre></td></tr></table></figure></p>
<p>list还定义几种构造函数，用n个值来初始化list，将另一个list的一部分数据来初始化list和复制构造函数。
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">list(size_type <span class="built_in">n</span>, const <span class="built_in">T</span>&amp; <span class="built_in">value</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">value</span>); &#125;</div><div class="line">list(<span class="built_in">int</span> <span class="built_in">n</span>, const <span class="built_in">T</span>&amp; <span class="built_in">value</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">value</span>); &#125;</div><div class="line">list(long <span class="built_in">n</span>, const <span class="built_in">T</span>&amp; <span class="built_in">value</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">value</span>); &#125;</div><div class="line">explicit list(size_type <span class="built_in">n</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">T</span>()); &#125;</div><div class="line">  list(const_iterator first, const_iterator last) &#123;</div><div class="line">  range_initialize(first, last);</div><div class="line">&#125;</div><div class="line">  list(const list&lt;<span class="built_in">T</span>, Alloc&gt;&amp; x) &#123;</div><div class="line">  range_initialize(x.begin(), x.end());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这几个函数调用了fill_initialize和range_initialize，来看下这两个函数。
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void fill_initialize(size_type n, const T&amp; value) &#123;</div><div class="line">  empty_initialize();</div><div class="line">  __STL_TRY &#123;</div><div class="line">    <span class="keyword">insert</span>(<span class="keyword">begin</span>(), n, <span class="keyword">value</span>);</div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(clear(); put_node(node));</div><div class="line">&#125;</div><div class="line"> void range_initialize(InputIterator first, InputIterator last) &#123;</div><div class="line">  empty_initialize();</div><div class="line">  __STL_TRY &#123;</div><div class="line">    <span class="keyword">insert</span>(<span class="keyword">begin</span>(), <span class="keyword">first</span>, <span class="keyword">last</span>);</div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(clear(); put_node(node));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数最后分别调用了insert函数的不同版本。一起来看下这两个insert函数。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</div><div class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::insert(iterator position, size_type n, <span class="keyword">const</span> T&amp; x) &#123;</div><div class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n)</div><div class="line">    insert(position, x);</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt; <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;</div><div class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T, Alloc&gt;::insert(iterator position,</div><div class="line">                            InputIterator first, InputIterator last) &#123;</div><div class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</div><div class="line">    insert(position, *first);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数通过循环调用 iterator insert(iterator position, const T&amp; x) 这个insert版本，将数据一个一个插入到position之前，初始时就是插入到傀儡节点后面，形成初始链表，源码如下:
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">iterator insert(iterator position, const T&amp; x) &#123;</div><div class="line">  link_type tmp = create_node(x); <span class="comment">//用x初始化构造一个节点</span></div><div class="line">  <span class="comment">// 将节点插入到position之前，更新前后关系</span></div><div class="line">  <span class="function"><span class="title">tmp</span>-&gt;</span>next = position.node;</div><div class="line">  <span class="function"><span class="title">tmp</span>-&gt;</span><span class="function"><span class="title">prev</span> = position.node-&gt;</span>prev;</div><div class="line">  (<span class="function"><span class="title">link_type</span>(position.node-&gt;</span><span class="function"><span class="title">prev</span>))-&gt;</span>next = tmp;</div><div class="line">  <span class="function"><span class="title">position</span>.node-&gt;</span>prev = tmp;</div><div class="line">  return tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后看下析构函数
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">~list() &#123;</div><div class="line">  clear();</div><div class="line">  put_node(<span class="keyword">node</span><span class="title">);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数，clear是清空链表所有数据，然后put_node是将傀儡节点回收了。</p>
<h1>一些小函数</h1>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (link_type)((*node).next); &#125;</div><div class="line"> <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type)((*node).next); &#125;</div><div class="line"> <span class="comment">// begin函数返回的是傀儡节点的下一个节点</span></div><div class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node; &#125;	</div><div class="line">   <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node; &#125;</div><div class="line"> <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;</div><div class="line"> <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </div><div class="line">   <span class="keyword">return</span> const_reverse_iterator(end()); </div><div class="line"> &#125;</div><div class="line"> <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;</div><div class="line"> <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </div><div class="line">   <span class="keyword">return</span> const_reverse_iterator(begin());</div><div class="line"> &#125; </div><div class="line"> <span class="comment">//当傀儡节点的下一个节点等于自己的时候，链表为空</span></div><div class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node-&gt;next == node; &#125;</div><div class="line"> <span class="comment">//链表元素个数，通过调用distance函数求值</span></div><div class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">   size_type result = <span class="number">0</span>;</div><div class="line">   distance(begin(), end(), result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line"> &#125;</div><div class="line"> <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>); &#125;</div><div class="line"> <span class="comment">//链表最多能存储节点数</span></div><div class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;  </div><div class="line"> <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;</div><div class="line"> <span class="comment">// 取节点的内容，为引用。</span></div><div class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--end()); &#125; </div><div class="line"> <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *(--end()); &#125;</div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x)</span> </span>&#123; __STD::swap(node, x.node); &#125;</div></pre></td></tr></table></figure></p>
<p>最后一个交换两个链表，只需要通过标准函数库的swap函数，交换两个傀儡节点即可，因为傀儡节点是每个链表的入口。</p>
<h1>一些常用函数</h1>
<ol>
<li>
<p>往链表前插一个元素，通过调用insert完成。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(begin(), x); &#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>往链表尾巴插一个元素，也是通过insert函数完成。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123; insert(end(), x); &#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>移除一个元素
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="title">iterator</span> erase(iterator position) &#123;</div><div class="line">  link_<span class="keyword">type</span> next_node = link_type(position.node-&gt;next);</div><div class="line">  link_<span class="keyword">type</span> prev_node = link_type(position.node-&gt;prev);</div><div class="line">  prev_node-&gt;next = next_node;</div><div class="line">  next_node-&gt;prev = prev_node;</div><div class="line">  destroy_node(position.node);</div><div class="line">  return iterator(next_node);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这个函数也很简单，只需要将被移除节点的前后节点跳过当前节点即可。</p>
<ol start="4">
<li>前后删除一个节点，用erase函数实现:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; erase(begin()); &#125;<span class="comment">//删除第一元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123; </div><div class="line">  iterator tmp = end();</div><div class="line">  erase(--tmp);<span class="comment">//删除傀儡节点前一个元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<h1>transfer函数</h1>
<p>这个函数是很多list接口调用的函数。这个函数有点难看懂，我把《STL源码剖析》上的图截下来，容易理解:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_022.png" alt="transfer函数示意图">;</p>
<p>源码如下:
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将[first,last)区间内的所有元素搬移到position之前</span></div><div class="line">void transfer(iterator position, iterator <span class="built_in">first</span>, iterator last) &#123;</div><div class="line">  if (position != last) &#123;</div><div class="line">    (*(link_type((*last.node).<span class="built_in">prev</span>))).<span class="built_in">next</span> = position.node;	　　　　<span class="comment">// (1)</span></div><div class="line">    (*(link_type((*<span class="built_in">first</span>.node).<span class="built_in">prev</span>))).<span class="built_in">next</span> = last.node;		<span class="comment">// (2)</span></div><div class="line">    (*(link_type((*position.node).<span class="built_in">prev</span>))).<span class="built_in">next</span> = <span class="built_in">first</span>.node;  	<span class="comment">// (3)</span></div><div class="line">    link_type tmp = link_type((*position.node).<span class="built_in">prev</span>);			<span class="comment">// (4)</span></div><div class="line">    (*position.node).<span class="built_in">prev</span> = (*last.node).<span class="built_in">prev</span>;			<span class="comment">// (5)</span></div><div class="line">    (*last.node).<span class="built_in">prev</span> = (*<span class="built_in">first</span>.node).<span class="built_in">prev</span>; 				<span class="comment">// (6)</span></div><div class="line">    (*<span class="built_in">first</span>.node).<span class="built_in">prev</span> = tmp;						<span class="comment">// (7)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按着序号来读那个示意图，应该能看懂，本质上就那几个关键节点的前后关系。</p>
<p>有了这个函数之后，就出现了一些很有用的函数:
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//将x链表的所有元素插入到当前list的<span class="built_in">position</span>处</div><div class="line">void <span class="built_in">splice</span>(iterator <span class="built_in">position</span>, list&amp; x) &#123;</div><div class="line">  <span class="keyword">if</span> (!x.empty()) </div><div class="line">    transfer(<span class="built_in">position</span>, x.begin(), x.end());</div><div class="line">&#125;</div><div class="line">//将i处节点插到<span class="built_in">position</span>之前，i和<span class="built_in">position</span>可能来自同一个链表</div><div class="line">void <span class="built_in">splice</span>(iterator <span class="built_in">position</span>, list&amp;, iterator i) &#123;</div><div class="line">  iterator j = i;</div><div class="line">  ++j;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">position</span> == i || <span class="built_in">position</span> == j) <span class="built_in">return</span>;</div><div class="line">  transfer(<span class="built_in">position</span>, i, j);</div><div class="line">&#125;</div><div class="line">// 将[<span class="built_in">first</span>,<span class="built_in">last</span>) 內的所有元素结合于 <span class="built_in">position</span> 所指位置之前。</div><div class="line">// <span class="built_in">position</span> 和[<span class="built_in">first</span>,<span class="built_in">last</span>)可指向同一個list，</div><div class="line">// 但<span class="built_in">position</span>不能位于[<span class="built_in">first</span>,<span class="built_in">last</span>)之內。</div><div class="line">void <span class="built_in">splice</span>(iterator <span class="built_in">position</span>, list&amp;, iterator <span class="built_in">first</span>, iterator <span class="built_in">last</span>)  &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">first</span> != <span class="built_in">last</span>) </div><div class="line">    transfer(<span class="built_in">position</span>, <span class="built_in">first</span>, <span class="built_in">last</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>remove函数</h1>
<p>将数值为value的所有元素移除:
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template &lt;class T, class Alloc&gt;</div><div class="line">void list&lt;T, Alloc&gt;::remove(const T&amp; <span class="built_in">value</span>) &#123;</div><div class="line">  iterator <span class="built_in">first</span> = begin();</div><div class="line">  iterator last = end();</div><div class="line">  <span class="keyword">while</span> (<span class="built_in">first</span> != last) &#123;	<span class="comment">// 通过前后节点来迭代所有节点</span></div><div class="line">    iterator <span class="built_in">next</span> = <span class="built_in">first</span>;</div><div class="line">    ++<span class="built_in">next</span>;</div><div class="line">    if (*<span class="built_in">first</span> == <span class="built_in">value</span>) erase(<span class="built_in">first</span>); 	<span class="comment">// 找到就移除</span></div><div class="line">    <span class="built_in">first</span> = <span class="built_in">next</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>merge函数</h1>
<p>合并两个链表，前提是两个链表必须有序，合并之后的链表也是有序的。merge之后，x链表被清空了。
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</div><div class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x) &#123;</div><div class="line">  iterator first1 = <span class="built_in">begin</span>();</div><div class="line">  iterator last1 = <span class="built_in">end</span>();</div><div class="line">  iterator first2 = x.<span class="built_in">begin</span>();</div><div class="line">  iterator last2 = x.<span class="built_in">end</span>();</div><div class="line"></div><div class="line">  <span class="built_in">while</span> (first1 != last1 &amp;&amp; first2 != last2)</div><div class="line">    <span class="built_in">if</span> (*first2 &lt; *first1) &#123;</div><div class="line">      iterator next = first2;</div><div class="line">      <span class="built_in">transfer</span>(first1, first2, ++next);</div><div class="line">      first2 = next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">else</span></div><div class="line">      ++first1;</div><div class="line">  <span class="built_in">if</span> (first2 != last2) <span class="built_in">transfer</span>(last1, first2, last2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>reverse函数</h1>
<p>这个函数是用于将链表数据反序:
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></div><div class="line">void list&lt;T, Alloc&gt;<span class="symbol">:</span><span class="symbol">:reverse</span>() &#123;</div><div class="line">  <span class="regexp">//</span>如果元素个数为０或１，啥都不做</div><div class="line">  <span class="keyword">if</span> (node-&gt;<span class="keyword">next</span> == node <span class="params">||</span> link_type(node-&gt;<span class="keyword">next</span>)-&gt;<span class="keyword">next</span> == node) <span class="keyword">return</span>;</div><div class="line">  iterator first = <span class="keyword">begin</span>();</div><div class="line">  ++first;</div><div class="line">  <span class="keyword">while</span> (first != <span class="keyword">end</span>()) &#123;</div><div class="line">    iterator old = first;</div><div class="line">    ++first;</div><div class="line">    transfer(<span class="keyword">begin</span>(), old, first);<span class="regexp">//</span>从链表<span class="keyword">begin</span>开始，一个一个插入<span class="keyword">begin</span>之前</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里要注意的是，在链表begin前插入元素，都将改变链表的begin。</p>
<h1>sort函数</h1>
<p>list不能使用STL的sort算法，因为STL的sort算法必须接受RamdonAccessIterator，而sort的迭代器为Bidirectional iterators，所以list自己实现了这个sort算法:
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</div><div class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::sort() &#123;</div><div class="line">  <span class="comment">//元素个数为0或1时，啥都不做</span></div><div class="line">  <span class="built_in">if</span> (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) <span class="built_in">return</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 一些新的list做临时存储</span></div><div class="line">  list&lt;T, Alloc&gt; carry;</div><div class="line">  list&lt;T, Alloc&gt; counter[<span class="number">64</span>];</div><div class="line">  <span class="keyword">int</span> <span class="built_in">fill</span> = <span class="number">0</span>;</div><div class="line">  <span class="built_in">while</span> (!empty()) &#123;</div><div class="line">    carry.splice(carry.<span class="built_in">begin</span>(), *<span class="keyword">this</span>, <span class="built_in">begin</span>());</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="built_in">while</span>(i &lt; <span class="built_in">fill</span> &amp;&amp; !counter[i].empty()) &#123;</div><div class="line">      counter[i].merge(carry);</div><div class="line">      carry.swap(counter[i++]);</div><div class="line">    &#125;</div><div class="line">    carry.swap(counter[i]);         </div><div class="line">    <span class="built_in">if</span> (i == <span class="built_in">fill</span>) ++<span class="built_in">fill</span>;</div><div class="line">  &#125; </div><div class="line"></div><div class="line">  <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">fill</span>; ++i) </div><div class="line">     counter[i].merge(counter[i<span class="number">-1</span>]);</div><div class="line">  swap(counter[<span class="built_in">fill</span><span class="number">-1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个排序算法，本人看的也不是很懂，看了<a href="http://m.blog.csdn.net/blog/yusiguyuan/38875429" target="_blank" rel="external">鱼思故渊</a>的博客，略懂程序执行流程。大家可以看他的博客。</p>
<p>当然list还提供了带自定义比较的上述函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Predicate&gt; <span class="function"><span class="keyword">void</span> <span class="title">remove_if</span><span class="params">(Predicate)</span></span>;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> BinaryPredicate&gt; <span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">(BinaryPredicate)</span></span>;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> StrictWeakOrdering&gt; <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">list</span>&amp;, StrictWeakOrdering)</span></span>;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> StrictWeakOrdering&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(StrictWeakOrdering)</span></span>;</div></pre></td></tr></table></figure></p>
<p>list大概就这些就这些了。</p>
<p>看STL源码真心可以学到东西，首先把基本数据结构复习了一遍，而且SGI里的数据结构比平时写的数据结构优秀多了。其次好好掌握了STL模板库用法。最后就是学到一些细节的东西，比如int(),double()表示这种类型的默认值。</p>
]]></content>
      
        <categories>
            
            <category> STL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
            <tag> C/C++ </tag>
            
            <tag> list </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STL源码分析之vector]]></title>
      <url>http://luodw.cc/2015/10/27/STL-vec/</url>
      <content type="html"><![CDATA[<p>C++标准模板库在日程编程应用非常的广泛，之前看到一篇大牛文章说，用C++开发，尽量用容器类+迭代器来代替数组+指针，因为数组+指针容易越界，或者内存泄露，相反，容器类和+迭代器都有国外大神将底层封装好，使用安全简单。而且标准模板库再一定程度上可以提高我们编程效率，假如要对一个结构体数组排序，写一个比较函数或者仿函数，调用sort函数即可。换做是c语言，还需自己写排序函数。。。</p>
<p>vector是有序容器里使用最广泛的容器。今天想分析下vector这个容器的实现，看这个文章之前，需要好好理解typetraits和iterator_traits，这两个是就是著名的特性萃取器，一个是萃取类型，一个是萃取迭代器类型。由于这两个东西很繁琐，就不写了，在代码中有用到地方，会有注释。</p>
<p>对了，再这篇文章之前，还需要把我之前<a href="http://luodw.github.io/2015/10/26/Calloc/#more" target="_blank" rel="external">内存池和配置器</a>文章看看，因为底层是用这个分配内存。</p>
<h1>构造函数</h1>
<p>先介绍vector这个模板类的成员变量:
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这不能算是成员变量，只能算内嵌类型，用于分配内存</span></div><div class="line">typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;</div><div class="line"><span class="comment">//表示目前使用空间的头</span></div><div class="line"><span class="keyword">iterator</span> start;</div><div class="line"><span class="comment">//表示目前使用空间的尾</span></div><div class="line"><span class="keyword">iterator</span> finish;</div><div class="line"><span class="comment">//表示目前可用空间的尾</span></div><div class="line"><span class="keyword">iterator</span> end_of_storage;</div></pre></td></tr></table></figure></p>
<p>finish表示下一个存储数据的位置，也就是说vector数组是存储在[start,end)里面的，而end_of_storage是可用的空间的尾，也就是说在finish和end_of_storage之间还可以存储数据，如果有容量的话。</p>
<p>好接下来是构造函数，首先是默认构造函数:
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//默认构造函数，迭代器都初始化为０，此时没有内存空间</div><div class="line">vector() <span class="symbol">:</span> start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</div><div class="line">//用<span class="built_in">n</span>个数类初始化vector</div><div class="line">  vector(size_type <span class="built_in">n</span>, const <span class="built_in">T</span>&amp; <span class="built_in">value</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">value</span>); &#125;</div><div class="line">  vector(<span class="built_in">int</span> <span class="built_in">n</span>, const <span class="built_in">T</span>&amp; <span class="built_in">value</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">value</span>); &#125;</div><div class="line">  vector(long <span class="built_in">n</span>, const <span class="built_in">T</span>&amp; <span class="built_in">value</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">value</span>); &#125;</div><div class="line">  explicit vector(size_type <span class="built_in">n</span>) &#123; fill_initialize(<span class="built_in">n</span>, <span class="built_in">T</span>()); &#125;</div></pre></td></tr></table></figure></p>
<p>这四个函数都调用了fill_initialize(size_type n, const T&amp; value) 这个函数，这个函数先调用allocate_and_fill这个函数分配内醋，并且填充数据。先看下fill_initialize函数:
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span>(<span class="params">size_type n, <span class="keyword">const</span> T&amp; <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">   start = allocate_and_fill(n, <span class="keyword">value</span>);<span class="comment">//分配内存，并且填充数据</span></div><div class="line">   finish = start + n;<span class="comment">//finish向后移动n个类型单位</span></div><div class="line">   end_of_storage = finish;<span class="comment">//可用空间和已使用空间相等</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>接来下看下allocate_and_fill这个函数:
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</div><div class="line">  iterator result = data_allocator::allocate(n);<span class="comment">//先调用配置器，分配内存</span></div><div class="line">  __STL_TRY &#123;</div><div class="line">    uninitialized_fill_n(result, n, x);<span class="comment">//这个函数用来向内存填充数据</span></div><div class="line">    <span class="keyword">return</span> result;<span class="comment">//返回内存首地址</span></div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(data_allocator::deallocate(result, n))//出现错误删除分配的内存;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数要说明几点:</p>
<ol>
<li>n是类型大小内存单元个数，作为data_allocator::allocate(n)这个函数的参数，并不是就分配n个字节，因为在allocate函数内部是如下调用的:
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static <span class="built_in">T</span> *allocate(size_t <span class="built_in">n</span>)  </div><div class="line">       &#123; return <span class="number">0</span> == <span class="built_in">n</span>? <span class="number">0</span> <span class="symbol">:</span> (<span class="built_in">T</span>*) All<span class="symbol">oc:</span><span class="symbol">:al</span>locate(<span class="built_in">n</span> * sizeof (<span class="built_in">T</span>)); &#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>所以分配到的内存是n个sizeof(T)大小的内存。</p>
<ol start="2">
<li>这个函数uninitialized_fill_n是内处处理函数，在 stl_uninitialized.h这个文件中，这个文件还包含了好几个类似函数。</li>
<li>如果一块内存单元赋值错误，那么会删除所有内存，就是类似&quot;commit and rollback&quot;回滚的功能。</li>
</ol>
<p>接下看下 uninitialized_fill_n这个函数:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first, Size n,</span></span></div><div class="line">                                            <span class="keyword">const</span> T&amp; x) &#123;</div><div class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, value_type(first));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数根据这个vector的数据类型，调用不同的函数:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T, <span class="keyword">class</span> T1&gt;</div><div class="line"><span class="keyword">inline</span> ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,</div><div class="line">                                              <span class="keyword">const</span> T&amp; x, T1*) &#123;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</div><div class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, is_POD());</div><div class="line">                                    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先判断这个数据类型是否是POD，POD是plain old data的简称，表示c语言的基础数据类型，int ,long,double等等，还有c语言的struct接口。如果是POD类型，直接用fill_n函数填充内存即可；如果不是POD类型，就需要调用构造函数来初始化内存，代码如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">inline</span> ForwardIterator</div><div class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</div><div class="line">                           <span class="keyword">const</span> T&amp; x, __true_type) &#123;</div><div class="line">  <span class="keyword">return</span> fill_n(first, n, x);<span class="comment">//类似int类型，直接用fill_n填充即可</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ForwardIterator, <span class="keyword">class</span> Size, <span class="keyword">class</span> T&gt;</div><div class="line">ForwardIterator</div><div class="line">__uninitialized_fill_n_aux(ForwardIterator first, Size n,</div><div class="line">                           <span class="keyword">const</span> T&amp; x, __false_type) &#123;</div><div class="line">  ForwardIterator cur = first;</div><div class="line">  __STL_TRY &#123;</div><div class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</div><div class="line">      construct(&amp;*cur, x);<span class="comment">//调用构造函数，这里用的是placement new来构造</span></div><div class="line">    <span class="keyword">return</span> cur;</div><div class="line">  &#125;</div><div class="line">  __STL_UNWIND(destroy(first, cur));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的构造函数调用是placement new，代码如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="keyword">const</span> T2&amp; value)</span> </span>&#123;</div><div class="line">  <span class="keyword">new</span> (p) T1(value);  <span class="comment">//将value值构造在内存p的位置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此为止，构造函数已构造完毕，接下来看下复制构造函数
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vector(const vector&lt;T, Alloc&gt;&amp; <span class="keyword">x</span>) &#123;</div><div class="line">  start = allocate_and_copy(<span class="keyword">x</span>.<span class="keyword">end</span>() - <span class="keyword">x</span>.<span class="keyword">begin</span>(), <span class="keyword">x</span>.<span class="keyword">begin</span>(), <span class="keyword">x</span>.<span class="keyword">end</span>())<span class="comment">;</span></div><div class="line">  finish = start + (<span class="keyword">x</span>.<span class="keyword">end</span>() - <span class="keyword">x</span>.<span class="keyword">begin</span>())<span class="comment">;</span></div><div class="line">  end_of_storage = finish<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先调用allocate_and_copy函数分配内存，以及复制数据,该函数如下；
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;class <span class="type">ForwardIterator</span>&gt;</div><div class="line"><span class="keyword">iterator</span> allocate_and_copy(size_type n,</div><div class="line">                           <span class="type">ForwardIterator</span> first, <span class="type">ForwardIterator</span> last) &#123;</div><div class="line">  <span class="keyword">iterator</span> <span class="literal">result</span> = data_allocator::allocate(n);//分配内存</div><div class="line">  __STL_TRY &#123;</div><div class="line">    uninitialized_copy(first, last, <span class="literal">result</span>);//复制函数</div><div class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line">  __STL_UNWIND(data_allocator::deallocate(<span class="literal">result</span>, n));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，看下uninitialized_copy这个函数；
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;<span class="built_in">class</span> InputIterator, <span class="built_in">class</span> ForwardIterator&gt;</div><div class="line">inline ForwardIterator</div><div class="line">  uninitialized_copy(InputIterator <span class="keyword">first</span>, InputIterator <span class="keyword">last</span>,</div><div class="line">                     ForwardIterator <span class="literal">result</span>) &#123;</div><div class="line"><span class="built_in">  return</span> __uninitialized_copy(<span class="keyword">first</span>, <span class="keyword">last</span>, <span class="literal">result</span>, value_type(<span class="literal">result</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据值的类型，调用不同的函数。也是区分是否为POD，调用不同的复制函数，这里不再讲述。</p>
<h1>析构函数</h1>
<p>这里构造函数暂时讲这么多，接来下，看下析构函数，析构函数很简单，先析构[start,finidh)，然后再把内存还给系统或内存池，来看下代码:
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">~vector<span class="comment">()</span> &#123; </div><div class="line">  destroy<span class="comment">(start, finish)</span>;  <span class="comment">//析构start到finish之间的数据</span></div><div class="line">  deallocate<span class="comment">()</span>;  <span class="comment">// 释放内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>destroy函数根据数据类型，如果是POD，则什么都不做，如果不是POD，则需要调用析构函数一个一个的析构。deallocate函数如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (start) data_allocator::deallocate(start, end_of_storage - start);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数回收[start,end_of_storage)之间的内存，如果是大于128b，则还给系统，如果小于128b，则还给内存池，后面可以继续使用。</p>
<h1>一些常用函数</h1>
<h2>push_back函数</h2>
<p>当创建一个空的vector时，此时空间为0，所以需要分配１个内存；当空间不够，且此时空间大小不为空时，分配原有空间的一倍，用于后续使用。来看下代码:
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span>(<span class="params"><span class="keyword">const</span> T&amp; x</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</div><div class="line">    construct(finish, x);    <span class="comment">//当还有空间时，直接在finish赋值，然后finish向后移动一个单位</span></div><div class="line">    ++finish;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">else</span></span></div><div class="line">    <span class="title">insert_aux</span>(<span class="params">end(</span>), x);<span class="comment">//内存不够时，调用分配函数，并赋值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看下insert_aux()函数:
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></div><div class="line"><span class="title">void</span> <span class="title">vector</span>&lt;<span class="title">T</span>, <span class="title">Alloc</span>&gt;::<span class="title">insert_aux</span>(<span class="title">iterator</span> <span class="title">position</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</div><div class="line">    construct(finish, *(finish - <span class="number">1</span>));</div><div class="line">    ++finish;</div><div class="line">    T x_copy = x;</div><div class="line">    copy_backward(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);<span class="comment">//把position到finish-2都向后移动一个单位，将position空间留出来</span></div><div class="line">    *position = x_copy;<span class="comment">//给这个空间赋值</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    const size_type old_size = size();</div><div class="line">    const size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="type">1</span>;<span class="comment">//设置新长度</span></div><div class="line">    iterator <span class="keyword">new</span><span class="type">_start</span> = data_allocator:<span class="type"></span>:allocate(len);<span class="comment">//分配新空间</span></div><div class="line">    iterator <span class="keyword">new</span><span class="type">_finish</span> = <span class="keyword">new</span><span class="type">_start</span>;<span class="comment">//finish和start一样</span></div><div class="line">    __STL_TRY &#123;</div><div class="line">      <span class="comment">//将[start,position)赋值到new_start</span></div><div class="line">      <span class="keyword">new</span><span class="type">_finish</span> = uninitialized_copy(start, position, <span class="keyword">new</span><span class="type">_start</span>);</div><div class="line">      <span class="comment">//将x放置在new_finish处</span></div><div class="line">      construct(<span class="keyword">new</span><span class="type">_finish</span>, x);</div><div class="line">      ++<span class="keyword">new</span><span class="type">_finish</span>;<span class="comment">//new_finish向后移动一个单位</span></div><div class="line">      <span class="comment">//将[position,finish)赋值到new_finish</span></div><div class="line">      <span class="keyword">new</span><span class="type">_finish</span> = uninitialized_copy(position, finish, <span class="keyword">new</span><span class="type">_finish</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#       ifdef  __STL_USE_EXCEPTIONS </span></div><div class="line">    <span class="keyword">catch</span>(...) &#123;</div><div class="line">      destroy(<span class="keyword">new</span><span class="type">_start</span>, <span class="keyword">new</span><span class="type">_finish</span>); </div><div class="line">      data_allocator:<span class="type"></span>:deallocate(<span class="keyword">new</span><span class="type">_start</span>, len);</div><div class="line">      <span class="keyword">throw</span>;<span class="comment">//错误删除分配空间</span></div><div class="line">    &#125;</div><div class="line"><span class="meta">#       endif /* __STL_USE_EXCEPTIONS */</span></div><div class="line">    destroy(begin(), end());<span class="comment">//析构原空间数据</span></div><div class="line">    deallocate();<span class="comment">//释放原内存</span></div><div class="line">    start = <span class="keyword">new</span><span class="type">_start</span>;<span class="comment">//更新start值</span></div><div class="line">    finish = <span class="keyword">new</span><span class="type">_finish</span>;<span class="comment">//更新finish值</span></div><div class="line">    end_of_storage = <span class="keyword">new</span><span class="type">_start</span> + len;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>根据这个函数，可以得到在使用vector过程中一个非常重要的注意点。因为没增加一个元素时，都有可能重新分配内存，那么原先的迭代器就将失效了，因为指向的内存已经被析构了。所以vector有添加数据时，一定要重新定义迭代器。</p>
</blockquote>
<h2>一些小函数</h2>
<p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">iterator <span class="built_in">begin</span>() &#123; <span class="built_in">return</span> start; &#125;<span class="comment">//初始迭代器</span></div><div class="line">const_iterator <span class="built_in">begin</span>() <span class="keyword">const</span> &#123; <span class="built_in">return</span> start; &#125;<span class="comment">//const迭代器</span></div><div class="line">iterator <span class="built_in">end</span>() &#123; <span class="built_in">return</span> finish; &#125;<span class="comment">//末端迭代器</span></div><div class="line">const_iterator <span class="built_in">end</span>() <span class="keyword">const</span> &#123; <span class="built_in">return</span> finish; &#125;</div><div class="line">reverse_iterator rbegin() &#123; <span class="built_in">return</span> reverse_iterator(<span class="built_in">end</span>()); &#125;<span class="comment">//逆向迭代器</span></div><div class="line">const_reverse_iterator rbegin() <span class="keyword">const</span> &#123; </div><div class="line">  <span class="built_in">return</span> const_reverse_iterator(<span class="built_in">end</span>()); </div><div class="line">&#125;</div><div class="line">reverse_iterator rend() &#123; <span class="built_in">return</span> reverse_iterator(<span class="built_in">begin</span>()); &#125;<span class="comment">//逆向迭代器</span></div><div class="line">const_reverse_iterator rend() <span class="keyword">const</span> &#123; </div><div class="line">  <span class="built_in">return</span> const_reverse_iterator(<span class="built_in">begin</span>()); </div><div class="line">&#125;</div><div class="line">size_type <span class="built_in">size</span>() <span class="keyword">const</span> &#123; <span class="built_in">return</span> size_type(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;<span class="comment">//vector元素个数</span></div><div class="line">size_type max_size() <span class="keyword">const</span> &#123; <span class="built_in">return</span> size_type(<span class="number">-1</span>) / <span class="keyword">sizeof</span>(T); &#125;<span class="comment">//vector最多可以容纳元素个数</span></div><div class="line"><span class="comment">//vector容量</span></div><div class="line">size_type capacity() <span class="keyword">const</span> &#123; <span class="built_in">return</span> size_type(end_of_storage - <span class="built_in">begin</span>()); &#125;</div><div class="line"><span class="keyword">bool</span> empty() <span class="keyword">const</span> &#123; <span class="built_in">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</div><div class="line">reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="built_in">return</span> *(<span class="built_in">begin</span>() + n); &#125;</div><div class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123; <span class="built_in">return</span> *(<span class="built_in">begin</span>() + n); &#125;</div></pre></td></tr></table></figure></p>
<p>这些小函数，最重要要区分size()和capacity()函数，前者是vector已有的元素数量，后者是这个vector总共可以存储的元素数量。</p>
<h1>erase函数</h1>
<p>这个函数有一个注意点，所以这里讲解下:
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">iterator erase(iterator <span class="built_in">position</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">position</span> + <span class="number">1</span> != end())</div><div class="line">    <span class="built_in">copy</span>(<span class="built_in">position</span> + <span class="number">1</span>, finish, <span class="built_in">position</span>);//将[<span class="built_in">position</span>+<span class="number">1</span>,finish)向前移动一个单位</div><div class="line">  --finish;</div><div class="line">  destroy(finish);//析构最后一个元素</div><div class="line">  <span class="built_in">return</span> <span class="built_in">position</span>;//返回擦除位置的迭代器</div><div class="line">&#125;</div><div class="line">iterator erase(iterator <span class="built_in">first</span>, iterator <span class="built_in">last</span>) &#123;//擦除一段元素</div><div class="line">  iterator i = <span class="built_in">copy</span>(<span class="built_in">last</span>, finish, <span class="built_in">first</span>);//将[<span class="built_in">last</span>,finish)向前移动<span class="built_in">last</span>-<span class="built_in">first</span>个单位</div><div class="line">  destroy(i, finish);//析构i到finish之间的元素，但是还可以用</div><div class="line">  finish = finish - (<span class="built_in">last</span> - <span class="built_in">first</span>);//更新finish</div><div class="line">  <span class="built_in">return</span> <span class="built_in">first</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数需要注意的是，当删除一段元素时，size()大小是会变化的，但是capacity()是不变的。</p>
<p>其他函数就不一一介绍了。接下来总结下:</p>
<ol>
<li>在看vector函数之前，一定要弄懂内存池，配置器和特性萃取，否则看不懂vector源码。</li>
<li>当向vector一个元素时，此时的迭代器是不安全的，需要重新定义。</li>
<li>当调用erase函数时，size()函数会变化，capacity不会花生变化。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> STL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> vector </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++STL内存池和空间配置器]]></title>
      <url>http://luodw.cc/2015/10/26/Calloc/</url>
      <content type="html"><![CDATA[<p>最近在写论文程序，经常用到C++ STL里的模板库，但是经常记不清那些模板类的成员方法，以及当用find函数查找时，不知道怎么判断是否未找到，所以我下定决心，索性把 <strong>STL源码剖</strong>看了，顺便把源码学习一遍。。。</p>
<p>C++ STL配置器分为两层配置器，当请求的内存大于128b时，就用第一层配置器分配内存，当请求的内存小于等于128b时就调用第二层配置器。这有点类似leveldb内存池arana，当需求大于1024时，则重新分配一块内存使用，小于1024时，从内存池里获取。这样的好处就是可以减少内存分配系统调用。试想，对于128b大小的内存，如果来了一个128b请求，则第二次128b请求就需要到系统分配内存了，但是如果来了一个32b的请求，则第四次32b请求才到系统分配内存。</p>
<h1>第一级配置器</h1>
<p>先来看下源码：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">class</span> __malloc_alloc_template &#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"><span class="comment">//malloc调用内存不足时调用函数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *oom_malloc(size_t);</div><div class="line"><span class="comment">//realloc调用内存不足时调用函数</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *oom_realloc(<span class="keyword">void</span> *, size_t);</div><div class="line"><span class="comment">//错误处理函数，类似C++的set_new_handler，默认值为０，如果不设置，则内存分配失败时，返回THROW_BAD_ALLOC</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> (* __malloc_alloc_oom_handler)();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> * allocate(size_t n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *result = malloc(n);	第一级配置器直接使用malloc分配内存</div><div class="line">    <span class="built_in">if</span> (<span class="number">0</span> == result) result = oom_malloc(n);<span class="comment">//如果分配失败，则调用oom_malloc()</span></div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> deallocate(<span class="keyword">void</span> *p, size_t <span class="comment">/* n */</span>)</div><div class="line">&#123;</div><div class="line">    free(p);	<span class="comment">//第一级配置器用free回收内存</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> * reallocate(<span class="keyword">void</span> *p, size_t <span class="comment">/* old_sz */</span>, size_t new_sz)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> * result = realloc(p, new_sz);	<span class="comment">//第一级配置器用reallocate重分配内存</span></div><div class="line">    <span class="built_in">if</span> (<span class="number">0</span> == result) result = oom_realloc(p, new_sz);／／分配失败，调用oom_realloc分配</div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置分配错误处理函数，用于在oom_malloc和oom_realloc中使用</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> (* set_malloc_handler(<span class="keyword">void</span> (*f)()))()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (* old)() = __malloc_alloc_oom_handler;</div><div class="line">    __malloc_alloc_oom_handler = f;</div><div class="line">    <span class="built_in">return</span>(old);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>第一级配置器相对简单，因为使用的正是我们平常使用的malloc，dealloc，free等，但是这个配置器提供了当内存配置错误时的处理函数oom_malloc，这个函数会调用__malloc_alloc_oom_handler)() 这个函数，去企图释放内存，然后重新调用malloc分配内存。这个函数默认是0，所以malloc调用失败默认操作是返回_THROW_BAD_ALLOC，来看下这个两个函数：</p>
<p>首先__malloc_alloc_oom_handler)() 默认值为0
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</div><div class="line"><span class="meta">#endi</span></div></pre></td></tr></table></figure></p>
<p>然后是两个内存分配失败函数oom_malloc和oom_realloc
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_malloc(<span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (* my_malloc_handler)();<span class="comment">//声明一个函数指针，用于赋值 __malloc_alloc_oom_handler</span></div><div class="line">    <span class="keyword">void</span> *result;<span class="comment">//返回的内存指针</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;	<span class="comment">// 不断尝试释放内存，分配，再释放，再分配...</span></div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">//为设置处理函数时，抛出错误</span></div><div class="line">        (*my_malloc_handler)();		<span class="comment">// 调用处理函数，尝试释放内存</span></div><div class="line">        result = <span class="built_in">malloc</span>(n);			<span class="comment">// 再重新分配内存。</span></div><div class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span>(result);<span class="comment">//如果分配成功，返回指针</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">void</span> * __malloc_alloc_template&lt;inst&gt;::oom_realloc(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (* my_malloc_handler)();</div><div class="line">    <span class="keyword">void</span> *result;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;	<span class="comment">// 不断尝试释放内存，分配，再释放，再分配...</span></div><div class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">////为设置处理函数时，抛出错误</span></div><div class="line">        (*my_malloc_handler)();	<span class="comment">//  调用处理函数，尝试释放内存</span></div><div class="line">        result = <span class="built_in">realloc</span>(p, n);	<span class="comment">// 再重新分配内存。</span></div><div class="line">        <span class="keyword">if</span> (result) <span class="keyword">return</span>(result);<span class="comment">////如果分配成功，返回指针</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数，在当内存分配失败时，会不断尝试区内存释放内存，再分配内存，所以再一定程度上提高内存分配成功。当需求内存不足128b时，会调用第二层配置器，接下来分析第二层配置器。</p>
<h1>第二层配置器</h1>
<p>第二层配置器有有一个内存池，用一个union obj数组free_list来存储内存的地址，数组的每一个元素都指向一个obj链表，也就是内存链表。数组从小到大表示负责8b,16b,24b,...,120b,128b内存请求。当请求的内存为n时，会将请求上条至2的指数大小，并从数组相应位置获取内存。例如如果请求为20b，则请求会上调至24b
。
先看下union obj这个定义:
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span> &#123;</span></div><div class="line">      <span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span>/<span class="regexp">/指向下一个内存的地址</span></div><div class="line">      char client_data[1];    /<span class="regexp">/内存的首地址</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个定义如果看不懂，可以查看我之前写的<strong>柔性数组</strong></p>
<p>来看下内存池模型图，来自于《STL源码剖析》:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_019.png" alt="当从内存池请求内存时"></p>
<p>这个图展示了当有内存请求到达时，先找到负责这个内存大小的数组元素指向的内存链表，取出第一块内存，然后把数组元素(obj指针)指向第二块内存的首地址，先介绍下几个成员:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;; <span class="comment">//内存对齐大小</span></div><div class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;<span class="comment">//这个数组负责最大的内存</span></div><div class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;<span class="comment">//数组大小</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> size_t <span class="title">ROUND_UP</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</div><div class="line">&#125;<span class="comment">//将bytes上调至2的指数倍，这里就是8的倍数</span></div><div class="line"> </div><div class="line"><span class="keyword">static</span> obj * __VOLATILE free_list[__NFREELISTS];<span class="comment">//内存池链表 </span></div><div class="line"><span class="function"><span class="keyword">static</span>  size_t <span class="title">FREELIST_INDEX</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> (((bytes) + __ALIGN<span class="number">-1</span>)/__ALIGN - <span class="number">1</span>);</div><div class="line">&#125;<span class="comment">//返回负责这个内存长度的数组索引</span></div></pre></td></tr></table></figure></p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></div><div class="line"> &#123;</div><div class="line">   obj * __VOLATILE * my_free_list;<span class="comment">//指向数组元素的指针</span></div><div class="line">   obj * __RESTRICT result;<span class="comment">//返回的内存地址</span></div><div class="line"></div><div class="line">   <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;<span class="comment">//如果请求内存大于128b，则调用第一级配置器</span></div><div class="line">       <span class="keyword">return</span>(malloc_alloc::allocate(n));</div><div class="line">   &#125;</div><div class="line">   my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line">   <span class="comment">// 根据请求内存大小，找到数组负责这个大小的索引位置的地址</span></div><div class="line">   result = *my_free_list;<span class="comment">//取出链表的第一块内存</span></div><div class="line">   <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;<span class="comment">//这个链表不够内存时，调用refill重新从内存池分配</span></div><div class="line">       <span class="keyword">void</span> *r = refill(ROUND_UP(n));</div><div class="line">       <span class="keyword">return</span> r;</div><div class="line">   &#125;</div><div class="line">   *my_free_list = result -&gt; free_list_link;<span class="comment">//对应索引数组的指针指向内存链表的下一块内存</span></div><div class="line">   <span class="keyword">return</span> (result);</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p>
<p>这是第二层配置器从内存池获取内存的调用函数，先判断请求内存是否大于128b，如果是，则调用第一级配置器，如果不是，则从第二级配置器请求一块内存。</p>
<p>当程序释放这块内存时，第二级配置器还负责回收这块内存，等下次有请求时，可以直接使用这块内存。示意图如下，从《STL源码剖析》摘取:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_020.png" alt="内存池回收内存">;</p>
<p>先计算机这块内存属于哪个数组元素负责，然后将这块回收的内存放置链表的第一个位置，这块内存的下一块内存为这个链表原先的第一块内存。源码如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> n)</span></span></div><div class="line">&#123;</div><div class="line">  obj *q = (obj *)p;<span class="comment">//将被回收的内存转换为obj</span></div><div class="line">  obj * __VOLATILE * my_free_list;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (n &gt; (<span class="keyword">size_t</span>) __MAX_BYTES) &#123;<span class="comment">//大于128b，调用第一级配置器回收</span></div><div class="line">      malloc_alloc::deallocate(p, n);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  my_free_list = free_list + FREELIST_INDEX(n);<span class="comment">//找到负责这块内存的数组元素</span></div><div class="line">  q -&gt; free_list_link = *my_free_list;<span class="comment">//回收的内存的下一块内存指向原链表的第一块内存</span></div><div class="line">  *my_free_list = q;<span class="comment">//链表第一块内存指向被回收的内存</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之前分析分配内存时，当free_list没有可用的内存时，会调用refill来从内存池分配内存。例如，如果请求内存为32b，此时内存链表中没有足够的内存了，那么refill会分配20块32b的内存块，然后把第一块返回给程序，其他19块由数组相应链表管理，源码如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">void</span>* __default_alloc_template&lt;threads, inst&gt;::refill(<span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;<span class="comment">//默认分配20块内存块</span></div><div class="line">    <span class="keyword">char</span> * chunk = chunk_alloc(n, nobjs);<span class="comment">//从内存池获取，返回第一块</span></div><div class="line">    obj * __VOLATILE * my_free_list;</div><div class="line">    obj * result;</div><div class="line">    obj * current_obj, * next_obj;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);<span class="comment">//如果只返回一块内存，直接返回</span></div><div class="line">    my_free_list = free_list + FREELIST_INDEX(n);</div><div class="line"></div><div class="line">      result = (obj *)chunk;<span class="comment">//不止一块内存，取出第一块内存</span></div><div class="line">      *my_free_list = next_obj = (obj *)(chunk + n);<span class="comment">//数组元素链表指针指向第二块内存</span></div><div class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) &#123;<span class="comment">//for循环为后续内存快建立链表关系</span></div><div class="line">        current_obj = next_obj;<span class="comment">//当前内存快</span></div><div class="line">        next_obj = (obj *)((<span class="keyword">char</span> *)next_obj + n);<span class="comment">//下一块内存快</span></div><div class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</div><div class="line">            current_obj -&gt; free_list_link = <span class="number">0</span>;<span class="comment">//最后一块的free_list_link为空</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            current_obj -&gt; free_list_link = next_obj;<span class="comment">//当前块的free_list_link指向下一块指针。</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span>(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来分析真正从内存池获取内存的函数chunk_alloc。先给下内存池实际操作示意图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_021.png" alt="内存池实际操作示意图">;</p>
<p>当free_list没有内存返回给用户时，refill函数会调用chunk_alloc从内存池获取内存，如果内存池剩余的内存(end_free-start_free)满足需求的内存(size*nobjs)，则直接从从内存池获取内存，返回给程序；当内存池的块不能满足20块时，返回一个以上的内存块；当内存池一块都不能满足时，先是回收剩余的内存，然后调用malloc从系统获取内存。如果系统内存不足，则先从数组其他链表获取内存，如果其他链表也不足够内存的话，就调用第一级内存来分配，因为第一级内存分配失败，有处理函数来解决。源码如下:
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</div><div class="line"><span class="keyword">char</span>*</div><div class="line">__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t <span class="built_in">size</span>, <span class="keyword">int</span>&amp; nobjs)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> * result;</div><div class="line">    size_t total_bytes = <span class="built_in">size</span> * nobjs;<span class="comment">//总需求内存</span></div><div class="line">    size_t bytes_left = end_free - start_free;<span class="comment">//内存池剩余的内存</span></div><div class="line"></div><div class="line">    <span class="built_in">if</span> (bytes_left &gt;= total_bytes) &#123;<span class="comment">//当内存池足够内存时，从内存池里获取</span></div><div class="line">        result = start_free;</div><div class="line">        start_free += total_bytes;</div><div class="line">        <span class="built_in">return</span>(result);</div><div class="line">    &#125; <span class="built_in">else</span> <span class="built_in">if</span> (bytes_left &gt;= <span class="built_in">size</span>) &#123;<span class="comment">//内存池不能满足，但是又可以满足一块以上时</span></div><div class="line">        nobjs = bytes_left/<span class="built_in">size</span>;<span class="comment">//重新设置内存块数</span></div><div class="line">        total_bytes = <span class="built_in">size</span> * nobjs;</div><div class="line">        result = start_free;</div><div class="line">        start_free += total_bytes;</div><div class="line">        <span class="built_in">return</span>(result);</div><div class="line">    &#125; <span class="built_in">else</span> &#123;<span class="comment">//当内存池的内存小于一块内存的大小时，先将剩余内存加在数组适当的位置</span></div><div class="line">        size_t bytes_to_get = <span class="number">2</span> * total_bytes + ROUND_UP(heap_size &gt;&gt; <span class="number">4</span>);</div><div class="line">        <span class="comment">// 将剩余内存利用起来</span></div><div class="line">        <span class="built_in">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</div><div class="line">            obj * __VOLATILE * my_free_list =</div><div class="line">                        free_list + FREELIST_INDEX(bytes_left);</div><div class="line"></div><div class="line">            ((obj *)start_free) -&gt; free_list_link = *my_free_list;</div><div class="line">            *my_free_list = (obj *)start_free;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">　　　　<span class="comment">//调用malloc从内存分配</span></div><div class="line">        start_free = (<span class="keyword">char</span> *)malloc(bytes_to_get);</div><div class="line">        <span class="built_in">if</span> (<span class="number">0</span> == start_free) &#123;<span class="comment">//系统内存不足时</span></div><div class="line">            <span class="keyword">int</span> i;</div><div class="line">            obj * __VOLATILE * my_free_list, *p;</div><div class="line">            <span class="comment">// 利用好自己拥有的内存，即从其他空闲链表获取内存.</span></div><div class="line">            <span class="built_in">for</span> (i = <span class="built_in">size</span>; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</div><div class="line">                my_free_list = free_list + FREELIST_INDEX(i);</div><div class="line">                p = *my_free_list;</div><div class="line">                <span class="built_in">if</span> (<span class="number">0</span> != p) &#123;</div><div class="line">                    *my_free_list = p -&gt; free_list_link;</div><div class="line">                    start_free = (<span class="keyword">char</span> *)p;</div><div class="line">                    end_free = start_free + i;</div><div class="line">		　　<span class="comment">//递归调用chunk_alloc，因为此时获取内存了</span></div><div class="line">                    <span class="comment">//所以，递归调用时，在else if语句时，即可返回　</span></div><div class="line">                    <span class="built_in">return</span>(chunk_alloc(<span class="built_in">size</span>, nobjs));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">	    end_free = <span class="number">0</span>;	<span class="comment">// 从其他链表也没获取到内存</span></div><div class="line">            start_free = (<span class="keyword">char</span> *)malloc_alloc::allocate(bytes_to_get);</div><div class="line">            <span class="comment">// 调用第一级配置器，因为有错误处理函数，也是最后的补救办法了</span></div><div class="line">        &#125;</div><div class="line">        heap_size += bytes_to_get;<span class="comment">//当从系统分配到内存时，更新到目前为止的内存总数</span></div><div class="line">        end_free = start_free + bytes_to_get;</div><div class="line">        <span class="built_in">return</span>(chunk_alloc(<span class="built_in">size</span>, nobjs));<span class="comment">//递归调用，在第一个if语句即可返回。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>使用配置器</h1>
<p>至此，STL两层配置器就分析结束了，接下来看下配置器使如何使用的。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;</div><div class="line"><span class="keyword">class</span> simple_alloc &#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></div><div class="line">                &#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::allocate(n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">                &#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></span></div><div class="line">                &#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></div><div class="line">                &#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个类封装了Alloc的分配和回收内存函数，并提供了四个用于内存操作的函数接口，一个模板是如何请求内存呢？
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc = alloc&gt;  <span class="comment">//alloc被默认为第二级配置器</span></div><div class="line"><span class="keyword">class</span> <span class="built_in">vector</span> &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> T value_type;</div><div class="line">  ...</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</div></pre></td></tr></table></figure></p>
<p>有代码可以看出，vector内嵌了data_allocator类型，当需要分配内存时，调用simple_alloc的成员方法即可。</p>
<p>参考:《STL源码剖析》和<a href="http://www.cnblogs.com/lfsblack/archive/2012/11/10/2764334.html" target="_blank" rel="external">lfsblackoverflow的博客</a></p>
]]></content>
      
        <categories>
            
            <category> STL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> 内存池 </tag>
            
            <tag> 空间配置器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之Table_cache]]></title>
      <url>http://luodw.cc/2015/10/25/leveldb-13/</url>
      <content type="html"><![CDATA[<p>上篇文章有说到过，leveldb有分为block_cache和table_cache。block_cache主要是用来缓存data_block，减少磁盘IO次数。那table_cache是用来干啥了？</p>
<p>先介绍table_cache的键值对形式，如下图所示：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--Table_cache.jpg" alt="table_cache的键值对格式">;</p>
<p>key值为sst文件的文件编号，value为这个sst文件的TableAndFile结构体指针，然后这个TableAndFile是由RandomAccessFile指针和Table指针组成。所以从这个TableAndFile指针，就可以获得这个文件的Table指针，随即可以得到这个文件的任何键值对。所以这个缓存有点类似Linux内核中的inode，由indoe就可以获取磁盘的data block。</p>
<p>先看下Table_cache这个类的定义：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//成员属性</span></div><div class="line">  Env* <span class="keyword">const</span> env_;<span class="comment">//操作系统封装类</span></div><div class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;<span class="comment">//数据库名字</span></div><div class="line">  <span class="keyword">const</span> Options* options_;<span class="comment">//配置选项类</span></div><div class="line">  Cache* cache_;<span class="comment">//Table_cache类</span></div><div class="line"></div><div class="line"><span class="comment">//构造函数如下:</span></div><div class="line">TableCache::TableCache(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</div><div class="line">                       <span class="keyword">const</span> Options* options,</div><div class="line">                       <span class="keyword">int</span> entries)</div><div class="line">    : env_(options-&gt;env),</div><div class="line">      dbname_(dbname),</div><div class="line">      options_(options),</div><div class="line">      cache_(NewLRUCache(entries)) &#123;<span class="comment">//Table_cache默认开启，而且为NewLRUCache</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先介绍下FindTable这个函数:
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,</div><div class="line">                             Cache::Handle** handle) &#123;</div><div class="line">  Status s;</div><div class="line">  char buf[sizeof(file_number)];<span class="comment">//定义用于存储文件编号的字符数组</span></div><div class="line">  EncodeFixed64(buf, file_number);<span class="comment">//整型编码存储在buf中</span></div><div class="line">  Slice key(buf, sizeof(buf));</div><div class="line">  *handle = cache_-&gt;Lookup(key);<span class="comment">//在Table中查找这个文件编号的handle。</span></div><div class="line">  <span class="keyword">if</span> (*handle == NULL) &#123;如果在TableCache中没有找到，则要新建一个handle，存储这个文件缓存</div><div class="line">    std::string fname = TableFileName(dbname_, file_number);</div><div class="line">    RandomAccessFile* <span class="keyword">file</span> = NULL;</div><div class="line">    <span class="keyword">Table</span>* <span class="keyword">table</span> <span class="comment">= NULL</span>;</div><div class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;file);</div><div class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">      std::string old_fname = SSTTableFileName(dbname_, file_number);</div><div class="line">      <span class="keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;<span class="keyword">file</span>).ok()) &#123;</div><div class="line">        s = Status::OK();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      s = <span class="keyword">Table</span>::Open(*options_, file, file_size, &amp;<span class="keyword">table</span>);//打开这个文件的<span class="keyword">Table</span>，存储在*<span class="keyword">table</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!s.ok()) &#123;</div><div class="line">      assert(<span class="keyword">table</span> == NULL);</div><div class="line">      delete file;</div><div class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></div><div class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      TableAndFile* tf = new TableAndFile;<span class="comment">//新建一个TableAndFile</span></div><div class="line">      tf-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</div><div class="line">      tf-&gt;<span class="keyword">table</span> = <span class="keyword">table</span>;</div><div class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);<span class="comment">//将这个新的tf存入Table_cache</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Table_cache中插入数据时，也注册了这个handle被删除时执行的回调函数。我来分析下，我觉得挺有意思的。首先来看下cache.cc里面handle删除函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> LRUCache::Erase(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash) &#123;</div><div class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</div><div class="line">  LRUHandle* e = table_.Remove(key, hash);<span class="comment">//先在哈希表删除这个handle</span></div><div class="line">  <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</div><div class="line">    LRU_Remove(e);<span class="comment">//循环双向链表删除这个handle</span></div><div class="line">    Unref(e);<span class="comment">//引用数减一，如果本来就等于1，则删除这个节点</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> LRUCache::Unref(LRUHandle* e) &#123;</div><div class="line">  assert(e-&gt;refs &gt; <span class="number">0</span>);</div><div class="line">  e-&gt;refs--;</div><div class="line">  <span class="keyword">if</span> (e-&gt;refs &lt;= <span class="number">0</span>) &#123;</div><div class="line">    usage_ -= e-&gt;charge;</div><div class="line">    (*e-&gt;deleter)(e-&gt;key(), e-&gt;value);<span class="comment">//这就是在table_cache注册的回调函数DeleteEntry</span></div><div class="line">    <span class="built_in">free</span>(e);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteEntry</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</div><div class="line">  TableAndFile* tf = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(value);</div><div class="line">  <span class="keyword">delete</span> tf-&gt;table;<span class="comment">//先delete  table</span></div><div class="line">  <span class="keyword">delete</span> tf-&gt;file;<span class="comment">//再delete  file</span></div><div class="line">  <span class="keyword">delete</span> tf;<span class="comment">//最后delete tf</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上就是handle被删除时的回调过程。</p>
<p>接下来，分析下table_cache这个类的迭代器：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Iterator* TableCache::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                                  <span class="keyword">uint64_t</span> file_number,</div><div class="line">                                  <span class="keyword">uint64_t</span> file_size,</div><div class="line">                                  Table** tableptr) &#123;</div><div class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">NULL</span>) &#123;</div><div class="line">    *tableptr = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Cache::Handle* handle = <span class="literal">NULL</span>;</div><div class="line">  Status s = FindTable(file_number, file_size, &amp;handle);<span class="comment">//通过文件编号在缓存中查找文件handle</span></div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> NewErrorIterator(s);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</div><div class="line">  <span class="comment">//获取这个这个文件编号的Table</span></div><div class="line">  Iterator* result = table-&gt;NewIterator(options);获取这个Table的迭代器</div><div class="line">  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);<span class="comment">//注册这个handle删除函数</span></div><div class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">NULL</span>) &#123;</div><div class="line">    *tableptr = table;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过源码可以看出，table_cache的迭代器，本质就是table的迭代器。leveldb迭代器设计帧的很巧妙。从block迭代器-&gt;table两层迭代器-&gt;table_cache迭代器。最后只有通过table_cache迭代器即可获取需要的数据。我觉得这样的做法就是上层接口很简单。</p>
<p>那什么时候将表格的添加进table_cache呢？</p>
<p>上次分析创建sst文件时，分析到了table_builder，其实还有个BuilderTable函数，在builder.h/.cc文件里。来分析下：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">Status BuildTable(const std::string&amp; dbname,<span class="comment">//数据库名称</span></div><div class="line">                  Env* env,<span class="comment">//操作系统封装类</span></div><div class="line">                  const Options&amp; options,<span class="comment">//配置选项类</span></div><div class="line">                  TableCache* table_cache,<span class="comment">//缓存</span></div><div class="line">                  Iterator* iter,<span class="comment">//immemtable迭代器，用来将immemtable数据刷回磁盘</span></div><div class="line">                  FileMetaData* meta) &#123;</div><div class="line">  Status s;</div><div class="line">  <span class="function"><span class="title">meta</span>-&gt;</span>file_size = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>SeekToFirst();</div><div class="line"></div><div class="line">  <span class="function"><span class="title">std</span>::string fname = TableFileName(dbname, meta-&gt;</span>number);</div><div class="line">  <span class="function"><span class="title">if</span> (iter-&gt;</span>Valid()) &#123;</div><div class="line">    WritableFile* file;</div><div class="line">    <span class="function"><span class="title">s</span> = env-&gt;</span>NewWritableFile(fname, &amp;file);创建WritableFile，用于存储memtable数据</div><div class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">      return s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    TableBuilder* builder = new TableBuilder(options, file);<span class="comment">//创建table_builder类，</span></div><div class="line">    <span class="function"><span class="title">meta</span>-&gt;</span><span class="function"><span class="title">smallest</span>.DecodeFrom(iter-&gt;</span>key());</div><div class="line">    <span class="function"><span class="title">for</span> (; iter-&gt;</span>V<span class="function"><span class="title">alid</span>(); iter-&gt;</span>Next()) &#123;</div><div class="line">      S<span class="function"><span class="title">lice</span> key = iter-&gt;</span>key();</div><div class="line">      <span class="function"><span class="title">meta</span>-&gt;</span>largest.DecodeFrom(key);</div><div class="line">      <span class="function"><span class="title">builder</span>-&gt;</span>A<span class="function"><span class="title">dd</span>(key, iter-&gt;</span>value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Finish and check for builder errors</span></div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">s</span> = builder-&gt;</span>Finish();<span class="comment">//建表完成</span></div><div class="line">      <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">        <span class="function"><span class="title">meta</span>-&gt;</span><span class="function"><span class="title">file_size</span> = builder-&gt;</span>FileSize();</div><div class="line">        <span class="function"><span class="title">assert</span>(meta-&gt;</span>file_size &gt; <span class="number">0</span>);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="function"><span class="title">builder</span>-&gt;</span>Abandon();</div><div class="line">    &#125;</div><div class="line">    delete builder;</div><div class="line"></div><div class="line">    <span class="comment">// Finish and check for file errors</span></div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">s</span> = file-&gt;</span>Sync();<span class="comment">//文件内容刷回磁盘</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">s</span> = file-&gt;</span>Close();</div><div class="line">    &#125;</div><div class="line">    delete file;</div><div class="line">    file = NULL;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      <span class="comment">// 这就是将这个文件添加进table_cache了</span></div><div class="line">      I<span class="function"><span class="title">terator</span>* it = table_cache-&gt;</span>NewIterator(ReadOptions(),</div><div class="line">                                              <span class="function"><span class="title">meta</span>-&gt;</span>number,</div><div class="line">                                              <span class="function"><span class="title">meta</span>-&gt;</span>file_size);</div><div class="line">      <span class="function"><span class="title">s</span> = it-&gt;</span>status();</div><div class="line">      delete it;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Check for input iterator errors</span></div><div class="line">  <span class="function"><span class="title">if</span> (!iter-&gt;</span>status().ok()) &#123;</div><div class="line">    <span class="function"><span class="title">s</span> = iter-&gt;</span>status();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">if</span> (s.ok() &amp;&amp; meta-&gt;</span>file_size &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// Keep it</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="function"><span class="title">env</span>-&gt;</span>DeleteFile(fname);</div><div class="line">  &#125;</div><div class="line">  return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，没创建一个sst文件时 ，就将这个文件的添加进table_cache中，这是有理由的，因为新创建的文件，也必定是最新的，所以在一定程度上可能马上就被要使用到。因为查询键值对时，就是从level0文件开始查询的，也就是最新的文件。</p>
<p>到这边，leveldb三大组件都分析结束了。最后还剩版本控制，db实现类。两个庞然大物，后面再慢慢分析了。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> table_cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之读sst文件]]></title>
      <url>http://luodw.cc/2015/10/24/leveldb-12/</url>
      <content type="html"><![CDATA[<p>上篇文章介绍了leveldb缓冲池，这篇文章主要来分析leveldb是如何读取磁盘的数据。这里先要说明下，leveldb有两种缓冲池，一个是block_cache,另一个是table_cache。block_cache缓冲的是data block，table_cache缓冲的是每个sst文件的文件指针(RandomAccessFile指针)和这个文件对应的Table指针。</p>
<p>当leveldb要获取键值对时，首先检测键值对是否在缓冲池中，如果在，直接从缓冲池中获取；如果不在缓冲池中，则先从磁盘中获取相应的块，存储在缓冲池中，然后再从缓冲池中获取数据，如果系统的局部性很强的话，那么缓冲是可以大大减少磁盘IO时间的。</p>
<h1>block类</h1>
<p>block类主要是磁盘的data block和index block在内存中的数据结构，当读取一个块时，首先把块内容存储在block里，然后table类再调用block的相应方法来处理数据。</p>
<p>所以先来看下block类的定义：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* data_;<span class="comment">//指向data block的内容首地址</span></div><div class="line"><span class="keyword">size_t</span> size_;<span class="comment">//data block数据长度</span></div><div class="line"><span class="keyword">uint32_t</span> restart_offset_;     <span class="comment">// 重启点数组的起始地址</span></div><div class="line"><span class="keyword">bool</span> owned_;   <span class="comment">//是否要用户自己delete这个block</span></div><div class="line"><span class="keyword">uint32_t</span> NumRestarts() <span class="keyword">const</span>;<span class="comment">//返回这个block重启点的个数</span></div><div class="line"><span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_; &#125;<span class="comment">//这个块数据长度</span></div><div class="line"><span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;<span class="comment">//返回这个block的迭代器</span></div></pre></td></tr></table></figure></p>
<p>先来看下这个类的构造函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Block::Block(<span class="keyword">const</span> BlockContents&amp; contents)</div><div class="line">    : data_(contents.data.data()),</div><div class="line">      size_(contents.data.size()),</div><div class="line">      owned_(contents.heap_allocated) &#123;</div><div class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">    size_ = <span class="number">0</span>;  <span class="comment">// 一个block至少有一个重启点所占的字节数</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">size_t</span> max_restarts_allowed = (size_-<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    <span class="keyword">if</span> (NumRestarts() &gt; max_restarts_allowed) &#123;</div><div class="line">      <span class="comment">// size太小</span></div><div class="line">      size_ = <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//如果了解一个data block的布局，就知道重启点为啥是如下计算了。</span></div><div class="line">      restart_offset_ = size_ - (<span class="number">1</span> + NumRestarts()) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个构造函数出现一个BlockContent类型，这个类型用来存储从磁盘读取的数据，定义如下：
<figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockContents</span> </span>&#123;</div><div class="line">  Slice data;           <span class="comment">// data block数据</span></div><div class="line">  <span class="built_in">bool</span> cachable;        <span class="comment">// 这个块是否放进缓存中，在ReadOption.fill_cache设置</span></div><div class="line">  <span class="built_in">bool</span> heap_allocated;  <span class="comment">// 是否是用户自己分配的内存，如果是，则需要用户自己delete。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>block这个类主要的接口就是返回这个类的迭代器，用于从data block中获取数据。我们来看下迭代器是如何实现的。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Comparator* <span class="keyword">const</span> comparator_;<span class="comment">//比较器</span></div><div class="line"> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> data_;      <span class="comment">// block的内容</span></div><div class="line"> <span class="keyword">uint32_t</span> <span class="keyword">const</span> restarts_;     <span class="comment">// 重启点数组的偏移量</span></div><div class="line"> <span class="keyword">uint32_t</span> <span class="keyword">const</span> num_restarts_; <span class="comment">// 重启点的个数</span></div><div class="line"> <span class="comment">//以上4个参数由block传进来，赋值之后就不再变化</span></div><div class="line"></div><div class="line"> <span class="comment">// current_ 指向正在读取的记录，如果current</span></div><div class="line"> <span class="keyword">uint32_t</span> current_;</div><div class="line"> <span class="keyword">uint32_t</span> restart_index_;  <span class="comment">// 当前记录所在重启点区域</span></div><div class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> key_;<span class="comment">//当前记录的键值</span></div><div class="line"> Slice value_;<span class="comment">//当前记录的值</span></div><div class="line"> Status status_;<span class="comment">//当前迭代器的状态</span></div></pre></td></tr></table></figure></p>
<p>以上就是block的成员变量，由于该迭代器成员函数较多，我就从迭代器初始化到迭代器取出一个值的顺序分析下源码：</p>
<p>构造函数:
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>:</div><div class="line">  Iter(<span class="keyword">const</span> Comparator* comparator,</div><div class="line">       <span class="keyword">const</span> <span class="keyword">char</span>* data,</div><div class="line">       uint32_t restarts,</div><div class="line">       uint32_t num_restarts)</div><div class="line">      : comparator_(comparator),</div><div class="line">        data_(data),</div><div class="line">        restarts_(restarts),</div><div class="line">        num_restarts_(num_restarts),</div><div class="line">        current_(restarts_),//当前记录指向重启点数组的首位置，表示无效</div><div class="line">        restart_index_(num_restarts_) &#123;<span class="comment">//当前记录所在重启点索引=重启点个数，表示无效</span></div><div class="line">    <span class="keyword">assert</span>(num_restarts_ &gt; <span class="number">0</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>构造出一个迭代器之后，首先要将迭代器的当前记录指向首位置，当前记录所在索引赋值为0，函数如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">  SeekToRestartPoint(<span class="number">0</span>);</div><div class="line">  ParseNextKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该函数调用了两个函数如下：
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">   <span class="type">void</span> SeekToRestartPoint(uint32_t <span class="keyword">index</span>) &#123;</div><div class="line">    key_.clear();<span class="comment">//一开始key_为空</span></div><div class="line">    restart_index_ = <span class="keyword">index</span>;<span class="comment">//当前记录所在重启点索引为0</span></div><div class="line"></div><div class="line">    <span class="comment">// ParseNextKey() starts at the end of value_, so set value_ accordingly</span></div><div class="line">    uint32_t <span class="keyword">offset</span> = GetRestartPoint(<span class="keyword">index</span>);<span class="comment">//找到这个索引重启点的偏移量</span></div><div class="line">    value_ = Slice(data_ + <span class="keyword">offset</span>, <span class="number">0</span>);<span class="comment">//value_一开始指向记录的首位置</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//解析当前记录</span></div><div class="line">  <span class="type">bool</span> ParseNextKey() &#123;</div><div class="line">    current_ = NextEntryOffset();<span class="comment">//将要被解析记录的偏移量，一开始时，就是0</span></div><div class="line">    <span class="keyword">const</span> char* p = data_ + current_;<span class="comment">//p指向将要被解析的记录首位置</span></div><div class="line">    <span class="keyword">const</span> char* limit = data_ + restarts_;  <span class="comment">// 记录指针最大值为重启点数组首位置</span></div><div class="line">    <span class="keyword">if</span> (p &gt;= limit) &#123;</div><div class="line">      <span class="comment">// 表示迭代到data block最后一条记录结束</span></div><div class="line">      current_ = restarts_;</div><div class="line">      restart_index_ = num_restarts_;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 解析出当前记录</span></div><div class="line">    uint32_t <span class="keyword">shared</span>, non_shared, value_length;</div><div class="line">    <span class="comment">//解析当前记录的共享长度，非共享长度，值的长度，然后返回的指针p指向非共享内容的首位置</span></div><div class="line">    p = DecodeEntry(p, limit, &amp;<span class="keyword">shared</span>, &amp;non_shared, &amp;value_length);</div><div class="line">    <span class="keyword">if</span> (p == NULL || key_.size() &lt; <span class="keyword">shared</span>) &#123;</div><div class="line">      CorruptionError();</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      key_.resize(<span class="keyword">shared</span>);<span class="comment">//第一条记录共享长度为0</span></div><div class="line">      key_.append(p, non_shared);<span class="comment">//第一条记录的非共享内容就是第一条完整记录</span></div><div class="line">      value_ = Slice(p + non_shared, value_length);<span class="comment">//解析出value值</span></div><div class="line">      <span class="keyword">while</span> (restart_index_ + <span class="number">1</span> &lt; num_restarts_ &amp;&amp;</div><div class="line">             GetRestartPoint(restart_index_ + <span class="number">1</span>) &lt; current_) &#123;</div><div class="line">        ++restart_index_;<span class="comment">//更新记录所在的重启点索引</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个函数非常重要，因为迭代器重要任务就是解析出记录。但是有一个难点，就是需要区分重启点第一条记录和非第一条记录的解析方式。</p>
<ol>
<li>当为第一条记录时，共享部分为0， key_.append(p, non_shared);这行代码就是将第一条完整记录加在key_后面。</li>
<li>当不是第一条记录时，此时key_.resize(shared);这行代码获取当前记录和上一条记录共享部分， key_.append(p, non_shared);这行代码就获得非共享部分，凑成完整的记录。</li>
</ol>
<p>经过上述函数，此时这个迭代器的key_指向第一条记录的key，value_指向第一条记录的value.</p>
<p>最后一个就是返回这个block的迭代器函数;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Iterator* Block::NewIterator(<span class="keyword">const</span> Comparator* cmp) &#123;</div><div class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> NewErrorIterator(Status::Corruption(<span class="string">"bad block contents"</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> num_restarts = NumRestarts();</div><div class="line">  <span class="keyword">if</span> (num_restarts == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> NewEmptyIterator();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iter(cmp, data_, restart_offset_, num_restarts);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他函数就不一一分析了，接下来，看下调用block，获取数据的Table类;</p>
<h1>Table类</h1>
<p>Table这个类是sst文件在内存的数据结构，保存了sst文件的index block,meta block，文件指针等等。Table这个类读取数据时，先从Block_cache查询，如果找到了，就直接返回，否则就到磁盘获取。先来看下这个类的属性定义：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Table::Rep &#123;</div><div class="line">  ~Rep() &#123;</div><div class="line">    <span class="keyword">delete</span> filter;</div><div class="line">    <span class="keyword">delete</span> [] filter_data;</div><div class="line">    <span class="keyword">delete</span> index_block;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Options options;<span class="comment">//上层传进来的options</span></div><div class="line">  Status status;<span class="comment">//这个表格的状态</span></div><div class="line">  RandomAccessFile* file;<span class="comment">//这个Table代表的文件</span></div><div class="line">  <span class="keyword">uint64_t</span> cache_id;<span class="comment">//缓存序号</span></div><div class="line">  FilterBlockReader* filter;<span class="comment">//读取Meta block类</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* filter_data;<span class="comment">//Meta block数据</span></div><div class="line"></div><div class="line">  BlockHandle metaindex_handle;  <span class="comment">// 读取Metaindex_block的handle</span></div><div class="line">  Block* index_block;<span class="comment">//index Block</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Table构造函数很简单，就是给Rep属性赋值。接来下，看下如何打开一个Table
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">Status Table::Open(const Options&amp; options,</div><div class="line">                   RandomAccessFile* file,</div><div class="line">                   uint64_t size,</div><div class="line">                   Table** table) &#123;</div><div class="line">  *table = NULL;</div><div class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</div><div class="line">    return Status::Corruption(<span class="string">"file is too short to be an sstable"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  char footer_space[Footer::kEncodedLength];<span class="comment">//存储footer空间</span></div><div class="line">  Slice footer_input;<span class="comment">//footer内容</span></div><div class="line">  S<span class="function"><span class="title">tatus</span> s = file-&gt;</span>Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</div><div class="line">                        &amp;footer_input, footer_space);<span class="comment">//从文件读取出footer</span></div><div class="line">  <span class="keyword">if</span> (!s.ok()) return s;</div><div class="line"></div><div class="line">  Footer footer;</div><div class="line">  s = footer.DecodeFrom(&amp;footer_input);<span class="comment">//从footer_input解码出footer这个类</span></div><div class="line">  <span class="keyword">if</span> (!s.ok()) return s;</div><div class="line"></div><div class="line">  <span class="comment">// 读取index block</span></div><div class="line">  BlockContents <span class="built_in">contents</span>;</div><div class="line">  Block* index_block = NULL;</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    ReadOptions opt;</div><div class="line">    <span class="keyword">if</span> (options.paranoid_checks) &#123;</div><div class="line">      opt.verify_checksums = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    s = ReadBlock(file, opt, footer.index_handle(), &amp;<span class="built_in">contents</span>);<span class="comment">//读取sst文件一个块函数，有crc检查</span></div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      index_block = new Block(<span class="built_in">contents</span>);<span class="comment">//转换为block类</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></div><div class="line">    <span class="comment">// ready to serve requests.</span></div><div class="line">    Rep* rep = new Table::Rep;<span class="comment">//给rep属性赋值</span></div><div class="line">    <span class="function"><span class="title">rep</span>-&gt;</span>options = options;</div><div class="line">    <span class="function"><span class="title">rep</span>-&gt;</span>file = file;</div><div class="line">    <span class="function"><span class="title">rep</span>-&gt;</span>metaindex_handle = footer.metaindex_handle();</div><div class="line">    <span class="function"><span class="title">rep</span>-&gt;</span>index_block = index_block;</div><div class="line">    <span class="function"><span class="title">rep</span>-&gt;</span><span class="function"><span class="title">cache_id</span> = (options.block_cache ? options.block_cache-&gt;</span>NewId() : <span class="number">0</span>);</div><div class="line">    <span class="function"><span class="title">rep</span>-&gt;</span>filter_data = NULL;</div><div class="line">    <span class="function"><span class="title">rep</span>-&gt;</span>filter = NULL;</div><div class="line">    *table = new Table(rep);</div><div class="line">    (*<span class="function"><span class="title">table</span>)-&gt;</span>ReadMeta(footer);<span class="comment">//读取Metaindex block</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (index_block) delete index_block;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Table::ReadMeta(const Footer&amp; footer) &#123;</div><div class="line">  <span class="function"><span class="title">if</span> (rep_-&gt;</span>options.filter_policy == NULL) &#123;</div><div class="line">    return;  <span class="comment">// 表示没有Metaindex block数据</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// TODO(sanjay): Skip this if footer.metaindex_handle() size indicates</span></div><div class="line">  <span class="comment">// it is an empty block.</span></div><div class="line">  ReadOptions opt;</div><div class="line">  <span class="function"><span class="title">if</span> (rep_-&gt;</span>options.paranoid_checks) &#123;</div><div class="line">    opt.verify_checksums = <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  BlockContents <span class="built_in">contents</span>;</div><div class="line">  <span class="function"><span class="title">if</span> (!ReadBlock(rep_-&gt;</span>file, opt, footer.metaindex_handle(), &amp;<span class="built_in">contents</span>).ok()) &#123;</div><div class="line">    <span class="comment">// Do not propagate errors since meta info is not needed for operation</span></div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  Block* meta = new Block(<span class="built_in">contents</span>);</div><div class="line"></div><div class="line">  I<span class="function"><span class="title">terator</span>* iter = meta-&gt;</span>NewIterator(BytewiseComparator());</div><div class="line">  std::string key = <span class="string">"filter."</span>;</div><div class="line">  <span class="function"><span class="title">key</span>.append(rep_-&gt;</span><span class="function"><span class="title">options</span>.filter_policy-&gt;</span>Name());</div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>Seek(key);<span class="comment">//查找目前过滤器Meta数据的handle</span></div><div class="line">  <span class="function"><span class="title">if</span> (iter-&gt;</span>V<span class="function"><span class="title">alid</span>() &amp;&amp; iter-&gt;</span>key() == Slice(key)) &#123;</div><div class="line">    R<span class="function"><span class="title">eadFilter</span>(iter-&gt;</span>value());<span class="comment">//读取Meta block，也就是filter条目</span></div><div class="line">  &#125;</div><div class="line">  delete iter;</div><div class="line">  delete meta;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Table::ReadFilter(const Slice&amp; filter_handle_value) &#123;</div><div class="line">  Slice v = filter_handle_value;</div><div class="line">  BlockHandle filter_handle;</div><div class="line">  <span class="keyword">if</span> (!filter_handle.DecodeFrom(&amp;v).ok()) &#123;<span class="comment">//转换为BlockHandle</span></div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// We might want to unify with ReadBlock() if we start</span></div><div class="line">  <span class="comment">// requiring checksum verification in Table::Open.</span></div><div class="line">  ReadOptions opt;</div><div class="line">  <span class="function"><span class="title">if</span> (rep_-&gt;</span>options.paranoid_checks) &#123;</div><div class="line">    opt.verify_checksums = <span class="literal">true</span>;<span class="comment">//需要CRC检查</span></div><div class="line">  &#125;</div><div class="line">  BlockContents <span class="keyword">block</span>;</div><div class="line">  <span class="function"><span class="title">if</span> (!ReadBlock(rep_-&gt;</span>file, opt, filter_handle, &amp;<span class="keyword">block</span>).ok()) &#123;<span class="comment">//将Meta数据读入block</span></div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">block</span>.heap_allocated) &#123;</div><div class="line">    <span class="function"><span class="title">rep_</span>-&gt;</span>filter_data = <span class="keyword">block</span>.<span class="keyword">data</span>.<span class="keyword">data</span>();<span class="comment">//Meta block过滤数据</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="title">rep_</span>-&gt;</span><span class="function"><span class="title">filter</span> = new FilterBlockReader(rep_-&gt;</span>options.filter_policy, <span class="keyword">block</span>.<span class="keyword">data</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要功能就是创建一个sst文件的Table结构。将index block和meta block读进内存，方便后续的操作</p>
<p>接下来分析下Table读取一个block的函数。这个函数就涉及到将数据读进缓存，所以先介绍下block_cache的格式。</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--Block_cache.jpg" alt="block_cache键值对格式">;</p>
<p>解释下：key值由这个block的cache_id和这个block在文件的偏移量组成，value即为这个block的block对象。</p>
<p>好，现在来分析下这个函数;
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">Iterator* Table::BlockReader(void* arg,</div><div class="line">                             const ReadOptions&amp; options,</div><div class="line">                             const Slice&amp; index_value) &#123;</div><div class="line">  Table* table = reinterpret_cast&lt;Table*&gt;(arg);</div><div class="line">  C<span class="function"><span class="title">ache</span>* block_cache = table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>options.block_cache;</div><div class="line">  Block* <span class="keyword">block</span> = NULL;</div><div class="line">  Cache::Handle* cache_handle = NULL;</div><div class="line"></div><div class="line">  BlockHandle handle;</div><div class="line">  Slice input = index_value;<span class="comment">//需要读取BlockHandle</span></div><div class="line">  Status s = handle.DecodeFrom(&amp;input);</div><div class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></div><div class="line">  <span class="comment">// can add more features in the future.</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    BlockContents <span class="built_in">contents</span>;</div><div class="line">    <span class="keyword">if</span> (block_cache != NULL) &#123;<span class="comment">//如果设置了block_cache</span></div><div class="line">      char cache_key_buffer[<span class="number">16</span>];<span class="comment">//block_cache的键值</span></div><div class="line">      E<span class="function"><span class="title">ncodeFixed64</span>(cache_key_buffer, table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>cache_id);<span class="comment">//前8字节存储cache_id</span></div><div class="line">      EncodeFixed64(cache_key_buffer+<span class="number">8</span>, handle.offset());<span class="comment">//后8字节存储这个block的偏移量</span></div><div class="line">      Slice key(cache_key_buffer, sizeof(cache_key_buffer));</div><div class="line">      <span class="function"><span class="title">cache_handle</span> = block_cache-&gt;</span>Lookup(key);<span class="comment">//在缓存中查找这个cache_handle</span></div><div class="line">      <span class="keyword">if</span> (cache_handle != NULL) &#123;<span class="comment">//如果缓存找到，直接用缓存中的block</span></div><div class="line">        <span class="function"><span class="title">block</span> = reinterpret_cast&lt;Block*&gt;(block_cache-&gt;</span>Value(cache_handle));</div><div class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果缓存中没有</span></div><div class="line">        <span class="function"><span class="title">s</span> = ReadBlock(table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>file, options, handle, &amp;<span class="built_in">contents</span>);从磁盘中读取出这个块</div><div class="line">        <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">          <span class="keyword">block</span> = new Block(<span class="built_in">contents</span>);</div><div class="line">          <span class="keyword">if</span> (<span class="built_in">contents</span>.cachable &amp;&amp; options.fill_cache) &#123;</div><div class="line">            <span class="function"><span class="title">cache_handle</span> = block_cache-&gt;</span>Insert(<span class="comment">//如果这个块设置了可缓存，插入缓存中</span></div><div class="line">                <span class="function"><span class="title">key</span>, <span class="keyword">block</span>, <span class="keyword">block</span>-&gt;</span>size(), &amp;DeleteCachedBlock);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没设置block_cache，直接磁盘读取</span></div><div class="line">      <span class="function"><span class="title">s</span> = ReadBlock(table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>file, options, handle, &amp;<span class="built_in">contents</span>);</div><div class="line">      <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">        <span class="keyword">block</span> = new Block(<span class="built_in">contents</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Iterator* iter;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">block</span> != NULL) &#123;</div><div class="line">    <span class="function"><span class="title">iter</span> = <span class="keyword">block</span>-&gt;</span>N<span class="function"><span class="title">ewIterator</span>(table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>options.comparator);<span class="comment">//获取这个块的迭代器</span></div><div class="line">    <span class="keyword">if</span> (cache_handle == NULL) &#123;</div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span>RegisterCleanup(&amp;DeleteBlock, <span class="keyword">block</span>, NULL);<span class="comment">//如果没有设置缓存，那么注册删除block函数</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span>RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);<span class="comment">//如果设置了缓存，那么注册释放block函数，就是引用数减1.</span></div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    iter = NewErrorIterator(s);</div><div class="line">  &#125;</div><div class="line">  return iter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数最后是当构造Table的迭代器时，作为函数指针传进构造函数中，Table的迭代器为两层迭代器，什么叫两层迭代器了？我的理解是：如果要读取一个sst文件的某个键值对，首先要读取data block，然后才是从这个data block中读取键值对。所以有两次迭代，即两个迭代器。</p>
<p>简要分析下，先看下Table返回两层迭代器的函数：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator* Table::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> NewTwoLevelIterator(</div><div class="line">      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),首先穿进去的index block的迭代器，用于读取data block</div><div class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>TwoLevelIterator类</h1>
<p>分析下两次迭代器，不算很难懂，属性如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">BlockFunction block_function_;<span class="comment">//就是传进来的BlockReader函数</span></div><div class="line"><span class="keyword">void</span>* arg_;<span class="comment">//Table指针</span></div><div class="line"><span class="keyword">const</span> ReadOptions options_;<span class="comment">//读取配置选项</span></div><div class="line">Status status_;</div><div class="line">IteratorWrapper index_iter_;<span class="comment">//index block迭代器，就是上述第一个参数</span></div><div class="line">IteratorWrapper data_iter_; <span class="comment">// 可能为空，读取某个data block的迭代器</span></div><div class="line"><span class="comment">// If data_iter_ is non-NULL, then "data_block_handle_" holds the</span></div><div class="line"><span class="comment">// "index_value" passed to block_function_ to create the data_iter_.</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data_block_handle_;<span class="comment">//用于判断两次data_iter是否相等。</span></div></pre></td></tr></table></figure></p>
<p>鉴于迭代函数都挺多，我还是一样，读取第一条记录作为样本讲解，首先构造成功之后，定位到哦第一条记录：
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="literal">void</span> TwoLevelIterator<span class="type">::SeekToFirst</span>() &#123;</div><div class="line">  index_iter_.SeekToFirst();<span class="comment">//index_block迭代器指向第一条记录，也就是第一个块的blockhandle</span></div><div class="line">  InitDataBlock();</div><div class="line">  <span class="keyword">if</span> (data_iter_.iter() != <span class="built_in">NULL</span>) data_iter_.SeekToFirst();</div><div class="line">  SkipEmptyDataBlocksForward();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="literal">void</span> TwoLevelIterator<span class="type">::InitDataBlock</span>() &#123;</div><div class="line">  <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</div><div class="line">    SetDataIterator(<span class="built_in">NULL</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    Slice <span class="keyword">handle</span> = index_iter_.value();<span class="comment">//指向第一个块的handle</span></div><div class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="built_in">NULL</span> &amp;&amp; <span class="keyword">handle</span>.compare(data_block_handle_) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// data_iter_不为空，而且还是相同块的迭代器，所以不变</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      Iterator* iter = (*block_function_)(arg_, options_, <span class="keyword">handle</span>);<span class="comment">//调用BlockReader，获取这个块的迭代器。</span></div><div class="line">      data_block_handle_.assign(<span class="keyword">handle</span>.<span class="built_in">data</span>(), <span class="keyword">handle</span>.size());<span class="comment">//为data_block_handle_赋值，用于判断两次data_iter_是否相等</span></div><div class="line">      SetDataIterator(iter);<span class="comment">//设置data_iter_</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过这两个函数之后，index_iter_指向index_block第一条记录，data_iter_指向第一个块的首位置。接下来通过查询来分析下两层迭代器如何获取数据。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TwoLevelIterator::Seek(<span class="keyword">const</span> Slice&amp; target) &#123;</div><div class="line">  index_iter_.Seek(target);<span class="comment">//找到target所以块的handle</span></div><div class="line">  InitDataBlock();<span class="comment">//初始化data_iter_，即指向target所在的块首位置</span></div><div class="line">  <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>) data_iter_.Seek(target);<span class="comment">//如果没报错即找到了，通过data_iter_.value即可获取值。</span></div><div class="line">  SkipEmptyDataBlocksForward();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> TwoLevelIterator::SkipEmptyDataBlocksForward() &#123;</div><div class="line">  <span class="keyword">while</span> (data_iter_.iter() == <span class="literal">NULL</span> || !data_iter_.Valid()) &#123;</div><div class="line">    <span class="comment">// Move to next block</span></div><div class="line">    <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</div><div class="line">      SetDataIterator(<span class="literal">NULL</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    index_iter_.Next();</div><div class="line">    InitDataBlock();</div><div class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>) data_iter_.SeekToFirst();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果查询到了，代码还是很好理解的，关键是如果没有查询到时，我还不是很理解。</p>
<p>从sst读取文件暂时分析到此。总结下，先 构造一个sst文件的Table类，然后构造出Table的迭代器，从迭代器就可以获取这个文件的任何键值。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> block </tag>
            
            <tag> sst文件 </tag>
            
            <tag> table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之Cache]]></title>
      <url>http://luodw.cc/2015/10/24/leveldb-11/</url>
      <content type="html"><![CDATA[<p>缓存对于一个系统的性能有着重要的影响。试想，如果leveldb每次查询数据时，都要从磁盘获取数据，那么磁盘多次的磁盘IO将严重影响leveldb的性能。所以levledb就在内存设计了一个缓存区，当查询数据时，先到缓存查询，如果缓存有需要的数据，即可直接返回数据即可，无需到磁盘获取数据；如果缓存没有，则到磁盘将数据取出放到缓存，下次再查询相同数据时，即可直接从缓存获取，大大减少了磁盘IO。</p>
<p>缓存在操作系统中更常见。例如，如果要读取文件，也是要先到操作系统内核缓存获取数据，内核缓存是以page为单位，没有再到磁盘中获取；还有CPU要从内存获取数据时，也是先在Cache中查询等等。</p>
<p>好，我们来看下leveldb的缓存设计。leveldb的缓存主要是由NewLRUCache这个类负责的，然后这个类包含了16个LRUCache，LRUCache这个类才是真正的缓存类，也就是说levledb包含了16个缓存。LRUCache这个类是一个环形双向链表组成的缓存，同时LRUCache还包含一个hash表，同样是存储缓存项，主要是为了加快查询速度。</p>
<p>以下这个图是我自己画的示意图，没有画出哈希表：</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--Cache.jpg" alt="leveldb缓存示意图">;</p>
<p>先给出缓存中代表键值对的数据结构：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> LRUHandle &#123;</div><div class="line">  <span class="keyword">void</span>* value;<span class="comment">//存储键值对的值</span></div><div class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);<span class="comment">//这个结构体的清除函数，由外界传进去注册</span></div><div class="line">  LRUHandle* next_hash;<span class="comment">//用于hash表冲突时使用</span></div><div class="line">  LRUHandle* next;<span class="comment">//当前节点的下一个节点</span></div><div class="line">  LRUHandle* prev;<span class="comment">//当前节点的上一个节点</span></div><div class="line">  <span class="keyword">size_t</span> charge;      <span class="comment">// 这个节点占用的内存</span></div><div class="line">  <span class="keyword">size_t</span> key_length;<span class="comment">//这个节点键值的长度</span></div><div class="line">  <span class="keyword">uint32_t</span> refs;<span class="comment">//这个节点引用次数，当引用次数为0时，即可删除</span></div><div class="line">  <span class="keyword">uint32_t</span> hash;      <span class="comment">// 这个键值的哈希值</span></div><div class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];   <span class="comment">// 存储键的字符串，也是C++柔性数组的概念。</span></div><div class="line"></div><div class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="comment">// For cheaper lookups, we allow a temporary Handle object</span></div><div class="line">    <span class="comment">// to store a pointer to a key in "value".</span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">return</span> *(<span class="keyword">reinterpret_cast</span>&lt;Slice*&gt;(value));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> Slice(key_data, key_length);</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="comment">//那句英文的意思就是，为了加速查询，有时候一个节点在value存储键。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个就是缓存中存储键值对的数据结构，键值对主要储存在key_data[1]和value里面。</p>
<h1>HandleTable</h1>
<p>接下来看下hash表的源码分析，源码挺长的，先看下成员数属性：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> length_;<span class="comment">//哈希数组的长度</span></div><div class="line"><span class="keyword">uint32_t</span> elems_;<span class="comment">//哈希表存储元素的数量</span></div><div class="line">LRUHandle** list_;<span class="comment">//哈希数组指针，因为数组存储的是指针，所以类型必须是指针的指针</span></div></pre></td></tr></table></figure></p>
<p>主要接口函数有：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在哈希表中，通过key和hash值查询LRUHandle，在删除，添加，查询时有用到</span></div><div class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></span></div><div class="line"><span class="comment">//在哈希表查询一个LRUHandle</span></div><div class="line">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </div><div class="line"><span class="comment">//在哈希表中删除一个LRUHandle</span></div><div class="line">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span></div><div class="line"><span class="comment">//在哈希表中添加一个LRUHandle</span></div><div class="line"> LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span></div><div class="line"><span class="comment">//改变哈希表的大小</span></div><div class="line"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>构造函数很简单，
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">HandleTable</span>() : <span class="selector-tag">length_</span>(<span class="number">0</span>), <span class="selector-tag">elems_</span>(<span class="number">0</span>), <span class="selector-tag">list_</span>(NULL) &#123; <span class="selector-tag">Resize</span>(); &#125;</div></pre></td></tr></table></figure></p>
<p>先是对成员初始化，然后调用Resize()，因为一开始没有哈希表，所以先给哈希表分配存储空间。第一次分配时，哈希数组长度为4，当后面元素数量大于哈希表长度时，再次分配哈希表大小为现在数组长度的2倍。
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">  void Resize() &#123;</div><div class="line">    uint32_t <span class="keyword">new</span><span class="type">_length</span> = <span class="number">4</span>;<span class="comment">//第一次默认分配大小数组长度为4</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">_length</span> &lt; elems_) &#123;</div><div class="line">      <span class="keyword">new</span><span class="type">_length</span> *= <span class="number">2</span>;<span class="comment">//后续分配为目前长度的2倍</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//以下是做重新哈希的工作，因为数组长度变化了，所以元素需要重新哈希</span></div><div class="line">    LRUHandle** <span class="keyword">new</span><span class="type">_list</span> = <span class="keyword">new</span> <span class="type">LRUHandle</span>*[<span class="keyword">new</span><span class="type">_length</span>];<span class="comment">//给哈希数组长度分配空间</span></div><div class="line">    memset(<span class="keyword">new</span><span class="type">_list</span>, <span class="number">0</span>, sizeof(<span class="keyword">new</span><span class="type">_list</span>[<span class="number">0</span>]) * <span class="keyword">new</span><span class="type">_length</span>);<span class="comment">//数组初始化为0</span></div><div class="line">    uint32_t count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; length_; i++) &#123;</div><div class="line">      LRUHandle* h = list_[i];<span class="comment">//h为数组的的元素，代表某个LRUHandle指针</span></div><div class="line">      <span class="keyword">while</span> (h != NULL) &#123;<span class="comment">//第i个哈希链的遍历</span></div><div class="line">        LRUHandle* next = h-&gt;next_hash;<span class="comment">//当前节点的下一个节点</span></div><div class="line">        uint32_t hash = h-&gt;hash;<span class="comment">//当前节点的哈希值</span></div><div class="line">        LRUHandle** ptr = &amp;<span class="keyword">new</span><span class="type">_list</span>[hash &amp; (<span class="keyword">new</span><span class="type">_length</span> - <span class="number">1</span>)];<span class="comment">//当前节点在新哈希数组中的索引位置</span></div><div class="line">        h-&gt;next_hash = *ptr;<span class="comment">//这句话在同一个哈希链上插入第二个元素时，更好理解</span></div><div class="line">        *ptr = h;<span class="comment">//索引位置赋值</span></div><div class="line">        h = next;<span class="comment">//开始迭代下一个元素</span></div><div class="line">        count++;<span class="comment">//哈希数组中所有元素</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    assert(elems_ == count);</div><div class="line">    delete[] list_;<span class="comment">//析构原有哈希数组</span></div><div class="line">    list_ = <span class="keyword">new</span><span class="type">_list</span>;<span class="comment">//list_指向新的哈希数组</span></div><div class="line">    length_ = <span class="keyword">new</span><span class="type">_length</span>;<span class="comment">//更新长度</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>第一次执行Resize时，不执行for循环，因为lenght_长度为0，所以就是新建一个空的哈希表。我来解释下h-&gt;next_hash = *ptr;我第一次没看懂这句话，所以我觉得有点难理解。</p>
<ol>
<li>一开始，*ptr值为空，所以h-&gt;next_hash值为0；</li>
<li>然后执行*ptr = h，把h赋值给*ptr，所以*ptr指向h。</li>
<li>当这条哈希链再来一个元素时，此时执行h-&gt;next_hash = *ptr;*ptr存储的是第一个节点的地址，然后新来的节点插在了第一个节点的前面。</li>
<li>最后执行*ptr = h，新哈希表的索引位置就存储第二个节点的地址。</li>
</ol>
<p>当插入，删除，查询时，都要先找到节点的地址，调用函数如下：
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LRUHandle** FindPointer(<span class="keyword">const</span> Slice&amp; key, uint32_t hash) &#123;</div><div class="line">  LRUHandle** <span class="built_in">ptr</span> = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)]<span class="comment">;//根据hash值，节点在哈希表中的索引位置</span></div><div class="line">  <span class="keyword">while</span> (*<span class="built_in">ptr</span> != <span class="literal">NULL</span> &amp;&amp;</div><div class="line">         ((*<span class="built_in">ptr</span>)-&gt;hash != hash || key != (*<span class="built_in">ptr</span>)-&gt;key())) &#123;</div><div class="line">    <span class="built_in">ptr</span> = &amp;(*<span class="built_in">ptr</span>)-&gt;next_hash<span class="comment">;//迭代哈希链，找到键值相等的节点</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">ptr</span><span class="comment">;返回这个节点的地址的地址</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先看下简单的查询操作;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> *FindPointer(key, hash);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>插入操作,先查找要插入的键值是否在哈希表中，如果在，那么用新的节点替换就的节点，并且函数返回旧的节点。
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LRUHandle* Insert(LRUHandle* h) &#123;</div><div class="line">    LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash);<span class="comment">//查找要插入的节点的地址</span></div><div class="line">    LRUHandle* old = *ptr;</div><div class="line">    h-&gt;next_hash = (old == <span class="keyword">NULL</span> ? <span class="keyword">NULL</span> : old-&gt;next_hash);<span class="comment">//这行和下一行将新节点插入到哈希链中</span></div><div class="line">    *ptr = h;</div><div class="line">    <span class="keyword">if</span> (old == <span class="keyword">NULL</span>) &#123;<span class="comment">//当old为空时，不存在相等的节点</span></div><div class="line">      ++elems_;<span class="comment">//元素个数+1</span></div><div class="line">      <span class="keyword">if</span> (elems_ &gt; length_) &#123;</div><div class="line">        <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></div><div class="line">        <span class="comment">// average linked list length (&lt;= 1).</span></div><div class="line">        Resize();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> old;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>为了保证哈希链的查找速度，尽量使平均哈希链长度为&lt;=1。所以函数有if判断。</p>
<p>接下来，是哈希表删除函数，找到要删除的节点，更新即可：
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="type">LRUHandle</span>* <span class="type">Remove</span>(<span class="keyword">const</span> <span class="type">Slice</span>&amp; key, uint32_t hash) &#123;</div><div class="line">  <span class="type">LRUHandle</span>** <span class="keyword">ptr</span> = <span class="type">FindPointer</span>(key, hash);//查找要删除的节点位置</div><div class="line">  <span class="type">LRUHandle</span>* <span class="literal">result</span> = *<span class="keyword">ptr</span>;//把要删除的节点地址赋给<span class="literal">result</span></div><div class="line">  <span class="keyword">if</span> (<span class="literal">result</span> != <span class="type">NULL</span>) &#123;</div><div class="line">    *<span class="keyword">ptr</span> = <span class="literal">result</span>-&gt;next_hash;//删除节点的位置赋值给删除节点的下一个节点</div><div class="line">    --elems_;//元素减一</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>LRUCache类</h1>
<p>接下来，我们来分析下双向链表缓存类LRUCache,先看下主要成员：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> capacity_;<span class="comment">//这个双向链表的存储容量，由每个节点的charge累加和</span></div><div class="line">port::Mutex mutex_;<span class="comment">//这个链表的互斥量</span></div><div class="line"><span class="keyword">size_t</span> usage_;<span class="comment">//已使用空间</span></div><div class="line">LRUHandle lru_;<span class="comment">//双向循环链表的傀儡节点，不存储数据，方便定位这个链表的入口</span></div><div class="line">HandleTable table_;<span class="comment">//上面讲解的哈新表，所以一个链表还附带一个哈希表</span></div></pre></td></tr></table></figure></p>
<p>lru之前(prev)的节点都是最新的节点，lru之后的节点(next)都是最“旧”的节点，所以插入新节点时，就往lru.prev插入.当空间不够时，删除lru.next后的节点。</p>
<p>构造函数如下：
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">LRUCache:</span>:LRUCache()</div><div class="line">    : usage_(<span class="number">0</span>) &#123;</div><div class="line">  <span class="comment">// 一开始为空的循环链表，所以lru的前后指针都指向自己</span></div><div class="line">  lru_.next = <span class="variable">&amp;lru_</span>;</div><div class="line">  lru_.prev = <span class="variable">&amp;lru_</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>向链表append一个节点，调用的是void LRUCache::LRU_Append(LRUHandle* e)，这个函数由insert函数调用;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> LRUCache::LRU_Append(LRUHandle* e) &#123;</div><div class="line">  <span class="comment">// 往lru_之前插入，使这个节点为最新节点</span></div><div class="line">  e-&gt;next = &amp;lru_;</div><div class="line">  e-&gt;prev = lru_.prev;</div><div class="line">  e-&gt;prev-&gt;next = e;</div><div class="line">  e-&gt;next-&gt;prev = e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Cache::Handle* LRUCache::Insert(</div><div class="line">    <span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash, <span class="keyword">void</span>* value, <span class="keyword">size_t</span> charge,</div><div class="line">    <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)) &#123;</div><div class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;<span class="comment">//多线程使用时，删除添加均需要锁住</span></div><div class="line"></div><div class="line">  LRUHandle* e = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(</div><div class="line">      <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUHandle)<span class="number">-1</span> + key.size()));<span class="comment">//给插入的节点分配空间</span></div><div class="line">  e-&gt;value = value;</div><div class="line">  e-&gt;deleter = deleter;</div><div class="line">  e-&gt;charge = charge;</div><div class="line">  e-&gt;key_length = key.size();</div><div class="line">  e-&gt;hash = hash;</div><div class="line">  e-&gt;refs = <span class="number">2</span>;  <span class="comment">// 链表引用一次，返回值引用一次</span></div><div class="line">  <span class="built_in">memcpy</span>(e-&gt;key_data, key.data(), key.size());<span class="comment">//给键值赋值</span></div><div class="line">  LRU_Append(e);<span class="comment">//调用上述函数，添加进循环链表</span></div><div class="line">  usage_ += charge;/链表空间使用量更新</div><div class="line"></div><div class="line">  LRUHandle* old = table_.Insert(e);<span class="comment">//同时往哈希表插入节点</span></div><div class="line">  <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</div><div class="line">    LRU_Remove(old);<span class="comment">//如果哈希表用新的节点替换了旧节点，那么循环链表也要删除旧节点</span></div><div class="line">    Unref(old);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;<span class="comment">//缓存不够用时，从循环链表的lru.next开始删除节点，同时也要把哈希表的节点删除</span></div><div class="line">    LRUHandle* old = lru_.next;</div><div class="line">    LRU_Remove(old);</div><div class="line">    table_.Remove(old-&gt;key(), old-&gt;hash);</div><div class="line">    Unref(old);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);返回新插入节点的指针</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除节点的函数比较简单，我就不多说了。</p>
<h1>ShardedLRUCache类</h1>
<p>这个类主要是一个封装类，封装类16个LRUCache类，就是16个环形链表+哈希表。根据键的哈希值，调用相应的LRUCache类的方法。</p>
<p>先看两个简单的函数：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t <span class="title">HashSlice</span><span class="params">(<span class="keyword">const</span> Slice&amp; s)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> Hash(s.data(), s.size(), <span class="number">0</span>);</div><div class="line">&#125;<span class="comment">//返回这个键值的哈希值，调用hash函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> uint32_t <span class="title">Shard</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits);</div><div class="line">&#125;<span class="comment">//用hash值最高的4位，来决定用那个LRUCache来操作这个键值</span></div></pre></td></tr></table></figure></p>
<p>主要接口如下，可以看到都是调用LRUCache里的方法
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">explicit</span> ShardedLRUCache(size_t capacity)</div><div class="line">      : last_id_(<span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">const</span> size_t per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++) &#123;</div><div class="line">      shard_[s].SetCapacity(per_shard);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">virtual</span> ~ShardedLRUCache() &#123; &#125;</div><div class="line">  <span class="keyword">virtual</span> Handle* Insert(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value, size_t charge,</div><div class="line">                         <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)) &#123;</div><div class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</div><div class="line">    <span class="built_in">return</span> shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">virtual</span> Handle* Lookup(<span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</div><div class="line">    <span class="built_in">return</span> shard_[Shard(hash)].Lookup(key, hash);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Release(Handle* handle) &#123;</div><div class="line">    LRUHandle* h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle);</div><div class="line">    shard_[Shard(h-&gt;hash)].Release(handle);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Erase(<span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</div><div class="line">    shard_[Shard(hash)].Erase(key, hash);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span>* Value(Handle* handle) &#123;</div><div class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle)-&gt;value;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">virtual</span> uint64_t NewId() &#123;</div><div class="line">    MutexLock l(&amp;id_mutex_);</div><div class="line">    <span class="built_in">return</span> ++(last_id_);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>看了leveldb缓存，我对缓存机制有了深刻的理解，大概就知道内核的缓存是如何实现的了，所以多看看优秀开源源码，可以学习到很多东西。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> Cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++之柔性数组]]></title>
      <url>http://luodw.cc/2015/10/22/Cplus6/</url>
      <content type="html"><![CDATA[<p>当初在看redis源码时，发现SDS定义如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sdshdr</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> len;</div><div class="line">	<span class="keyword">int</span> <span class="built_in">free</span>;</div><div class="line">	<span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>有没发现char buf[]这个定义，不对，不能称为定义，因为数组的长度未知，称为声明吧。如果单独定义char buf[]是会报错的，因为长度未知，那么为什么放在结构体里面就可以了。今天在看STL源码解析时，看到内存配置器有个联合体的定义把我迷惑迷惑的是不要不要的，在百度过程中发现了<strong>柔性数组</strong>这个东西。</p>
<p>先介绍柔性数组这个东西，再来看STL里的联合体。</p>
<p>如果在一个结构体里面放置一个一个动态分配的字符串，我们可以在结构体里面放置一个指向动态分配的内存指针，如下定义：
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct test</div><div class="line">&#123;</div><div class="line">	int a<span class="comment">;</span></div><div class="line">	char *p<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>但是如果这样，会造成结构体和字符串的分离，可以把结构体和字符串放在一起效果会更好，例如
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">char</span> ch[]=<span class="string">"hello world!"</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span>* p=(<span class="class"><span class="keyword">struct</span> <span class="title">test</span></span>*)malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">test</span></span>)+<span class="keyword">sizeof</span>(ch)+<span class="number">1</span>);</div><div class="line">strcpy(p+<span class="number">1</span>,ch);</div></pre></td></tr></table></figure></p>
<p>这样一来，就可以通过(char*)(p+1)来访问字符串了。但是老是这样的话，不是很方便。如果能在结构体里放置一个指针又不占用内存，那将会非常完美。柔性数组就这样出来了。且看如下定义：
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct test</div><div class="line">&#123;</div><div class="line">        int a<span class="comment">;</span></div><div class="line">        char buf[]<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>没错，就是和SDS定义一样的，因为这个数组没有指定长度，所以这个数组并不占用内存，大家都知道这个数组名代表这个数组的首位置，所以在这个结构体里，这个buf只是指向成员a的下一个地址而已。我们还是可以如下定义这个结构体。
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">char</span> ch[]=<span class="string">"hello world!"</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span>* p=(<span class="class"><span class="keyword">struct</span> <span class="title">test</span></span>*)malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">test</span></span>)+<span class="keyword">sizeof</span>(ch)+<span class="number">1</span>);</div><div class="line">strcpy(p-&gt;buf,ch);</div></pre></td></tr></table></figure></p>
<p>这时，当p指向的内存空间当做一个整体时，buf指向的就是一块动态长度的内存，柔性一词来源于此。这样的做法有以下几个好处:</p>
<ol>
<li>首先柔性数组不占内存，值代表地址；</li>
<li>可以通过p-&gt;buf来访问字符串，符合常规用法。</li>
<li>字符串长度为动态分配。</li>
</ol>
<p>接下来，我就要讲解困惑我的那个联合体了。
首先来看下定义：
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span>&#123;</span></div><div class="line">	<span class="class"><span class="keyword">union</span> <span class="title">obj</span> *<span class="title">free_list_link</span>;</span></div><div class="line">	char client_data[<span class="number">1</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>首先要知道这个联合体的大小=联合体里最大的数据类型的大小，所以这个联合体的大小为8字节（我系统64位）；我今天的困惑是啥了？先看下如下代码：
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span></span></div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">union</span> <span class="title">obj</span> *<span class="title">free_list_link</span>;</span></div><div class="line">    char client_data[<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    <span class="regexp">//</span>假设这两个是要分配出去的内存。</div><div class="line">    char mem[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    char mem1[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    </div><div class="line">    <span class="regexp">//</span>现在是每一块内存的开始均是一个<span class="class"><span class="keyword">union</span> <span class="title">node</span>结构</span></div><div class="line">    /<span class="regexp">/----------------------------------</span></div><div class="line">    /<span class="regexp">/| union obj | ....................</span></div><div class="line">    /<span class="regexp">/ ----------------------------------  </span></div><div class="line">    union obj *p1 = (union obj *)mem; /<span class="regexp">/用一个变量表示这个结构</span></div><div class="line">    </div><div class="line">   /<span class="regexp">/p1-&gt;free_list_link 设置为下一个内存的起始段</span></div><div class="line">    p1-&gt;free_list_link = (union obj *)mem1 ;</div><div class="line">    </div><div class="line">    /<span class="regexp">/可以看到mem和client_data 两个指针值是一致的</span></div><div class="line">    cout &lt;&lt;"mem             = " &lt;&lt; (void *)mem &lt;&lt; endl;</div><div class="line">    cout &lt;&lt;"p1-&gt;client_data = " &lt;&lt; (void *)p1-&gt;client_data &lt;&lt; endl;</div><div class="line"></div><div class="line">    /<span class="regexp">/client_data只是为了简化本段内存的定义的，只是方便一些，</span></div><div class="line">    /<span class="regexp">/可以使用(void *)p1表示本段内存，但是每次要转换，可能不方便吧，</span></div><div class="line">    /<span class="regexp">/实际中可能也用不到</span></div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个程序是CSDN上的一个验证程序，最后输出两个值相等。我今天很困惑，因为union的所有成员变量共享同一块内存，那么对p1-&gt;free_list_link赋值为什么没有破坏掉pi-&gt;client_data的值？</p>
<p>看了柔性数组之后，才解开了我的困惑，因为虽然给client_data分配了一个字符的内存，但是client_data始终指向的是内存的首地址。如果说要覆盖client_data的值，那么也要先给client_data赋初值，这时，client_data的数据就占有了这个8字节内存，如果再给free_list_link赋值，那么这时就真正破坏了client_data的数据，但是client_data还是指向这内存的首地址。这也是用一指针大小的内存，实现着两个功能，太妙了。</p>
<p>柔性指针有参考梦中乐园的博客<a href="http://www.cppblog.com/Dream5/articles/148386.html" target="_blank" rel="external">http://www.cppblog.com/Dream5/articles/148386.html</a>，特别指出下。</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 柔性数组 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之写sst文件]]></title>
      <url>http://luodw.cc/2015/10/21/leveldb-10/</url>
      <content type="html"><![CDATA[<p>本篇文章分析下leveldb写sst文件的源码，本质上就是为immemtable compaction到leveldb0文件提供接口，主要是插入。如果要理解这部分的源码，首先必须先将上篇sst文件格式搞清楚，否则，看源码会非常吃力，或者说毫无头绪。</p>
<p>这部分源码涉及到table文件下的block_builder.h/.cc，filter_block.h/.cc和table_builder.h/.cc。先分析下block_builder.h/.cc文件，主要功能就是用于写data block和index block。向外提供主要接口就是void BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value) .</p>
<h1>BlockBuilder类</h1>
<p>首先，看这个类的类名就知道这个类是用来构造一个块的，data block和index block都是通过这个类构造出来的。来看下这个类的成员变量有哪些：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">const</span> Options*        options_;      <span class="comment">//Option类，由最上层open函数传进来，这里主要用于counter_ &lt; options_-&gt;block_restart_interval)</span></div><div class="line"><span class="comment">//判断两个Restart节点之间，记录数量是否小于option定义的值</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>           buffer_;      <span class="comment">// 这个块的所有数据，数据一条一条添加到这个string中</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; restarts_;    <span class="comment">// 存储每一个Restart[i]</span></div><div class="line">  <span class="keyword">int</span>                   counter_;     <span class="comment">// 两个Restart之间记录的条数</span></div><div class="line">  <span class="keyword">bool</span>                  finished_;    <span class="comment">// 是否调用finish，也就是是否写完一个块。</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>           last_key_;    <span class="comment">//每次写记录时的上一条记录，用于提供共享记录部分</span></div></pre></td></tr></table></figure></p>
<p>因为这个类就要是为了构造块，所以这个类首先要提供add键值对的接口，其次是要有返回这个块所有数据的接口，便于上层接口将数据写到磁盘中，所以主要接口如下：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">BlockBuilder</span>(<span class="params"><span class="keyword">const</span> Options* options</span>)</span>;</div><div class="line"><span class="comment">//重置block的各个属性，准备下一次写</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</div><div class="line"><span class="comment">//往当前块添加一条记录</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; <span class="keyword">value</span></span>)</span>;</div><div class="line"><span class="comment">//当前块写结束，返回这个块的所有内容，在tablebuilder写入文件</span></div><div class="line"><span class="function">Slice <span class="title">Finish</span>(<span class="params"></span>)</span>;</div><div class="line"><span class="comment">//估计这个块的数据量，用于判断当前块是否大于option当中定义数据块大小</span></div><div class="line"><span class="function">size_t <span class="title">CurrentSizeEstimate</span>(<span class="params"></span>) <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure></p>
<p>接下来，分析每个函数的源码，构造函数如下;
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">BlockBuilder::BlockBuilder(<span class="keyword">const</span> Options* options)</div><div class="line">    : options_(options),</div><div class="line">      restarts_(),</div><div class="line">      counter_(0),</div><div class="line">      finished_(<span class="keyword">false</span>) &#123;</div><div class="line">    <span class="keyword">assert</span>(options-&gt;block_restart_interval &gt;= <span class="number">1</span>);</div><div class="line">    restarts_.push_back(<span class="number">0</span>); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发现构造函数没有什么好分析的，就最后一句。因为第一条肯定是Restart点，所以把0地址添加进restarts。</p>
<p>重置函数源码如下：</p>
<p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">kBuilder::Reset() &#123;</div><div class="line">  buffer_.<span class="built_in">clear</span>();<span class="comment">//块内容清零</span></div><div class="line">  restarts_.<span class="built_in">clear</span>();<span class="comment">//Restart节点清零</span></div><div class="line">  restarts_.push_back(<span class="number">0</span>); <span class="comment">//把0偏移加到Restart节点</span></div><div class="line">  counter_ = <span class="number">0</span>;<span class="comment">//两个Restart节点之间记录数清零</span></div><div class="line">  finished_ = <span class="keyword">false</span>;<span class="comment">//还未结束</span></div><div class="line">  last_key_.<span class="built_in">clear</span>();<span class="comment">//last_key清零</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来是这个块内容大小的估计函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">size_t</span> BlockBuilder::CurrentSizeEstimate() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> (buffer_.size() +                        <span class="comment">// 数据容量大小</span></div><div class="line">          restarts_.size() * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) +   <span class="comment">//Restart数组大小 </span></div><div class="line">          <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));  <span class="comment">//Restart数组大小值所占的字节</span></div></pre></td></tr></table></figure></p>
<p>这个函数主要用于判断某个块的容量是否到达上限，到达之后，要把数据刷新到磁盘，然后重新开始写下一个块。</p>
<p>接下来是这个类最重要的函数，add添加键值对函数，这里还是把记录格式在贴出来，方便对照：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.jpg" alt="data block记录格式">
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BlockBuilder::Add(<span class="keyword">const</span> Slice&amp; <span class="built_in">key</span>, <span class="keyword">const</span> Slice&amp; value) &#123;</div><div class="line">  Slice last_key_piece(last_key_);<span class="comment">//上一条记录</span></div><div class="line">  <span class="keyword">assert</span>(!finished_);<span class="comment">//这个块还没写结束，如果结束，再添加会报错</span></div><div class="line">  <span class="keyword">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);<span class="comment">//两个Restart节点之间记录数小于等于预先设定的值</span></div><div class="line">  <span class="keyword">assert</span>(buffer_.empty() </div><div class="line">         || options_-&gt;comparator-&gt;Compare(<span class="built_in">key</span>, last_key_piece) &gt; <span class="number">0</span>);<span class="comment">//后面添加的键比上条记录大，skiplist有序</span></div><div class="line">  size_t shared = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</div><div class="line">    <span class="comment">// 计算当前记录和上条记录共享部分长度</span></div><div class="line">    <span class="keyword">const</span> size_t min_length = std::<span class="built_in">min</span>(last_key_piece.<span class="built_in">size</span>(), <span class="built_in">key</span>.<span class="built_in">size</span>());</div><div class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == <span class="built_in">key</span>[shared])) &#123;</div><div class="line">      shared++;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 如果上面if语句为false，则添加一个Restart节点，counter_=0。</span></div><div class="line">    restarts_.push_back(buffer_.<span class="built_in">size</span>());</div><div class="line">    counter_ = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">    <span class="keyword">const</span> size_t non_shared = <span class="built_in">key</span>.<span class="built_in">size</span>() - shared;<span class="comment">//当前记录和上条记录非共享部分长度</span></div><div class="line"></div><div class="line">  <span class="comment">// 将shared,non_shared,value的长度添加进buffer_</span></div><div class="line">  PutVarint32(&amp;buffer_, shared);</div><div class="line">  PutVarint32(&amp;buffer_, non_shared);</div><div class="line">  PutVarint32(&amp;buffer_, value.<span class="built_in">size</span>());</div><div class="line"></div><div class="line">  <span class="comment">// 添加当前记录的非共享内容和vlue内容</span></div><div class="line">  buffer_.<span class="built_in">append</span>(<span class="built_in">key</span>.data() + shared, non_shared);</div><div class="line">  buffer_.<span class="built_in">append</span>(value.data(), value.<span class="built_in">size</span>());</div><div class="line"></div><div class="line">  <span class="comment">// 更新上一条记录，即为当前记录</span></div><div class="line">  last_key_.resize(shared);</div><div class="line">  last_key_.<span class="built_in">append</span>(<span class="built_in">key</span>.data() + shared, non_shared);</div><div class="line">  <span class="keyword">assert</span>(Slice(last_key_) == <span class="built_in">key</span>);</div><div class="line">  counter_++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数需要注意的是，每个Restart节点的共享部分为0,，因为没有上一条记录嘛。然后按协议封装好一条完整记录添加到buffer_即可，接下来，就是finish函数做的事了。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Slice BlockBuilder::Finish() &#123;</div><div class="line">  <span class="comment">// 将Restart数组添加到记录后面</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;</div><div class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</div><div class="line">  &#125;</div><div class="line">  PutFixed32(&amp;buffer_, restarts_.size());<span class="comment">//添加Restart数组大小到Restart数组后面</span></div><div class="line">  finished_ = <span class="literal">true</span>;<span class="comment">//这次数据块写结束</span></div><div class="line">  <span class="keyword">return</span> Slice(buffer_);<span class="comment">//向上层调用返回这个数据块的内容</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要是向table_builder提供返回这个块内容的接口，然后由table_builder调用函数写回磁盘。</p>
<h1>FilterBlockBuilder类</h1>
<p>这个类用于写Meta block，也就是创建过滤器。先来分析主要成员变量：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> FilterPolicy* policy_;    <span class="comment">//过滤策略，比较有名的是布隆过滤器</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> keys_;              <span class="comment">// 每一个Fliter条目包含的键值</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;     <span class="comment">// 每个Filter条目包含键值的首地址偏移量，相对于keys_首地址来说</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> result_;            <span class="comment">// 到目前为止，所有Filter天幕包含的数据</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;   <span class="comment">// 临时slice向量，用于向result_添加本次keys_数据</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_;<span class="comment">//每个Filter的偏移量</span></div></pre></td></tr></table></figure></p>
<p>接下来介绍下主要函数：</p>
<p>开始创建Fliter条目函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> FilterBlockBuilder::StartBlock(<span class="keyword">uint64_t</span> block_offset) &#123;</div><div class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);<span class="comment">//kFilterBase默认大小为2&gt;&gt;11</span></div><div class="line">  assert(filter_index &gt;= filter_offsets_.size());</div><div class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.size()) &#123;</div><div class="line">    GenerateFilter();<span class="comment">//创建Filter条目</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在table_builder.cc中，当一个块被刷新到磁盘时，就调用一次start_block函数，而触发块刷新的条件是，这个块的大小&gt;=r-&gt;options.block_size=4096，所以每次都创建一个Filter，但是Filter有两个数组指向&gt;=2的Filter条目。</p>
<p>创建Filer条目函数:
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> FilterBlockBuilder::GenerateFilter() &#123;</div><div class="line">  <span class="keyword">const</span> size_t num_keys = start_.<span class="built_in">size</span>();<span class="comment">//这个Filter键值的个数</span></div><div class="line">  <span class="built_in">if</span> (num_keys == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// 添加下一个Filter条目的偏移量</span></div><div class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</div><div class="line">    <span class="built_in">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 往result_添加key值</span></div><div class="line">  start_.push_back(keys_.<span class="built_in">size</span>());  <span class="comment">// 简化长度计算</span></div><div class="line">  tmp_keys_.resize(num_keys);</div><div class="line">  <span class="built_in">for</span> (size_t i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</div><div class="line">    size_t length = start_[i+<span class="number">1</span>] - start_[i];</div><div class="line">    tmp_keys_[i] = Slice(base, length);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//添加Filter偏移量以及将keys_添加进result_。</span></div><div class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());</div><div class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], num_keys, &amp;result_);</div><div class="line"></div><div class="line">  <span class="comment">//重置以下三个成员变量</span></div><div class="line">  tmp_keys_.<span class="built_in">clear</span>();</div><div class="line">  keys_.<span class="built_in">clear</span>();</div><div class="line">  start_.<span class="built_in">clear</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Filter i添加键值的函数:
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> FilterBlockBuilder::AddKey(<span class="keyword">const</span> Slice&amp; <span class="built_in">key</span>) &#123;</div><div class="line">  Slice k = <span class="built_in">key</span>;</div><div class="line">  start_.push_back(keys_.<span class="built_in">size</span>());</div><div class="line">  keys_.<span class="built_in">append</span>(k.data(), k.<span class="built_in">size</span>());<span class="comment">//添加键值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>表示Meta block块写结束的函数:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Slice FilterBlockBuilder::Finish() &#123;</div><div class="line">  <span class="keyword">if</span> (!start_.empty()) &#123;</div><div class="line">    GenerateFilter();<span class="comment">//为剩下的键值对创建Filter。</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 将Filter i的偏移量数组添加到result_</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = result_.size();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.size(); i++) &#123;</div><div class="line">    PutFixed32(&amp;result_, filter_offsets_[i]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  PutFixed32(&amp;result_, array_offset);<span class="comment">//将Filter i偏移量数组大小添加进result_</span></div><div class="line">  result_.push_back(kFilterBaseLg);  <span class="comment">// 添加beselg值</span></div><div class="line">  <span class="keyword">return</span> Slice(result_);<span class="comment">//向上层函数返回这个Meta block的内容。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>TableBuilder类</h1>
<p>这个类主要功能就是创建一个sst文件，它调用了block_builder和filerblockbuilder。这个类属性有点多，需要好好记清楚了。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TableBuilder::Rep &#123;</div><div class="line">  Options options;<span class="comment">//上层传进来的optians，就是open函数的参数</span></div><div class="line">  Options index_block_options;<span class="comment">//暂时没看出用处</span></div><div class="line">  WritableFile* file;<span class="comment">//sst文件封装类</span></div><div class="line">  <span class="keyword">uint64_t</span> offset;<span class="comment">//sst文件的偏移量，每写一个块，就更新一次</span></div><div class="line">  Status status;<span class="comment">//这个类操作的状态</span></div><div class="line">  BlockBuilder data_block;<span class="comment">//写数据块的类</span></div><div class="line">  BlockBuilder index_block;<span class="comment">//写index_block的类</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> last_key;<span class="comment">//用于写index block时最大键值 </span></div><div class="line">  <span class="keyword">int64_t</span> num_entries;<span class="comment">//这个块总的记录数</span></div><div class="line">  <span class="keyword">bool</span> closed;          <span class="comment">// 调用finish或者abandon，文件写结束</span></div><div class="line">  FilterBlockBuilder* filter_block;<span class="comment">//创建过滤器的类</span></div><div class="line">  <span class="keyword">bool</span> pending_index_entry;<span class="comment">//data block为空时，该值为true,用于写handler</span></div><div class="line">  BlockHandle pending_handle;  <span class="comment">// 用于写index block的handler</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compressed_output;<span class="comment">//转换为压缩的字符串</span></div></pre></td></tr></table></figure></p>
<p>关键还是data_block，因为data_block要用多次，写块，刷新到磁盘，重置块等等。C++中用class代替struct，这里展示了struct用的场景之一，就是类里成员变量太多时，可以用struct封装。</p>
<p>接下来，主要介绍table_builder主要函数。</p>
<p>往data block添加一条记录函数：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::Add(const Slice&amp; key, const Slice&amp; value) &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>closed);</div><div class="line">  <span class="keyword">if</span> (!ok()) return;</div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>num_entries &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="function"><span class="title">assert</span>(r-&gt;</span><span class="function"><span class="title">options</span>.comparator-&gt;</span>C<span class="function"><span class="title">ompare</span>(key, Slice(r-&gt;</span>last_key)) &gt; <span class="number">0</span>);</div><div class="line">  &#125;<span class="comment">//后续的key大于上条记录的key</span></div><div class="line"></div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>pending_index_entry) &#123;<span class="comment">//当data_block为空时，将上个datablock的handler添加到index block</span></div><div class="line">    <span class="function"><span class="title">assert</span>(r-&gt;</span>data_block.empty());</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">options</span>.comparator-&gt;</span>F<span class="function"><span class="title">indShortestSeparator</span>(&amp;r-&gt;</span>last_key, key);</div><div class="line">    std::string handle_encoding;</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>pending_handle.EncodeTo(&amp;handle_encoding);<span class="comment">//将handle解码到字符串handle_encoding</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">index_block</span>.Add(r-&gt;</span>last_key, Slice(handle_encoding));<span class="comment">///index_block添加一条记录</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>pending_index_entry = <span class="literal">false</span>;<span class="comment">//赋值为false，开始新一个数据块写</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">filter_block</span>-&gt;</span>AddKey(key);<span class="comment">//如果有定义过滤器，将这条记录键值添加到meta block的filter条目中</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>last_key.assign(key.<span class="keyword">data</span>(), key.size());<span class="comment">//重置last_key</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>num_entries++;<span class="comment">//记录数+1</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>data_block.Add(key, value);数据块添加记录</div><div class="line"></div><div class="line">  <span class="function"><span class="title">const</span> size_t estimated_block_size = r-&gt;</span>data_block.CurrentSizeEstimate();</div><div class="line">  <span class="function"><span class="title">if</span> (estimated_block_size &gt;= r-&gt;</span>options.block_size) &#123;</div><div class="line">    Flush();<span class="comment">//当这个数据块的数据量大于预先设置的值时，刷新到磁盘</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刷新函数为：</p>
<p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::Flush() &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>closed);</div><div class="line">  <span class="keyword">if</span> (!ok()) return;</div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>data_block.empty()) return;</div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>pending_index_entry);</div><div class="line">  W<span class="function"><span class="title">riteBlock</span>(&amp;r-&gt;</span><span class="function"><span class="title">data_block</span>, &amp;r-&gt;</span>pending_handle);<span class="comment">//将数据写回缓冲区</span></div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>pending_index_entry = <span class="literal">true</span>;</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Flush();<span class="comment">//数据刷新到磁盘</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">filter_block</span>-&gt;</span>S<span class="function"><span class="title">tartBlock</span>(r-&gt;</span>offset);<span class="comment">//重新开启一个Filter条目</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刷新操作主要有以下步骤：</p>
<ol>
<li>将这个块的数据刷新到磁盘。因为底层调用的是c标准io流，所以数据是先写到用户态的缓存中，然后调用flush，再刷新到磁盘。</li>
<li>在WriteBlock函数内部还在index block添加一条记录。</li>
<li>重新开启一条Filter条目。</li>
</ol>
<p>接下来是WriteBlock函数：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::WriteBlock(BlockBuilder* <span class="keyword">block</span>, BlockHandle* handle) &#123;</div><div class="line">  assert(ok());</div><div class="line">  Rep* r = rep_;</div><div class="line">  S<span class="function"><span class="title">lice</span> raw = <span class="keyword">block</span>-&gt;</span>Finish();<span class="comment">//data block原生内容</span></div><div class="line"></div><div class="line">  Slice block_contents;</div><div class="line">  C<span class="function"><span class="title">ompressionType</span> type = r-&gt;</span>options.compression;<span class="comment">//是否将数据压缩</span></div><div class="line">  <span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></div><div class="line">  switch (type) &#123;</div><div class="line">    case kNoCompression:</div><div class="line">      block_contents = raw;</div><div class="line">      break;</div><div class="line"></div><div class="line">    case kSnappyCompression: &#123;</div><div class="line">      <span class="function"><span class="title">std</span>::string* compressed = &amp;r-&gt;</span>compressed_output;</div><div class="line">      <span class="keyword">if</span> (port::Snappy_Compress(raw.<span class="keyword">data</span>(), raw.size(), compressed) &amp;&amp;</div><div class="line">          <span class="function"><span class="title">compressed</span>-&gt;</span>size() &lt; raw.size() - (raw.size() / <span class="number">8</span>u)) &#123;</div><div class="line">        block_contents = *compressed;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></div><div class="line">        <span class="comment">// store uncompressed form</span></div><div class="line">        block_contents = raw;</div><div class="line">        type = kNoCompression;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  WriteRawBlock(block_contents, type, handle);<span class="comment">//真正写操作</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>compressed_output.clear();</div><div class="line">  <span class="function"><span class="title">block</span>-&gt;</span>Reset();<span class="comment">//重置data block，用于下次写</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要是用于判断data block的数据是否要压缩存储，真正下操作在下面函数：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::WriteRawBlock(const Slice&amp; block_contents,</div><div class="line">                                 CompressionType type,</div><div class="line">                                 BlockHandle* handle) &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  <span class="function"><span class="title">handle</span>-&gt;</span><span class="function"><span class="title">set_offset</span>(r-&gt;</span>offset);<span class="comment">//设置当前块的偏移量</span></div><div class="line">  <span class="function"><span class="title">handle</span>-&gt;</span>set_size(block_contents.size());<span class="comment">//设置当前块的大小</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Append(block_contents);<span class="comment">//将内容写进用户态缓冲区</span></div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>status.ok()) &#123;</div><div class="line">    char trailer[kBlockTrailerSize];</div><div class="line">    trailer[<span class="number">0</span>] = type;</div><div class="line">    uint32_t crc = crc32c::Value(block_contents.<span class="keyword">data</span>(), block_contents.size());</div><div class="line">    crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></div><div class="line">    EncodeFixed32(trailer+<span class="number">1</span>, crc32c::Mask(crc));</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Append(Slice(trailer, kBlockTrailerSize));</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>status.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>offset += block_contents.size() + kBlockTrailerSize;<span class="comment">//写进一个块，这时sst文件偏移量增加</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数主要作用就是将数据写进用户态缓冲区，添加类型和CRC码，更新偏移量。</p>
<p>最后还有一个sst文件写完成函数，用于上层函数调用：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">Status TableBuilder::Finish() &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  Flush();<span class="comment">//刷新最后的数据</span></div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>closed);</div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>closed = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</div><div class="line"></div><div class="line">  <span class="comment">// 写Meta block，调用filterblockbuilder的finish函数返回所有内容</span></div><div class="line">  <span class="function"><span class="title">if</span> (ok() &amp;&amp; r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">    W<span class="function"><span class="title">riteRawBlock</span>(r-&gt;</span><span class="function"><span class="title">filter_block</span>-&gt;</span>Finish(), kNoCompression,</div><div class="line">                  &amp;filter_block_handle);<span class="comment">//将这个meta block的偏移量和写进filter_block_handle，用于metaindex block写</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 写metaindex block</span></div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    B<span class="function"><span class="title">lockBuilder</span> meta_index_block(&amp;r-&gt;</span>options);</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">      <span class="comment">// meta_index block块内容格式为"filter.Name"</span></div><div class="line">      std::string key = <span class="string">"filter."</span>;</div><div class="line">      <span class="function"><span class="title">key</span>.append(r-&gt;</span><span class="function"><span class="title">options</span>.filter_policy-&gt;</span>Name());</div><div class="line">      std::string handle_encoding;</div><div class="line">      filter_block_handle.EncodeTo(&amp;handle_encoding);</div><div class="line">      meta_index_block.Add(key, handle_encoding);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></div><div class="line">    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 写index block</span></div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>pending_index_entry) &#123;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">options</span>.comparator-&gt;</span>F<span class="function"><span class="title">indShortSuccessor</span>(&amp;r-&gt;</span>last_key);</div><div class="line">      std::string handle_encoding;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>pending_handle.EncodeTo(&amp;handle_encoding);</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">index_block</span>.Add(r-&gt;</span>last_key, Slice(handle_encoding));</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>pending_index_entry = <span class="literal">false</span>;</div><div class="line">    &#125;<span class="comment">//写finish里flush函数刷新的数据块的偏移量和大小</span></div><div class="line">    W<span class="function"><span class="title">riteBlock</span>(&amp;r-&gt;</span>index_block, &amp;index_block_handle);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 写Footer</span></div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    Footer footer;</div><div class="line">    footer.set_metaindex_handle(metaindex_block_handle);</div><div class="line">    footer.set_index_handle(index_block_handle);</div><div class="line">    std::string footer_encoding;</div><div class="line">    footer.EncodeTo(&amp;footer_encoding);</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Append(footer_encoding);</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>status.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>offset += footer_encoding.size();<span class="comment">//更新偏移量</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="title">return</span> r-&gt;</span>status;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此，一个sst文件就建好了。最后还有一个函数，用于调用table_builder来创建sst文件，在builder.h/.cc里,这个等到compaction是再分析。</p>
<p>leveldb将immemtable compcation到sst0就这样分析结束，接下来，就是读sst文件，读总是比写更复杂。。。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> block </tag>
            
            <tag> filterpolicy </tag>
            
            <tag> tablebuilder </tag>
            
            <tag> blockbuilder </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之sst文件格式]]></title>
      <url>http://luodw.cc/2015/10/21/leveldb-09/</url>
      <content type="html"><![CDATA[<p>之前leveldb分析，讲解了leveldb两大组件memtable和log文件。这篇文章主要分析leveldb将内存数据写入磁盘文件，这些磁盘文件的格式，下一篇文章再分析源码。</p>
<p>leveldb插入数据时，首先将数据插入memtable，当memtable数据量达到一定大小时，当前memtable赋值给immemtable（也是memtable类型，但是这个是只读的），然后产生一个新的memtable用于后续的数据插入，immemtable将会把数据持久化到磁盘中。</p>
<p>磁盘文件是按分level的，immemtable首先将数据compaction到level0文件中，称为minor compaction。所以level0之间可能存在数据重叠。当某个level i文件达到一定数量时，选择一个文件与level i+1合并，称为major　compaction。可以再看下leveldb模型图：</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1360076329_9985.JPG" alt="leveldb模型图"></p>
<h1>sst文件格式</h1>
<p>leveldb将sst文件切割成一个一个块，每个块都是有数据＋类型＋CRC码，所以每个sst文件打开格式都是如下图所示：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--sst%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%801.jpg" alt="sst文件格式"></p>
<p>leveldb根据用途将这些block又分为数据块，元数据块，元数据块索引块，数据块索引块和文件尾。</p>
<ol>
<li>数据块主要就是存储数据的地方，immemtable中的键值对就是存储在数据块；</li>
<li>元数据块主要就是用于过滤，加快检索速度。</li>
<li>元数据块索引块，leveldb默认一个过滤器，所以元数据块索引块就一条记录；</li>
<li>数据块索引块，存储每一个数据块的偏移和大小，用于定位索引块。</li>
<li>文件尾，存储了数据块索引块和元数据块索引块，用于读取这两个块；
模型图如下：</li>
</ol>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--sst%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%802.jpg" alt="sst文件具体格式"></p>
<p>例如要读取某个data block，可以先读取出footer，然后读取出index block,由于index block中存储各个数据块的偏移和大小，就可以读取出这个data block。</p>
<p>接下来，将分别介绍各种块的格式。</p>
<h1>data block格式</h1>
<p>首先介绍的是数据块的格式，模型图如下：</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--Block.jpg" alt="data block格式"></p>
<p>数据块上部分主要存储的是一条条的记录，记录的格式如下：</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.jpg" alt="sst记录格式"></p>
<p>每一条记录有key共享长度＋key非共享长度＋value长度＋key非共享内容+value内容组成。leveldb为了节约存储，并不是存储每一条记录键值的完整值，而是两条记录如果有共享的部分，那么第二条记录可以和第一条共享共享的部分。例如第一条记录为hello world:11，第二条记录为hello you:9，那么第一条记录存储格式为:0+11+2+hello world+11，首先说明下，第一条记录共享长度为0，因为它没有上条记录，所以就没有共享。那么第二条记录存储格式为：6+3+1+you+9。</p>
<p>数据块Restart[i]表示一个共享记录的开始，这条记录和第一条记录一样，共享长度为０，Restart[i]存储就是这个共享记录的偏移。</p>
<p>数据块的最后一个部分为Restart点的个数，图中为3个。</p>
<h1>Meta block格式</h1>
<p>Meta block存储主要是过滤器的内容，先给出模型图如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--Filter.jpg" alt="Meta block格式"></p>
<p>Filter i存储的是这个每个数据块的键值，当要读取i数据块时，可以先到Filter i查找键值，如果没有找到，就没必要读取这个块了。因为filter比data块小，读取IO消耗更小。Filter i 偏移表示Filter i在Meta block的偏移量，偏移数组的位置就是第一个Filter 1 偏移的地址，最后g(base）用于决定数据量多大时，创建一个Filter。</p>
<h1>索引块的格式</h1>
<h2>Meta block格式</h2>
<p>Meta block格式相对简单，因为leveldb默认只有一个过滤器，当然用户可以自己定义过滤器。格式如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--Metaindex.jpg" alt="Meta block格式"></p>
<p>其中，key＝&quot;filter.&quot;+过滤器名字。后面两个字段表示Meta block块的在文件的偏移量和大小，方便读取。</p>
<h2>index block格式</h2>
<p>index block格式如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%951.jpg" alt="index block格式">
第一个字段存储第i块最大的键值，但是必须比第i+1个data block最小键值小。因为block数据是有序的（skiplist数据为有序），所以有最大键值，就可以知道这个块存储的数据的键值范围。第二个和第三个字段分别表示第i个data block的偏移量和大小，方便读取。</p>
<p>例如第i个data block最小键值为hello，最大键值为world；第i+1个data block最小键值为www，最大键值为yellow，所以第i个data block的键值字段为world。</p>
<h1>Footer格式</h1>
<p>sst文件最后一部分为Footer，格式如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--Footer.jpg" alt="Footer格式">
前两个存储Metaindex块的偏移量和大小以及Index块的偏移量和大小。也是为了后续读取方便。Padding填充部分，Magic number魔数，用于验证正确性。</p>
<p>sst文件格式大概就如上所示，下一篇文章，分下源码。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> sst </tag>
            
            <tag> block </tag>
            
            <tag> filterpolicy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之读写log文件]]></title>
      <url>http://luodw.cc/2015/10/18/leveldb-08/</url>
      <content type="html"><![CDATA[<p>这篇文章讲讲leveldb第二大组件log文件的读写。log文件也可以称为恢复日志。当leveldb插入数据时，先插入log日志文件中，接着再插入内存memtable中。这样以来，万一在使用过程中，突然断电，memtable还来不及把数据持久化到磁盘时，内存数据就不会丢失，这时就可以从log文件中恢复。redis也有类似文件。</p>
<p>log文件按块划分，默认每块为32768kb=32M。这么大有个好处，就是减少从磁盘读取数据的次数，减少磁盘IO。可以看如下图：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--log.jpg" alt="log文件模型">;
这个图中有3个block。然后每一条数据的格式：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_017.png" alt="log记录格式">;
log文件每一条记录由四个部分组成：</p>
<ol>
<li>CheckSum，即CRC验证码，占4个字节</li>
<li>记录长度，即数据部分的长度，2个字节</li>
<li>类型，这条记录的类型，后续讲解，1个字节</li>
<li>数据，就是这条记录的数据。</li>
</ol>
<p>关于记录的类型，平常使用中有4种：</p>
<ol>
<li>FULL，表示这是一条完整的记录</li>
<li>FIRST，表示这是一条记录的第一部分。</li>
<li>MIDDLE，表示这是一条记录的中间部分。</li>
<li>LAST，表示这是一条记录的最后一部分。</li>
</ol>
<h2>log日志Writer类</h2>
<p>log日志写相对简单，把数据按记录的格式封装好，再写入文件即可。成员变量有：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WritableFile* dest_;<span class="comment">//log日志文件封装类</span></div><div class="line"><span class="keyword">int</span> block_offset_;       <span class="comment">// 块内偏移量用于指定写地址</span></div></pre></td></tr></table></figure></p>
<p>添加记录函数：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">Status Writer::AddRecord(<span class="keyword">const</span> Slice&amp; slice) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();<span class="comment">//添加记录数据</span></div><div class="line">  <span class="keyword">size_t</span> left = slice.size();<span class="comment">//记录数据长度</span></div><div class="line"></div><div class="line">  Status s;</div><div class="line">  <span class="keyword">bool</span> begin = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;<span class="comment">//当前块剩余容量</span></div><div class="line">    assert(leftover &gt;= <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;<span class="comment">//如果剩余容量小于记录头长度（7kb）</span></div><div class="line">	<span class="comment">//用00填充</span></div><div class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</div><div class="line">        assert(kHeaderSize == <span class="number">7</span>);</div><div class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</div><div class="line">      &#125;</div><div class="line">      block_offset_ = <span class="number">0</span>;<span class="comment">//开始写一个新块，块内偏移就为0了。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</div><div class="line">    <span class="comment">//当前块除了记录头还有剩余空间</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<span class="comment">//可用的空间</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</div><div class="line">    <span class="comment">//判断当前块能否容下当前记录</span></div><div class="line">    RecordType type;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> end = (left == fragment_length);<span class="comment">//判断是否是记录的最后一部分</span></div><div class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</div><div class="line">      type = kFullType;<span class="comment">//完整块</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</div><div class="line">      type = kFirstType;<span class="comment">//记录第一块</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</div><div class="line">      type = kLastType;<span class="comment">//最后一块</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      type = kMiddleType;<span class="comment">//记录中间块</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);<span class="comment">//将fragment_length长度记录写入文件</span></div><div class="line">    ptr += fragment_length;<span class="comment">//指针向后移动frament_length个字节</span></div><div class="line">    left -= fragment_length;<span class="comment">//记录剩余长度</span></div><div class="line">    begin = <span class="literal">false</span>;</div><div class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Writer::EmitPhysicalRecord(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> n) &#123;</div><div class="line">  assert(n &lt;= <span class="number">0xffff</span>);  </div><div class="line">  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</div><div class="line"></div><div class="line">  <span class="comment">// 封装好记录头checksum7+length2+flag1</span></div><div class="line">  <span class="keyword">char</span> buf[kHeaderSize];</div><div class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &amp; <span class="number">0xff</span>);</div><div class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);</div><div class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</div><div class="line"></div><div class="line">  <span class="comment">// 用crc填充buf前四个字节</span></div><div class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</div><div class="line">  crc = crc32c::Mask(crc);                 <span class="comment">// Adjust for storage</span></div><div class="line">  EncodeFixed32(buf, crc);</div><div class="line"></div><div class="line">  <span class="comment">// 将记录头写入缓存</span></div><div class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    s = dest_-&gt;Append(Slice(ptr, n));<span class="comment">//将记录内容写入缓存</span></div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      s = dest_-&gt;Flush();<span class="comment">//将缓存的数据刷新进内核。</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  block_offset_ += kHeaderSize + n;<span class="comment">//更新块内偏移量</span></div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>log写文件分析就结束了。接下来分析log文件读取，读取相对较难。</p>
<h2>log文件Reader类</h2>
<p>我们先来看下Reader类的成员变量：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SequentialFile* <span class="keyword">const</span> file_;<span class="comment">//读取文件封装类</span></div><div class="line"> Reporter* <span class="keyword">const</span> reporter_;<span class="comment">//报告错误类</span></div><div class="line"> <span class="keyword">bool</span> <span class="keyword">const</span> checksum_;<span class="comment">//是否要进行CRC验证</span></div><div class="line"> <span class="keyword">char</span>* <span class="keyword">const</span> backing_store_;<span class="comment">//读取是存储备份</span></div><div class="line"> Slice buffer_;<span class="comment">//一次性读取一个块，而且用于定位lsat_record_offset_</span></div><div class="line"> <span class="keyword">bool</span> eof_;   <span class="comment">// 是否是最后一次读</span></div><div class="line"></div><div class="line"> <span class="comment">// 上条记录的偏移量</span></div><div class="line"> <span class="keyword">uint64_t</span> last_record_offset_;</div><div class="line"> <span class="comment">// 当前块结尾在log文件的偏移量</span></div><div class="line"> <span class="keyword">uint64_t</span> end_of_buffer_offset_;</div><div class="line"></div><div class="line"> <span class="comment">// 开始查找的起始地址</span></div><div class="line"> <span class="keyword">uint64_t</span> <span class="keyword">const</span> initial_offset_;</div></pre></td></tr></table></figure></p>
<p>读取文件函数：
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">bool Reader::ReadRecord(Slice* record, std::string* scratch) &#123;</div><div class="line">  <span class="keyword">if</span> (last_record_offset_ &lt; initial_offset_) &#123;</div><div class="line">    <span class="keyword">if</span> (!SkipToInitialBlock()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">  record-&gt;<span class="built_in">clear</span>();</div><div class="line">  bool in_fragmented_record = <span class="keyword">false</span>;<span class="comment">//上条记录是否为完整记录</span></div><div class="line">  uint64_t prospective_record_offset = <span class="number">0</span>;<span class="comment">//当前读取记录的偏移量</span></div><div class="line"></div><div class="line">  Slice fragment;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">//当前记录的起始地址</span></div><div class="line">    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.<span class="built_in">size</span>();</div><div class="line">    <span class="comment">//读取当前记录</span></div><div class="line">    <span class="keyword">const</span> unsigned <span class="built_in">int</span> record_type = ReadPhysicalRecord(&amp;fragment);</div><div class="line">    <span class="keyword">switch</span> (record_type) &#123;</div><div class="line">      <span class="keyword">case</span> kFullType:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          <span class="comment">// 完整记录，直接读取即可。</span></div><div class="line">          <span class="keyword">if</span> (scratch-&gt;empty()) &#123;</div><div class="line">            in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ReportCorruption(scratch-&gt;<span class="built_in">size</span>(), <span class="string">"partial record without end(1)"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        prospective_record_offset = physical_record_offset;</div><div class="line">        scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        *record = fragment;</div><div class="line">        last_record_offset_ = prospective_record_offset;<span class="comment">//对于下一条记录而言，这偏移量就是上条记录的偏移量，</span></div><div class="line"><span class="comment">//也就是这条记录的偏移量</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kFirstType:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          <span class="comment">// 如果是一条记录的第一部分</span></div><div class="line">          <span class="keyword">if</span> (scratch-&gt;empty()) &#123;</div><div class="line">            in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ReportCorruption(scratch-&gt;<span class="built_in">size</span>(), <span class="string">"partial record without end(2)"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        prospective_record_offset = physical_record_offset;</div><div class="line">        scratch-&gt;assign(fragment.data(), fragment.<span class="built_in">size</span>());<span class="comment">//把第一部分的数据添加进scratch</span></div><div class="line">        in_fragmented_record = <span class="keyword">true</span>;<span class="comment">//下一条记录就是属于当前记录的一部分</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kMiddleType:</div><div class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</div><div class="line">          ReportCorruption(fragment.<span class="built_in">size</span>(),</div><div class="line">                           <span class="string">"missing start of fragmented record(1)"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.data(), fragment.<span class="built_in">size</span>());<span class="comment">//将当前记录添加进scratch</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kLastType:</div><div class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</div><div class="line">          ReportCorruption(fragment.<span class="built_in">size</span>(),</div><div class="line">                           <span class="string">"missing start of fragmented record(2)"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.data(), fragment.<span class="built_in">size</span>());<span class="comment">//当前记录最后部分添加进scratch</span></div><div class="line">          *record = Slice(*scratch);<span class="comment">//给record赋值，即记录的内容</span></div><div class="line">          last_record_offset_ = prospective_record_offset;<span class="comment">//指向当前记录的起始地址</span></div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kEof:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          <span class="comment">// This can be caused by the writer dying immediately after</span></div><div class="line">          <span class="comment">// writing a physical record but before completing the next; don't</span></div><div class="line">          <span class="comment">// treat it as a corruption, just ignore the entire logical record.</span></div><div class="line">          scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kBadRecord:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          ReportCorruption(scratch-&gt;<span class="built_in">size</span>(), <span class="string">"error in middle of record"</span>);</div><div class="line">          in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">          scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">default</span>: &#123;</div><div class="line">        <span class="built_in">char</span> buf[<span class="number">40</span>];</div><div class="line">        snprintf(buf, sizeof(buf), <span class="string">"unknown record type %u"</span>, record_type);</div><div class="line">        ReportCorruption(</div><div class="line">            (fragment.<span class="built_in">size</span>() + (in_fragmented_record ? scratch-&gt;<span class="built_in">size</span>() : <span class="number">0</span>)),</div><div class="line">            buf);</div><div class="line">        in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">        scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从文件读取记录的函数如下:
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Reader::ReadPhysicalRecord(Slice* result) &#123;</div><div class="line">  <span class="built_in">while</span> (true) &#123;</div><div class="line">    <span class="built_in">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) &#123;</div><div class="line">      <span class="built_in">if</span> (!eof_) &#123;</div><div class="line">        <span class="comment">// 因为不是结尾，说明上次读取的是一整个块，现在这个块只剩下补充的0，跳过即可。</span></div><div class="line">        buffer_.<span class="built_in">clear</span>();</div><div class="line"> 	<span class="comment">//读取一个新块</span></div><div class="line">        Status status = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);</div><div class="line">        end_of_buffer_offset_ += buffer_.<span class="built_in">size</span>();<span class="comment">//缓存块偏移量指向这个块结尾。</span></div><div class="line">        <span class="built_in">if</span> (!status.ok()) &#123;</div><div class="line">          buffer_.<span class="built_in">clear</span>();</div><div class="line">          ReportDrop(kBlockSize, status);</div><div class="line">          eof_ = true;</div><div class="line">          <span class="built_in">return</span> kEof;<span class="comment">//如果读取失败，返回结尾</span></div><div class="line">        &#125; <span class="built_in">else</span> <span class="built_in">if</span> (buffer_.<span class="built_in">size</span>() &lt; kBlockSize) &#123;</div><div class="line">          eof_ = true;<span class="comment">//读取成功，但是读取记录小于头，实际大小应该是0，到达文件结尾</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">continue</span>;</div><div class="line">      &#125; <span class="built_in">else</span> &#123;</div><div class="line">        buffer_.<span class="built_in">clear</span>();</div><div class="line">        <span class="built_in">return</span> kEof;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 解析记录头</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* header = buffer_.data();</div><div class="line">    <span class="keyword">const</span> uint32_t a = <span class="keyword">static_cast</span>&lt;uint32_t&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</div><div class="line">    <span class="keyword">const</span> uint32_t b = <span class="keyword">static_cast</span>&lt;uint32_t&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> type = header[<span class="number">6</span>];<span class="comment">//记录类型</span></div><div class="line">    <span class="keyword">const</span> uint32_t length = a | (b &lt;&lt; <span class="number">8</span>);<span class="comment">//记录长度</span></div><div class="line">    <span class="built_in">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) &#123;</div><div class="line">      size_t drop_size = buffer_.<span class="built_in">size</span>();</div><div class="line">      buffer_.<span class="built_in">clear</span>();</div><div class="line">      <span class="built_in">if</span> (!eof_) &#123;</div><div class="line">        ReportCorruption(drop_size, <span class="string">"bad record length"</span>);</div><div class="line">        <span class="built_in">return</span> kBadRecord;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// If the end of the file has been reached without reading |length| bytes</span></div><div class="line">      <span class="comment">// of payload, assume the writer died in the middle of writing the record.</span></div><div class="line">      <span class="comment">// Don't report a corruption.</span></div><div class="line">      <span class="built_in">return</span> kEof;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">if</span> (type == kZeroType &amp;&amp; length == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// Skip zero length record without reporting any drops since</span></div><div class="line">      <span class="comment">// such records are produced by the mmap based writing code in</span></div><div class="line">      <span class="comment">// env_posix.cc that preallocates file regions.</span></div><div class="line">      buffer_.<span class="built_in">clear</span>();</div><div class="line">      <span class="built_in">return</span> kBadRecord;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Check crc</span></div><div class="line">    <span class="built_in">if</span> (checksum_) &#123;</div><div class="line">      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));</div><div class="line">      uint32_t actual_crc = crc32c::Value(header + <span class="number">6</span>, <span class="number">1</span> + length);</div><div class="line">      <span class="built_in">if</span> (actual_crc != expected_crc) &#123;</div><div class="line">        <span class="comment">// Drop the rest of the buffer since "length" itself may have</span></div><div class="line">        <span class="comment">// been corrupted and if we trust it, we could find some</span></div><div class="line">        <span class="comment">// fragment of a real log record that just happens to look</span></div><div class="line">        <span class="comment">// like a valid log record.</span></div><div class="line">        size_t drop_size = buffer_.<span class="built_in">size</span>();</div><div class="line">        buffer_.<span class="built_in">clear</span>();</div><div class="line">        ReportCorruption(drop_size, <span class="string">"checksum mismatch"</span>);</div><div class="line">        <span class="built_in">return</span> kBadRecord;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    buffer_.remove_prefix(kHeaderSize + length);<span class="comment">//buffer_是一块的长度，当读取结束一条记录时</span></div><div class="line"><span class="comment">//buffer_指向内容的指针向前移动KheaderSize+length，即下一条记录的起始地址</span></div><div class="line"></div><div class="line">    <span class="comment">// 跳过初始地址之前的记录</span></div><div class="line">    <span class="built_in">if</span> (end_of_buffer_offset_ - buffer_.<span class="built_in">size</span>() - kHeaderSize - length &lt;</div><div class="line">        initial_offset_) &#123;</div><div class="line">      result-&gt;<span class="built_in">clear</span>();</div><div class="line">      <span class="built_in">return</span> kBadRecord;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *result = Slice(header + kHeaderSize, length);<span class="comment">//获取记录内容部分</span></div><div class="line">    <span class="built_in">return</span> type;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读写log文件主要是要熟悉log文件的记录模型和文件的偏移量，这样当按格式，一个字节一个字节写入log文件是时，Reader类才能精确地一个一个字节从文件读出。我上两张图帮助理解：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--log1.jpg" alt="log文件读取记录">
这张图假设读取Record C的第一部分，因为在第一块内，所以end_of_buffer_offset_指向第一个块的最后一个字节，last_record_offset_指向Record B，buffer_的长度为B记录第一部分长度。当第一部分读取结束时，此时，因为第一块已经读取结束，所以从新从文件读取一个块存如buffer_，end_of_buffer_offset_指向第二个块的最后一个字节。因为buffer_.size()=一个块的容量，所以接下来读取C记录第二部分的偏移量为Block2的首地址。下图展示了读取RecordB之后图示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--log2.jpg" alt="log文件读取记录"></p>
<p>至此，log文件读取结束，也就是leveldb第二大组件。leveldb第三大组件为sst文件，接下来几篇文章讲解。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> log </tag>
            
            <tag> log::reader </tag>
            
            <tag> log::writer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之memtable]]></title>
      <url>http://luodw.cc/2015/10/17/leveldb-06/</url>
      <content type="html"><![CDATA[<p>在讲memtable之前，有必要先讲讲leveldb模型,当向leveldb写入数据时，首先将数据写入log文件，然后在写入memtable内存中。log文件主要是用在当断电时，内存中数据会丢失，数据可以从log文件中恢复。当memtable数据达到一定大小即（options属性write_buffer_size大小，默认4&lt;&lt;20)，会变为immemtable，然后log文件也生成一个新的log文件.immemtable数据将会被持久化到磁盘中。模型图如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1360076329_9985.JPG" alt="leveldb模型图">
取自博客“sparkliang的专栏”</p>
<p>所以memtable算是leveldb重要组件之一。在介绍memtable时，需要先简单介绍几个知识点。</p>
<h2>整型数据存储</h2>
<p>leveldb所有数据都是字符形式，即使是整型，也将被转换为字符型存储。这样的好处就是可以减少内存空间的使用。例如，假如有一个int型数据，小于128，存储为整型时，需要占用四个字节，存储为字符型时，只需要一个字节即可。leveldb有两种整型和字符型数据转换。一种是fixed，一种是varint。</p>
<h3>fixed转换</h3>
<p>fixed转换相对简单，就是将int的每一个字节存入字符数组中即可。举个简单例子：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;<span class="comment">//如果是小端，直接内存复制即可，不知道小端的，百度。</span></div><div class="line">    <span class="built_in">memcpy</span>(buf, &amp;value, <span class="keyword">sizeof</span>(value));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    buf[<span class="number">0</span>] = value &amp; <span class="number">0xff</span>;<span class="comment">//如果是大端，则需要一个一个字节的复制，先复制第一个字节</span></div><div class="line">    buf[<span class="number">1</span>] = (value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;<span class="comment">//复制第二个字节</span></div><div class="line">    buf[<span class="number">2</span>] = (value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;<span class="comment">//复制第三个字节</span></div><div class="line">    buf[<span class="number">3</span>] = (value &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;<span class="comment">//复制第四个字节</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">解码（从字符串到整型）也相对简单</div><div class="line"><span class="function"><span class="keyword">inline</span> uint32_t <span class="title">DecodeFixed32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</div><div class="line">    <span class="comment">// Load the raw bytes</span></div><div class="line">    <span class="keyword">uint32_t</span> result;</div><div class="line">    <span class="built_in">memcpy</span>(&amp;result, ptr, <span class="keyword">sizeof</span>(result));  <span class="comment">// 小端直接内存复制即可</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> ((<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">0</span>])))</div><div class="line">	<span class="comment">//取最小字节</span></div><div class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">1</span>])) &lt;&lt; <span class="number">8</span>)</div><div class="line">	<span class="comment">//取第二字节，并且向左移动8个字节，作为整型的第二个字节，下面也是如此</span></div><div class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">2</span>])) &lt;&lt; <span class="number">16</span>)</div><div class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">3</span>])) &lt;&lt; <span class="number">24</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>固定长度编码还有64位类型，在文件coding.cc中</p>
<h3>varint</h3>
<p>这种转型将一个字节分成两部分，前7个字节存储数据，第8个字节表示高位是否还有数据。简单例子：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</div><div class="line">  <span class="comment">// Operate on characters as unsigneds</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;<span class="comment">//128二进制为1000 0000</span></div><div class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) &#123;</div><div class="line">    *(ptr++) = v;<span class="comment">//如果v小于128，则将v低7位复制给ptr，ptr第8位为0，表示高位没数据，ptr+1</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;<span class="comment">//v的低7位复制为ptr的低7位，ptr第8位为1，表示高位还有数据。</span></div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">7</span>;<span class="comment">////再把v的高7位复制为（ptr+1)的低7位，(ptr+1)第8位为0，表示高位没有数据了。下面分析也是一样。</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">21</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">14</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">28</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">21</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">21</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">28</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</div><div class="line">&#125;</div><div class="line"></div><div class="line">解析主要代码如下：</div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p,</span></span></div><div class="line">                                   <span class="keyword">const</span> <span class="keyword">char</span>* limit,</div><div class="line">                                   <span class="keyword">uint32_t</span>* value) &#123;</div><div class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</div><div class="line">    <span class="keyword">uint32_t</span> byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));<span class="comment">//取出p指向的字节</span></div><div class="line">    p++;<span class="comment">//指向下一个字节</span></div><div class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</div><div class="line">      <span class="comment">// 高位还有数据，继续循环</span></div><div class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);<span class="comment">//每7位移动一次，分别向result7位赋值。</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      result |= (byte &lt;&lt; shift);<span class="comment">//最后七位，最高为一定为0.</span></div><div class="line">      *value = result;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>解析varint的代码，思想主要就是取出字符数组的每一个字节，然后取出低7位的值，赋值给result的低7位。如果有第二个字节，则取出第二个字节得到低7位，向左移动7位，然后赋给result的8~14位。后续也是如此。</p>
<h2>leveldb键的形式</h2>
<p>第一次看leveldb源码，会被Leveldb的多种key给弄混了。
首先是internalkey，格式为：
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">|user key|sequence number|type|</div><div class="line">internal key size=key_size+<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>ParsedInternalKey:
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|user key|sequence number|type|</div></pre></td></tr></table></figure></p>
<p>skiplist内部存储的key，格式为:
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">VarInt</span>(interbal key size)len | internal key | <span class="type">VarInt</span>(value) len | value |</div></pre></td></tr></table></figure></p>
<p>membtable传入的是LookupKey：
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">|internal key size|internalkey|</div></pre></td></tr></table></figure></p>
<p>LookupKey定义如下：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">LookupKey</span> &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Initialize *this for looking up user_key at a snapshot with</span></div><div class="line">  <span class="comment">// the specified sequence number.</span></div><div class="line">  LookupKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber sequence);</div><div class="line"></div><div class="line">  ~LookupKey();</div><div class="line"></div><div class="line">  <span class="comment">// Return a key suitable for lookup in a MemTable.</span></div><div class="line">  <span class="function">Slice <span class="title">memtable_key</span>(<span class="params"></span>) <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(start_, end_ - start_); &#125;</div><div class="line">  <span class="comment">//memtable_key本质上和LookupKey一样。</span></div><div class="line">  <span class="comment">// Return an internal key (suitable for passing to an internal iterator)</span></div><div class="line">  <span class="function">Slice <span class="title">internal_key</span>(<span class="params"></span>) <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the user key</span></div><div class="line">  <span class="function">Slice <span class="title">user_key</span>(<span class="params"></span>) <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// We construct a char array of the form:</span></div><div class="line">  <span class="comment">//    klength  varint32               &lt;-- start_</span></div><div class="line">  <span class="comment">//    userkey  char[klength]          &lt;-- kstart_</span></div><div class="line">  <span class="comment">//    tag      uint64</span></div><div class="line">  <span class="comment">//                                    &lt;-- end_</span></div><div class="line">  <span class="comment">// The array is a suitable MemTable key.</span></div><div class="line">  <span class="comment">// The suffix starting with "userkey" can be used as an InternalKey.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* start_;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* kstart_;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* end_;</div><div class="line">  <span class="keyword">char</span> space_[<span class="number">200</span>];      <span class="comment">// Avoid allocation for short keys</span></div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  LookupKey(<span class="keyword">const</span> LookupKey&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> LookupKey&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所以总结下如下:</p>
<ol>
<li>最短的为internalkey，就是userkey+sequence+type组成</li>
<li>接下来是lookupkey,由internalkey的长度+internalkey组成</li>
<li>skiplist中存储的键为lookupkey+value的长度+value。</li>
</ol>
<h2>memtable</h2>
<p>memtable主要功能就是为上层调用插入数据提供接口，所以memtable主要有三个公有接口，Get,Add,NewIterator，分别是获取某个键值，添加某个键值，以及获取迭代memtable的迭代器。私有成员主要有四个：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</div><div class="line"><span class="keyword">struct</span> KeyComparator &#123;</div><div class="line">   <span class="keyword">const</span> InternalKeyComparator comparator;</div><div class="line">   <span class="keyword">explicit</span> KeyComparator(<span class="keyword">const</span> InternalKeyComparator&amp; c) : comparator(c) &#123; &#125;</div><div class="line">   <span class="keyword">int</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b) <span class="keyword">const</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">KeyComparator comparator_;<span class="comment">//比较器</span></div><div class="line"> <span class="keyword">int</span> refs_;<span class="comment">//饮用次数</span></div><div class="line"> Arena arena_;<span class="comment">//内存池</span></div><div class="line"> Table table_;<span class="comment">//skiplist</span></div></pre></td></tr></table></figure></p>
<p>memtable构造函数：
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MemTable::MemTable<span class="comment">(const InternalKeyComparator&amp; cmp)</span></div><div class="line">    : comparator_<span class="comment">(cmp)</span>,<span class="comment">//InternalkeyComparator来初始化comoparator_</span></div><div class="line">      refs_<span class="comment">(0)</span>,<span class="comment">//引用次数为0</span></div><div class="line">      table_<span class="comment">(comparator_, &amp;arena_)</span> &#123;<span class="comment">//跳跃链表初始化</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>memtable插入一条记录：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MemTable::Add(SequenceNumber s, ValueType type,</div><div class="line">                   <span class="keyword">const</span> Slice&amp; key,</div><div class="line">                   <span class="keyword">const</span> Slice&amp; value) &#123;</div><div class="line">  <span class="comment">// Format of an entry is concatenation of:</span></div><div class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></div><div class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></div><div class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></div><div class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></div><div class="line">  <span class="keyword">size_t</span> key_size = key.size();<span class="comment">////键值长度</span></div><div class="line">  <span class="keyword">size_t</span> val_size = value.size();<span class="comment">//值的长度</span></div><div class="line">  <span class="keyword">size_t</span> internal_key_size = key_size + <span class="number">8</span>;<span class="comment">//InternalKey的长度</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len =</div><div class="line">      VarintLength(internal_key_size) + internal_key_size +</div><div class="line">      VarintLength(val_size) + val_size;<span class="comment">//skiplist节点键的长度</span></div><div class="line">  <span class="keyword">char</span>* buf = arena_.Allocate(encoded_len);<span class="comment">//分配键值内存</span></div><div class="line">  <span class="keyword">char</span>* p = EncodeVarint32(buf, internal_key_size);<span class="comment">//键值长度存入buf中</span></div><div class="line">  <span class="built_in">memcpy</span>(p, key.data(), key_size);<span class="comment">//键的内容存入buf</span></div><div class="line">  p += key_size;<span class="comment">//指针向后移动key_size个字节</span></div><div class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);<span class="comment">//序列号和类型</span></div><div class="line">  p += <span class="number">8</span>;</div><div class="line">  p = EncodeVarint32(p, val_size);<span class="comment">//值的长度</span></div><div class="line">  <span class="built_in">memcpy</span>(p, value.data(), val_size);<span class="comment">//值的内容</span></div><div class="line">  assert((p + val_size) - buf == encoded_len);</div><div class="line">  table_.Insert(buf);<span class="comment">//插入到skiplist中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>memtable插入操作很简单的，只要按协议封装好键值即可，最后插入skiplist中。</p>
<p>memtable读取操作：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> MemTable::Get(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s) &#123;</div><div class="line">  Slice memkey = key.memtable_key();<span class="comment">//取出memtable_key</span></div><div class="line">  Table::<span class="function">Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;获得skiplist的迭代器</div><div class="line">  iter.Seek(memkey.data());<span class="comment">//迭代器查找</span></div><div class="line">  <span class="keyword">if</span> (iter.Valid()) &#123;</div><div class="line">    <span class="comment">// entry format is:</span></div><div class="line">    <span class="comment">//    klength  varint32</span></div><div class="line">    <span class="comment">//    userkey  char[klength]</span></div><div class="line">    <span class="comment">//    tag      uint64</span></div><div class="line">    <span class="comment">//    vlength  varint32</span></div><div class="line">    <span class="comment">//    value    char[vlength]</span></div><div class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></div><div class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></div><div class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.key();</div><div class="line">    <span class="keyword">uint32_t</span> key_length;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = GetVarint32Ptr(entry, entry+<span class="number">5</span>, &amp;key_length);</div><div class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</div><div class="line">            Slice(key_ptr, key_length - <span class="number">8</span>),</div><div class="line">            key.user_key()) == <span class="number">0</span>) &#123;<span class="comment">//如果找到了key值</span></div><div class="line">      <span class="comment">// Correct user key</span></div><div class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);<span class="comment">//取出标签，判断类型</span></div><div class="line">      <span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</div><div class="line">        <span class="keyword">case</span> kTypeValue: &#123;<span class="comment">//是正常值的类型</span></div><div class="line">          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</div><div class="line">          value-&gt;assign(v.data(), v.size());</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> kTypeDeletion:<span class="comment">//要删除的类型</span></div><div class="line">          *s = Status::NotFound(Slice());</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>memtable迭代器定义如下：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MemTableIterator: <span class="keyword">public</span> Iterator &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> MemTableIterator(MemTable::Table* table) : iter_(table) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">bool</span> Valid() <span class="keyword">const</span> &#123; <span class="built_in">return</span> iter_.Valid(); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Seek(<span class="keyword">const</span> Slice&amp; k) &#123; iter_.Seek(EncodeKey(&amp;tmp_, k)); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> SeekToFirst() &#123; iter_.SeekToFirst(); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> SeekToLast() &#123; iter_.SeekToLast(); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Next() &#123; iter_.Next(); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Prev() &#123; iter_.Prev(); &#125;</div><div class="line">  <span class="keyword">virtual</span> Slice key() <span class="keyword">const</span> &#123; <span class="built_in">return</span> GetLengthPrefixedSlice(iter_.key()); &#125;</div><div class="line">  <span class="keyword">virtual</span> Slice value() <span class="keyword">const</span> &#123;</div><div class="line">    Slice key_slice = GetLengthPrefixedSlice(iter_.key());</div><div class="line">    <span class="built_in">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.<span class="built_in">size</span>());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> Status status() <span class="keyword">const</span> &#123; <span class="built_in">return</span> Status::OK(); &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  MemTable::Table::Iterator iter_;</div><div class="line">  std::<span class="keyword">string</span> tmp_;       <span class="comment">// For passing to EncodeKey</span></div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  MemTableIterator(<span class="keyword">const</span> MemTableIterator&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTableIterator&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>memtable迭代器本质是调用skiplist的迭代器，代理模式。leveldb为了接口的简单，一层一层的封装，memtable属于内存部分的封装，接来文章，将关于log文件的封装。</p>
<p>返回memtable迭代器;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Iterator* MemTable::NewIterator() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MemTableIterator(&amp;table_);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至此memtable分析结束。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> memtable </tag>
            
            <tag> varint </tag>
            
            <tag> lookupkey </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之Skiplist]]></title>
      <url>http://luodw.cc/2015/10/16/leveldb-05/</url>
      <content type="html"><![CDATA[<p>leveldb在内存中存储数据的区域称为memtable，这个memtable底层是用跳跃链表skiplist来实现的。redis也采用跳跃链表来实现有序链表。</p>
<p>skiplist的效率可以和平衡树媲美，平均O(logN)，最坏O(N)的查询效率，但是用skiplist实现比平衡树实现简单，所以很多程序用跳跃链表来代替平衡树。</p>
<p>leveldb是支持多线程操作的，但是skiplist并没有使用linux下锁，信号量来实现同步控制，据说是因为锁机制导致某个线程占有资源，其他线程阻塞的情况，导致系统资源利用率降低。所以leveldb采用的是<strong>内存屏障</strong>来实现同步机制。有时间要好好研究下内存屏障的知识，挺有比格的。</p>
<p>先看下skiplist链表的模型图：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodw--skiplist.jpg" alt="Skiplist模型图"></p>
<h2>内存屏障</h2>
<p>leveldb实现的skiplist看起来有点复杂，主要是用到泛型类以及内存屏障。我们先来看下内存屏障AtomicPointer类，即原子类操作：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> AtomicPointer &#123;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">void</span>* rep_;<span class="comment">//原子指针</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  AtomicPointer() &#123; &#125;</div><div class="line">  <span class="keyword">explicit</span> AtomicPointer(<span class="keyword">void</span>* p) : rep_(p) &#123;&#125;</div><div class="line">  <span class="keyword">inline</span> <span class="keyword">void</span>* NoBarrier_Load() <span class="keyword">const</span> &#123; <span class="built_in">return</span> rep_; &#125;<span class="comment">//无需同步获取数据</span></div><div class="line">  <span class="keyword">inline</span> <span class="keyword">void</span> NoBarrier_Store(<span class="keyword">void</span>* v) &#123; rep_ = v; &#125;<span class="comment">//无需同步设置数据</span></div><div class="line">  <span class="keyword">inline</span> <span class="keyword">void</span>* Acquire_Load() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">void</span>* result = rep_;</div><div class="line">    MemoryBarrier();<span class="comment">//先设置result的值，然后检查rep_是否有变化，如果有变化，</span></div><div class="line"><span class="comment">//则result重新从内存中获取数据。可以保持数据最新</span></div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">inline</span> <span class="keyword">void</span> Release_Store(<span class="keyword">void</span>* v) &#123;</div><div class="line">    MemoryBarrier();<span class="comment">//先更新rep_的值，然后再设置为v.</span></div><div class="line">    rep_ = v;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> MemoryBarrier() &#123;</div><div class="line">  <span class="comment">// See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on</span></div><div class="line">  <span class="comment">// this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.</span></div><div class="line">  __asm__ __volatile__(<span class="string">""</span> : : : <span class="string">"memory"</span>);<span class="comment">//这句话表示当内存的中的数据被修改时，</span></div><div class="line"><span class="comment">//其他处理器上的寄存器和cache上这个变量的副本都将失效，必须从内存中重新获取。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>内存屏障主要用处就是保证内存数据和处理器寄存器和缓存数据一致性。因为当某个处理器上改变某个变量x时，那么其他处理器上的x的副本都必须失效，否则将会读取错误值。</p>
<h2>skiplist节点</h2>
<p>接下来，我们看下skiplist节点源代码：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">struct</span> SkipList&lt;Key,Comparator&gt;::Node &#123;</div><div class="line">  <span class="keyword">explicit</span> Node(<span class="keyword">const</span> Key&amp; k) : key(k) &#123; &#125;</div><div class="line"></div><div class="line">  Key <span class="keyword">const</span> key;</div><div class="line"></div><div class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></div><div class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></div><div class="line">  Node* Next(<span class="keyword">int</span> n) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    <span class="comment">// Use an 'acquire load' so that we observe a fully initialized</span></div><div class="line">    <span class="comment">// version of the returned Node.</span></div><div class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].Acquire_Load());</div><div class="line">  &#125;<span class="comment">//获取当前节点的下一个节点</span></div><div class="line"></div><div class="line">  <span class="keyword">void</span> SetNext(<span class="keyword">int</span> n, Node* x) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    <span class="comment">// Use a 'release store' so that anybody who reads through this</span></div><div class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></div><div class="line">    next_[n].Release_Store(x);<span class="comment">//设置当前节点的下个节点。</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></div><div class="line">  Node* NoBarrier_Next(<span class="keyword">int</span> n) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].NoBarrier_Load());</div><div class="line">  &#125;<span class="comment">//无需内存屏障的查找下一个节点</span></div><div class="line"></div><div class="line">  <span class="keyword">void</span> NoBarrier_SetNext(<span class="keyword">int</span> n, Node* x) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    next_[n].NoBarrier_Store(x);</div><div class="line">  &#125;无需内存屏障的设置下一个节点</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></div><div class="line">  port::AtomicPointer next_[<span class="number">1</span>];<span class="comment">//节点的层数。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是skiplist节点类，可以查找下一个节点，可以设置下一个节点。nect_[1]是一个很优秀的设计。只定义数组第一个节点，然后分配内存时，分配（高度-1）个数组类型的内存。其实就是动态分配内存。否则一开始用数组分配大数组，易造成内存浪费。</p>
<h2>skiplist实现</h2>
<p>skiplist成员变量有：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> kMaxHeight = <span class="number">12</span> &#125;;<span class="comment">//定义skiplist链表最高节点</span></div><div class="line"><span class="comment">// Immutable after construction</span></div><div class="line">Comparator <span class="keyword">const</span> compare_;<span class="comment">//比较器有最顶层的options通过一层一层传递下来，用于///链表排序</span></div><div class="line">Arena* <span class="keyword">const</span> arena_;    <span class="comment">// leveldb内存池，从memtable传过来</span></div><div class="line"></div><div class="line">Node* <span class="keyword">const</span> head_;<span class="comment">//skiplist头节点</span></div><div class="line"></div><div class="line"><span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></div><div class="line"><span class="comment">// values are ok.</span></div><div class="line">port::AtomicPointer max_height_;   <span class="comment">// skiplist目前的最高高度</span></div><div class="line">  <span class="comment">// Read/written only by Insert().</span></div><div class="line">Random rnd_;<span class="comment">//随机类，用于随机化一个节点高度</span></div></pre></td></tr></table></figure></p>
<p>enum{kMaxHeight = 12}也是很优秀设计，《efficetive C++》有一个章节有讲到尽量不要使用宏定义定义常量，取代的办法是const常量和enum类型。</p>
<p>skiplist构造函数如下;
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line">SkipList&lt;Key,Comparator&gt;::SkipList(Comparator cmp, Arena* arena)</div><div class="line">    : compare_(cmp),</div><div class="line">      arena_(arena),</div><div class="line">      head_(NewNode(<span class="number">0</span> <span class="comment">/* any key will do */</span>, kMaxHeight)),</div><div class="line">      max_height_(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="number">1</span>)),</div><div class="line">      rnd_(<span class="number">0xdeadbeef</span>) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kMaxHeight; i++) &#123;</div><div class="line">    head_-&gt;SetNext(i, <span class="literal">NULL</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cmp和arena_都是调用者传进来，head_头指针key初始化为0,高度为链表高度上限。max_height_初始化为1.for循环将头节点的前一个节点都设为NULL。</p>
<p>分配一个新节点的源码如下：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">typename</span> SkipList&lt;Key,Comparator&gt;::Node*</div><div class="line">SkipList&lt;Key,Comparator&gt;::NewNode(<span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> <span class="built_in">height</span>) &#123;</div><div class="line">  <span class="keyword">char</span>* mem = arena_-&gt;AllocateAligned(</div><div class="line">      <span class="keyword">sizeof</span>(Node) + <span class="keyword">sizeof</span>(port::AtomicPointer) * (<span class="built_in">height</span> - <span class="number">1</span>));<span class="comment">//从内存池里面分配</span></div><div class="line"><span class="comment">//足够的内存，用于存储新节点。</span></div><div class="line">  <span class="built_in">return</span> <span class="keyword">new</span> (mem) Node(key);<span class="comment">//返回这个节点。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接来看下skiplist插入一个新节点的代码，思想是，在插入高度为height的节点时，首先要找到这个节点height个前节点，然后插入就和普通的链表插入一样。
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Insert(<span class="keyword">const</span> Key&amp; key) &#123;</div><div class="line">  Node* prev[kMaxHeight];<span class="comment">//kMaxHeight个前节点，因为高度还未知，所以先设为最大值</span></div><div class="line">  Node* x = FindGreaterOrEqual(key, prev);<span class="comment">//查找key值节点前GetMaxHeight()个前节点。</span></div><div class="line"></div><div class="line">  assert(x == NULL || !Equal(key, x-&gt;key));</div><div class="line"></div><div class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = RandomHeight();<span class="comment">//随机化一个节点高度</span></div><div class="line">  <span class="built_in">if</span> (<span class="built_in">height</span> &gt; GetMaxHeight()) &#123;<span class="comment">//如果当前节点的高度大于最高节点，则高出部分的的前节</span></div><div class="line"><span class="comment">//点都是头节点。</span></div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; <span class="built_in">height</span>; i++) &#123;</div><div class="line">      prev[i] = head_;</div><div class="line">    &#125;</div><div class="line">    max_height_.NoBarrier_Store(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="built_in">height</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  x = NewNode(key, <span class="built_in">height</span>);<span class="comment">//新建节点</span></div><div class="line">  <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>; i++) &#123;</div><div class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i))<span class="comment">//设立当前节点的后节点;</span></div><div class="line">    prev[i]-&gt;SetNext(i, x);<span class="comment">//设立当前节点的前节点。</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入节点逻辑其实和单链表类似，只是查找前后节点麻烦点，需要找到不止一个。接下来是判断链表是否含有某个key值的接口：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">bool</span> SkipList&lt;Key,Comparator&gt;::Contains(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</div><div class="line">  Node* x = FindGreaterOrEqual(key, <span class="literal">NULL</span>);<span class="comment">//返回第0层上个节点</span></div><div class="line">  <span class="keyword">if</span> (x != <span class="literal">NULL</span> &amp;&amp; Equal(key, x-&gt;key)) &#123;<span class="comment">//如果x不为NULL,且key值与x的key值相等，则说明key在链表中。</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>链表是没有删除接口的，但是有删除功能。因为当我们插入数据时，key的形式为key:value，当删除数据时，则插入key:deleted类似删除的标记，等到Compaction再删除。</p>
<h2>skiplist迭代器</h2>
<p>leveldb用的最多的就是迭代器了，最后我们来分析链表迭代器，分析迭代器，为看STL源码也积累基础。声明如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Iterator &#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></div><div class="line">    <span class="comment">// The returned iterator is not valid.</span></div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Returns the key at the current position.</span></div><div class="line">    <span class="comment">// REQUIRES: Valid()</span></div><div class="line">    <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Advances to the next position.</span></div><div class="line">    <span class="comment">// REQUIRES: Valid()</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Advances to the previous position.</span></div><div class="line">    <span class="comment">// REQUIRES: Valid()</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Position at the first entry in list.</span></div><div class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Position at the last entry in list.</span></div><div class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> SkipList* list_;<span class="comment">//迭代器迭代的跳跃链表</span></div><div class="line">    Node* node_;<span class="comment">//指向当前的节点</span></div><div class="line">    <span class="comment">// Intentionally copyable</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>迭代器的成员变量有，需要遍历的链表，以及指向当前节点的节点指针。</p>
<p>链表迭代器构造函数如下
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> SkipList&lt;Key,Comparator&gt;::Iterator::Iterator(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>) &#123;</div><div class="line">  list_ = <span class="built_in">list</span>;</div><div class="line">  node_ = <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>迭代器具体实现代码如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> SkipList&lt;Key,Comparator&gt;::Iterator::Valid() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> node_ != <span class="literal">NULL</span>;</div><div class="line">&#125;<span class="comment">//判断迭代器当前节点是否有效</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Key&amp; SkipList&lt;Key,Comparator&gt;::Iterator::key() <span class="keyword">const</span> &#123;</div><div class="line">  assert(Valid());</div><div class="line">  <span class="keyword">return</span> node_-&gt;key;</div><div class="line">&#125;<span class="comment">//返回当前节点的key值</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Iterator::Next() &#123;</div><div class="line">  assert(Valid());</div><div class="line">  node_ = node_-&gt;Next(<span class="number">0</span>);</div><div class="line">&#125;<span class="comment">//跳跃链表的第0层就是单链表，所以可以直接指向下一个节点</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Iterator::Prev() &#123;</div><div class="line">  <span class="comment">// Instead of using explicit "prev" links, we just search for the</span></div><div class="line">  <span class="comment">// last node that falls before key.</span></div><div class="line">  assert(Valid());</div><div class="line">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</div><div class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</div><div class="line">    node_ = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">//查找当前节点的上一个节点。</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Iterator::Seek(<span class="keyword">const</span> Key&amp; target) &#123;</div><div class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, <span class="literal">NULL</span>);</div><div class="line">&#125;<span class="comment">//查找某个特定的key值的节点。</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Iterator::SeekToFirst() &#123;</div><div class="line">  node_ = list_-&gt;head_-&gt;Next(<span class="number">0</span>);</div><div class="line">&#125;<span class="comment">//查找第一个节点</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">class</span> Comparator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Iterator::SeekToLast() &#123;</div><div class="line">  node_ = list_-&gt;FindLast();</div><div class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</div><div class="line">    node_ = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">//最后一个节点</span></div></pre></td></tr></table></figure></p>
<p>还有一些函数我并没有列出，都是这些主函数的辅助函数，很简单，都能看懂。至此，跳跃链表就这样分析结束，下一篇，介绍memtable。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> skiplist </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之内存池Arena]]></title>
      <url>http://luodw.cc/2015/10/15/leveldb-04/</url>
      <content type="html"><![CDATA[<p>这篇博客主要讲解下leveldb内存池，内存池很多地方都有用到，像linux内核也有个内存池。内存池的存在主要就是减少malloc或者new调用的次数，较少内存分配所带来的系统开销。</p>
<p>Arena类采用vector来存储每次分配内存的指针，每一次分配的内存，我们称为一个块block。block默认大小为4096kb。我们可以先看下Arena的模型：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/luodwarena.jpg" alt="leveldb内存池Arena模型"></p>
<p>我们来看看源码：
首先看下这个类的几个成员变量：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* alloc_ptr_;<span class="comment">//内存的偏移量指针，即指向未使用内存的首地址</span></div><div class="line"><span class="keyword">size_t</span> alloc_bytes_remaining_;<span class="comment">//还剩下的内存数</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; blocks_;<span class="comment">//存储每一次分配的内存指针</span></div><div class="line"><span class="keyword">size_t</span> blocks_memory_;<span class="comment">//到目前为止分配的总内存。</span></div></pre></td></tr></table></figure></p>
<p>构造函数和析构函数：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Arena::Arena() &#123;</div><div class="line">  blocks_memory_ = <span class="number">0</span>;</div><div class="line">  alloc_ptr_ = <span class="literal">NULL</span>;  <span class="comment">// First allocation will allocate a block</span></div><div class="line">  alloc_bytes_remaining_ = <span class="number">0</span>;</div><div class="line">&#125;<span class="comment">//构造函数初始化总总分配的内存为0，指针偏移量为NULL,剩余内存为0。</span></div><div class="line"><span class="built_in">vector</span>会调用默认构造函数初始化。</div><div class="line"></div><div class="line">Arena::~Arena() &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; blocks_.size(); i++) &#123;</div><div class="line">    <span class="keyword">delete</span>[] blocks_[i];</div><div class="line">  &#125;</div><div class="line">&#125;<span class="comment">//Arena析构时，只需要把所有的指针指向的内存都delete就可以了。</span></div></pre></td></tr></table></figure></p>
<p>都说谷歌的C++编程风格是最优美的。leveldb里面的每个类的构造函数都直接初始化所有的属性，这样就不会导致使用为初始化的变量，而且代码很清晰，知道哪些属性被初始化为何值。</p>
<p>接下来分析下Arena内存分配的主要函数。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span></span>;</div></pre></td></tr></table></figure></p>
<p>Arena对外提供的接口是public里的函数，但是该函数会调用private里的两个函数.我分析内存分配策略。当要分配内存的时候：</p>
<ol>
<li>如果需求的内存小于剩余的内存，那么直接在剩余的内存分配就可以了；</li>
<li>如果需求的内存大于剩余的内存，而且大于4096/4，则给这内存单独分配一块bytes（函数参数）大小的内存。</li>
<li>如果需求的内存大于剩余的内存，而且小于4096/4，则重新分配一个内存块，默认大小4096，用于存储数据。</li>
</ol>
<p>针对第二点，按源码的注释是说避浪费太多的剩余空间。我的理解是，如果剩余的内存为1500kb，那么假设有一个内存需求是500kb，一个内存需求是1500kb,则第一个需求可以使用三次才导致进行一次重新内存分配，而第二个只能使用一次就要进行一次重新内存分配。所以leveldb第二条的用意主要还是减少内存分配的次数。</p>
<p>源码如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> <span class="keyword">char</span>* Arena::Allocate(<span class="keyword">size_t</span> bytes) &#123;</div><div class="line">  <span class="comment">// The semantics of what to return are a bit messy if we allow</span></div><div class="line">  <span class="comment">// 0-byte allocations, so we disallow them here (we don't need</span></div><div class="line">  <span class="comment">// them for our internal use).</span></div><div class="line">  assert(bytes &gt; <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;<span class="comment">//需要的内存小于剩余的内存，直接分配，</span></div><div class="line"><span class="comment">//移动指针偏移量，减少剩余内存，返回刚分配内存的首位置</span></div><div class="line">    <span class="keyword">char</span>* result = alloc_ptr_;<span class="comment">//先保存指针偏移量，用于返回</span></div><div class="line">    alloc_ptr_ += bytes;<span class="comment">//指针偏移量向上移动bytes个字节</span></div><div class="line">    alloc_bytes_remaining_ -= bytes;<span class="comment">//剩余内存减少bytes个字节</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> AllocateFallback(bytes);<span class="comment">//当需求内存大于剩余内存时</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">char</span>* Arena::AllocateFallback(<span class="keyword">size_t</span> bytes) &#123;</div><div class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;<span class="comment">//需求内存大于1024kb时</span></div><div class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></div><div class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></div><div class="line">    <span class="keyword">char</span>* result = AllocateNewBlock(bytes);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// We waste the remaining space in the current block.</span></div><div class="line">  alloc_ptr_ = AllocateNewBlock(kBlockSize);<span class="comment">//需求内存大于剩余内存，且小于1024时。</span></div><div class="line">  alloc_bytes_remaining_ = kBlockSize;</div><div class="line"></div><div class="line">  <span class="keyword">char</span>* result = alloc_ptr_;</div><div class="line">  alloc_ptr_ += bytes;</div><div class="line">  alloc_bytes_remaining_ -= bytes;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">char</span>* Arena::AllocateNewBlock(<span class="keyword">size_t</span> block_bytes) &#123;</div><div class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];<span class="comment">//分配内存</span></div><div class="line">  blocks_memory_ += block_bytes;<span class="comment">//总的内存加上刚分配的内存</span></div><div class="line">  blocks_.push_back(result);<span class="comment">//添加进内存指针数组</span></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>arena还提供了字节对齐内存分配，一般情况是8个字节对齐分配，即内存地址后三位必须为0.我们来看下源码，挺多学问的。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* Arena::AllocateAligned(<span class="keyword">size_t</span> bytes) &#123;</div><div class="line">  <span class="comment">//用于判断对齐的大小，我64位电脑sizeof(void*)=8，不大于8，所以对齐大小为8。</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> align = (<span class="keyword">sizeof</span>(<span class="keyword">void</span>*) &gt; <span class="number">8</span>) ? <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) : <span class="number">8</span>;</div><div class="line">  <span class="comment">//用于判断align是否为2的次幂，内存对齐肯定是2的次幂。</span></div><div class="line">  assert((align &amp; (align<span class="number">-1</span>)) == <span class="number">0</span>);   </div><div class="line">  <span class="comment">//判断当前的模式，align-1后三位为1，其他都为0，所以指针与align-1做与运算，</span></div><div class="line"><span class="comment">//其实就是指针与align求余运算。例如如果地址值为9，9&amp;7，则最后一位为1，9%8=1。</span></div><div class="line">  <span class="keyword">size_t</span> current_mod = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align<span class="number">-1</span>);</div><div class="line">  <span class="comment">//根据当前的模式，算出需要添加的字节数</span></div><div class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod);</div><div class="line">  <span class="keyword">size_t</span> needed = bytes + slop;<span class="comment">//原来需求的字节大小，加上为了对齐补充的字节大小</span></div><div class="line">  <span class="keyword">char</span>* result;</div><div class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</div><div class="line">    result = alloc_ptr_ + slop;</div><div class="line">    alloc_ptr_ += needed;</div><div class="line">    alloc_bytes_remaining_ -= needed;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// AllocateFallback always returned aligned memory</span></div><div class="line">    result = AllocateFallback(bytes);</div><div class="line">  &#125;</div><div class="line">  assert((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (align<span class="number">-1</span>)) == <span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里边有一个uintptr_t类型，定义在&lt;stddef.h&gt;头文件里，是无符号长整形类型，是typedef unsigned long int 类型，对应有符号类型为typedef long int intptr_t。这种类型是机器指针大小对应,如果32位系统，则uintptr_t也为32位，如果是64位系统，则这个值为64位。</p>
<p>Arena最后一个对外接口是返回这个内存池分配总的内存大小。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> MemoryUsage() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> blocks_memory_ + blocks_.capacity() * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>Arena内存大小包括分配的内存空间大小和所有指针大小之和。</p>
<p>Arena在memtabla（也就是跳跃链表）使用较多，因为刚插入的内存数据都放在了memtable里。</p>
<p>至此Arena就分析结束了。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> Arena </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之Status]]></title>
      <url>http://luodw.cc/2015/10/15/leveldb-03/</url>
      <content type="html"><![CDATA[<p>Status类是leveldb用来判断某个函数执行返回时的状态，状态主要是用迭代类型enum类表示
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Code</span> &#123;</span></div><div class="line">  kOk = <span class="number">0</span>,</div><div class="line">  kNotFound = <span class="number">1</span>,</div><div class="line">  kCorruption = <span class="number">2</span>,</div><div class="line">  kNotSupported = <span class="number">3</span>,</div><div class="line">  kInvalidArgument = <span class="number">4</span>,</div><div class="line">  kIOError = <span class="number">5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能很多人对enum这种类型并不是很熟，因为平常使用的并不多。接下来先简单介绍下enum。</p>
<p>enum类型本质是上一种int类型，4个字节，上述代码是不占内存的，因为上述只是enum Code的声明，表示Code类型的变量只能是上述6个值中的某一个，Code code这样才定义了一个Code类型，而且code只能使用声明中列出的字符串来初始化，不能用其他整形变量来初始化。像sizeof(code)=4;</p>
<p>像如下的调用
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Code</span> <span class="built_in">code</span>=kOk;</div><div class="line">cout&lt;&lt;<span class="built_in">code</span>&lt;&lt;endl;</div></pre></td></tr></table></figure></p>
<p>将会输出0.</p>
<p>Status本质就一个成员变量const char* state_;为了节省内存，state_分三部分使用:</p>
<ul>
<li>state_[0..3]:消息的长度，不包括前5个字节</li>
<li>state_[4]:消息的类型</li>
<li>state_[5..]:具体的消息内容</li>
</ul>
<p>介绍主要几个函数：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="function">Status <span class="title">OK</span><span class="params">()</span> </span>&#123; <span class="function"><span class="keyword">return</span> <span class="title">Status</span><span class="params">()</span></span>; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return error status of an appropriate type.</span></div><div class="line">  <span class="keyword">static</span> Status NotFound(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">Status</span><span class="params">(kNotFound, msg, msg2)</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status Corruption(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">Status</span><span class="params">(kCorruption, msg, msg2)</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status NotSupported(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">Status</span><span class="params">(kNotSupported, msg, msg2)</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status InvalidArgument(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">Status</span><span class="params">(kInvalidArgument, msg, msg2)</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status IOError(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="function"><span class="keyword">return</span> <span class="title">Status</span><span class="params">(kIOError, msg, msg2)</span></span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这几个静态函数用于直接返回一个特定类型的Status对象，这有个调用的例子
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Status s;</div><div class="line"><span class="comment">//以下调用会用到赋值操作符</span></div><div class="line">s = Status::Corruption(<span class="string">"corrupted key for "</span>, user_key);<span class="comment">//version_set.cc 413页</span></div></pre></td></tr></table></figure></p>
<p>这几个函数直接调用的是以下函数
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Status(Code code, <span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2);</div></pre></td></tr></table></figure></p>
<p>实现如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Status::Status(Code code, <span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2) &#123;</div><div class="line">  assert(code != kOk);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> len1 = msg.size();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> len2 = msg2.size();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> size = len1 + (len2 ? (<span class="number">2</span> + len2) : <span class="number">0</span>);<span class="comment">//判断第二个字符串长度是否为0，</span></div><div class="line">如果不为<span class="number">0</span>，则信息总长度为len1+<span class="number">2</span>+len2，这里的<span class="number">2</span>是用于存储<span class="string">':'</span>和<span class="string">' '</span>。</div><div class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">5</span>];<span class="comment">//state_总长度还包括前5个</span></div><div class="line">  <span class="built_in">memcpy</span>(result, &amp;size, <span class="keyword">sizeof</span>(size));<span class="comment">//将信息长度存入result前四个字节</span></div><div class="line">  result[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(code);<span class="comment">//第5个字节存状态。</span></div><div class="line">  <span class="built_in">memcpy</span>(result + <span class="number">5</span>, msg.data(), len1);<span class="comment">//第6个字节开始存信息内容</span></div><div class="line">  <span class="keyword">if</span> (len2) &#123;<span class="comment">//如果msg2不为空，则信息内容还用加上': '+msg2。</span></div><div class="line">    result[<span class="number">5</span> + len1] = <span class="string">':'</span>;</div><div class="line">    result[<span class="number">6</span> + len1] = <span class="string">' '</span>;</div><div class="line">    <span class="built_in">memcpy</span>(result + <span class="number">7</span> + len1, msg2.data(), len2);</div><div class="line">  &#125;</div><div class="line">  state_ = result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，介绍下复制构造函数和赋值操作符，之前也提到有用到这赋值操作符。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> Status::Status(<span class="keyword">const</span> Status&amp; s) &#123;</div><div class="line">  state_ = (s.state_ == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : CopyState(s.state_);</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Status::<span class="keyword">operator</span>=(<span class="keyword">const</span> Status&amp; s) &#123;</div><div class="line">  <span class="keyword">if</span> (state_ != s.state_) &#123;</div><div class="line">    <span class="keyword">delete</span>[] state_;</div><div class="line">    state_ = (s.state_ == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : CopyState(s.state_);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本质上都是调用CopyState来复制s.state_的内容。这并不不是简单的bitwise copy，因为CopyState有重新开辟一块内存存储s.state_的内容,然后把指针赋给调用函数的s.state_指针。</p>
<p>接下来几个都是用于判断状态的成员方法。直接通过code()函数返回这个Status的状态。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Returns true iff the status indicates success.</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (state_ == <span class="literal">NULL</span>); &#125;</div><div class="line"></div><div class="line"><span class="comment">// Returns true iff the status indicates a NotFound error.</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsNotFound</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> code() == kNotFound; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Returns true iff the status indicates a Corruption error.</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCorruption</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> code() == kCorruption; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Returns true iff the status indicates an IOError.</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsIOError</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> code() == kIOError; &#125;</div></pre></td></tr></table></figure></p>
<p>code函数的定义如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Code <span class="title">code</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (state_ == <span class="literal">NULL</span>) ? kOk : <span class="keyword">static_cast</span>&lt;Code&gt;(state_[<span class="number">4</span>]);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数先判断state_是否为空，如果为空，则返回kOk，否则取出state_第四个字节，转换为Code类型返回。</p>
<p>最后简单摘录几个调用的例子：</p>
<ol>
<li></li>
</ol>
<p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Status s<span class="comment">;</span></div><div class="line"><span class="attribute">s</span> = descriptor_log_-&gt;AddRecord(record)<span class="comment">;</span></div><div class="line">     if (s.ok()) &#123;</div></pre></td></tr></table></figure></p>
<ol start="2">
<li></li>
</ol>
<p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">s</span> = Status::Corruption(<span class="string">"corrupted key for "</span>, user_key);</div></pre></td></tr></table></figure></p>
<p>总结下：Status这个类调用场景，主要是在某个函数fun里面定义一个Status，可以通过静态函数返回值获得或者调用另一个返回值获得，最后fun返回时，检查这个函数的返回状态。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> Status </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb源码分析之Slice]]></title>
      <url>http://luodw.cc/2015/10/15/leveldb-02/</url>
      <content type="html"><![CDATA[<p>leveldb和redis这样的优秀开源框架都没有使用C++自带的字符串string，redis自己写了个sds，leveldb写了slice，本质上这三个实现原理都是一样的(当然sds是用C实现的)，都有成员属性指向字符串的指针和这个字符串的长度。方法无非就是取字符串取字符串长度，字符串拼接等等。</p>
<p>我把slice作为leveldb源码部分的第一个讲解，主要是slice是这个源码最基础的部分，都是别人使用它，它不使用别人。而且相对简单。</p>
<p>我这先上class slice源码，我一一注释：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span> </span>&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  // Create an empty slice.</div><div class="line">  //创建空的字符串，用法Slice slice;</div><div class="line">  Slice() : data_(<span class="string">""</span>), size_(0) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create a slice that refers to d[0,n-1].</span></div><div class="line">  <span class="comment">//用一个字符串指针和字符串长度初始化一个Slice</span></div><div class="line">  Slice(<span class="keyword">const</span> <span class="keyword">char</span>* d, size_t n) : data_(d), size_(n) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create a slice that refers to the contents of "s"，</span></div><div class="line">  <span class="comment">//用C++字符串初始化Slice</span></div><div class="line">  Slice(<span class="keyword">const</span> std::string&amp; s) : data_(s.data()), size_(s.size()) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></div><div class="line">  <span class="comment">//用一个字符串指针初始化Slice，</span></div><div class="line">  Slice(<span class="keyword">const</span> <span class="keyword">char</span>* s) : data_(s), size_(strlen(s)) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return a pointer to the beginning of the referenced data</span></div><div class="line">  <span class="comment">// 获取Slice字符串，不能改变值</span></div></pre></td></tr></table></figure></p>
<p>这前几个函数都是Slice的构造函数，用空字符串，C风格以NULL结尾的字符串，C++ string字符串
来构造Slice。</p>
<p>常用的几个函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Return the length (in bytes) of the referenced data</span></div><div class="line"><span class="comment">// 获取字符串的长度</span></div><div class="line"><span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Return true iff the length of the referenced data is zero</span></div><div class="line"><span class="comment">// 判断Slice是否为空，如果为空，返回true，如果不为空，则返回false；</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Return the ith byte in the referenced data.</span></div><div class="line"><span class="comment">// REQUIRES: n &lt; size()</span></div><div class="line"><span class="comment">// 重载[]操作符，用户通过slice[n]获取第n个字符</span></div></pre></td></tr></table></figure></p>
<p>特定情形下使用的函数。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</div><div class="line">    assert(n &lt; size());</div><div class="line">    <span class="keyword">return</span> data_[n];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Change this slice to refer to an empty array</span></div><div class="line">  <span class="comment">//将这个Slice清空</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; data_ = <span class="string">""</span>; size_ = <span class="number">0</span>; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Drop the first "n" bytes from this slice.</span></div><div class="line">  <span class="comment">//去除Slice前缀n个字符，例如为了取出Status信息，需要去除前5个前缀字符</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</div><div class="line">    assert(n &lt;= size());</div><div class="line">    data_ += n;<span class="comment">//指针向前移动n个字符</span></div><div class="line">    size_ -= n;<span class="comment">//长度减n</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return a string that contains the copy of the referenced data.</span></div><div class="line">  <span class="comment">//返回Slice的string形式的副本</span></div><div class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(data_, size_); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Three-way comparison.  Returns value:</span></div><div class="line">  <span class="comment">//   &lt;  0 iff "*this" &lt;  "b",</span></div><div class="line">  <span class="comment">//   == 0 iff "*this" == "b",</span></div><div class="line">  <span class="comment">//   &gt;  0 iff "*this" &gt;  "b"</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return true iff "x" is a prefix of "*this"</span></div><div class="line">  <span class="comment">// 判断这个Slice是否以字符串x为前缀</span></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp;</div><div class="line">            (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</div><div class="line">  <span class="keyword">size_t</span> size_;</div><div class="line"></div><div class="line">  <span class="comment">// Intentionally copyable</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 重载==操作符，用于判断Slice==Slice</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</div><div class="line">  <span class="keyword">return</span> ((x.size() == y.size()) &amp;&amp;</div><div class="line">          (<span class="built_in">memcmp</span>(x.data(), y.data(), x.size()) == <span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 重载不等于操作符</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</div><div class="line">  <span class="keyword">return</span> !(x == y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//字符串比较函数</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Slice::compare(<span class="keyword">const</span> Slice&amp; b) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</div><div class="line">  <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</div><div class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;<span class="comment">//字符串相等的情况下，可能长度不一样，所以也要进行判断。</span></div><div class="line">    <span class="keyword">if</span> (size_ &lt; b.size_) r = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_) r = +<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> r;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>leveldb的字符串Slice还是算比较简单的，相比与redis的sds,sds还有字符串的拼接啦，长整形和字符串互转等等。
简单使用：
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明定义一个空字符串</span></div><div class="line">Slice slice；</div><div class="line"><span class="comment">//有一个字符串指针初始化Slice</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p=<span class="string">"orange"</span></div><div class="line">Slice slice(p);</div><div class="line"><span class="comment">//获取Slice的字符串</span></div><div class="line">slice.data();</div><div class="line"><span class="comment">//获取Slice字符串的长度</span></div><div class="line">slice.<span class="built_in">size</span>()</div></pre></td></tr></table></figure></p>
<p>Slice分析到此就结束了，下一篇，主要介绍下状态类Status.</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
            <tag> slice </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb安装和使用]]></title>
      <url>http://luodw.cc/2015/10/14/leveldb-01/</url>
      <content type="html"><![CDATA[<p>我研一时就给自己定义了学习路线，系统-&gt;语言-&gt;开源框架。研一的时候，我学习了linux系统命令，系统调用，内核一些原理，研二刚看了C++对象模型，所以接下来我要学习下leveldb源码。研一暑假时，我看了redis源码，这个leveldb源码分析结束之后，再把那个整理下发上来。</p>
<p>分析开源优秀框架的源码是非常有价值，有意义的。</p>
<ol>
<li>首先分了某个框架，那么你就对这个框架从底层上的了解。</li>
<li>其次，可以了解到某个语言是怎么用的。我看了leveldb，某种目的上，就是想看看C++面向对象是怎么使用的。因为平时，我们都是用C++面向过程的部分。</li>
<li>最后，学习优秀框架架构，以及框架里面很多细节知识。例如redis里面就嵌入一个io多路复用框架ae。</li>
</ol>
<p>这篇文章首先介绍下leveldb是如何安装以及简单使用，接来的文章，就介绍下leveldb源码解析。</p>
<h2>leveldb安装</h2>
<p>首先可以从<a href="https://github.com/google/leveldb.git" target="_blank" rel="external">https://github.com/google/leveldb.git</a>下载leveldb，然后cd到leveldb目录中，执行
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">make</span></div></pre></td></tr></table></figure></p>
<p>过一会，就可以在目录下看到静态链接库libleveldb.a和动态链接库libleveldb.so.1.18.
如果不用动态链接库的话，安装已经完成了。但是如果要用动态链接库，则还需要把头文件以及动态链接库拷贝到系统路径里面，具体如下：</p>
<ol>
<li>
<p>把include/leveldb目录拷贝到/usr/include
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">sudo</span> <span class="meta">cp</span> -r <span class="meta">include</span>/leveldb /usr/<span class="meta">include</span></div></pre></td></tr></table></figure></p>
</li>
<li>
<p>把动态链接库文件拷贝到/usr/lib下，再按当前目录下的形式，创建两个软连接。
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo cp libleveldb.so.<span class="number">1.18</span> /usr/<span class="class"><span class="keyword">lib</span></span></div><div class="line">cd /usr/<span class="class"><span class="keyword">lib</span></span></div><div class="line">sudo ln -s libleveldb.so.<span class="number">1.18</span> libleveldb.so.<span class="number">1</span></div><div class="line">sudo ln -s libleveldb.so.<span class="number">1</span> libleveldb.so</div><div class="line">ldconfig</div></pre></td></tr></table></figure></p>
</li>
</ol>
<p>最后要执行ldconfig命令，将动态链接库加到缓存中，这样系统才能真正使用这个动态链接库。我在之前一篇文章有说<a href="http://luodw.github.io/2015/09/25/config/#more" target="_blank" rel="external">http://luodw.github.io/2015/09/25/config/#more</a></p>
<p>自此，leveldb就算安装好了。</p>
<h2>leveldb入门程序</h2>
<p>接下来，我用一个小程序来介绍下leveldb使用方法。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;leveldb/db.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	leveldb::DB *db;</div><div class="line">	leveldb::Options options;</div><div class="line">	options.create_if_missing=<span class="literal">true</span>;</div><div class="line">	leveldb::Status status = leveldb::DB::Open(options,<span class="string">"./testdb"</span>,&amp;db);</div><div class="line">	assert(status.ok());</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> key1=<span class="string">"people"</span>;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> value1=<span class="string">"jason"</span>;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> value;</div><div class="line">	leveldb::Status s=db-&gt;Put(leveldb::WriteOptions(),key1,value1);</div><div class="line">	<span class="keyword">if</span>(s.ok())</div><div class="line">		s=db-&gt;Get(leveldb::ReadOptions(),<span class="string">"people"</span>,&amp;value);</div><div class="line">	<span class="keyword">if</span>(s.ok())</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;value&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="built_in">cout</span>&lt;&lt;s.ToString()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">delete</span> db;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序很简单，就是插入一条键值对，接着取出这个键值对。</p>
<p>静态链接库如下编译，静态链接库必须在当前目录下，或者指出库的绝对路径
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ mytest<span class="selector-class">.cc</span> -o mytest ./libleveldb<span class="selector-class">.a</span> -lpthread</div></pre></td></tr></table></figure></p>
<p>动态链接库编译如下，动态链接库不需要在当前文件下，系统能自动到相关路径下查找，所以动态链接库相对静态链接库相对方便些。
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ mytest<span class="selector-class">.cc</span> -o mytest -lpthread -lleveldb</div></pre></td></tr></table></figure></p>
<p>一定要加-lpthread，因为leveldb有用到线程相关调用。</p>
<p>最后运行结果如下：
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">jason</span></div></pre></td></tr></table></figure></p>
<p>据我了解，leveldb无外乎就是键值对的插入，查询，有迭代器全局查询，还有快照和批量操作。待我深入学习之后，在分享出来。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++赋值操作符和析构函数语义学]]></title>
      <url>http://luodw.cc/2015/10/12/Cplus5-md/</url>
      <content type="html"><![CDATA[<p>赋值操作符和复制构造函数语义学几乎一样，我只列出展示Memberwise Copy语义。</p>
<ol>
<li>当class内含一个member object，而其class有一个copy assignment operator时。</li>
<li>当一个class的base class有一个copy assignment operator时。</li>
<li>当一个class声明了任何virtual functions（我们一定不要拷贝右端class的vptr地址，因为它可能是一个derived class object）时。</li>
<li>当class继承自一个virtual base class(不论此base class 有没有copy operator)时。</li>
</ol>
<h3>析构函数语义学</h3>
<p>析构函数也并不是默认会自动生成的。析构函数在以下两种情况下由编译器合成。</p>
<ol>
<li>这个class含有member object，这个object有析构函数。</li>
<li>这个类的基类有析构函数。</li>
</ol>
<p>编写以下例子测试：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> i=<span class="number">0</span>):b(i)&#123;&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> A :<span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">        A()&#123;</div><div class="line">        	<span class="built_in">cout</span>&lt;&lt;<span class="string">"A()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">        &#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"test()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">        B b;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        A a;</div><div class="line">        a.test();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序的汇编代码如下：
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump <span class="keyword">of</span> assembler code <span class="keyword">for</span> <span class="keyword">function</span> main():</div><div class="line">   <span class="number">0x000000000040092d</span> &lt;+<span class="number">0</span>&gt;:	push   <span class="meta">%rbp</span></div><div class="line">   <span class="number">0x000000000040092e</span> &lt;+<span class="number">1</span>&gt;:	mov    <span class="meta">%rsp</span>,<span class="meta">%rbp</span></div><div class="line">   <span class="number">0x0000000000400931</span> &lt;+<span class="number">4</span>&gt;:	sub    $0x10,<span class="meta">%rsp</span></div><div class="line">   <span class="number">0x0000000000400935</span> &lt;+<span class="number">8</span>&gt;:	lea    -<span class="number">0x10</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x0000000000400939</span> &lt;+<span class="number">12</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x000000000040093c</span> &lt;+<span class="number">15</span>&gt;:	callq  <span class="number">0x4009bc</span> &lt;A::A()&gt;</div><div class="line">   <span class="number">0x0000000000400941</span> &lt;+<span class="number">20</span>&gt;:	lea    -<span class="number">0x10</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x0000000000400945</span> &lt;+<span class="number">24</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x0000000000400948</span> &lt;+<span class="number">27</span>&gt;:	callq  <span class="number">0x400a1c</span> &lt;A::test()&gt;</div><div class="line">   <span class="number">0x000000000040094d</span> &lt;+<span class="number">32</span>&gt;:	mov    $0x0,<span class="meta">%eax</span></div><div class="line">   <span class="number">0x0000000000400952</span> &lt;+<span class="number">37</span>&gt;:	leaveq </div><div class="line">   <span class="number">0x0000000000400953</span> &lt;+<span class="number">38</span>&gt;:	retq   </div><div class="line">End <span class="keyword">of</span> assembler dump.</div></pre></td></tr></table></figure></p>
<p>并没有析构函数，因为B没有析构函数，当我给B加一个什么都不做的析构函数时，反汇编代码如下：
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">31</span>	        return <span class="number">0</span><span class="comment">;</span></div><div class="line">   <span class="number">0x0000000000400a2e</span> &lt;+<span class="number">33</span>&gt;:	<span class="keyword">mov</span>    <span class="number">$0</span>x0,%ebx</div><div class="line">   <span class="number">0x0000000000400a33</span> &lt;+<span class="number">38</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x20</span>(%rbp),%rax</div><div class="line">   <span class="number">0x0000000000400a37</span> &lt;+<span class="number">42</span>&gt;:	<span class="keyword">mov</span>    %rax,%rdi</div><div class="line">   <span class="number">0x0000000000400a3a</span> &lt;+<span class="number">45</span>&gt;:	callq  <span class="number">0x400b96</span> &lt;A::~A()&gt;</div></pre></td></tr></table></figure></p>
<p>在return语句之后，编译器生成了一个析构函数。</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 对象模型 </tag>
            
            <tag> 赋值操作符 </tag>
            
            <tag> 析构函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++复制构造函数语义学]]></title>
      <url>http://luodw.cc/2015/10/12/Cplus4/</url>
      <content type="html"><![CDATA[<p>上篇讲了C++构造函数语义学，这篇文章接着将C++复制构造函数语义学，也属于构造函数。
C++有三种情况会用到C++复制构造函数</p>
<ol>
<li>直接用一个类对象类初始化另一个类对象</li>
<li>类变量作为函数参数时，此时如果传进对象实参，形参将会用实参显试初始化。</li>
<li>类变量作为函数返回值时。</li>
</ol>
<p>C++复制构造函数和构造函数一样，也是需要的时候才会产生。什么情况下会产生复制构造函数了？</p>
<p>C++有分Bitwise Copy Semantics和Memberwise Copy Semantics。默认情况下，C++用的是Bitwise Copy Semantics，即一个个bit拷贝复制。但是在以下情况下，必须用Memberwise Copy Semantics，即成员变量为单位复制。</p>
<ol>
<li>当class内含一个member object，而后者的class声明有一个copy constructor时（不论是用户自己定义的，还是编译器生成的）。</li>
<li>当class继承自一个base class而后者存在一个copy constructor时（再次强调，不论是显示声明或编译器合成）</li>
<li>当class声明了一个或多个virtual functions时。</li>
<li>当class派生自一个继承串链时，其中有一个或多个virtual base classes时。</li>
</ol>
<p>前两个相对较简单，我用一个例子来测试第三条。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a=<span class="number">0</span>):a(a)&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"test"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	A a1=a;</div><div class="line">	a1.test();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>main函数反汇编代码如下：
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump <span class="keyword">of</span> assembler code <span class="keyword">for</span> <span class="keyword">function</span> main():</div><div class="line">   <span class="number">0x000000000040085d</span> &lt;+<span class="number">0</span>&gt;:	push   <span class="meta">%rbp</span></div><div class="line">   <span class="number">0x000000000040085e</span> &lt;+<span class="number">1</span>&gt;:	mov    <span class="meta">%rsp</span>,<span class="meta">%rbp</span></div><div class="line">   <span class="number">0x0000000000400861</span> &lt;+<span class="number">4</span>&gt;:	sub    $0x20,<span class="meta">%rsp</span></div><div class="line">   <span class="number">0x0000000000400865</span> &lt;+<span class="number">8</span>&gt;:	lea    -<span class="number">0x20</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x0000000000400869</span> &lt;+<span class="number">12</span>&gt;:	mov    $0x0,<span class="meta">%esi</span></div><div class="line">   <span class="number">0x000000000040086e</span> &lt;+<span class="number">17</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x0000000000400871</span> &lt;+<span class="number">20</span>&gt;:	callq  <span class="number">0x4008e2</span> &lt;A::A(int)&gt;</div><div class="line">   <span class="number">0x0000000000400876</span> &lt;+<span class="number">25</span>&gt;:	mov    -<span class="number">0x20</span>(<span class="meta">%rbp</span>),<span class="meta">%eax</span></div><div class="line">   <span class="number">0x0000000000400879</span> &lt;+<span class="number">28</span>&gt;:	mov    <span class="meta">%eax</span>,-<span class="number">0x10</span>(<span class="meta">%rbp</span>)</div><div class="line">   <span class="number">0x000000000040087c</span> &lt;+<span class="number">31</span>&gt;:	lea    -<span class="number">0x10</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x0000000000400880</span> &lt;+<span class="number">35</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x0000000000400883</span> &lt;+<span class="number">38</span>&gt;:	callq  <span class="number">0x4008f8</span> &lt;A::test()&gt;</div><div class="line">   <span class="number">0x0000000000400888</span> &lt;+<span class="number">43</span>&gt;:	mov    $0x0,<span class="meta">%eax</span></div><div class="line">   <span class="number">0x000000000040088d</span> &lt;+<span class="number">48</span>&gt;:	leaveq </div><div class="line">   <span class="number">0x000000000040088e</span> &lt;+<span class="number">49</span>&gt;:	retq   </div><div class="line">End <span class="keyword">of</span> assembler dump.</div></pre></td></tr></table></figure></p>
<p>并没有调用复制构造函数。</p>
<p>当我把<strong>test函数改成virtual</strong>时，汇编代码如下：
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code for function main():</div><div class="line">   <span class="number">0x00000000004008cd</span> &lt;+<span class="number">0</span>&gt;:	<span class="keyword">push</span>   %rbp</div><div class="line">   <span class="number">0x00000000004008ce</span> &lt;+<span class="number">1</span>&gt;:	<span class="keyword">mov</span>    %rsp,%rbp</div><div class="line">   <span class="number">0x00000000004008d1</span> &lt;+<span class="number">4</span>&gt;:	<span class="keyword">sub</span>    <span class="number">$0</span>x20,%rsp</div><div class="line">   <span class="number">0x00000000004008d5</span> &lt;+<span class="number">8</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x20</span>(%rbp),%rax</div><div class="line">   <span class="number">0x00000000004008d9</span> &lt;+<span class="number">12</span>&gt;:	<span class="keyword">mov</span>    <span class="number">$0</span>x0,%esi</div><div class="line">   <span class="number">0x00000000004008de</span> &lt;+<span class="number">17</span>&gt;:	<span class="keyword">mov</span>    %rax,%rdi</div><div class="line">   <span class="number">0x00000000004008e1</span> &lt;+<span class="number">20</span>&gt;:	callq  <span class="number">0x40095e</span> &lt;A::A(<span class="keyword">int</span>)&gt;</div><div class="line">   <span class="number">0x00000000004008e6</span> &lt;+<span class="number">25</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x20</span>(%rbp),%rdx</div><div class="line">   <span class="number">0x00000000004008ea</span> &lt;+<span class="number">29</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x10</span>(%rbp),%rax</div><div class="line">   <span class="number">0x00000000004008ee</span> &lt;+<span class="number">33</span>&gt;:	<span class="keyword">mov</span>    %rdx,%rsi</div><div class="line">   <span class="number">0x00000000004008f1</span> &lt;+<span class="number">36</span>&gt;:	<span class="keyword">mov</span>    %rax,%rdi</div><div class="line">   <span class="number">0x00000000004008f4</span> &lt;+<span class="number">39</span>&gt;:	callq  <span class="number">0x4009aa</span> &lt;A::A(A const&amp;)&gt;</div><div class="line">   <span class="number">0x00000000004008f9</span> &lt;+<span class="number">44</span>&gt;:	<span class="keyword">lea</span>    -<span class="number">0x10</span>(%rbp),%rax</div><div class="line">   <span class="number">0x00000000004008fd</span> &lt;+<span class="number">48</span>&gt;:	<span class="keyword">mov</span>    %rax,%rdi</div><div class="line">   <span class="number">0x0000000000400900</span> &lt;+<span class="number">51</span>&gt;:	callq  <span class="number">0x400980</span> &lt;A::<span class="keyword">test</span>()&gt;</div><div class="line">   <span class="number">0x0000000000400905</span> &lt;+<span class="number">56</span>&gt;:	<span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</div><div class="line">   <span class="number">0x000000000040090a</span> &lt;+<span class="number">61</span>&gt;:	leaveq </div><div class="line">   <span class="number">0x000000000040090b</span> &lt;+<span class="number">62</span>&gt;:	retq   </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>我们可以看到调用**callq  0x4009aa &lt;A::A(A const&amp;)&gt;**复制构造函数。跟进到这个复制构造函数时，可以看到这个函数只是简单的将虚拟函数表复制给对象的首8个字节，因为没有用户其他代码。</p>
<p>当我再一次改造这个程序时，即用子类来初始化父类时：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> i=<span class="number">0</span>):b(i)&#123;&#125;</div><div class="line">	B(B <span class="keyword">const</span>&amp; b)</div><div class="line">	&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"test"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A :<span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>):B(b),a(a)&#123;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"test"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	B b=a;</div><div class="line">	b.test1();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时我深入到B的复制构造函数中，即断点在B(B const&amp; b)函数里，该函数的汇编代码为：
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(gdb) disas</div><div class="line">Dump of assembler code for function B::B(B const&amp;):</div><div class="line">   <span class="number">0x00000000004009e6</span> &lt;+<span class="number">0</span>&gt;:	<span class="keyword">push</span>   %rbp</div><div class="line">   <span class="number">0x00000000004009e7</span> &lt;+<span class="number">1</span>&gt;:	<span class="keyword">mov</span>    %rsp,%rbp</div><div class="line">   <span class="number">0x00000000004009ea</span> &lt;+<span class="number">4</span>&gt;:	<span class="keyword">mov</span>    %rdi,-<span class="number">0x8</span>(%rbp)</div><div class="line">   <span class="number">0x00000000004009ee</span> &lt;+<span class="number">8</span>&gt;:	<span class="keyword">mov</span>    %rsi,-<span class="number">0x10</span>(%rbp)</div><div class="line">   <span class="number">0x00000000004009f2</span> &lt;+<span class="number">12</span>&gt;:	<span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax</div><div class="line">   <span class="number">0x00000000004009f6</span> &lt;+<span class="number">16</span>&gt;:	<span class="keyword">movq</span>   <span class="number">$0</span>x400b70,(%rax)</div><div class="line">=&gt; <span class="number">0x00000000004009fd</span> &lt;+<span class="number">23</span>&gt;:	<span class="keyword">pop</span>    %rbp</div><div class="line">   <span class="number">0x00000000004009fe</span> &lt;+<span class="number">24</span>&gt;:	retq   </div><div class="line">End of assembler dump.</div><div class="line">(gdb) x /x $<span class="built_in">rdi</span></div><div class="line"><span class="number">0x7fffffffd710</span>:	<span class="number">0x00400b70</span></div><div class="line">(gdb) x /x $<span class="built_in">rsi</span></div><div class="line"><span class="number">0x7fffffffd700</span>:	<span class="number">0x00400b50</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>0x00400b70这是B的虚函数地址，0x00400b50这是A的虚函数地址，由汇编可以看出，B b=a，调用的是B的复制构造函数，在复制构造函数内，直接把B的虚函数地址复制给b。所以类里面有虚函数必须合成默认构造函数，否则用子类的的对象来初始化父类对象时，如果采用bitwise复制，那么复制的是子类的虚函数表，这显然是错误的。</p>
<h3>编译器优化</h3>
<p>当有以下代码时，
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A foo()</div><div class="line">&#123;</div><div class="line">	A a<span class="comment">;</span></div><div class="line">	a.test()<span class="comment">;</span></div><div class="line">	return a<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">A a=foo()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>按正常理解，最后一句是会调用复制构造函数，然而编译器会做出优化，编译器正真做的就和我普通想得不一样了。</p>
<p>编译器会改写这个函数，这样以来就不用调用复制构造函数了，因为当类成员很多很大时，复制操作是很耗时的。
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void foo<span class="comment">(A &amp;_result)</span></div><div class="line">&#123;</div><div class="line">	_result.test<span class="comment">()</span>;</div><div class="line">&#125;</div><div class="line">A a;</div><div class="line">foo<span class="comment">(a)</span>;</div></pre></td></tr></table></figure></p>
<p>通过查看反汇编也可以看出编译器这样的改写，这中优化也叫作named return value(NRV)
，自己也可以写个程序测试下，并没有调用复制构造函数。</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 对象模型 </tag>
            
            <tag> 复制构造函数 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++构造函数语义学]]></title>
      <url>http://luodw.cc/2015/10/11/Cplus3-1/</url>
      <content type="html"><![CDATA[<p><strong>深度探索C++对象模型</strong>一书，第二章讲解了C++构造函数以及复制构造函数语义学，第五章讲解了C++赋值构造函数和析构函数语义学。特别是复制和赋值函数讲解了Bitwise Copy Semantics和Memberwise Copy Semantics。接下来几篇文章，我将总结这些知识点。</p>
<h3>构造函数</h3>
<p>首先给出两个常见的误解：</p>
<ol>
<li>任何class如果没有定有default constructor，就会被合成出来</li>
<li>编译器合成出来的default construct会显示设定“class 内每个data member的默认值”</li>
</ol>
<p>刚接触C++不久的用户估计都有上述的幻觉吧，我们姑且写为“C++对象两大幻觉”。然后看过对象模型这本书之后，完全颠覆你之前的想法。</p>
<p>当我们设计一个类的时候，如果没有显示的定义一个构造函数，那么编译器有可能为这个类产生一个构造函数，也有可能不产生。书中称不产生的构造函数为trivial(没啥用的)，称产生出来的构造函数为nontrivial。</p>
<p>书中总结了会产生nontrivial构造函数的4中情况：</p>
<ol>
<li>当类的对象成员（类的成员是个对象），有默认构造函数时。因为对于成员是普通的变量类型（相当与C语言struct结构，俗称POD(Plain Old Data））是生成trivial构造函数，啥都不做，所以变量是没有初始化。但是如果类成员是一个对象，必须要有个构造函数类初始化这个对象成员，那么这个类必须要有个构造函数，用户没有定义的话，编译器生成一个。</li>
<li>带有默认构造函数的基类。因为在定义子类的时候，是先调用父类的构造函数。所以如果父类有默认构造函数，子类页必须有。</li>
<li>带有虚函数的类。很简单嘛，因为由虚函数指针，必须有默认构造函数。</li>
<li>带有一个虚基类的class。因为虚基类在子类的上面，需要一种机制使子类能调用虚基类的成员函数，所以必须有默认构造函数。</li>
</ol>
<h4>实例验证</h4>
<p>我用一个例子来验证第一条是否正确。其他就不一一验证了。需要用到反汇编。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	 <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后编译链接，用gdb查看main函数的汇编代码：
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump <span class="keyword">of</span> assembler code <span class="keyword">for</span> <span class="keyword">function</span> main():</div><div class="line">   <span class="number">0x000000000040085d</span> &lt;+<span class="number">0</span>&gt;:	push   <span class="meta">%rbp</span></div><div class="line">   <span class="number">0x000000000040085e</span> &lt;+<span class="number">1</span>&gt;:	mov    <span class="meta">%rsp</span>,<span class="meta">%rbp</span></div><div class="line">   <span class="number">0x0000000000400861</span> &lt;+<span class="number">4</span>&gt;:	sub    $0x10,<span class="meta">%rsp</span></div><div class="line">   <span class="number">0x0000000000400865</span> &lt;+<span class="number">8</span>&gt;:	lea    -<span class="number">0x10</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x0000000000400869</span> &lt;+<span class="number">12</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x000000000040086c</span> &lt;+<span class="number">15</span>&gt;:	callq  <span class="number">0x4008ca</span> &lt;A::test()&gt;</div><div class="line">   <span class="number">0x0000000000400871</span> &lt;+<span class="number">20</span>&gt;:	mov    $0x0,<span class="meta">%eax</span></div><div class="line">   <span class="number">0x0000000000400876</span> &lt;+<span class="number">25</span>&gt;:	leaveq </div><div class="line">   <span class="number">0x0000000000400877</span> &lt;+<span class="number">26</span>&gt;:	retq   </div><div class="line">End <span class="keyword">of</span> assembler dump.</div></pre></td></tr></table></figure></p>
<p>该汇编程序很简单，只是简单将a的地址传入test函数中，并没有调用构造函数。
当我改造这个程序，将A的成员变量改成某个类，如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> i=<span class="number">0</span>):b(i)&#123;&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"test"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	B b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	a.test();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>main反汇编代码如下:
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump <span class="keyword">of</span> assembler code <span class="keyword">for</span> <span class="keyword">function</span> main():</div><div class="line">   <span class="number">0x000000000040085d</span> &lt;+<span class="number">0</span>&gt;:	push   <span class="meta">%rbp</span></div><div class="line">   <span class="number">0x000000000040085e</span> &lt;+<span class="number">1</span>&gt;:	mov    <span class="meta">%rsp</span>,<span class="meta">%rbp</span></div><div class="line">   <span class="number">0x0000000000400861</span> &lt;+<span class="number">4</span>&gt;:	sub    $0x10,<span class="meta">%rsp</span></div><div class="line">   <span class="number">0x0000000000400865</span> &lt;+<span class="number">8</span>&gt;:	lea    -<span class="number">0x10</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x0000000000400869</span> &lt;+<span class="number">12</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x000000000040086c</span> &lt;+<span class="number">15</span>&gt;:	callq  <span class="number">0x400916</span> &lt;A::A()&gt;</div><div class="line">   <span class="number">0x0000000000400871</span> &lt;+<span class="number">20</span>&gt;:	lea    -<span class="number">0x10</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x0000000000400875</span> &lt;+<span class="number">24</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x0000000000400878</span> &lt;+<span class="number">27</span>&gt;:	callq  <span class="number">0x4008ec</span> &lt;A::test()&gt;</div><div class="line">   <span class="number">0x000000000040087d</span> &lt;+<span class="number">32</span>&gt;:	mov    $0x0,<span class="meta">%eax</span></div><div class="line">   <span class="number">0x0000000000400882</span> &lt;+<span class="number">37</span>&gt;:	leaveq </div><div class="line">   <span class="number">0x0000000000400883</span> &lt;+<span class="number">38</span>&gt;:	retq   </div><div class="line">End <span class="keyword">of</span> assembler dump.</div></pre></td></tr></table></figure></p>
<p>看到汇编代码那个醒目的&lt;A::A()&gt;了吗？</p>
<p>当我自定义一个构造函数，然后啥也不做时，
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">A</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时,A a会调用默认构造函数，即上述那个，A()函数反汇编代码如下：
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(gdb) disas</div><div class="line">Dump <span class="keyword">of</span> assembler code <span class="keyword">for</span> <span class="keyword">function</span> A::A():</div><div class="line">   <span class="number">0x00000000004008ec</span> &lt;+<span class="number">0</span>&gt;:	push   <span class="meta">%rbp</span></div><div class="line">   <span class="number">0x00000000004008ed</span> &lt;+<span class="number">1</span>&gt;:	mov    <span class="meta">%rsp</span>,<span class="meta">%rbp</span></div><div class="line">   <span class="number">0x00000000004008f0</span> &lt;+<span class="number">4</span>&gt;:	sub    $0x10,<span class="meta">%rsp</span></div><div class="line">   <span class="number">0x00000000004008f4</span> &lt;+<span class="number">8</span>&gt;:	mov    <span class="meta">%rdi</span>,-<span class="number">0x8</span>(<span class="meta">%rbp</span>)</div><div class="line">   <span class="number">0x00000000004008f8</span> &lt;+<span class="number">12</span>&gt;:	mov    -<span class="number">0x8</span>(<span class="meta">%rbp</span>),<span class="meta">%rax</span></div><div class="line">   <span class="number">0x00000000004008fc</span> &lt;+<span class="number">16</span>&gt;:	mov    $0x0,<span class="meta">%esi</span></div><div class="line">   <span class="number">0x0000000000400901</span> &lt;+<span class="number">21</span>&gt;:	mov    <span class="meta">%rax</span>,<span class="meta">%rdi</span></div><div class="line">   <span class="number">0x0000000000400904</span> &lt;+<span class="number">24</span>&gt;:	callq  <span class="number">0x4008d6</span> &lt;B::B(int)&gt;</div><div class="line">=&gt; <span class="number">0x0000000000400909</span> &lt;+<span class="number">29</span>&gt;:	leaveq </div><div class="line">   <span class="number">0x000000000040090a</span> &lt;+<span class="number">30</span>&gt;:	retq   </div><div class="line">End <span class="keyword">of</span> assembler dump.</div></pre></td></tr></table></figure></p>
<p>看到醒目的B::B(int)了吗？说明:</p>
<ol>
<li>当在类由某个对象成员变量时，如果该类没有构造函数，则编译器帮忙生成一个构造函数；</li>
<li>如果自己定义了一个构造函数，则编译器将B的构造函数代码加在自定义代码之后。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 对象模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++成员变量指针和成员函数指针]]></title>
      <url>http://luodw.cc/2015/10/10/ptr/</url>
      <content type="html"><![CDATA[<p><strong>深度探索C++对象模型</strong>这本书还有提到C++类的成员变量指针和成员函数指针，虽然在实际开发中用的不多，但是还是需要理解下。</p>
<h2>成员变量指针</h2>
<h3>非静态成员指针</h3>
<p>类成员变量指针，实际上并不是真正意义上的指针，即它并不是指向内存中某个地址，而是该成员变量与对象指针的偏移量。该偏移量只有附着在某个具体对象，才能指向对象成员变量的具体地址。</p>
<p>如下程序:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>):a(a),b(b)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="string">"  "</span>&lt;&lt;<span class="string">"b="</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(A::*pFun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A ap;</div><div class="line">	ap.print();<span class="comment">//输出a和b的默认值</span></div><div class="line">	<span class="keyword">int</span> A::*aptr=&amp;A::a;<span class="comment">//aptr为A这个类中，a的成员指针</span></div><div class="line">	<span class="keyword">int</span> A::*bptr=&amp;A::b;<span class="comment">////aptr为A这个类中，a的成员指针</span></div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"aptr=%d,bptr=%d\n"</span>,aptr,bptr);<span class="comment">//输出两个指针值</span></div><div class="line">	ap.*bptr=<span class="number">5</span>;通过成员指针修改成员的值</div><div class="line">	ap.print();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序的输出如下:
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">a</span>=<span class="number">0</span>  b=<span class="number">0</span></div><div class="line"><span class="attr">aptr</span>=<span class="number">0</span>,bptr=<span class="number">4</span></div><div class="line"><span class="attr">a</span>=<span class="number">0</span>  b=<span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>由结果可以看出，指向a的指针值为0,指向b的指针值为4，刚好都是这两个变量在类A实例对象中，与对象指针的偏移量。然后通过将该指针绑定到一个对象，修改该对象的值，也是可以成功的。因为平时，我们用ap.a访问变量a时，编译器就是将ap+a的偏移量来访问的。</p>
<h3>静态成员</h3>
<p>对于C++静态成员的指针，其值就是指向内存中数据区某个地址，就是真正意义上的指针，因为静态成员属于类范围，不属于某个对象。</p>
<p>编写如下程序验证：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A()&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	 <span class="keyword">static</span> <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> A::a=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(A::*pFun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;A::a;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"p=%p\n"</span>,p);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序输出如下：
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">p</span>=<span class="number">0</span>x601058</div></pre></td></tr></table></figure></p>
<p>说明下：C++类的静态成员必须在类外初始化，而且初始化一次。如果是
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> a即可在类里面初始化</div></pre></td></tr></table></figure></p>
<h2>成员函数指针</h2>
<h3>非静态函数指针</h3>
<p>C++非静态成员函数的指针，其值就是指向一块内存地址。但是指针不能直接调用，它需要绑定到一个对象才能调用。
例子程序如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> i=<span class="number">3</span>):a(i)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	  <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(A::*pFun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A ap;</div><div class="line">	pFun fun=&amp;A::test;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A::test);</div><div class="line">	<span class="comment">//fun();</span></div><div class="line">	(ap.*fun)();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序的输出如下：
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x4009d8</span></div><div class="line">a=<span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>由输出可以看出的确是一个真正意义上的地址指针。但是为什么一定要绑定一个对象了？我的猜想是因为该函数可能会修改成员变量，而修改成员变量必须传入对象指针，所以必须与对象绑定在一起。</p>
<h3>虚拟成员函数指针</h3>
<p>虚拟成员函数指针的值表示该函数在虚函数表中，离表头的偏移量+1。因为在通过反汇编代码知道当一个对象调用虚拟函数时，主要是通过
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">1. </span>获取指向虚函数表指针的值。</div><div class="line"><span class="bullet">2. </span>指向虚函数表指针的值加上虚函数离表头的偏移量即为该函数的地址。</div></pre></td></tr></table></figure></p>
<p>所以虚函数表示虚函数在虚函数表的偏移量+1，在、再绑定到一个对象，即可调用这个虚函数。
实例程序如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> i=<span class="number">3</span>):a(i)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	  <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(A::*pFun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A ap;</div><div class="line">	pFun fun=&amp;A::test3;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A::test1);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A::test2);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A::test3);</div><div class="line">	(ap.*fun)();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序输出如下：
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x1</span></div><div class="line"><span class="number">0x9</span></div><div class="line"><span class="number">0x11</span><span class="comment">//十进制数为17</span></div><div class="line">a=<span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>因为我这是在64位系统下跑的，所以指针大小为8字节，三个虚函数，所以输出三个地址，他们之间相差8个字节，即指针的大小.</p>
<h3>静态函数</h3>
<p>静态函数的指针的值，和静态成员指针的值一样，也是真正意义上的指针，指向内存中某个地址。</p>
<p>实例程序如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A()&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	  <span class="keyword">static</span> <span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> A::a=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pFun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A ap;</div><div class="line">	pFun fun=&amp;A::test;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A::test);</div><div class="line">	fun();<span class="comment">//opt不需要绑定到一个对象</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序输出如下：
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x400986</span></div><div class="line">a=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p><em>谈谈我对这些指针本质上的理解。</em></p>
<blockquote>
<p>一个类，当它编译，运行，实例化一个对象时，在内存中总是可以找到该对象的所有成员变量和函数地址。</p>
</blockquote>
<ol>
<li>非静态成员通过对象指针+偏移量访问。</li>
<li>虚函数可以通过对象指针加偏移量得到。</li>
<li>静态成员，非静态函数，静态函数可以通过链接时获得。</li>
</ol>
<p>所以：</p>
<ol>
<li>非静态成员指针表示一个偏移量，因为通过对象可以访问到。</li>
<li>虚函数指针表示虚函数地址在虚函数表中的偏移量。</li>
<li>静态成员，非静态函数和静态函数不能通过对象指针直接访问到，所以这三个的指针类型必须是具体的函数地址。</li>
</ol>
<blockquote>
<p>C++类访问成员的方式决定了该成员指针的类型。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 成员变量指针 </tag>
            
            <tag> 成员函数指针 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++多态实现原理]]></title>
      <url>http://luodw.cc/2015/10/09/duotai/</url>
      <content type="html"><![CDATA[<p>对C++有一定了解的人，都知道虚函数机制是实现C++多态重要条件。但是，不知道大家有没想过一个问题，提出问题之前，我先说说我对C++指针的理解。</p>
<h3>C++指针</h3>
<blockquote>
<p>C++中某种类型的指针表示内存中某一个地址以及其大小。</p>
</blockquote>
<p>关键点有两个：</p>
<ol>
<li>某一个地址：即指针的值</li>
<li>大小：指针的类型限定了指针能表示的大小。</li>
</ol>
<p>例如char *指针，它在内存中就表示一个字节的大小。int *指针，在内存中就表示4个字节的大小。
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct test</div><div class="line">&#123;</div><div class="line">	char a<span class="comment">;</span></div><div class="line">	int b<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>struct test*型指针就表示8个字节的大小，因为还有a之后要填充3个字节，为了内存对齐</p>
<p>但是对于由父类的指针指向子类的对象时，就会出现字段切割。例如：
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">A</span></div><div class="line">&#123;</div><div class="line"><span class="attribute">public</span>:</div><div class="line">	int a;</div><div class="line">&#125;;</div><div class="line"><span class="selector-tag">class</span> <span class="selector-tag">B</span><span class="selector-pseudo">:public</span> <span class="selector-tag">A</span></div><div class="line">&#123;</div><div class="line"><span class="attribute">public</span>:</div><div class="line">	int b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果A *ap=new B;这行代码首先在堆中申请一块sizeof(B)=8字节大小的内存，然后把内存地址赋给ap。但是ap的类型是A，sizeof(A)=4,所以ap只能表示B对象的前四个字节，这就出现内存切割了。</p>
<p>对于学习C/C++的工程师，一定要好好理解指针表示的意义，才能很好的掌握好C/C++这门语言。</p>
<h3>C++多态原理</h3>
<p>编写以下测试代码：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A()&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a2</span><span class="params">()</span></span>=<span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B:<span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">//cout&lt;&lt;sizeof(*this)&lt;&lt;endl;</span></div><div class="line">		a=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a2</span><span class="params">()</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	A* a=<span class="keyword">new</span> B();</div><div class="line">	a-&gt;a1();</div><div class="line">	a-&gt;a2();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>A* a=new B();这行代码，大家都知道是指针a指向堆中12（虚函数表指针8字节+a4字节）字节大小的B对象。但是a是A类型的指针，只能表示8(虚函数表指针)个字节，那么在调用a-&gt;a1()函数时，是怎么设置a值的了？因为a并不能取到8字节外的值。</p>
<blockquote>
<p>某个对象在调用自己的非static成员函数时，会将这个对象的指针作为this传进成员函数，这样才能操作这个对象的成员。</p>
</blockquote>
<p>为了上述答案，我又看了这个小程序的反汇编代码，如下：
main函数调用a1的反汇编代码：
<figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">29</span>		a-&gt;a1()<span class="comment">;</span></div><div class="line">   <span class="number">0</span>x00000000004009cd &lt;+<span class="number">48</span>&gt;:	mov    -<span class="number">0</span>x18(<span class="built_in">%rbp</span>),<span class="built_in">%rax</span><span class="comment">//将a放入rax寄存器</span></div><div class="line">   <span class="number">0</span>x00000000004009d1 &lt;+<span class="number">52</span>&gt;:	mov    (<span class="built_in">%rax</span>),<span class="built_in">%rax</span><span class="comment">//虚函数表地址放入rax</span></div><div class="line">   <span class="number">0</span>x00000000004009d4 &lt;+<span class="number">55</span>&gt;:	mov    (<span class="built_in">%rax</span>),<span class="built_in">%rax</span><span class="comment">//a1函数地址放入rax</span></div><div class="line">   <span class="number">0</span>x00000000004009d7 &lt;+<span class="number">58</span>&gt;:	mov    -<span class="number">0</span>x18(<span class="built_in">%rbp</span>),<span class="built_in">%rdx</span>在把a放入rdx</div><div class="line">   <span class="number">0</span>x00000000004009db &lt;+<span class="number">62</span>&gt;:	mov    <span class="built_in">%rdx</span>,<span class="built_in">%rdi</span><span class="comment">//把a放入rdi，rdi寄存器在调用函数时，作为传入参数只用，这句代码，其实就是成员函数传入this</span></div><div class="line">---Type &lt;<span class="keyword">return</span>&gt; to <span class="keyword">continue</span>, or <span class="keyword">q</span> &lt;<span class="keyword">return</span>&gt; to <span class="keyword">quit</span>---</div><div class="line">   <span class="number">0</span>x00000000004009de &lt;+<span class="number">65</span>&gt;:	callq  *<span class="built_in">%rax</span><span class="comment">//调用a1函数</span></div></pre></td></tr></table></figure></p>
<p>这是进入a1函数的反汇编代码：
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(gdb) b <span class="number">17</span><span class="comment">//先进入a1函数</span></div><div class="line">Breakpoint <span class="number">1</span> at <span class="number">0x400a74</span>: <span class="keyword">file</span> duotai.cc, line <span class="number">17.</span></div><div class="line">(gdb) r</div><div class="line">Starting program: /home/charles/mydir/paper_project/duotai </div><div class="line"></div><div class="line">Breakpoint <span class="number">1</span>, B::a1 (this=<span class="number">0x603010</span>) at duotai.cc:<span class="number">17</span></div><div class="line"><span class="number">17</span>			a=<span class="number">1</span>;</div><div class="line">(gdb) disas<span class="comment">//查看a1函数的反汇编代码</span></div><div class="line">Dump of assembler code <span class="keyword">for</span> function B::a1():</div><div class="line">   <span class="number">0x0000000000400a6c</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</div><div class="line">   <span class="number">0x0000000000400a6d</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</div><div class="line">   <span class="number">0x0000000000400a70</span> &lt;+<span class="number">4</span>&gt;:	mov    %rdi,<span class="number">-0x8</span>(%rbp)<span class="comment">//rdi就是main函数传进来的参数，也就是this指针</span></div><div class="line">=&gt; <span class="number">0x0000000000400a74</span> &lt;+<span class="number">8</span>&gt;:	mov    <span class="number">-0x8</span>(%rbp),%rax<span class="comment">//this放入rax</span></div><div class="line">   <span class="number">0x0000000000400a78</span> &lt;+<span class="number">12</span>&gt;:	movl   $0x1,<span class="number">0x8</span>(%rax)<span class="comment">//将1存入this指针+8字节偏移量的位置，这句代码就是a=1</span></div><div class="line">   <span class="number">0x0000000000400a7f</span> &lt;+<span class="number">19</span>&gt;:	pop    %rbp</div><div class="line">   <span class="number">0x0000000000400a80</span> &lt;+<span class="number">20</span>&gt;:	retq   </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>从反汇编代码，我们知道，在调用a1函数时，传入的是a指针，而且在设置a时，直接将a指针+8.这样就可以操作B的成员了。但是a是A类型的指针，在a1里面怎么就知道可以+8来操作B成员a了。</p>
<p>后来我就加了注释那句，在B成员函数里面输出this指针都是等于16(8字节虚函数表指针+4字节a+4字节填充)。说明编译器做了如下规定：</p>
<blockquote>
<p>不管是父类还是子类，只要是调用子类的成员方法，在子类成员方法里面，都把传入的this指针的大小设为子类对象的大小。</p>
</blockquote>
<p>这样就可以解释之前的问题了。</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 多态 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++对象模型之内存布局三]]></title>
      <url>http://luodw.cc/2015/10/08/Cplus3/</url>
      <content type="html"><![CDATA[<p>经过两天的摸索，今天终于搞清楚C++对象模型．前两篇已经讲解了单继承，多重继承和多继承的对象模型．今天讲解菱形继承，虽然过程艰难，但是收获丰富．</p>
<h3>简单虚继承对象模型</h3>
<p>首先编写如下的测试程序：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>):a1(a1),a2(a2)&#123;&#125;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">     <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">af</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::af()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">    <span class="keyword">int</span> a1;</div><div class="line">    <span class="keyword">int</span> a2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C: <span class="keyword">virtual</span> <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    C(<span class="keyword">int</span> a1=<span class="number">1</span>,<span class="keyword">int</span> a2=<span class="number">2</span>,<span class="keyword">int</span> c1=<span class="number">4</span>):A(a1,a2),c1(c1)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::f1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cf</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::cf()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">    <span class="keyword">int</span> c1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pfun)</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">     C *cp=<span class="keyword">new</span> C;</div><div class="line">    pfun fun=<span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The C's virtual table-&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</div><div class="line">    &#123;</div><div class="line">        fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)cp+i);</div><div class="line">        fun();</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"c1="</span>&lt;&lt;*((<span class="keyword">int</span>*)cp+<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"The A's virtual table-&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">     <span class="keyword">long</span>* p=(<span class="keyword">long</span>*)cp+<span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</div><div class="line">    &#123;</div><div class="line">        fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)p+i);</div><div class="line">        fun();</div><div class="line">    &#125;  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"a1="</span>&lt;&lt;*((<span class="keyword">int</span>*)p+<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">"a2="</span>&lt;&lt;*((<span class="keyword">int</span>*)p+<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述程序的输出如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_014.png" alt="简单虚基类验证程序输出">
简单解释下：</p>
<ol>
<li>当存在虚基类时，先是子类的成员，然后才是虚基类的成员．</li>
</ol>
<p>以下是C对象的对象模型：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/C++%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF1.jpg" alt="简单虚继承对象模型"></p>
<p>通过在gdb下，输入指令:
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> p obj <span class="keyword">on</span></div><div class="line"><span class="keyword">set</span> p pretty <span class="keyword">on</span> </div><div class="line">p *this(要运行到成员函数里面)</div></pre></td></tr></table></figure></p>
<p>也可以输出C对象的对象模型．截图如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_015.png" alt="通过gdb显示C对象模型"></p>
<blockquote>
<p>我在理解这个的时候，有分析过c对象调用虚基类的成员方法．通过反汇编代码，我发现当cp调用A中方法时，它先从C类的虚函数表首地址-24字节处获取Ａ子对象相对于cp的偏移量16．所以C的虚函数表首地址负方向的空间还是有研究的地方。．</p>
</blockquote>
<p>当我把Ｃ对象的函数f1改成f时，即重写A中的f方法，这时cp中A的子对象中f方法将被C的f方法替换，但是程序输出有错，原因不明。如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/C++%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF2.jpg" alt="C重写A的f方法"></p>
<h3>菱形继承下的对象模型</h3>
<p>编写如下程序：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>):a1(a1),a2(a2)&#123;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Af</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::Af()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B1:<span class="keyword">virtual</span> <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B1(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>):A(a1,a2),b1(b1)&#123;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B1::f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B1::f1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Bf1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B1::Bf1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B2:<span class="keyword">virtual</span> <span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B2(<span class="keyword">int</span> b2=<span class="number">0</span>):b2(b2)&#123;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B2::f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B2::f2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Bf2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B2::Bf2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="keyword">int</span> b2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class</span> C:  <span class="keyword">public</span> B1,<span class="keyword">public</span> B2</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	C(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>,<span class="keyword">int</span> b2=<span class="number">0</span>,<span class="keyword">int</span> c1=<span class="number">0</span>):B1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),B2(<span class="number">6</span>),c1(<span class="number">7</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::f1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::f2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Cf</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::Cf()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="keyword">int</span> c1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pfun)</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	C *cp=<span class="keyword">new</span> C;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(*bp)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	pfun fun=<span class="literal">NULL</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"The B1's virtual table-&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">	&#123;</div><div class="line">		fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)cp+i);</div><div class="line">		fun();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">long</span>* p=(<span class="keyword">long</span>*)cp+<span class="number">2</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"The B2's virtual table-&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</div><div class="line">	&#123;</div><div class="line">		fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)p+i);</div><div class="line">		fun();</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"The A2's virtual table-&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	A *ap=<span class="keyword">reinterpret_cast</span>&lt;A*&gt;((<span class="keyword">long</span>*)cp+<span class="number">4</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</div><div class="line">	&#123;</div><div class="line">		fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)ap+i);</div><div class="line">		fun();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时程序输出仍然有错，因为c重写了A中的方法。原因不明。c对象模型为：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF3.jpg" alt="菱形虚继承的对象模型"></p>
<p>如果c不重写A的f方法，即将A的f方法改为f0，则程序输出如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_016.png" alt="将A的f方法改为f0"></p>
<p>我都实在ubuntu下，g++编译器实现的。但是vs的编译器实现是不同，大家可以看陈皓大哥的博客，附上陈皓大哥的博客。</p>
<blockquote>
<p>陈皓专栏<a href="http://blog.csdn.net/haoel/article/details/3081328/" target="_blank" rel="external">http://blog.csdn.net/haoel/article/details/3081328/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 对象模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用core文件分析程序段错误]]></title>
      <url>http://luodw.cc/2015/10/08/gdb2/</url>
      <content type="html"><![CDATA[<p>经过昨天使用反汇编理解c函数栈的调用过程之后，今天阅读相关文章，发现gdb分析core文件挺有意思的，所以就研究了下．</p>
<p>我们经常在编程过程遇到过段错误，段错误出现的原因好一些，我知道就是访问栈溢出外的内存，将一块内存地址(并非函数入口)强制转化为函数指针，访问int *p=NULL指针等等，有时候我们并不知道出现错误的位置在哪，这时就可以用gdb分析．</p>
<p>这是用到的例子程序:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_core</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> a[<span class="number">100000000</span>];</div><div class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        test_core();</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要用core文件，首先要产生core文件．系统默认是不产生core文件的．通过命令
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> -c</div></pre></td></tr></table></figure></p>
<p>可以设置．默认情况下该命令的值为0，表示不产生core文件．通过命令
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ulimit -cn(<span class="name">n</span>为core文件最大值，单位kb)</div></pre></td></tr></table></figure></p>
<p>我设置为1024kb，如下图所示：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_009.png" alt="core文件产生过程"></p>
<p>接下来，我们通过gdb命令分析core文件．
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">gdb</span> ./core_test core</div></pre></td></tr></table></figure></p>
<p>程序输出如下：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_010.png" alt="gdb分析core文件界面"></p>
<p>从图片可以看出，该程序出现段错误是由test_core()函数中，第5行导致的．主要因为之前为a申请的内存太大，超出了系统允许每个进程的栈大小．默认值是8192kb，可以通过ulimit -s查看．所以当访问b时，访问的是一个超出栈的地址空间，所以出现段错误．</p>
<p>我们可以查看此时的栈帧信息，如下:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_011.png" alt="出现错误的栈帧信息">
从图中可以看出，rip寄存器指向的是指令0x400538，也就是出现段错误的位置．可以查看$rip指令处的汇编代码，如下:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_013.png" alt="段错误的指令位置">
可以查看出错的内存位置．当我们访问那个内存位置时出现可错误，因为超出栈空间．</p>
<p>参考博客：<a href="http://baidutech.blog.51cto.com/4114344/904419/" target="_blank" rel="external">http://baidutech.blog.51cto.com/4114344/904419/</a></p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
            <category> Linux </category>
            
            <category> Gdb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> linux </tag>
            
            <tag> gdb </tag>
            
            <tag> core </tag>
            
            <tag> Segmentation fault </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用gdb反汇编理解c函数栈调用过程．]]></title>
      <url>http://luodw.cc/2015/10/07/gdb/</url>
      <content type="html"><![CDATA[<p>今天在研究C++虚继承内存布局时，一直不能输出虚基类的虚函数指针，所以想通过gdb反汇编看看代码是什么问题，然后就看了一些这方面的知识．真是获益匪浅．之前写了一篇关于C程序函数栈的分配方式<a href="http://luodw.github.io/2015/09/28/cmemory/" target="_blank" rel="external">http://luodw.github.io/2015/09/28/cmemory/</a>，这篇博客将从汇编的角度解释函数栈分配方式．这里也附上之前那附图：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/C%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.jpg" alt="c函数栈布局"></p>
<p>首先编写一个非常简单的程序：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">	 <span class="keyword">int</span> accum = <span class="number">0</span>; </div><div class="line">	 <span class="keyword">int</span> t;</div><div class="line">	 t = x + y;</div><div class="line">	 accum += t;</div><div class="line">	 <span class="keyword">return</span> accum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">	   <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</div><div class="line">	   <span class="keyword">int</span> result = sum( x, y );</div><div class="line">	   <span class="built_in">printf</span>(<span class="string">"\n\n     result = %d \n\n"</span>, result);</div><div class="line">	   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先堆程序进行编译，加-g，可以得到带调试信息的可执行程序，然后在gdb程序中,
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">disas </span>main或者<span class="keyword">disas </span>sum查看这两个函数的汇编代码</div></pre></td></tr></table></figure></p>
<p>main函数的汇编代码如下，没有进行优化的代码(-O2,-O3)：
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(gdb) disas main</div><div class="line">Dump of assembler code <span class="keyword">for</span> function main:</div><div class="line">   <span class="number">0x0000000000400554</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp <span class="comment">//寄存器rbp指向一个函数栈的栈底，这句代码将调用函数的rbp压入新函数栈的栈底，腾出rbp给新函数使用．</span></div><div class="line">   <span class="number">0x0000000000400555</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp <span class="comment">//寄存器rsp，指向函数栈的栈顶，将寄存器rsp的值赋值给rbp，因为执行push %rbp之后，rsp就指向了rbp，所以此时rbp就指向了main函数的栈底．</span></div><div class="line">   <span class="number">0x0000000000400558</span> &lt;+<span class="number">4</span>&gt;:	sub    $0x20,%rsp <span class="comment">//将rsp栈顶指针向下移动32个字节，即用于开辟内存，存储该函数的局部变量</span></div><div class="line">   <span class="number">0x000000000040055c</span> &lt;+<span class="number">8</span>&gt;:	mov    %edi,<span class="number">-0x14</span>(%rbp)</div><div class="line">   <span class="number">0x000000000040055f</span> &lt;+<span class="number">11</span>&gt;:	mov    %rsi,<span class="number">-0x20</span>(%rbp)</div><div class="line">   <span class="number">0x0000000000400563</span> &lt;+<span class="number">15</span>&gt;:	movl   $0x1,<span class="number">-0xc</span>(%rbp)<span class="comment">//将1存储在rbp位置-12偏移量的位置，即x的值</span></div><div class="line">   <span class="number">0x000000000040056a</span> &lt;+<span class="number">22</span>&gt;:	movl   $0x2,<span class="number">-0x8</span>(%rbp)<span class="comment">//将2存储在rbp位置-8偏移量的位置，即y的值</span></div><div class="line">   <span class="number">0x0000000000400571</span> &lt;+<span class="number">29</span>&gt;:	mov    <span class="number">-0x8</span>(%rbp),%edx<span class="comment">//把y值存储在寄存器edx</span></div><div class="line">   <span class="number">0x0000000000400574</span> &lt;+<span class="number">32</span>&gt;:	mov    <span class="number">-0xc</span>(%rbp),%eax<span class="comment">//把x值存储在寄存器eax</span></div><div class="line">   <span class="number">0x0000000000400577</span> &lt;+<span class="number">35</span>&gt;:	mov    %edx,%esi<span class="comment">//把ｙ存储在esi，即sum参数y</span></div><div class="line">   <span class="number">0x0000000000400579</span> &lt;+<span class="number">37</span>&gt;:	mov    %eax,%edi<span class="comment">//把x存储在eax，即sum参数x</span></div><div class="line">   <span class="number">0x000000000040057b</span> &lt;+<span class="number">39</span>&gt;:	callq  <span class="number">0x40052d</span> &lt;sum&gt;<span class="comment">//call命令，跳转到sum函数，</span></div><div class="line">   <span class="number">0x0000000000400580</span> &lt;+<span class="number">44</span>&gt;:	mov    %eax,<span class="number">-0x4</span>(%rbp)<span class="comment">//将eax值（即sum函数返回值）存入rbp－4偏移量的内存位置．</span></div><div class="line">   <span class="number">0x0000000000400583</span> &lt;+<span class="number">47</span>&gt;:	mov    <span class="number">-0x4</span>(%rbp),%eax<span class="comment">//把result值放在eax，</span></div><div class="line">   <span class="number">0x0000000000400586</span> &lt;+<span class="number">50</span>&gt;:	mov    %eax,%esi<span class="comment">//把result值放在esi，即printf参数</span></div><div class="line">   <span class="number">0x0000000000400588</span> &lt;+<span class="number">52</span>&gt;:	mov    $0x400624,%edi<span class="comment">//0x400624为字符串的地址，将给地址存储在edi，printf函数的参数．</span></div><div class="line">   <span class="number">0x000000000040058d</span> &lt;+<span class="number">57</span>&gt;:	mov    $0x0,%eax</div><div class="line">   <span class="number">0x0000000000400592</span> &lt;+<span class="number">62</span>&gt;:	callq  <span class="number">0x400410</span> &lt;printf@plt&gt;<span class="comment">//调用printf函数</span></div><div class="line">   <span class="number">0x0000000000400597</span> &lt;+<span class="number">67</span>&gt;:	mov    $0x0,%eax<span class="comment">//返回值为0．</span></div><div class="line">   <span class="number">0x000000000040059c</span> &lt;+<span class="number">72</span>&gt;:	leaveq </div><div class="line">   <span class="number">0x000000000040059d</span> &lt;+<span class="number">73</span>&gt;:	retq   </div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>一些指令需要解释下，否则很难和之前那篇文章的那个图联系起来．</p>
<ol>
<li>mian函数是c或c++函数的入口地址，但是不是汇编的入口地址，汇编入口地址为_start，所以main函数也是和普通函数一样入栈出栈．</li>
<li>rbp和rsp为一个函数栈的边界，rbp指向栈底，rsp指向栈顶．</li>
<li>call 指令调用一函数时，调用函数先将参数存入esi和sdi，然后将返回地址压入栈，main函数即将0x400580压入栈，最后跳转到被调用函数执行，main函数中即地址0x40052d．</li>
<li>leaveq指令用于释放函数栈，相当于执行movl %ebp,%esp和popl %ebp即和创建栈相反过程．第一句将esp栈顶值替换为ebp的值，即将被调用函数的栈销毁，然后第二句将esp指向的调用函数的ebp值弹出，存入ebp，这时，ebp即为还原为调用函数的栈底,esp减一，指向返回地址．</li>
<li>retq指令将esp指向的返回地址弹出，存入eip寄存器中，自从调用函数栈完全销毁，程序从call指令下一条指令开始执行．</li>
</ol>
<p>接下来是sum函数的汇编代码:
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(gdb) disas sum</div><div class="line">Dump of assembler code for function sum:</div><div class="line">   <span class="number">0x000000000040052d</span> &lt;+<span class="number">0</span>&gt;:	push   <span class="symbol">%rbp</span>//将main函数的rbp压入栈</div><div class="line">   <span class="number">0x000000000040052e</span> &lt;+<span class="number">1</span>&gt;:	mov    <span class="symbol">%rsp</span>,<span class="symbol">%rbp</span>//</div><div class="line">   <span class="number">0x0000000000400531</span> &lt;+<span class="number">4</span>&gt;:	mov    <span class="symbol">%edi</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="symbol">%rbp</span>)//参数值<span class="keyword">x</span>存入sum函数栈底偏移量<span class="number">14</span>的位置</div><div class="line">   <span class="number">0x0000000000400534</span> &lt;+<span class="number">7</span>&gt;:	mov    <span class="symbol">%esi</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">18</span>(<span class="symbol">%rbp</span>)//参数值y存入sum函数栈底偏移量<span class="number">18</span>的位置</div><div class="line">   <span class="number">0x0000000000400537</span> &lt;+<span class="number">10</span>&gt;:	movl   $<span class="number">0x0</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>)//初始化accum的值，为<span class="number">0</span></div><div class="line">   <span class="number">0x000000000040053e</span> &lt;+<span class="number">17</span>&gt;:	mov    <span class="number">-0</span><span class="keyword">x</span><span class="number">18</span>(<span class="symbol">%rbp</span>),<span class="symbol">%eax</span></div><div class="line">   <span class="number">0x0000000000400541</span> &lt;+<span class="number">20</span>&gt;:	mov    <span class="number">-0</span><span class="keyword">x</span><span class="number">14</span>(<span class="symbol">%rbp</span>),<span class="symbol">%edx</span>将<span class="keyword">x</span>,y分别存入eax和edx，用于计算</div><div class="line">   <span class="number">0x0000000000400544</span> &lt;+<span class="number">23</span>&gt;:	<span class="keyword">add</span>    <span class="symbol">%edx</span>,<span class="symbol">%eax</span>//<span class="keyword">x</span>+y</div><div class="line">   <span class="number">0x0000000000400546</span> &lt;+<span class="number">25</span>&gt;:	mov    <span class="symbol">%eax</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">4</span>(<span class="symbol">%rbp</span>)//将t的值存入rbp偏移量－４的位置</div><div class="line">   <span class="number">0x0000000000400549</span> &lt;+<span class="number">28</span>&gt;:	mov    <span class="number">-0</span><span class="keyword">x</span><span class="number">4</span>(<span class="symbol">%rbp</span>),<span class="symbol">%eax</span>//把t存入eax，用于计算</div><div class="line">   <span class="number">0x000000000040054c</span> &lt;+<span class="number">31</span>&gt;:	<span class="keyword">add</span>    <span class="symbol">%eax</span>,<span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>)//将t的值和rbp偏移量为<span class="number">-8</span>的值，即accum的值相加，存入accum．</div><div class="line">   <span class="number">0x000000000040054f</span> &lt;+<span class="number">34</span>&gt;:	mov    <span class="number">-0</span><span class="keyword">x</span><span class="number">8</span>(<span class="symbol">%rbp</span>),<span class="symbol">%eax</span>//将accum值存入eax，用于返回值，main函数从eax中获取该值</div><div class="line">   <span class="number">0x0000000000400552</span> &lt;+<span class="number">37</span>&gt;:	pop    <span class="symbol">%rbp</span>//将main函数的rbp值存入rbp</div><div class="line">   <span class="number">0x0000000000400553</span> &lt;+<span class="number">38</span>&gt;:	retq   //程序指令回到main函数<span class="keyword">call</span>指令的下一条指令执行．</div><div class="line">End of assembler dump.</div></pre></td></tr></table></figure></p>
<p>有几点需要说明下:</p>
<ol>
<li>因为sum函数没有在调用其他函数，所以在sum函数内部没有将esp向下移动．esp还是指向sum函数ebp处．</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Gdb </category>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gdb </tag>
            
            <tag> 反汇编 </tag>
            
            <tag> 函数栈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++对象模型之内存布局二]]></title>
      <url>http://luodw.cc/2015/10/07/Cplus2/</url>
      <content type="html"><![CDATA[<p>上篇文章讲了无多态和有多态下的单继承的对象内存布局，这篇文章将深入讲解多重继承和多继承．</p>
<h3>多重继承</h3>
<h4>理论讲解</h4>
<p>多重继承，顾名思义，就是继承关系大于２，即至少有父类，子类，孙子类三代关系，先定义以下三个类：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A3</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A3()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span>  A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C:<span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	C(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>,<span class="keyword">int</span> c1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">C1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::C1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::A1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> c1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>类B公有继承A，类C公有继承B，图一是类C的内存布局
<img src="http://7xjnip.com1.z0.glb.clouddn.com/C++%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%803.jpg" alt="图一　多重继承内存布局"></p>
<p>其实多重继承和单继承很类似，就是在父类的基础上添加成员变量和更新虚函数表．</p>
<h4>实例讲解</h4>
<p>编写了以下程序进行验证:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A3</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A3()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span>  A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C:<span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	C(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>,<span class="keyword">int</span> c1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">C1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::C1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::A1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> c1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pfun)</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	C *bp=<span class="keyword">new</span> C;</div><div class="line">	pfun fun=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</div><div class="line">	&#123;</div><div class="line">		fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)bp+i);</div><div class="line">		fun();</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)bp+<span class="number">6</span>)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序的输出结果为：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_007.png" alt="多重继续的程序验证">
程序的输出顺序和上述给出的图一样，这就证明了我给出的内存布局图是正确的．</p>
<h3>多继承</h3>
<h4>理论讲解</h4>
<p>多继承，顾名思义就是说一个子类的父类不止一个．定义以下三个类，以及他们的继承关系：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> b1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C:<span class="keyword">public</span> A,<span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	C(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>,<span class="keyword">int</span> c1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">C1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::C1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> c1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义了三个类，类C分别继承类A和类B，类C的内存布局图二所示：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/C++%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%804.jpg" alt="图二　多继承下的内存布局"></p>
<p>多继承的内存布局和单继承和多重继承不一样，子类继承一个父类，子类就有一个虚函数表，当子类继承两个父类时，子类就有两个虚函数表；而且子类自己定义的虚函数，放在了第一个继承类的虚函数表里．</p>
<h4>程序验证</h4>
<p>编写以下程序来验证上述理论：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> b1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> C:<span class="keyword">public</span> A,<span class="keyword">public</span> B</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	C(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>,<span class="keyword">int</span> c1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">C1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::C1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"C::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> c1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pfun)</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	C *bp=<span class="keyword">new</span> C;</div><div class="line">	pfun fun=<span class="literal">NULL</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"The A's virtual table-&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</div><div class="line">	&#123;</div><div class="line">		fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)bp+i);</div><div class="line">		fun();</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"The B's virtual table-&gt;"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* p=(<span class="keyword">int</span>*)bp+<span class="number">4</span>;<span class="comment">//因为bp是指向C的第一个字节，也就是A的虚函数表地址，如果要获得B的虚函数地址，需要将该指针移到B的虚函数表地址，A的虚函数表地址(8字节)＋a1(4字节)+a2(4字节)=16字节，所以把bp转换为int*指针再加４．</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</div><div class="line">	&#123;</div><div class="line">		fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)p+i);</div><div class="line">		fun();</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)p+<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出最后虚函数结束符．</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该程序输出的结果为：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_008.png" alt="图二　多继承的验证程序输出"></p>
<p>程序的输出和上述理论给出的一样．</p>
<p>还有虚拟继承和菱形继承，留在最后一篇文章讲解．</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 对象内存模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++对象模型之内存布局一]]></title>
      <url>http://luodw.cc/2015/10/06/Cplus1/</url>
      <content type="html"><![CDATA[<p>如果想学习在linux或者在linux平台下开发，学习C/或C++是非常好的选择．俗话说，术业有专攻，学一门技术，就尽量学得深，也可以作为行走江湖，混口饭吃的一项本领．</p>
<p>对于C，当初我是看了<strong>C与指针</strong>这门书，这本书讲解了很多我没有了解过的知识点，特别是指针讲解的很到位．最后还设计了C运行时内存模型．</p>
<p>对于C++的学习，我看了<strong>C++ Primer</strong>之后，进阶的书为<strong>深入理解C++对象模型</strong>，这本书讲解了C++类在内存中是如何布局以及成员函数是怎么调用，有助于理解C++多态是如何实现的．总之，受益匪浅．</p>
<p>接下来，我将用几篇博客聊聊C++对象模型．</p>
<h2>无多态的对象布局</h2>
<h3>单个类</h3>
<p>假设有以下一个类的定义：
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=0,<span class="keyword">int</span> a2=0);</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果类没有虚函数，那么class的布局和c语言的struct布局一样，只有成员变量．对象内存布局如图１所示．</p>
<h3>继承类</h3>
<p>有一个类B继承A，定义如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span>  A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>);</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">B1</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>子类的构造函数是先构造父类，在构造子类，所以类B对象内存布局只要在A成员之后加上B的成员即可，示意图如图１：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/C++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B1.jpg" alt="图１　无多态下类内存布局"></p>
<h2>多态下对象内存布局</h2>
<h3>单个类</h3>
<p>首先定义一个类，带有虚函数：
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">A</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>);</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span>(<span class="params"></span>)</span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span>(<span class="params"></span>)</span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A3</span>(<span class="params"></span>)</span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>因为class A带有虚函数，所以A对象的内存布局就要增加一个指针，指向类A的虚函数表．对象模型如图２所示.<strong>深入理解C++对象模型</strong>将指针放在了对象的末尾，但是现在主流的编译器都将指针放在了对象的首位置．
<img src="http://7xjnip.com1.z0.glb.clouddn.com/C++%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.jpg" alt="图２ 单继承下的对象模型"></p>
<h3>单继承</h3>
<p>单继承类的定义如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span>  A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>);</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当父类有虚函数时，子类继承父类的虚函数表，而且虚函数的顺序是先父类的虚函数，再子类的虚函数；当父类的虚函数被子类重写时，则虚函数表中的父类虚函数指针要替换为子类的虚函数指针，示意图如图２．</p>
<h3>实例验证</h3>
<p>为了验证之前的对象模型是否正确，我写了如下程序进行验证：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">class</span> A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	A(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A3</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A3()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> a1;</div><div class="line">	<span class="keyword">int</span> a2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B :<span class="keyword">public</span>  A</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	B(<span class="keyword">int</span> a1=<span class="number">0</span>,<span class="keyword">int</span> a2=<span class="number">0</span>,<span class="keyword">int</span> b1=<span class="number">0</span>)&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B1()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">A2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">B2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::B2()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">	<span class="keyword">int</span> b1;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pfun)</span><span class="params">()</span></span>;<span class="comment">//定义函数指针</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	B *bp=<span class="keyword">new</span> B;</div><div class="line">	pfun fun=<span class="literal">NULL</span>;<span class="comment">//函数指针变量，用于循环迭代虚函数表</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">	&#123;</div><div class="line">		fun=(pfun)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)bp+i);<span class="comment">//因为我的ubuntu是64位的，所以用long类型．如果是32位的系统，可以用int类型．</span></div><div class="line">		fun();</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)bp+<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出虚函数表的结束符</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>稍微解释下
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span>=(<span class="title">pfun</span></span>)*((long*)*(long*)bp+i)</div></pre></td></tr></table></figure></p>
<ul>
<li>(long*)bp，将对象的指针类型转换为(long*)类型，用于取出虚函数表的地址．</li>
<li>*(long*)bp，＊为取出指针指向的值．此式子即虚函数表的地址，也就是第一个虚函数的地址．</li>
<li>(long*)*(long*)bp，将虚函数表的地址指针转换为(long*)，用于后续迭代．</li>
<li>*(long*)*(long*)bp，＊求指针值，即为第一个虚函数的地址，最后转换为pfun指针.</li>
</ul>
<p>该程序输出结果为：
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_006.png" alt="验证C++内存模型程序输出"></p>
<p>输出顺序和我上述一样．</p>
<p>多重继承，多继承以及菱形继承留在下一篇博客．</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 对象内存模型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim配色Solarized]]></title>
      <url>http://luodw.cc/2015/10/06/vimcolor/</url>
      <content type="html"><![CDATA[<p>vim配色方案由好多中，如果厌烦了系统自带的颜色，可以尝试修改vim配色，给自己个新鲜感．其中solarized配色是我最喜欢一种．
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_004.png" alt="Solarized配色">
网上很多教程是针对mac改造的，所以照着教程做下来，vim是不能显示浅蓝色背景，所以还需要Gnome-Terminal设置背景色．</p>
<h3>先改终端的配色为Solarized</h3>
<p>要先设置Terminal配色，否则ls命令下都是灰蒙蒙的．
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">clone</span> <span class="title">git</span>://github.com/seebi/dircolors-solarized.git</div></pre></td></tr></table></figure></p>
<p>dircolor-solarized 有几个配色，你可以去项目那看看说明，我自己用的是 dark256：
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp ~/dircolors-solarized/dircolors.<span class="number">256</span>dark ~/<span class="selector-class">.dircolors</span></div><div class="line">eval <span class="string">'dircolors .dircolors'</span></div></pre></td></tr></table></figure></p>
<p>设置 Terminal 支持 256 色，vim .barshrc 并添加 export TERM=xterm-256color，这样 dircolors for GNU ls 算设置完成.别忘了先 source .bashrc .接下来下载 Solarized 的Gnome-Terminal 配色：
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone gi<span class="variable">t:</span>//github.<span class="keyword">com</span>/sigurdga/gnome-terminal-colors-solarized.git</div><div class="line"><span class="keyword">cd</span> gnome-terminal-colors-solarized </div><div class="line">./set_dark.<span class="keyword">sh</span> 或./set_light.<span class="keyword">sh</span></div></pre></td></tr></table></figure></p>
<p>dark为浅蓝色背景，light为白色背景</p>
<h3>改VIM配色</h3>
<p>改完终端的配色，再改VIM的配色，只要把 solarized.vim 复制到 ~/.vim/colors/ 目录下就可以了下载地址为：
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http<span class="variable">s:</span>//github.<span class="keyword">com</span>/altercation/<span class="keyword">vim</span>-colors-solarized</div></pre></td></tr></table></figure></p>
<p>修改.vimrc：
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">syntax</span> enable</div><div class="line"><span class="keyword">set</span> background=dark</div><div class="line"><span class="keyword">colorscheme</span> solarized</div></pre></td></tr></table></figure></p>
<p>即可．</p>
]]></content>
      
        <categories>
            
            <category> Configure </category>
            
            <category> Vim </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Configure </tag>
            
            <tag> Vim </tag>
            
            <tag> Solarized </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim大杀器YouCompleteMe]]></title>
      <url>http://luodw.cc/2015/10/06/ycm/</url>
      <content type="html"><![CDATA[<p>之前看了知乎上一篇文章，如何把vim打造成IDE，看了之后，真是大开眼界，突然觉得自己一点都不懂vim了，要成为一名称职的IDE，首先智能补全是要有的，那YouCompleteMe就派上用场了．</p>
<p>YouCompleteMe是在clang/llvm基础上构建起来的．它整合了多种插件：</p>
<ul>
<li>clang_complete</li>
<li>AutoComplPop</li>
<li>Supertab</li>
<li>neocomplcache</li>
<li>Syntastic(类似功能,仅仅针对c/c++/obj-c代码)</li>
</ul>
<p>支持语言有：C,C++,obj-c,C#,python.</p>
<h3>ycm安装</h3>
<p>在vimrc中添加代码
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Bundle</span> <span class="string">'Valloric/YouCompleteMe'</span></div></pre></td></tr></table></figure></p>
<p>保存退出，打开vim，在正常模式下输入
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">:BundleInstall</span></div></pre></td></tr></table></figure></p>
<p>等待vundle将YouCompleteMe安装完成．时间较长，请耐心等待．</p>
<p>然后编译安装
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span> ~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</div><div class="line">./install.<span class="keyword">py</span> --clang-completer</div></pre></td></tr></table></figure></p>
<p>安装结束之后，打开vim，如果没有提示报错或提示，则说明安装成功了．</p>
<h3>配置ycm:</h3>
<p>ycm安装成功后，还不能代码补全提示，需要配置.ycm_extra_conf.py．之前我都是直接用网上教程的配置文件，结果都不能很好的智能提示，最好的方法还是用ycm自带的.ycm_extra_conf.py文件．
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp third_party/ycmd/examples/<span class="selector-class">.ycm_extra_conf</span><span class="selector-class">.py</span> ~/</div></pre></td></tr></table></figure></p>
<p>此时在home目录下就有.ycm_extra_conf.py文件．顺带提一下，ycm会从项目的文件开始，一步一步往上查找配置文件，如果没找到，就用.vimrc里的指明的全局文件．</p>
<p>配置.vimrc文件．在Bundle 'Valloric/YouCompleteMe'这句话之后添加
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span>=<span class="string">'~/.ycm_extra_conf.py'</span></div></pre></td></tr></table></figure></p>
<p>接着打开一个c或c++文件，即可看到代码提示了．但是还不是很智能，所以待我深入学习之
后，在补充．</p>
<blockquote>
<p>补充一</p>
</blockquote>
<p>按上述的配置还不能对C++智能补充，还需要在.ycm_extra_conf.py文件中的flags中添加C++头文件索引．
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'-isystem'</span>,</div><div class="line"><span class="string">'/usr/include/c++/4.8.2'</span></div></pre></td></tr></table></figure></p>
<p>cpp文件可以智能提示补充了．</p>
<blockquote>
<p>补充二</p>
</blockquote>
<p>在使用ycm时，但代码出现错误时，我们可以在普通模式下输入
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">:YcmDiags</span></div></pre></td></tr></table></figure></p>
<p>然后会出现Quickfix窗口，里面罗列了代码的错误．这时当光标指向错误列表某一个时，按回车键，即可跳转到错误处．</p>
<p>问题是跳转过去之后，怎么定位下一个错误了？quickfix帮助文档是说用ln，网上教程是cn但是，我这都不行，只能用鼠标点了．</p>
<p>那么怎么设置vim支持鼠标操作了．即：
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="built_in">set</span> mouse=<span class="keyword">a</span>　即可</div></pre></td></tr></table></figure></p>
<p>说明下：</p>
<p>'mouse' 选项的字符决定 Vim 在什么场合下会使用鼠标:</p>
<ul>
<li>n       普通模式</li>
<li>v       可视模式</li>
<li>i       插入模式</li>
<li>c       命令行模式</li>
<li>h       在帮助文件里，以上所有的模式</li>
<li>a       以上所有的模式</li>
<li>r       跳过 |hit-enter| 提示</li>
<li>A       在可视模式下自动选择</li>
</ul>
<p>缺省情况下'mouse'为空，即不适用鼠标．set mouse=a 等价与set mouse=nvich表示任何场合都用鼠标．</p>
]]></content>
      
        <categories>
            
            <category> Configure </category>
            
            <category> Vim </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Configure </tag>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim安装vundle和powerline]]></title>
      <url>http://luodw.cc/2015/10/05/vimconf/</url>
      <content type="html"><![CDATA[<p>上次写了一篇关于在vim下配置markdown语法高亮配置,这篇文章主要是讲如何安装Vundle和Powerline插件,这篇文章实为markdown配置高亮之前的配置,相对较简单.</p>
<ul>
<li>Vundle主要是vim用于管理插件的插件,有了它之后,安装,更新插件将变的非常简单.</li>
<li>Powerline主要是用于打造华丽状态栏的插件.</li>
</ul>
<h3>安装Vundle</h3>
<ol>
<li>
<p>首先创建目录~/.vim/bundle/vundle,系统默认是没有这个目录的,可运行如下命令:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -<span class="selector-tag">p</span> ~/.vim/bundle/vundle</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>接着从github上下载插件
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone http:<span class="regexp">//gi</span>thub.com<span class="regexp">/gmarik/</span>vundle.git ~<span class="regexp">/.vim/</span>bundle<span class="regexp">/vundle</span></div></pre></td></tr></table></figure></p>
</li>
<li>
<p>配置.vimrc文件</p>
</li>
</ol>
<p>系统默认也是没有该文件所以先创建.vimrc文件,然后访问网页<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="external">https://github.com/VundleVim/Vundle.vim</a>,查找到配置文件,但是该配置文件是教导如何在.vimrc配置安装插件,所以把其他Plugin都删除了,只留Vundle即可.
如下所以:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> nocompatible              " be iMproved, required</div><div class="line">filetype off                  " required</div><div class="line"></div><div class="line">" <span class="keyword">set</span> the runtime path to <span class="keyword">include</span> Vundle and initialize</div><div class="line"><span class="keyword">set</span> rtp+=~/.vim/bundle/Vundle.vim</div><div class="line">call vundle#begin()</div><div class="line">" alternatively, pass a path where Vundle should install plugins</div><div class="line">"call vundle#begin('~/some/path/here')</div><div class="line"></div><div class="line">" let Vundle manage Vundle, required</div><div class="line"><span class="keyword">Plugin</span> 'VundleVim/Vundle.vim</div><div class="line"></div><div class="line">" All of your Plugins must be added before the following <span class="keyword">line</span></div><div class="line">call vundle#end()            " required</div><div class="line">filetype <span class="keyword">plugin</span> indent <span class="keyword">on</span>    " required</div><div class="line">" To ignore <span class="keyword">plugin</span> indent changes, instead <span class="keyword">use</span>:</div><div class="line">"filetype <span class="keyword">plugin</span> <span class="keyword">on</span></div><div class="line">"</div><div class="line">" Brief <span class="keyword">help</span></div><div class="line">" :PluginList       - lists configured plugins</div><div class="line">" :PluginInstall    - installs plugins; <span class="keyword">append</span> `!` to <span class="keyword">update</span> or just :PluginUpdate</div><div class="line">" :PluginSearch foo - searches <span class="keyword">for</span> foo; <span class="keyword">append</span> `!` to refresh <span class="keyword">local</span> cache</div><div class="line">" :PluginClean      - confirms removal of unused plugins; <span class="keyword">append</span> `!` to auto-approve removal</div><div class="line">"</div><div class="line">" see :<span class="keyword">h</span> vundle <span class="keyword">for</span> <span class="keyword">more</span> details or wiki <span class="keyword">for</span> FAQ</div><div class="line">" Put your non-<span class="keyword">Plugin</span> stuff after this <span class="keyword">line</span></div></pre></td></tr></table></figure></p>
<ol start="4">
<li>运行vim,在普通模式下输入:PluginInstall,即可安装vundle插件.</li>
</ol>
<p>vundle下插件可以是plugin抑或bundle,所以在配置文件中将plugin改成bundle,然后在vim时输入BundleInstall也是可以安装插件的.</p>
<p>补充下配置文件几个说明:</p>
<ol>
<li>set nocompatible 不要使用vi的键盘模式,而是使用vim自己的.</li>
<li>filetype on 检查文件类型.</li>
<li>filetype plugin on 载入文件类型插件.</li>
<li>filetype indent on 为特定文件类型载入相关缩进文件.</li>
</ol>
<p>Bundle几个常用命令:</p>
<ol>
<li>更新插件 :BundleUpdate</li>
<li>清除不再使用的插件 :BundleClean</li>
<li>列出所有的插件 :BundleList</li>
<li>查找插件 :BundleSearch</li>
</ol>
<h3>安装Powerline插件</h3>
<p>平常使用vim时,大家可能习惯状态栏了,不知道原来状态栏是可以打扮的那么华丽.
系统默认状态栏为:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_001.png" alt="系统默认的状态栏">
使用Powerline插件之后:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_002.png" alt="华丽的状态栏">
状态栏不仅可以显示彩色,还可以根据不同的状态进行颜色的转换.</p>
<ol>
<li>安装Powerline插件
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Bundle</span> <span class="string">'git<span class="variable">@github</span>.com:Lokaltog/vim-powerline.git'</span></div></pre></td></tr></table></figure></li>
</ol>
<p>然后运行vim,输入:BundleInstall即可安装Powerline插件.</p>
<ol start="2">
<li>配置.vimrc文件
在.vimrc文件中输入以下设置
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> laststatus=2</div><div class="line"><span class="keyword">set</span> <span class="comment">t_Co=256</span></div><div class="line">let <span class="comment">g:Powerline_symbols=</span> <span class="comment">'unicode'</span></div><div class="line"><span class="keyword">set</span> <span class="comment">encoding=utf8</span></div></pre></td></tr></table></figure></li>
</ol>
<p>就这么简单几步,就将vim的状态栏打造为华丽的状态栏了.</p>
]]></content>
      
        <categories>
            
            <category> Configure </category>
            
            <category> Vim </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Configure </tag>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言一些低调的函数]]></title>
      <url>http://luodw.cc/2015/09/28/cfun/</url>
      <content type="html"><![CDATA[<p>C语言一些函数平时很少见,但是有时候却非常有用.也别是字符串处理函数和主函数处理函数.</p>
<h2>strchr和strrchr</h2>
<p>首先出场的是strchr和strrchr函数,原型如下:</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="function">c har *<span class="title">strchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str,<span class="keyword">int</span> ch)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str,<span class="keyword">int</span> ch)</span></span>;</div></pre></td></tr></table></figure></p>
<p>strchr函数主要功能就是查找ch在字符串str中首次出现的位置,然后函数返回指向这个位置的指针.strrchr函数功能和strchr函数基本一致,只是它查找的是ch在字符串str最后出现的位置,并返回指向这个位置的指针.</p>
<p>有以下例子:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> <span class="keyword">const</span> *p=<span class="string">"hello,world,wou!"</span>;</div><div class="line">	<span class="keyword">char</span> *ans;</div><div class="line">	ans=<span class="built_in">strchr</span>(p,<span class="string">'w'</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,ans);</div><div class="line">	ans=<span class="built_in">strrchr</span>(p,<span class="string">'w'</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,ans);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为:</p>
<p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">world,wou!</div><div class="line">wou!</div></pre></td></tr></table></figure></p>
<h2>strspn和strcspn</h2>
<p>函数原型如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="keyword">size_t</span> <span class="built_in">strspn</span>(<span class="keyword">char</span> <span class="keyword">const</span> *str,<span class="keyword">char</span> <span class="keyword">const</span> *group);</div><div class="line"><span class="keyword">size_t</span> <span class="built_in">strcspn</span>(<span class="keyword">char</span> <span class="keyword">const</span> *str,<span class="keyword">char</span> <span class="keyword">const</span> *group);</div></pre></td></tr></table></figure></p>
<p>strspn函数功能是返回str起始部分开始,与group中任意字符不匹配的第一个的位置.strcspn函数功能与strspn相反,它返回的是str起始部分开始,与group中任意字符匹配的第一个位置.</p>
<p>举个例子:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> len1,len2,len3;</div><div class="line">	<span class="keyword">char</span> buffer[]=<span class="string">"25,142,330,Smith,J,239-4123"</span>;</div><div class="line">	len1=<span class="built_in">strspn</span>(buffer,<span class="string">"0123456789"</span>);</div><div class="line">	len2=<span class="built_in">strspn</span>(buffer,<span class="string">",0123456789"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\t%d\n"</span>,len1,len2);</div><div class="line">	<span class="keyword">char</span> buffer1[]=<span class="string">"fcb74"</span>;</div><div class="line">	len3=<span class="built_in">strcspn</span>(buffer1,<span class="string">"0123456789"</span>);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,len3);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span>	<span class="number">11</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure></p>
<h2>strtok</h2>
<p>函数原型为:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">char</span> <span class="keyword">const</span> *sep)</span></span>;</div></pre></td></tr></table></figure></p>
<p>sep是字符串,定义了用作分隔符的字符集合.函数找到str的下一个标记,并将其用NULL结尾,然后返回一个指向这个标记的指针.一般的用法是第一次调用第一个参数为指向字符串的指针,之后都用NULL作为第一个参数,这样可以输出分割出的所有子字符串.</p>
<p>举个例子:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> s[] = <span class="string">"ab-cd : ef;gh :i-jkl;mnop;qrs-tu: vwx-y;z"</span>;</div><div class="line">	<span class="keyword">char</span> *delim = <span class="string">"-: "</span>;</div><div class="line">	<span class="keyword">char</span> *p;</div><div class="line">   	<span class="built_in">printf</span>(<span class="string">"%s "</span>, strtok(s, delim));</div><div class="line">    	<span class="keyword">while</span>((p = strtok(<span class="literal">NULL</span>, delim)))</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s "</span>, p);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);								   </div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;								</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为:
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ab cd ef<span class="comment">;gh i jkl;mnop;qrs tu vwx y;z</span></div></pre></td></tr></table></figure></p>
<h2>参数处理函数getopt</h2>
<p>在看UNIX进程间通信机制时,经常看到的函数就是getopt,然后平时我们又很少接触到.
函数原型为:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * <span class="keyword">const</span> argv[ ],<span class="keyword">const</span> <span class="keyword">char</span> * optstring)</span></span>;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *optarg;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optind, opterr, optopt;</div></pre></td></tr></table></figure></p>
<p>这个函数设置了几个全局变量,optarg——指向当前选项参数（如果有）的指针.optind——再次调用 getopt() 时的下一个 argv 指针的索引.optopt——最后一个未知选项</p>
<p>optstring的指定的内容的意义(例如getopt(argc,argv,&quot;ab:c:de::&quot;);</p>
<ol>
<li>单个字符,表示选项,例如上述函数参数,可以在运行程序时,添加选项-a</li>
<li>单个字符后街一个冒号:表示该选项后必须跟一个参数,参数紧跟在选项后或者空格隔开.该参数的指针赋给optarg,例如可以添加-b 123</li>
<li>单个字符后跟两个冒号::,表示后面可以跟一个参数或者不跟.</li>
</ol>
<p>举个例子:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> ch;</div><div class="line">  opterr=<span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">while</span>((ch=getopt(argc,argv,<span class="string">"a:b::cde"</span>))!=<span class="number">-1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"optind:%d\n"</span>,optind);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"optarg:%s\n"</span>,optarg);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"ch:%c\n"</span>,ch);</div><div class="line">    <span class="keyword">switch</span>(ch)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'a'</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"option a:'%s'\n"</span>,optarg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'b'</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"option b:'%s'\n"</span>,optarg);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'c'</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"option c\n"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'d'</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"option d\n"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'e'</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"option e\n"</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"other option:%c\n"</span>,ch);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"optopt+%c\n"</span>,optopt);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以这样来调用上述程序:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./<span class="selector-tag">a</span><span class="selector-class">.out</span> -a1234 -b432 -c -d</div></pre></td></tr></table></figure></p>
<p>输出为:
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="string">optind:</span><span class="number">2</span></div><div class="line"><span class="string">optarg:</span><span class="number">1234</span></div><div class="line"><span class="string">ch:</span>a</div><div class="line">option <span class="string">a:</span><span class="string">'1234'</span></div><div class="line">optopt+</div><div class="line"><span class="string">optind:</span><span class="number">3</span></div><div class="line"><span class="string">optarg:</span><span class="number">432</span></div><div class="line"><span class="string">ch:</span>b</div><div class="line">option <span class="string">b:</span><span class="string">'432'</span></div><div class="line">optopt+</div><div class="line"><span class="string">optind:</span><span class="number">4</span></div><div class="line"><span class="string">optarg:</span>(<span class="literal">null</span>)</div><div class="line"><span class="string">ch:</span>c</div><div class="line">option c</div><div class="line">optopt+</div><div class="line"><span class="string">optind:</span><span class="number">5</span></div><div class="line"><span class="string">optarg:</span>(<span class="literal">null</span>)</div><div class="line"><span class="string">ch:</span>d</div><div class="line">option d</div><div class="line">optopt+</div></pre></td></tr></table></figure></p>
<p>要理解上述输出,先分析参数</p>
<ol>
<li>argc=5;</li>
<li>argv[0]=a.out</li>
<li>argv[1]=-a1234</li>
<li>argv[2]=-b432</li>
<li>argv[3]=-c</li>
<li>argv[4]=-d</li>
</ol>
<p>getopt函数中的argc和argv即为main函数参数argc和argv.全局变量optind默认值为1,所以getopt第一次读取的参数为argv[1],然后optind+1.所以第一次输出optind=2,argv[1]的选项为a,参数字符串为1234.</p>
<p>如果getopt找不到符合的参数则会印出错误的信息,并将全局变量optopt设为&quot;?&quot;字符.
上述输出均为字符&quot;+&quot;,则说明找到了符合的参数,没有出错.后面的分析和上面一样.</p>
<p>如果不希望getopt打印出错误信息,只有将全局变量opterr设为即可.</p>
<p><strong>参考</strong></p>
<blockquote>
<p>C与指针</p>
<p>雪精灵的专栏博客 <a href="http://blog.csdn.net/baixue6269/article/details/7550184" target="_blank" rel="external">http://blog.csdn.net/baixue6269/article/details/7550184</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> C函数 </tag>
            
            <tag> strchr </tag>
            
            <tag> strtok </tag>
            
            <tag> getopt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C/C++运行时内存环境]]></title>
      <url>http://luodw.cc/2015/09/28/cmemory/</url>
      <content type="html"><![CDATA[<p>在学习C/C++的过程中,熟悉程序在内存的布局环境是很有必要的,也体现着一个合格C/C++程序员必备的素质.例如运行时申请的内存在哪了?共享内存在进程哪块内存中?全局变量为何在所有函数都要效等等...</p>
<p>&lt;!--more--&gt;</p>
<h3>C程序内存布局</h3>
<p>C程序在内存中由栈,堆,BSS段,数据段,代码段组成,如下图所示:</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/C%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="C程序内存布局"></p>
<p>Linux将虚拟内存分为内核态和用户态,内核态为1GB,用户态为3G,每个程序都各自占有自己的3GB内存,不同的进程不能互相访问变量,除非使用Linxu进程间通信机制,有时间把<strong>进程间通信机制</strong>发上来.</p>
<ul>
<li>
<p>栈:是由系统自动分配和释放的,存储局部变量,由高地址往低地址.例如在某个函数foo中定义的局部变量,int vari,char *p,struct book *b等等,这些变量都存储在栈中,当foo函数结束后,这些变量自动销毁,系统回收内存.</p>
</li>
<li>
<p>堆:自由存储区.堆区内存是由程序员自己申请和释放的,由低地址向高地址.C语言用函数malloc申请,C++用函数new申请.例如,char *p=new char.那么new char申请的内存在堆中,p存储在栈中,并指向堆中刚申请的内存.</p>
</li>
<li>
<p>缓冲区:缓冲区是一块很大内存,这样一来,栈和堆是不会相交的.进程共享内存也是存在这块内存中.</p>
</li>
<li>
<p>数据段和BSS:合称静态区(全局区).存储静态和全局变量.数据段主要是存储已初始化的全局变量,静态变量(全局和局部)和常量数据(字符串常量).BSS区存储为初始化的全局未初始化变量.</p>
</li>
<li>
<p>代码段:主要是存储程序运行的代码.为只读.</p>
</li>
</ul>
<h3>C程序函数栈分配方式</h3>
<p>分析完程序的内存布局之后,接下来,分析下c函数栈的分配.示意图如下;</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/C%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.jpg" alt="C程序函数栈的分配方式"></p>
<p>假如由以下代码:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> sum;</div><div class="line">	sum=a+b;</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a,b,result=<span class="number">0</span>;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</div><div class="line">	result=sum(a,b);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,result);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>则当在main函数中调用sum函数时,sum函数的栈布局如上图所示.</p>
<ol>
<li>main函数首先将参数按从右到左的顺序(即先b在a)压入栈,接着把返回地址压入栈.</li>
<li>程序跳转到sum函数中,sum函数将原BP指针压入栈,然后BP新值即为原BP值的地址.BP称为帧指针,通过BP添加偏移量即可取参数返回地址以及局部变量.例如参数2可以通过BP+12获得,返回地址通过BP+4获得等等.</li>
<li>sum函数把局部变量压入局部变量内存区,地址从低地址向高地址.这就解决我之前一个困惑.先前提到栈是从高地址向低地址的,但是我们平时在编程过程中,申请一个数组,然后数组的指针是加1,向高地址走的.原因就在此.</li>
<li>最后就是通用寄存器.因为被调用的函数可能更改调用函数中存储数据的寄存器,所以要在被调用函数中保存原寄存器的值,然后被调用函数结束之后,在把这些值弹出到寄存器中.</li>
</ol>
<p>当被调用函数<strong>sum函数</strong>结束之后,返回值被存储在寄存器EAX中,然后调用函数<strong>main函数</strong>从寄存器EAX中获取返回值.</p>
<p>至此,C程序运行时内存环境就分析完了.</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 内存布局 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim配置markdown语法高亮]]></title>
      <url>http://luodw.cc/2015/09/26/vim-md/</url>
      <content type="html"><![CDATA[<p>linux下写markdown,目前还没看到很优秀的编辑器,sublime是一款非常不错都编辑器,可是对中文支持不是很好,所以只能投向与<strong>vim</strong>的怀抱.</p>
<p>&lt;!--more--&gt;</p>
<p>vim有一个插件markdown对markdown提供语法高亮支持,非常实用,安装如下:</p>
<ul>
<li>github下载: <a href="https://github.com/plasticboy/vim-markdown" target="_blank" rel="external">https://github.com/plasticboy/vim-markdown</a></li>
<li>解压之后有两个文件夹,syntax和ftdetect,里面都含有文件markdown.vim,将两个文件拷贝到$VIM下对用的syntax和ftdetect,没有的话,则自己新建.可以执行以下命令:
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cp</span> ./<span class="keyword">syntax</span>/markdown.<span class="keyword">vim</span> ~/.<span class="keyword">vim</span>/<span class="keyword">syntax</span>/</div><div class="line"><span class="keyword">cp</span> ./ftdetect/markdown.<span class="keyword">vim</span> ~/.<span class="keyword">vim</span>/ftdetect/</div></pre></td></tr></table></figure></li>
</ul>
<p>一切就是这么简单，复制到对应目录，然后重启你的vim就ok了。</p>
<h4>插件内容</h4>
<p>尽管名字相同，两个文件夹中的文件是不同的。</p>
<ol>
<li>syntax中的 mkd.vim 是关键的语法解析文件，里面是关于语法高亮的详细定义。</li>
<li>ftdetect中的 mkd.vim 定义的是自动解析哪些文件。</li>
</ol>
<p>下面是github最新版本中的定义方式，支持的后缀名包括花括号中的内容，如果有新的定义，可以自己加.</p>
<p>au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}   set filetype=mkd</p>
]]></content>
      
        <categories>
            
            <category> Configure </category>
            
            <category> Vim </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Configure </tag>
            
            <tag> Vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux一些软件配置]]></title>
      <url>http://luodw.cc/2015/09/25/config/</url>
      <content type="html"><![CDATA[<p>平时在用linux安装软件时的一些配置,记录下来</p>
<h4>安装eclipse在桌面创建图标</h4>
<p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">首先：gedit /usr/share/applications/eclipse.desktop</div><div class="line">内容输入：</div><div class="line">[Desktop Entry]</div><div class="line">Encoding=UTF-<span class="number">8</span></div><div class="line">Name=Eclipse</div><div class="line">Comment=Eclipse IDE</div><div class="line">Exec=/usr/local/android/eclipse/eclipse</div><div class="line">Icon=/usr/local/android/eclipse/icon.xpm</div><div class="line">Terminal=<span class="literal">false</span></div><div class="line">StartupNotify=<span class="literal">true</span></div><div class="line">Type=Application</div><div class="line">Categories=Application;Development;</div><div class="line">eclipse配置CDT，到官网下载CDT，http:<span class="comment">//www.eclipse.org/cdt/，然后安装</span></div></pre></td></tr></table></figure></p>
<h4>安装MySQL</h4>
<p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">执行sudo apt-get <span class="keyword">install</span> mysql-<span class="keyword">server</span> mysql-<span class="keyword">client</span>进行安装 MySQL。</div><div class="line">mysql  用户名:root   密码：root</div></pre></td></tr></table></figure></p>
<h4>VIM换行缩进</h4>
<p><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">在主目录下新建．vimrc文件，在该文件中输入一下内容</div><div class="line"><span class="keyword">set</span> tabstop=4 </div><div class="line"><span class="keyword">set</span> <span class="comment">softtabstop=4</span> </div><div class="line"><span class="keyword">set</span> <span class="comment">shiftwidth=4</span> </div><div class="line"><span class="keyword">set</span> <span class="comment">noexpandtab</span> </div><div class="line"><span class="keyword">set</span> <span class="comment">nu</span>  </div><div class="line"><span class="keyword">set</span> <span class="comment">autoindent</span> </div><div class="line"><span class="keyword">set</span> <span class="comment">cindent</span></div><div class="line">解释：Tabstop:表示一个 tab 显示出来是多少个空格的长度<span class="comment">?</span>默认<span class="comment"> 8</span>。</div><div class="line">Softtabstop:表示在编辑模式的时候按退格键的时候退回缩进的长度?当使用 expandtab 时特别有用。</div><div class="line">Shiftwidth:表示每一级缩进的长度?一般设置成跟 softtabstop 一样。 当设置成<span class="comment"> expandtab</span> 时<span class="comment">?</span>缩进用空格来表示<span class="comment">?noexpandtab</span> 则是用制表符表示一个缩进。</div><div class="line">Nu:表示显示行号。</div><div class="line">Autoindent:表示自动缩进。</div><div class="line">Cindent:是特别针对C语言自动缩进</div></pre></td></tr></table></figure></p>
<h4>Linux配置Hiredis</h4>
<p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">博客地址：<span class="string">http:</span><span class="comment">//www.ithao123.cn/content-998027.html</span></div></pre></td></tr></table></figure></p>
<h4>静态链接库和动态链接库</h4>
<p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">静态链接库只需放在可执行程序同一个文件夹下即可，程序编译的时候,</div><div class="line">    gcc test.c libtest.a -o test即可</div><div class="line">动态链接库必须放在系统可查询的目录下，调用时加-l，顺序如下：</div><div class="line">　　<span class="number">1</span>.首先查询/etc/ld.so.conf.d目录下所有*.conf文件中的路径;</div><div class="line">    <span class="number">2</span>./usr/<span class="class"><span class="keyword">lib</span></span></div><div class="line">    <span class="number">3</span>./<span class="class"><span class="keyword">lib</span></span></div><div class="line">    如果是通过make install添加的动态链接库，则可以什么都不要做；</div><div class="line">    但是，如果是自己复制黏贴进相应的目录的时候，则需要运行命令ldconfig，</div><div class="line">将新添加的动态链接库的信息添加进ld.so.cache缓冲，不然会报错，找不到相</div><div class="line">应的库函数</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Configure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Configure </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Sublime3支持C++智能提示]]></title>
      <url>http://luodw.cc/2015/09/25/sublime/</url>
      <content type="html"><![CDATA[<p>sublime3是一款非常好的编辑器,用它来敲写代码是一个非常棒的利器. SublimeClang是C++自动补全插件,功能强大.</p>
<p>首先要安装<strong>Package Control</strong>,一个用于管理插件的好工具,可以用于安装,删除,禁用相应的插件.安装如下:</p>
<ol>
<li>点击Preferences &gt; Browse Packages菜单</li>
<li>进入打开的目录的上层目录，然后再进入Installed Packages/目录</li>
<li>下载Package Control.sublime-package<a href="https://sublime.wbond.net/Package%20Control.sublime-package" target="_blank" rel="external">https://sublime.wbond.net/Package Control.sublime-package</a>并复制到Installed Packages/目录</li>
<li>重启Sublime Text。</li>
</ol>
<p>重新启动SublimeText 3，然后使用快捷键Ctrl + Shift + p，在弹出的输入框中输入Package Control则可以看到Install Package的选项，选择它后一会儿（看左下角的状态）会弹出插件查询及安装窗口，输入想用的插件，选中回车即可。</p>
<p>SublimeClang是Sublime Text中唯一的C/C++自动补全插件，功能强大，自带语法检查功能，不过最近作者已经停止更新了，目前只能在Sublime Text 2的Package Control中可以找到并自动安装，在SublimeText 3中只能手动通过源码安装，其代码线在<a href="https://github.com/quarnster/SublimeClang%E4%B8%AD" target="_blank" rel="external">https://github.com/quarnster/SublimeClang中</a></p>
<p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">安装相关软件</div><div class="line">sudo apt-<span class="built_in">get</span> install cmake build-essential clang git</div><div class="line"><span class="keyword">cd</span> ~/.config/sublime-text-<span class="number">3</span>/Packages</div><div class="line">git clone --recursive http<span class="variable">s:</span>//github.<span class="keyword">com</span>/quarnster/SublimeClang SublimeClang</div><div class="line"><span class="keyword">cd</span> SublimeClang</div><div class="line"><span class="keyword">cp</span> /usr/lib/x86_64-linux-gnu/libclang-<span class="number">3.4</span>.<span class="keyword">so</span>.<span class="number">1</span> internals/libclang.<span class="keyword">so</span>   #这一步很重要，如果你的clang库不是<span class="number">3.4</span>版本的话，请将对应版本的库拷贝到internals中</div><div class="line"><span class="keyword">cd</span> src</div><div class="line"><span class="built_in">mkdir</span> build</div><div class="line"><span class="keyword">cd</span> build</div><div class="line">cmake ..</div><div class="line"><span class="keyword">make</span></div></pre></td></tr></table></figure></p>
<p>一切成功的话将会在SublimeClang/internals目录中生成libcache.so库文件。重启Sublime Text，然后按快捷键Ctrl + `(Esc下面那个键)打开自带的控制输出，看看有没有错误，如果没有错误就说明一切OK了</p>
<blockquote>
<p>摘自Cynric 的博客 <a href="http://blog.csdn.net/cywosp/article/details/32721011" target="_blank" rel="external">http://blog.csdn.net/cywosp/article/details/32721011</a></p>
</blockquote>
<blockquote>
<p>Written with <a href="https://stackedit.io/" target="_blank" rel="external">StackEdit</a>.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Configure </category>
            
            <category> Sublime </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Configure </tag>
            
            <tag> Sublime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++句柄类]]></title>
      <url>http://luodw.cc/2015/09/24/cppp3/</url>
      <content type="html"><![CDATA[<p>假设有一个父类base，然后从base继承了多个子类base1，base2等等，C++句柄类主要是用来管理
多个子类，统一个的接口，不同的操作．句柄类需要智能指针的基础知识和多态的知识，句柄类其实
就是智能指针＋多态知识．如果，对智能指针不是很了解，可以查看我上篇博客．</p>
<p>&lt;!--more--&gt;</p>
<p>直接看代码如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">class</span> animal</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> animal* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>=<span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">haul</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> cat:<span class="keyword">public</span> animal</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    cat(<span class="built_in">std</span>::<span class="built_in">string</span> n):name(n)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"create cat:"</span>&lt;&lt;name&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    ~cat()&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> animal* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> cat(*<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">" \teat"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">haul</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;name &lt;&lt;<span class="string">" \thaul"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> dog:<span class="keyword">public</span> animal</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    dog(<span class="built_in">std</span>::<span class="built_in">string</span> n):name(n)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"create dog:"</span>&lt;&lt;name&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    ~dog()&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> animal* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> dog(*<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="string">" \teat"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">haul</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;name &lt;&lt;<span class="string">" \thaul"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> handle</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    handle():an(<span class="literal">NULL</span>),use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>))&#123;&#125;</div><div class="line">    handle(<span class="keyword">const</span> animal&amp;);</div><div class="line">    handle(<span class="keyword">const</span> handle&amp; h):an(h.an),use(h.use)&#123;++*use;&#125;</div><div class="line">    handle&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> handle&amp;);</div><div class="line">    ~handle()&#123;decr_use();&#125;</div><div class="line">    <span class="keyword">const</span> animal* <span class="keyword">operator</span>-&gt;()<span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span>(an) </div><div class="line">            <span class="keyword">return</span> an;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> (animal*)<span class="number">-1</span>;&#125;</div><div class="line">    <span class="keyword">const</span> animal* <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span>(an) </div><div class="line">            <span class="keyword">return</span> an;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> (animal*)<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    animal *an;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> *use;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decr_use</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (--*use==<span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//std::cout&lt;&lt;"use is = "&lt;&lt;*use&lt;&lt;std::endl;</span></div><div class="line">            <span class="keyword">delete</span> an;</div><div class="line">            <span class="keyword">delete</span> use;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">handle::handle(<span class="keyword">const</span> animal &amp;an):an(an.clone()),use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>))&#123;    &#125;</div><div class="line"></div><div class="line">handle&amp; handle::<span class="keyword">operator</span>=(<span class="keyword">const</span> handle&amp; h)</div><div class="line">&#123;</div><div class="line">    ++*h.use;</div><div class="line">    decr_use();</div><div class="line">    an=h.an;</div><div class="line">    use=h.use;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">以下是测试函数，</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"smart_ptr.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">cat <span class="title">c</span><span class="params">(<span class="string">"tom"</span>)</span></span>;</div><div class="line">    <span class="function">dog <span class="title">d</span><span class="params">(<span class="string">"jim"</span>)</span></span>;</div><div class="line">    <span class="function">handle <span class="title">h</span><span class="params">(c)</span></span>;</div><div class="line">    h-&gt;eat();<span class="comment">//通过重载-&gt;操作符实现</span></div><div class="line">    (*h)-&gt;haul();<span class="comment">//通过重载*操作符实现</span></div><div class="line"></div><div class="line">    <span class="function">handle <span class="title">h1</span><span class="params">(d)</span></span>;</div><div class="line">    h1-&gt;eat();</div><div class="line">    (*h1)-&gt;haul();</div><div class="line">    <span class="comment">// handle *h2=new handle(h);</span></div><div class="line">    <span class="comment">// delete h2;</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为：</p>
<p><img src="http://img.blog.csdn.net/20150901172818103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>可以看到通过传给句柄类不同的子类，同样的接口却调用不同的子类的函数，实现了多态．我注释掉的那两行，
主要时用来验证智能指针的，因为有指针成员，必须使用智能指针，保证指针安全．</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++智能指针]]></title>
      <url>http://luodw.cc/2015/09/24/cppp2/</url>
      <content type="html"><![CDATA[<p>最近楼主在深入学习C++，发现智能指针和句柄类挺有意思的，而且也有点难度，所以就写下来，日后可以回顾．
这篇博文先介绍智能指针，下篇介绍句柄类．</p>
<p>C++中，如果类中有指针类型的数据成员，则很容易出现悬垂指针，即一个指向无效内存的地址．如下：</p>
<p>&lt;!--more--&gt;</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">class</span> HasPtr&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HasPtr(<span class="keyword">int</span> *p):ptr(p)&#123;&#125;</div><div class="line">    HasPtr(<span class="keyword">const</span> HasPtr&amp; hptr):ptr(hptr.ptr)&#123;&#125;</div><div class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; hptr)</div><div class="line">    &#123;</div><div class="line">        ptr=hptr.ptr;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    ~HasPtr()&#123;</div><div class="line">        <span class="keyword">delete</span> ptr;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"The value of ptr is: "</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> *ptr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里定义了一个简单类，公有成员有构造函数，复制构造函数，赋值重载操作符和简单输出指针值．</p>
<p>下面代码简单调用这个类：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HasPtr.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> *ip=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</div><div class="line">　　<span class="function">HasPtr <span class="title">ptr</span><span class="params">(ip)</span></span>;</div><div class="line">　　 ptr.print();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数输出如下：</p>
<p><img src="http://img.blog.csdn.net/20150901210652405?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>接下来，我new一个HasPtr，复制ptr，然后把这个新生产的HasPtr给delete掉，则输出发生了变化，代码如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"HasPtr.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> *ip=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>);</div><div class="line">    <span class="function">HasPtr <span class="title">ptr</span><span class="params">(ip)</span></span>;</div><div class="line">    HasPtr *new_ptr=<span class="keyword">new</span> HasPtr(ptr);</div><div class="line">    <span class="keyword">delete</span> new_ptr;</div><div class="line">    ptr.print();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：</p>
<p><img src="http://img.blog.csdn.net/20150901172457459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>问题来了，为什么ptr的输出值为０了？</p>
<p>原来这是因为new_ptr在复制ptr时，只是简单的指针值赋值，也就是说这两个对象的ptr指向的是堆中的
同一个变量，当new_ptr销毁时，把ptr的指针指向的成员都销毁了，这样的输出是没定义的，因为ptr的
指针指向的时一块无效的内存．有没解决的办法了？有，这时智能指针的就派上用场了．</p>
<p>智能指针主要思想就是添加一个计数成员变量（＜＜C++ Primer＞＞用的时技术类，思想一样），
当进行类复制或赋值时，这时类计数成员变量要加１，表示有多少个类引用指针变量，当销毁一个类时，
要判断计数成员是否为０，如果为０，则表示没有对象引用该指针指向的内存，可以delete，
如果不为０，则析构函数啥都不做．代码如下：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">class</span> HasPtr&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    HasPtr(<span class="keyword">int</span> *p):ptr(p),use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>))&#123;&#125;</div><div class="line">    HasPtr(<span class="keyword">const</span> HasPtr&amp; hptr):ptr(hptr.ptr),use(hptr.use)&#123; ++*use;&#125;</div><div class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; hptr)</div><div class="line">    &#123;</div><div class="line">        ++*hptr.use;</div><div class="line">        decr_use();<span class="comment">//这个过程主要是删除被复制对象的自身成员，防止内存泄露</span></div><div class="line">        ptr=hptr.ptr;</div><div class="line">        use=hptr.use;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    ~HasPtr()&#123;</div><div class="line">        decr_use();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"The value of ptr is: "</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> *ptr;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> *use;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decr_use</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (--*use==<span class="number">0</span>)<span class="comment">//判断是否是最后一个引用指针指向的内存</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">delete</span> ptr;</div><div class="line">            <span class="keyword">delete</span> use;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样改变之后，输出的结果就还是42，而不是０．</p>
<p><img src="http://img.blog.csdn.net/20150901172350764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[c语言字符数组一些启示]]></title>
      <url>http://luodw.cc/2015/09/23/cpp1-md/</url>
      <content type="html"><![CDATA[<p>最近博主在学习《linux系统编程》，所以想记下来学习的一些心得，与大家分享，也备以后回顾只用。
　　第一天，就从我在今天学习过程遇到的问题写起，博主今天在学习标准IO库，遇到一个问题，
关于字符指针的问题，代码如下：</p>
<p>&lt;!--more--&gt;</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  FILE *stream;</div><div class="line">  <span class="keyword">char</span> *s;</div><div class="line">  <span class="keyword">int</span> c;</div><div class="line">  <span class="keyword">int</span> n=<span class="number">6</span>;</div><div class="line">  stream=fopen(<span class="string">"./test.txt"</span>,<span class="string">"r"</span>);</div><div class="line"><span class="keyword">while</span>(--n&gt;<span class="number">0</span> &amp;&amp; (c=fgetc(stream))!=EOF)</div><div class="line">&#123;</div><div class="line">  *s++=c;</div><div class="line">&#125;</div><div class="line">  *s=<span class="string">'\0'</span>;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"s=%s\n"</span>,s);</div><div class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本程序很简单，就是以标准流的形式打开一个文件，然后从文件读取n-1个字符，但是运行这个程序的时候，会出现段错误，百度之后，得知，是因为使用了未申请的内存或者申请的内存有错误，那么问题出现在哪了？
　　通过查资料得知问题出现在char <em>s 和</em>s++=c。因为在程序中，字符指针没有初始化，即没有给该指针赋值（s不知道指向何处），那么如果给该指针赋值，那么值不知存哪去，而s++也没有意义。所以应该先给s赋值一个地址字符数组的地址，然后在往这个地址赋值，加1赋值等等。所以改进代码如下</p>
<p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> #include&lt;stdio.h&gt;</div><div class="line"> <span class="number">2</span> #include&lt;stdlib.h&gt;</div><div class="line"> <span class="number">3</span> </div><div class="line"> <span class="number">4</span> int main()</div><div class="line"> <span class="number">5</span> &#123;</div><div class="line"> <span class="number">6</span>     FILE *stream;</div><div class="line"> <span class="number">7</span>     char *s;</div><div class="line"> <span class="number">8</span>     char str[<span class="number">1024</span>];</div><div class="line"> <span class="number">9</span>     s=str;</div><div class="line"><span class="number">10</span>     int c;</div><div class="line"><span class="number">11</span>     int n=<span class="number">6</span>;</div><div class="line"><span class="number">12</span>     stream=fopen(<span class="string">"./test.txt"</span>,<span class="string">"r"</span>);</div><div class="line"><span class="number">13</span>     while(--n&gt;<span class="number">0</span>  &amp;&amp;  (c=fgetc(stream))!=<span class="literal">EOF</span>)</div><div class="line"><span class="number">14</span>     &#123;   </div><div class="line"><span class="number">15</span>         *s++=c;</div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span>     *s='\<span class="number">0</span>';</div><div class="line"><span class="number">18</span>     printf(<span class="string">"s=%s<span class="subst">\n</span>"</span>,str);</div><div class="line"><span class="number">19</span>     exit(<span class="number">0</span>);</div><div class="line"><span class="number">20</span> &#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下图所示：
<img src="http://img.blog.csdn.net/20150219205507506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE5NzI5NDk3Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="运行结果">
　　由于较少使用c语言，所以一些基本的知识点都忘了，所以我也感受到了，学习语言一定要多写，看着都懂，但是当自己写的时候，就会碰到各种细节问题。平时看起来很简单的问题，当自己亲身躬为的时候，有时候并不是那么简单。
　　可能我写很基础或不是完全正确，希望大神可以指点指点。</p>
]]></content>
      
        <categories>
            
            <category> C/C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis安装与运行]]></title>
      <url>http://luodw.cc/2015/09/23/redis-basic/</url>
      <content type="html"><![CDATA[<p>Redis是一个key-value存储系统，即键值对非关系型数据库，和Memcached类似，目前正在被越来越多的互联网公司采用。本教程只是简易的教程，指导大家如何安装运行Redis以及简单地操作Redis。如果要深入学习Redis，可以参考文章末尾的链接。</p>
<p>&lt;!--more--&gt;</p>
<p>Redis支持存储的value类型包括string(字符串)、list(链表)、set(集合)和zset(有序集 合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类keyvalue存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。</p>
<h2>Redis安装</h2>
<p>首先，从网站  <a href="https://github.com/dmajkic/redis/downloads" target="_blank" rel="external">https://github.com/dmajkic/redis/downloads</a>  下载Redis最新版本2.4.5，然后解压至计算机某个磁盘中即可。接着运行两个Doc窗口，一个用户Redis服务器，一个用于Redis客户端。两个Doc窗口都进入Redis数据库根目录，服务器窗口在根目录下输入redis-server redis.conf即可运行Redis服务器，如图7.2.1所示</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/redis-server.png" alt="图7.2.1 启动Redis服务器"></p>
<p>客户端在根目录下输入redis-cli，即可运行Redis客户端，如图7.2.2所示</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/redis-cli.png" alt="图7.2.2启动Redis客户端"></p>
<p>此时，服务器端显示接受一个客户端，显示为IP地址：端口，如图7.2.3所示</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/QQ%E6%88%AA%E5%9B%BE20150913220408.png" alt="图7.2.3 Redis显示接受一个客户端"></p>
<p>至此，Redis运行成功，接下来，即可操作Redis存取数据。</p>
<h2>Redis实例演示</h2>
<p>本实验用的数据为如下三个表格：</p>
<p>学生表格：</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/QQ%E5%9B%BE%E7%89%8720150922203728.png" alt="学生表格"></p>
<p>课程表格：</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/QQ%E5%9B%BE%E7%89%8720150922203801.png" alt="课程表格"></p>
<p>成绩表格：</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/QQ%E5%9B%BE%E7%89%8720150922203733.png" alt="成绩表格"></p>
<p>本部分实验的数据如上，必须先把数据存入Redis。关系数据库转化为KV键值数据库，并不是简单的set key value，因为表格之间存在着关系，所以我们采用如下方法：
　　　　　　　　　　　　　　　　　　　Key=表名：主键值：列名
　　　　　　　　　　　　　　　　　　　　　Value=列值
例如，对于之前数据的存入，可以按如图7.2.4方式存入：</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/%E5%AE%9E%E4%BE%8B%E6%88%AA%E5%9B%BE2.png" alt="图7.2.4 Redis实例数据库插入"></p>
<p>针对之前存入的数据，我们在这简单地演示Redis的增删改查。Redis支持5中数据类型，不同数据类型，增删改查可能不同，这里用最简单的数据类型字符串作为演示。</p>
<h3>Redis插入数据</h3>
<p>Redis插入一条数据，只需要先设计好键值，然后用set命令存入即可。例如在课程表插入新的课程算法，4学分，所以可输入set Course:8:Cname 算法和set Course:8:Ccredit 4，如图7.2.5所示;</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/insert.png" alt="图7.2.5 Redis插入数据"></p>
<h3>Redis修改数据</h3>
<p>Redis并没有修改数据的命令，所以如果在Redis中要修改一条数据，只能在使用set命令时，使用同样的键值，然后用新的value值来覆盖旧的数据。例如修改新添加的课程，名字改为编译原理，则图7.2.6所示：</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/update.png" alt="图7.2.6 Redis修改数据"></p>
<p>先调用get命令，输出原先的值，然后set新的值，最后再get得到新值，所以修改成功。</p>
<h3>Redis删除数据</h3>
<p>Redis有专门删除数据的命令del，用法为del key值即可。所以如果要删除之前新增的课程编译原理，只需输入命令del Course:8:Cname，同时还应该把本课程的学分删除del Course:8:Ccredit，如图7.2.7所示;</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/delete.png" alt="图7.2.7 Redis删除数据"></p>
<p>当输入del Course:8:Cname时，返回1，说明成功操作一条数据。当再次输入get命令时，输出为空，说明删除成功。</p>
<h3>Redis查询数据</h3>
<p>Redis最简单的查询方式为用get命令，之前的图例已有展示。如果要进行关系数据库表格连接查询，则需要进行多步查询，这时要先将(姓名，学号)和(课程名，课程号)键值对存储数据库，用于后续查询，如图7.2.8所示：</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/QQ%E6%88%AA%E5%9B%BE20150914171515.png" alt="图7.2.8 Redis简单查询"></p>
<p>这时，如果要查询李勇的数学分数，在关系数据库中需要连接3个表，Redis的做法为</p>
<p>①输入命令：get 李勇  获得李勇的学号；
②输入命令：get 数学  获得数学的课程号；
③获得李勇学号和数学的课程号之后，在输入命令get SC:学号:课程号:Grade 即可得到李勇的分数，如图7.2.9所示：</p>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2015/09/QQ%E6%88%AA%E5%9B%BE20150914172043.png" alt="图7.2.9 Redis复杂查询"></p>
<p>本文只是初步介绍Redis的安装与运行，如果想深入学习Redis,可以点击以下链接查看：</p>
<p>* Redis中文官方网站 <a href="http://www.redis.cn/" target="_blank" rel="external">http://www.redis.cn/</a> ，含有Redis简介以及Redis客户端和Redis命令的详细介绍，是学习Redis的好地方。
　　* 这篇博客 <a href="http://blog.csdn.net/eroswang/article/details/7080412" target="_blank" rel="external">http://blog.csdn.net/eroswang/article/details/7080412</a> 简要介绍了Redis以及Redis命令的使用，容易上手。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
