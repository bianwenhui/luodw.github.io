<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>罗道文的私房菜</title>
  <subtitle>分享知识，分享快乐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://luodw.cc/"/>
  <updated>2017-03-25T10:54:24.489Z</updated>
  <id>http://luodw.cc/</id>
  
  <author>
    <name>罗道文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lua原来这么好用</title>
    <link href="http://luodw.cc/2017/03/24/lua/"/>
    <id>http://luodw.cc/2017/03/24/lua/</id>
    <published>2017-03-24T12:34:22.000Z</published>
    <updated>2017-03-25T10:54:24.489Z</updated>
    
    <content type="html"><![CDATA[<p>今天这篇文章就随意谈谈lua。最近在看nginx+lua，刚好学了lua，就被这门语言的简练给吸引了。lua语言可以大大减轻一个人的心智负担，除了变量，操作符，语句以及函数这些最基础的语言功能外，剩下最重要的就是数据结构table（数组本质上也是table的特例）了。不用去记那么多的语法以及黑魔法，简直大快人心。</p>
<p>我现在对Lua使用感兴趣部分就是nginx+lua和redis内嵌lua；特别是前者，nginx+lua+redis构建高性能应用。lua+nginx可以使nginx不需要重新编译的情况下添加功能，特别是，如果只是修改lua文件，nginx都不需要重新加载配置文件，极大便利了nginx开发；而redis内嵌lua，让redis服务器有了计算能力，而且减小带宽传输（多个命令）以及原子执行多个命令达到cas效果。</p>
<p>下面就说说最近的一些内容和心得，主要以下三部分：</p>
<ol>
<li>通过lua脚本操作redis；</li>
<li>nginx+lua示例；</li>
<li>lua面向对象实现；</li>
<li>总结；</li>
</ol>
<h1>通过lua脚本操作redis</h1>
<hr>
<p>之前在学习redis以及看源码时，由于不懂lua，所以redis内嵌Lua模块就跳过去了，如今学了Lua，因此想把这块知识补上。redis对Lua的支持，主要有以下以下７个命令，</p>
<ol>
<li>EVAL</li>
<li>EVALSHA</li>
<li>SCRIPT DEBUG</li>
<li>SCRIPT EXISTS</li>
<li>SCRIPT FLUSH</li>
<li>SCRIPT KILL</li>
<li>SCRIPT LOAD
具体这些命令怎么使用，以及实现原理如何，可以看链接<a href="http://redisbook.readthedocs.io/en/latest/feature/scripting.html" target="_blank" rel="external">Lua脚本-Redis设计与实现</a>和<a href="https://redis.io/commands/eval" target="_blank" rel="external">redis官网</a>。这里主要介绍下EVAL命令。</li>
</ol>
<p>EVAL命令格式为</p>
<blockquote>
<p>EVAL script numkeys key [key ...] arg [arg ...]</p>
</blockquote>
<p>这里的</p>
<ol>
<li>script即为lua脚本或lua脚本文件;</li>
<li>key一般指lua脚本操作的键，在lua脚本文件中，通过KEYS[i]获取;</li>
<li>arg指外部传递给lua脚本的参数，可以通过ARGV[i]获取；</li>
</ol>
<p>下面通过两个简单的示例展示eval命令的用法。首先是脚本语句，来自redis官网，如下
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt;  <span class="built_in">eval</span> <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> <span class="number">2</span> key1 key2 <span class="built_in">first</span> <span class="built_in">second</span></div><div class="line"><span class="number">1</span>) <span class="string">"key1"</span></div><div class="line"><span class="number">2</span>) <span class="string">"key2"</span></div><div class="line"><span class="number">3</span>) <span class="string">"first"</span></div><div class="line"><span class="number">4</span>) <span class="string">"second"</span></div></pre></td></tr></table></figure></p>
<p>这个示例中lua脚本为一个return语句，返回了lua一个数组，这个数组四个元素分别是通过外部传入lua脚本。因为redis内嵌了Lua虚拟机，因此redis接收到这个lua脚本之后，然后交给lua虚拟机执行。当lua虚拟机执行结束，即将执行结果返回给redis，redis将结果按自己的协议转换为返回给客户端的回复，最后再通过TCP将回复发回给客户端。</p>
<p>通过这个例子也可以看出，在lua脚本中可以通过KEYS[i]来获取外部传入的键值，通过ARGV[i]来获取外部传入的参数。</p>
<p>下面给出一个复杂点的lua脚本，在给出脚本之前，先看下redis中有哪些需要的数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; zrange people 0 3</div><div class="line">1) &quot;jom&quot;</div><div class="line">2) &quot;lily&quot;</div><div class="line">3) &quot;tom&quot;</div><div class="line">127.0.0.1:6379&gt; hgetall jom</div><div class="line">1) &quot;sex&quot;</div><div class="line">2) &quot;boy&quot;</div><div class="line">3) &quot;age&quot;</div><div class="line">4) &quot;12&quot;</div><div class="line">127.0.0.1:6379&gt; hgetall lily</div><div class="line">1) &quot;age&quot;</div><div class="line">2) &quot;15&quot;</div><div class="line">3) &quot;sex&quot;</div><div class="line">4) &quot;girl&quot;</div><div class="line">127.0.0.1:6379&gt; hgetall tom</div><div class="line">1) &quot;sex&quot;</div><div class="line">2) &quot;boy&quot;</div><div class="line">3) &quot;girl&quot;</div><div class="line">4) &quot;13&quot;</div></pre></td></tr></table></figure></p>
<p>下面lua脚本的作用就是通过一次网络请求获取'jom'，'lily'，'tom'三个人的个人信息
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--[[</span></div><div class="line">--Keys[1] is the key</div><div class="line">--argv[1] is the offset</div><div class="line">--argv[2] is the limit</div><div class="line">--]]</div><div class="line"></div><div class="line"><span class="comment">-- 获取外部传入的命令</span></div><div class="line"><span class="keyword">local</span> key,offset,limit = KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], ARGV[<span class="number">2</span>]</div><div class="line"><span class="comment">-- 通过ZRANGE获取键为key的有序集合元素，偏移量为offset，个数为limit，即所有人名字</span></div><div class="line"><span class="keyword">local</span> names = redis.call(<span class="string">'ZRANGE'</span>, key, offset, limit)</div><div class="line"><span class="comment">-- infos存储所有个人信息</span></div><div class="line"><span class="keyword">local</span> infos = &#123;&#125;</div><div class="line"><span class="comment">-- 遍历所有名字</span></div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#names <span class="keyword">do</span></div><div class="line">	<span class="keyword">local</span> ck = names[i]</div><div class="line">    <span class="comment">-- 通过HGETALL命令获取每个人的个人信息</span></div><div class="line">	<span class="keyword">local</span> info = redis.call(<span class="string">'HGETALL'</span>,ck)</div><div class="line">    <span class="comment">-- 并且在个人信息中插入姓名</span></div><div class="line">	table.insert(info,<span class="string">'name'</span>)</div><div class="line">	table.insert(info,names[i])</div><div class="line"></div><div class="line">    <span class="comment">-- 插入infos中</span></div><div class="line">	infos[i] = info</div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="comment">-- 将结果返回给redis</span></div><div class="line"><span class="keyword">return</span> infos</div></pre></td></tr></table></figure></p>
<p>在命令行上执行eval命令，即可以得到结果，如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ ../redis/src/redis-cli --eval redlua.lua people , 0 2</div><div class="line">1) 1) &quot;sex&quot;</div><div class="line">   2) &quot;boy&quot;</div><div class="line">   3) &quot;age&quot;</div><div class="line">   4) &quot;12&quot;</div><div class="line">   5) &quot;name&quot;</div><div class="line">   6) &quot;jom&quot;</div><div class="line">2) 1) &quot;age&quot;</div><div class="line">   2) &quot;15&quot;</div><div class="line">   3) &quot;sex&quot;</div><div class="line">   4) &quot;girl&quot;</div><div class="line">   5) &quot;name&quot;</div><div class="line">   6) &quot;lily&quot;</div><div class="line">3) 1) &quot;sex&quot;</div><div class="line">   2) &quot;boy&quot;</div><div class="line">   3) &quot;girl&quot;</div><div class="line">   4) &quot;13&quot;</div><div class="line">   5) &quot;name&quot;</div><div class="line">   6) &quot;tom&quot;</div></pre></td></tr></table></figure></p>
<p>试想，如果没有使用lua脚本，那么上述功能需要在应用程序中先发送ZRANGE命令，获取所有姓名；获取到所有姓名之后，在遍历所有姓名，针对每个姓名访问redis获取给人信息，至少四次网络IO。而管道在这种场景上也派不上用场。由此可知，lua脚本在这种场景下提高redis性能是有多大的帮助了。</p>
<blockquote>
<p>需要特别注意的是people（键）后面的逗号左右都要留空格，不然会报错！</p>
</blockquote>
<h1>ngx+lua示例</h1>
<hr>
<p>ngx+lua是我最近非常感兴趣的一门技术，因为在带来高性能的同时，并没有提高编程的复杂性。如果是用c语言开发nginx第三方模块，需要了解nginx内部的数据结构以及接口，难度和心智上都有挑战。本小节也是通过简单的ngx+lua示例来展示在lua是如何在nginx中使用的。</p>
<p>开发环境可以通过<a href="http://wiki.jikexueyuan.com/project/nginx-lua/development-environment.html" target="_blank" rel="external">极客学院教程</a>安装。即安装OpenResty框架。安装的目录在/usr/servers，测试目录在/usr/example。</p>
<p>第一个示例展示如何获在lua脚本中获取http请求所有信息，这个示例来自<a href="http://jinnianshilongnian.iteye.com/blog/2186448" target="_blank" rel="external">开涛的博客</a>，可以很好理解在lua中如何获取nginx请求信息。在example.conf中添加如下路径映射
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">location ~/lua_test/(\d+)/(\d+)$ &#123;</div><div class="line">   set $a $1;</div><div class="line">   set $b $host;</div><div class="line">   default_type &apos;text/html&apos;;</div><div class="line">   lua_code_cache on;</div><div class="line">   content_by_lua_file /usr/example/lua/lua_test.lua;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在/usr/example/lua/文件下新建lua_test.lua文件，复制如下代码
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- nginx变量</span></div><div class="line"><span class="keyword">local</span> var = ngx.var</div><div class="line">ngx.say(<span class="string">"ngx.var.a :"</span>,var.a,<span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"ngx.var.b :"</span>,var.b,<span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"ngx.var[2] :"</span>,var[<span class="number">2</span>],<span class="string">"&lt;br/&gt;"</span>)</div><div class="line"></div><div class="line"><span class="comment">-- 请求头</span></div><div class="line"><span class="keyword">local</span> headers = ngx.req.get_headers()</div><div class="line">ngx.say(<span class="string">"headers begin"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"Host : "</span>, headers[<span class="string">"Host"</span>], <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"user-agent : "</span>, headers[<span class="string">"user-agent"</span>], <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(headers) <span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></div><div class="line">                ngx.say(k, <span class="string">" : "</span>, table.concat(v, <span class="string">","</span>), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">else</span></div><div class="line">                        ngx.say(k, <span class="string">" : "</span>, v, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">ngx.say(<span class="string">"headers end"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"&lt;br/&gt;"</span>)</div><div class="line"></div><div class="line"><span class="comment">--get请求uri参数  </span></div><div class="line">ngx.say(<span class="string">"uri args begin"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</div><div class="line"></div><div class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(uri_args) <span class="keyword">do</span></div><div class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></div><div class="line">                ngx_say(k, <span class="string">" : "</span>, table.concat(v, <span class="string">". "</span>),<span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">else</span></div><div class="line">                ngx.say(k, <span class="string">": "</span>, v, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">--post请求参数  </span></div><div class="line">ngx.req.read_body()</div><div class="line">ngx.say(<span class="string">"post args begin"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="keyword">local</span> post_args = ngx.req.get_post_args()</div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(post_args) <span class="keyword">do</span></div><div class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></div><div class="line">                ngx.say(k, <span class="string">" : "</span>, table.concat(v, <span class="string">", "</span>), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">else</span></div><div class="line">                ngx.say(k, <span class="string">": "</span>, v, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">        <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">ngx.say(<span class="string">"post args end"</span>, <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--请求的http协议版本  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.http_version : "</span>, ngx.req.http_version(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--请求方法  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.get_method : "</span>, ngx.req.get_method(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--原始的请求头内容  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.raw_header : "</span>,  ngx.req.raw_header(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line"><span class="comment">--请求的body内容体  </span></div><div class="line">ngx.say(<span class="string">"ngx.req.get_body_data() : "</span>, ngx.req.get_body_data(), <span class="string">"&lt;br/&gt;"</span>)</div><div class="line">ngx.say(<span class="string">"&lt;br/&gt;"</span>)</div></pre></td></tr></table></figure></p>
<p>由代码可以看出，lua脚本中主要信息来自于ngx.var和ngx.req这两个属性。在执行程序之前，先nginx需要先reload一次，最后我们就可以通过curl命令来访问nginx
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$curl -XPOST -d &apos;name=json&amp;age=26&apos; &apos;http://127.0.0.1:80/lua_test/1/2?token=ds43klk54fd&apos;</div><div class="line">ngx.var.a :1&lt;br/&gt;</div><div class="line">ngx.var.b :127.0.0.1&lt;br/&gt;</div><div class="line">ngx.var[2] :2&lt;br/&gt;</div><div class="line">headers begin&lt;br/&gt;</div><div class="line">Host : 127.0.0.1&lt;br/&gt;</div><div class="line">user-agent : curl/7.35.0&lt;br/&gt;</div><div class="line">host : 127.0.0.1&lt;br/&gt;</div><div class="line">content-type : application/x-www-form-urlencoded&lt;br/&gt;</div><div class="line">accept : */*&lt;br/&gt;</div><div class="line">content-length : 16&lt;br/&gt;</div><div class="line">user-agent : curl/7.35.0&lt;br/&gt;</div><div class="line">headers end&lt;br/&gt;</div><div class="line">&lt;br/&gt;</div><div class="line">uri args begin&lt;br/&gt;</div><div class="line">token: ds43klk54fd&lt;br/&gt;</div><div class="line">post args begin&lt;br/&gt;</div><div class="line">age: 26&lt;br/&gt;</div><div class="line">name: json&lt;br/&gt;</div><div class="line">post args end&lt;br/&gt;</div><div class="line">&lt;br/&gt;</div><div class="line">ngx.req.http_version : 1.1&lt;br/&gt;</div><div class="line">ngx.req.get_method : POST&lt;br/&gt;</div><div class="line">ngx.req.raw_header : POST /lua_test/1/2?token=ds43klk54fd HTTP/1.1</div><div class="line">User-Agent: curl/7.35.0</div><div class="line">Host: 127.0.0.1</div><div class="line">Accept: */*</div><div class="line">Content-Length: 16</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">&lt;br/&gt;</div><div class="line">ngx.req.get_body_data() : name=json&amp;age=26&lt;br/&gt;</div><div class="line">&lt;br/&gt;</div></pre></td></tr></table></figure></p>
<p>通过代码和结果一一比对，可以看出已经正确获取请求信息。我觉得这是一个很好的入门示例，因为处理http请求，获取http请求头信息是非常有必要的，而上述例子则展示接口信息。</p>
<p>下面另一个示例是展示ngx+lua存取redis。同样在example.conf添加路径映射
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="attribute">location</span> ~/redis_test/(\d+)$ &#123;</div><div class="line">        <span class="attribute">default_type</span> <span class="string">'text/html'</span>;</div><div class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</div><div class="line">        <span class="attribute">lua_code_cache</span> <span class="literal">on</span>;</div><div class="line">        <span class="attribute">content_by_lua_file</span> /usr/example/lua/redis.lua;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在/usr/example/lua/文件夹下新建redis.lua，复制如下代码:
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">local</span> json = <span class="built_in">require</span>(<span class="string">"cjson"</span>)</div><div class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">"resty.redis"</span>)</div><div class="line"></div><div class="line"><span class="keyword">local</span> red = redis:new()</div><div class="line">red:set_timeout(<span class="number">1000</span>)</div><div class="line"></div><div class="line"><span class="keyword">local</span> ip = <span class="string">"127.0.0.1"</span></div><div class="line"><span class="keyword">local</span> port = <span class="number">6379</span></div><div class="line"></div><div class="line"><span class="keyword">local</span> ok, err = red:connect(ip, port)</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></div><div class="line">        ngx.say(<span class="string">"connect to redis error : "</span>, err)</div><div class="line">        <span class="keyword">return</span> ngx.exit(<span class="number">500</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">local</span> id = ngx.var[<span class="number">1</span>]</div><div class="line"><span class="keyword">local</span> value = <span class="string">"value-"</span>..id</div><div class="line"></div><div class="line">red:set(id,value)</div><div class="line"></div><div class="line"><span class="keyword">local</span> resp, err = red:get(id)</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> resp <span class="keyword">then</span></div><div class="line">        ngx.say(<span class="string">"get from redis error : "</span>, err)</div><div class="line">        <span class="keyword">return</span> ngx.exit(<span class="number">500</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">red:<span class="built_in">close</span>()</div><div class="line"></div><div class="line">ngx.say(json.encode(&#123;content=resp&#125;))</div></pre></td></tr></table></figure></p>
<p>OpenResty将常用的lua包都已经打包好，包括redis客户端，memcache客户端，mysql客户端以及cjson等等，非常方便ngx+lua的开发。在执行程序之前，先reload一次配置文件，执行结果如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ curl http://127.0.0.1:80/redis_test/1</div><div class="line">&#123;&quot;content&quot;:&quot;value-1&quot;&#125;</div><div class="line">$ curl http://127.0.0.1:80/redis_test/2</div><div class="line">&#123;&quot;content&quot;:&quot;value-2&quot;&#125;</div><div class="line">$ curl http://127.0.0.1:80/redis_test/3</div><div class="line">&#123;&quot;content&quot;:&quot;value-3&quot;&#125;</div></pre></td></tr></table></figure></p>
<p>最后可以通过redis-cli客户端验证上述三个键值对是否插入成功。由这个例子可以展开讨论，如下</p>
<ol>
<li>因为OpenResty提供了redis，mysql以及模板渲染，因此利用ngx+lua可以直接部署一个小型网站；</li>
<li>可以在nginx本地搭一个redis缓存；当数据请求时，先访问本地的redis缓存，如果redis缓存需要的数据，直接直接在nginx层返回；如果redis没有缓存需要的数据，则转向web服务器。这样可以减轻后端服务器和数据库的压力，以及缩短请求时间。</li>
</ol>
<h1>lua面向对象实现</h1>
<hr>
<p>lua没有提供面像对象的实现，但是可以通过table来模拟。所以可知table在lua中是多么核心的数据结构。这里，我用redis客户端来说明lua是如何模拟面像对象的实现。
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">----引入table.new函数，兼容版本恩体</span></div><div class="line"><span class="keyword">local</span> ok, new_tab = <span class="built_in">pcall</span>(<span class="built_in">require</span>, <span class="string">"table.new"</span>)</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">or</span> <span class="built_in">type</span>(new_tab) ~= <span class="string">"function"</span> <span class="keyword">then</span></div><div class="line"><span class="comment">----如果还没有table.new接口，则自定义一个函数，返回一个空表格</span></div><div class="line">    new_tab = <span class="function"><span class="keyword">function</span> <span class="params">(narr, nrec)</span></span> <span class="keyword">return</span> &#123;&#125; <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"><span class="comment">-----------------------------------------------------</span></div><div class="line"><span class="comment">--新建一个表格</span></div><div class="line"> <span class="keyword">local</span> _M = new_tab(<span class="number">0</span>, <span class="number">155</span>)</div><div class="line"> _M.<span class="built_in">_VERSION</span> = <span class="string">'0.24'</span></div><div class="line"><span class="comment">-----------------------------------------------------</span></div><div class="line"><span class="keyword">local</span> mt = &#123; <span class="built_in">__index</span> = _M &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.new</span><span class="params">(self)</span></span></div><div class="line">    <span class="keyword">local</span> sock, err = tcp()</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sock <span class="keyword">then</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="comment">--设置返回表的元表</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">setmetatable</span>(&#123; sock = sock &#125;, mt)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>上述new方法即相当于类的构造函数，因此，我们可以通过如下方式新建一个对象
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-----此时require返回的redis即为模块中的_M</span></div><div class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span>(<span class="string">"resty.redis"</span>)</div><div class="line"><span class="keyword">local</span> red = redis:new()</div></pre></td></tr></table></figure></p>
<p>通过redis:new()方法返回一个{sock=sock}表格，然后设置这个表格的元表为resty.redis模块中的_M表格；__index元表格的意思就是当在red中访问一个不存在的属性时，则可以到元表中查询；因此当red调用下述函数时:
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">red:connect(<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</div><div class="line"><span class="comment">--------------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M.connect</span><span class="params">(self, ...)</span></span></div><div class="line"><span class="comment">----如果是red调用改方法，则self即为red</span></div><div class="line">    <span class="keyword">local</span> sock = self.sock</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sock <span class="keyword">then</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">"not initialized"</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    self.subscribed = <span class="literal">nil</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> sock:connect(...)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>因为red中并不存在connect方法，因此red到它的_M中查找connect方法，并执行；其实_M和red在lua中是两个不同的对象，就是因为red的元表为_M，因此可以把_M当作是对象red的模板，也就是类的概念。</p>
<h1>总结</h1>
<hr>
<p>本文主要介绍了lua在redis和nginx的应用，以及lua面向对象的实现。多了解一些编程语言，可以更好对编程语言的理解。后面还是深入再看看ngx+lua的开发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天这篇文章就随意谈谈lua。最近在看nginx+lua，刚好学了lua，就被这门语言的简练给吸引了。lua语言可以大大减轻一个人的心智负担，除了变量，操作符，语句以及函数这些最基础的语言功能外，剩下最重要的就是数据结构table（数组本质上也是table的特例）了。不用去
    
    </summary>
    
      <category term="lua" scheme="http://luodw.cc/categories/lua/"/>
    
    
      <category term="lua" scheme="http://luodw.cc/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Nginx是这么运行的</title>
    <link href="http://luodw.cc/2017/03/17/nginx01/"/>
    <id>http://luodw.cc/2017/03/17/nginx01/</id>
    <published>2017-03-17T03:19:36.000Z</published>
    <updated>2017-03-24T14:05:05.008Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前就有看nginx的冲动，但是一直被一些事耽搁着，最近在繁忙之中，抽出点时间，看了下nginx代码，发现整体上并不是很难看懂，而且刚好想学习nginx+lua开发，因此，决定在今后一段时间内，对技术的时间投入都放在nginx+lua了。nginx在互联网公司使用很广，最重要的功能当属反向代理和负载均衡了吧，当然还有缓存；所以对nginx的熟悉使用和深入了解，对于一名后台开发人员，至关重要。</p>
<p>记得我之前在很多文章有提到，后台组件框架主要有三种：redis单进程单线程，memcache单进程多线程，nginx多进程；等看了nginx之后，我也算集齐了；nginx以模块化方式开发，比如核心模块，event模块，http模块，然后为了支持多平台，event模块下又有对各大平台的封装支持，例如linux平台epoll，mac平台kqueue等等；然后http模块也被拆分成了很多子模块。</p>
<p>这篇文章算是我自己做的笔记吧，把之前研究的东西记录下。也许是之前看过redis和golang以及python的http框架，nginx整体框架比较容易就看懂了，当然很多细节还需后面慢慢看；这篇文章主要介绍nginx是如何开启，以及请求是怎么执行的，所以这篇文章主要就是以下两点：</p>
<ol>
<li>nginx开启流程;</li>
<li>重要回调函数设置；</li>
<li>nginx处理http请求；</li>
<li>总结</li>
</ol>
<h1>1. nginx开启流程</h1>
<hr>
<p>nginx体量很大，想要在较短时间内看完所有代码很难，而且我看得时间也不是很多，所以，这里主要站在宏观角度，对nginx做个整体剖析；其实如果直接从main函数直接开始看，其实也是可以看懂大部分，但是nginx回调函数太多了，看着看着，突然跑出一个回调函数，经常就懵逼了；因此，就需要用gdb来定点调试；</p>
<p>要使用gdb，首先需要在gcc编译时，加入-g选项，可以如下操作：</p>
<ol>
<li>打开nginx目录/auto/cc/conf文件，然后更改ngx_compile_opt=&quot;-c&quot;选项，添加-g，即为ngx_compile_opt=&quot;-c -g&quot;;</li>
<li>然后运行./configure和make即可编译生成可执行文件，在文件objs目录下;</li>
</ol>
<p>生成可执行文件nginx之后，直接在终端运行即可，nginx会加载默认配置文件，以daemon形式运行;</p>
<p>nginx运行之后，即可通过gdb来调试;按如下命令开启gdb
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gdb -<span class="selector-tag">q</span> -tui</div><div class="line"><span class="comment">// -q 安静模式，即不输出多余信息，-tui提供一个窗口显示代码</span></div></pre></td></tr></table></figure></p>
<p>然后，通过pidof命令获取nginx进程号，即可attach，如下：
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">shell pidof nginx</span></div></pre></td></tr></table></figure></p>
<p>nginx默认开启一个master进程和一个worker进程，因此上述命令会返回两个进程号，在我主机上8125和8126，较小是master进程，较大的是worker进程；接下来，先看下master进程，
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">attach</span> <span class="number">8125</span></div></pre></td></tr></table></figure></p>
<p>这样就可以直接调试nginx的worker进程，用命令bt可以查看master进程的函数栈
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="keyword">bt</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007efd445d9f76</span> <span class="keyword">in</span> do_sigsuspend (set=<span class="number">0x7ffe517ce5d0</span>) <span class="meta">at</span> ../sysdeps/unix/sysv/linux/sigsuspend.c:<span class="number">31</span></div><div class="line">#<span class="number">1</span>  __GI___sigsuspend (set=set@entry=<span class="number">0x7ffe517ce5d0</span>) <span class="meta">at</span> ../sysdeps/unix/sysv/linux/sigsuspend.c:<span class="number">41</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000042cc12</span> <span class="keyword">in</span> ngx_master_process_cycle (cycle=cycle@entry=<span class="number">0x181f110</span>) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">163</span></div><div class="line">#<span class="number">3</span>  <span class="number">0x000000000040c83d</span> <span class="keyword">in</span> main (argc=&lt;optimized <span class="keyword">out</span>&gt;, argv=&lt;optimized <span class="keyword">out</span>&gt;) <span class="meta">at</span> src/core/nginx.c:<span class="number">367</span></div></pre></td></tr></table></figure></p>
<p>nginx开启之后，首先启动的就是master进程，从main函数开始，</p>
<ol>
<li>main函数主要是做一些初始化操作，初始化启动参数，开启daemon，新建pid文件等等，然后调用ngx_master_process_cycle函数；</li>
<li>在ngx_master_process_cycle函数中最重要就是开启子进程，然后调用sigsuspend函数，master进程则阻塞在在信号中；</li>
</ol>
<p>因此，master进程任务就是开启子进程，然后管理子进程；怎么管理了？</p>
<p>信号，对，就是信号；当master进程收到一个信号之后，就把这个信号传递给worker进程，worker进程进而根据不同信号分别处理；那么问题又来了，master进程是如何把信号传递给worker进程的？</p>
<p>管道，对，就是管道；原理和memcache的master线程和worker线程通信机制一样；即每个worker进程有两个文件描述符fd[0]和fd[1]，一个读端，一个写端；worker进程将读端加入epoll事件监听，当master进程收到一个信号后，在每个worker进程写端写入一个flag，然后worker进程触发读事件，读取flag，并根据flag做相应操作。</p>
<p>因此nginx接收客户端请求以及处理客户端请求，主要是在worker进程，我们来看下，worker进程函数栈
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) attach <span class="number">8126</span></div><div class="line">(gdb) bt</div><div class="line">#<span class="number">0</span>  x00007efd4469d9f3 <span class="keyword">in</span> __epoll_wait_nocancel () at ../sysdeps/unix/syscall-template.S:<span class="number">81</span></div><div class="line">#<span class="number">1</span>  x000000000042dcae <span class="keyword">in</span> ngx_epoll_process_events (<span class="keyword">cycle</span>=x181f110, timer=<span class="number">18446744073709551615</span>, flags=<span class="number">1</span>) at src/event/modules/ngx_epoll_module.c:<span class="number">717</span></div><div class="line">#<span class="number">2</span>  x0000000000426225 <span class="keyword">in</span> ngx_process_events_and_timers (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110) at src/event/ngx_event.c:<span class="number">242</span></div><div class="line">#<span class="number">3</span>  x000000000042c15a <span class="keyword">in</span> ngx_worker_process_cycle (<span class="keyword">cycle</span>=x181f110, <span class="keyword">data</span>=&lt;optimized <span class="keyword">out</span>&gt;) at src/os/unix/ngx_process_cycle.c:<span class="number">753</span></div><div class="line">#<span class="number">4</span>  x000000000042ac46 <span class="keyword">in</span> ngx_spawn_process (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110, proc=proc@<span class="built_in">entry</span>=x42c0d9 &lt;ngx_worker_process_cycle&gt;, <span class="keyword">data</span>=<span class="keyword">data</span>@<span class="built_in">entry</span>=x0, </div><div class="line">    <span class="keyword">name</span>=<span class="keyword">name</span>@<span class="built_in">entry</span>=x47a4cf <span class="string">"worker process"</span>, respawn=respawn@<span class="built_in">entry</span>=-<span class="number">3</span>) at src/os/unix/ngx_process.c:<span class="number">198</span></div><div class="line">#<span class="number">5</span>  x000000000042c2b7 <span class="keyword">in</span> ngx_start_worker_processes (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110, n=<span class="number">1</span>, <span class="keyword">type</span>=<span class="keyword">type</span>@<span class="built_in">entry</span>=-<span class="number">3</span>) at src/os/unix/ngx_process_cycle.c:<span class="number">358</span></div><div class="line">#<span class="number">6</span>  x000000000042cb13 <span class="keyword">in</span> ngx_master_process_cycle (<span class="keyword">cycle</span>=<span class="keyword">cycle</span>@<span class="built_in">entry</span>=x181f110) at src/os/unix/ngx_process_cycle.c:<span class="number">130</span></div><div class="line">#<span class="number">7</span>  x000000000040c83d <span class="keyword">in</span> main (argc=&lt;optimized <span class="keyword">out</span>&gt;, argv=&lt;optimized <span class="keyword">out</span>&gt;) at src/core/nginx.c:<span class="number">367</span></div></pre></td></tr></table></figure></p>
<p>因为worker进程是由master进程fork出来，因此worker进程包含master进程的函数栈；我们直接从#5函数开始看，</p>
<ol>
<li>ngx_start_worker_processes 函数调用ngx_spawn_process开启子进程，并且设置master进程和worker进程通信的管道；</li>
<li>ngx_spawn_process函数主要是设置master进程和worker进程间通信管道，例如非阻塞等等，然后通过fork函数正式开启子进程；子进程调用通过参数传递进来的回调函数ngx_worker_process_cycle正式切入子进程部分，父进程则接着设置worker进程相关属性；</li>
<li>ngx_worker_process_cycle一开始调用ngx_worker_process_init函数对worker进程做些初始化设置，包括设置进程优先级，worker进程允许打开的最大文件描述符，对阻塞信号的设置，初始化所有模块，将master进程和worker进程间通信管道添加到监听可读事件等等；然后在一个无限循环中，函数ngx_worker_process_cycle接着调用ngx_process_events_and_timers，开启事件监听循环；</li>
<li>在ngx_process_events_and_timers函数中，先是获取锁，如果获取到锁，listenfd即可接收客户端，否则listenfd不可接收客户端事件；然后调用ngx_process_events函数，这个函数也就是ngx_epoll_process_events函数，开启开启事件监听；</li>
</ol>
<p>ok，worker进程此时已就绪，等待客户端连接以及请求数据；为了避免惊群现象以及实现worker进程负载均衡，每次有客户端连接时，所有worker进程会先争抢锁，如果某个worker进程获取到锁，即可执行接收客户端和客户端请求事件；如果worker进程没有争抢到锁，只执行客户端请求事件。</p>
<h1>2. 重要回调函数设置</h1>
<hr>
<p>当nginx的master进程和worker进程开启之后，客户端即可发送请求；接下来，就看看nginx是如何处理请求的；</p>
<p>当客户端发送请求之后，首先是通过tcp三次握手建立连接；当连接建立成功之后，即执行listenfd的回调函数，但是listenfd的回调函数是哪个了？这对于新手来说，其实是很难发现listenfd回调函数；下面分析下；</p>
<blockquote>
<p>像listenfd的回调函数以及模块间是如何拼凑在一起，这些几乎都是在模块初始化时完成的。对于listenfd的回调函数即是在event模块初始化时或者调用event模块一些设置函数时设置；客户端连接上服务器之后，服务器收到请求之后的回调函数也是在http模块初始化时或者调用模http模块一些设置函数时设置的。</p>
</blockquote>
<p>在event模块初始化时，调用的是ngx_event_process_init函数，下面列出这个函数最重要的代码:
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_event_process_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//.......</span></div><div class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; ngx_modules[m]; m++) &#123;</div><div class="line">        <span class="keyword">if</span> (ngx_modules[m]-&gt;type != NGX_EVENT_MODULE) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ngx_modules[m]-&gt;ctx_index != ecf-&gt;use) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">module</span> = ngx_modules[m]-&gt;ctx;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;actions.init(cycle, ngx_timer_resolution) != NGX_OK) &#123;</div><div class="line">            <span class="comment">/* fatal */</span></div><div class="line">            <span class="built_in">exit</span>(<span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">   　 &#125;</div><div class="line">    <span class="comment">//..........</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</div><div class="line">        rev-&gt;handler = ngx_event_accept;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ngx_event_flags &amp; NGX_USE_RTSIG_EVENT) &#123;</div><div class="line">                <span class="keyword">if</span> (ngx_add_conn(c) == NGX_ERROR) &#123;</div><div class="line">                    <span class="keyword">return</span> NGX_ERROR;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="number">0</span>) == NGX_ERROR) &#123;</div><div class="line">                    <span class="keyword">return</span> NGX_ERROR;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在for循环中，迭代每个监听套接字，recv为listenfd连接对象的读事件，这里设置listenfd读事件的回调函数为ngx_event_accept函数，然后将每个listenfd添加到事件监听中，并设置为可读事件。</p>
<p>ok，当我们去看ngx_add_conn和ngx_add_event的定义时，如下：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_add_event        ngx_event_actions.add</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_add_conn         ngx_event_actions.add_conn</span></div></pre></td></tr></table></figure></p>
<p>说明ngx_add_conn和ngx_add_event都是结构体ngx_event_actions结构体中设置的函数指针；其实这个ngx_event_actions就是nginx跨平台的关键，因为不同平台使用的事件监听器是不一样的，导致ngx_event_actions也就不一样。例如linux使用的是epoll，因此ngx_event_actions结构体就是在epoll模块加载时设置，在上述代码前半部分。我们来看下epoll模块actions.init函数：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ngx_epoll_module.c</span></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_epoll_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_msec_t</span> timer)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    nevents = epcf-&gt;events;</div><div class="line">    ngx_io = ngx_os_io;</div><div class="line">    ngx_event_actions = ngx_epoll_module_ctx.actions;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码可以看出，ngx_event_actions被设置为ngx_epoll_module_ctx.actions，接着看下这个结构体:
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ngx_event_module_t</span>  ngx_epoll_module_ctx = &#123;</div><div class="line">    &amp;epoll_name,</div><div class="line">    ngx_epoll_create_conf,               <span class="comment">/* create configuration */</span></div><div class="line">    ngx_epoll_init_conf,                 <span class="comment">/* init configuration */</span></div><div class="line"></div><div class="line">    &#123;<span class="comment">// actions</span></div><div class="line">        ngx_epoll_add_event,             <span class="comment">/* add an event */</span></div><div class="line">        ngx_epoll_del_event,             <span class="comment">/* delete an event */</span></div><div class="line">        ngx_epoll_add_event,             <span class="comment">/* enable an event */</span></div><div class="line">        ngx_epoll_del_event,             <span class="comment">/* disable an event */</span></div><div class="line">        ngx_epoll_add_connection,        <span class="comment">/* add an connection */</span></div><div class="line">        ngx_epoll_del_connection,        <span class="comment">/* delete an connection */</span></div><div class="line">        <span class="literal">NULL</span>,                            <span class="comment">/* process the changes */</span></div><div class="line">        ngx_epoll_process_events,        <span class="comment">/* process the events */</span></div><div class="line">        ngx_epoll_init,                  <span class="comment">/* init the events */</span></div><div class="line">        ngx_epoll_done,                  <span class="comment">/* done the events */</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>因此，当调用ngx_add_conn和ngx_add_event时，分别调用的是ngx_epoll_add_connection和ngx_epoll_add_event;如此一来，如果此时是mac平台，那么使用的事件监听器是kqueue，那么当调用ngx_add_event时，调用的就是ngx_kqueue_add_event。如果使用的poll监听器，那么调用将是ngx_poll_add_event等等。</p>
<p>接下来，再分析一个很重要的回调函数，即客户端连上客户端之后，发送请求时的回调函数，先来看下，listenfd回调函数
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">ngx_event_accept</span><span class="params">(<span class="keyword">ngx_event_t</span> *ev)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        socklen = NGX_SOCKADDRLEN;</div><div class="line">        <span class="comment">//......</span></div><div class="line">        s = accept(lc-&gt;fd, (<span class="keyword">struct</span> sockaddr *) sa, &amp;socklen);</div><div class="line">        <span class="comment">//.......</span></div><div class="line">         ngx_accept_disabled = ngx_cycle-&gt;connection_n / <span class="number">8</span></div><div class="line">                              - ngx_cycle-&gt;free_connection_n;</div><div class="line"></div><div class="line">        c = ngx_get_connection(s, ev-&gt;<span class="built_in">log</span>);</div><div class="line">        <span class="comment">//.......</span></div><div class="line">         <span class="keyword">if</span> (ngx_add_conn &amp;&amp; (ngx_event_flags &amp; NGX_USE_EPOLL_EVENT) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (ngx_add_conn(c) == NGX_ERROR) &#123;</div><div class="line">                ngx_close_accepted_connection(c);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">log</span>-&gt;data = <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">log</span>-&gt;handler = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        ls-&gt;handler(c);</div><div class="line">        <span class="comment">//.....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当客户端连接服务器时，首先listenfd回调函数先是调用accept函数接收客户端请求，然后从对象池中获取一个封装客户端socket连接对象，如果目前使用的是epoll事件监听器，则调用ngx_add_conn(c)放入事件监听，最后调用ngx_listening_t的回调函数，对客户端连接进一步操作；ok，这个ls-&gt;handler(c)是个啥？我在第一次看代码时，一脸懵逼！！！还记得之前说的吗？模块之间的衔接，几乎都是在模块初始化或者调用模块一些设置函数时设置的，因此接下来，就来看看http模块初始化时做了什么。http模块并没有在模块初始化函数中设置ls-&gt;handler(c)，而是在当读取到&quot;http&quot;命令时，执行命令函数ngx_http_block中设置；
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *</span></div><div class="line"><span class="title">ngx_http_block</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_command_t</span> *cmd, <span class="keyword">void</span> *conf)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//......</span></div><div class="line">    <span class="keyword">if</span> (ngx_http_optimize_servers(cf, cmcf, cmcf-&gt;ports) != NGX_OK) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_CONF_ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//......</span></div><div class="line">&#125;</div><div class="line">------------------------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_optimize_servers</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_http_core_main_conf_t</span> *cmcf,</span></div><div class="line">    <span class="keyword">ngx_array_t</span> *ports)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//........</span></div><div class="line">     <span class="keyword">if</span> (ngx_http_init_listening(cf, &amp;port[p]) != NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">&#125;</div><div class="line">--------------------------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_init_listening</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_http_conf_port_t</span> *port)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">      ls = ngx_http_add_listening(cf, &amp;addr[i]);</div><div class="line">        <span class="keyword">if</span> (ls == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> NGX_ERROR;</div><div class="line">        &#125;</div><div class="line">    <span class="comment">//.........</span></div><div class="line">&#125;</div><div class="line">------------------------------------------------------------------</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_listening_t *</span></div><div class="line"><span class="title">ngx_http_add_listening</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf, <span class="keyword">ngx_http_conf_addr_t</span> *addr)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//........................</span></div><div class="line">     ls-&gt;handler = ngx_http_init_connection;</div><div class="line">     <span class="comment">//.........................</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>真是藏的够深，经历了四个函数，终于看到ls-handler设置函数了，即为ngx_http_init_connection函数，而这个函数在http模块，为客户端http请求处理的入口函数；到此为止，我们可以知道服务器在接收到客户端之后，首先将客户端封装成ngx_connection_t结构体，然后交给http模块执行http请求。</p>
<h1>3. nginx处理http请求</h1>
<hr>
<p>nginx处理http的请求是nginx最重要的职能，也是最复杂的一部分。可以大概说下执行流程：</p>
<ol>
<li>读取解析请求行；</li>
<li>读取解析请求头；</li>
<li>开始最重要的部分，即多阶段处理；nginx把请求处理划分成了11个阶段，也就是说当nginx读取了请求行和请求头之后，将请求封装了结构体ngx_http_request_t，然后每个阶段的handler都会根据这个ngx_http_request_t，对请求进行处理，例如重写uri，权限控制，路径查找，生成内容以及记录日志等等；</li>
<li>将结果返回给客户端；</li>
</ol>
<p>多阶段处理是nginx模块最重要的部分，因为第三方模块也是注册在这；例如有人写了一个利用nginx和memcache做页面缓存的第三方模块，也可以把memcache换成redis集群等等；而且nginx多阶段处理有点类似python和golang　web框架的中间件，后者主要是用装饰器模式，对handler一层一层封装，而nginx是用数组（链表）形式组合多阶段handler，然后按handler链表执行即可；</p>
<p>因为多阶段这块内容还没完全看懂，所以跟着网上教程，写了个最简单的第三方模块，用于设置定点调试，观察http阶段函数执行过程，步骤如下：</p>
<ol>
<li>在nginx目录下新建一个目录thm（third mudole），在新建一个foo目录（foo模块），然后在foo目录下新建ngx_http_foo_module.c
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_config.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_core.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ngx_http.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_foo_init</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_foo_handler</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span> ngx_http_foo_module_ctx = &#123;</div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* preconfiguration */</span></div><div class="line">    ngx_http_foo_init,                 <span class="comment">/* postconfiguration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* create main configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* init main configuration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* create server configuration */</span></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* merge server configuration */</span></div><div class="line"></div><div class="line">    <span class="literal">NULL</span>,                              <span class="comment">/* create location configuration */</span></div><div class="line">    <span class="literal">NULL</span>                               <span class="comment">/* merge location configuration */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">ngx_module_t</span>  ngx_http_foo_module = &#123;</div><div class="line">    NGX_MODULE_V1,</div><div class="line">    &amp;ngx_http_foo_module_ctx,                      <span class="comment">/* module context */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* module directives */</span></div><div class="line">    NGX_HTTP_MODULE,                               <span class="comment">/* module type */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init master */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init module */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init process */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* init thread */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* exit thread */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* exit process */</span></div><div class="line">    <span class="literal">NULL</span>,                                          <span class="comment">/* exit master */</span></div><div class="line">    NGX_MODULE_V1_PADDING</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_foo_handler</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></div><div class="line">&#123;</div><div class="line">    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</div><div class="line">            <span class="string">"#### hello, this FOO module"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_DECLINED;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ngx_int_t</span></div><div class="line"><span class="title">ngx_http_foo_init</span><span class="params">(<span class="keyword">ngx_conf_t</span> *cf)</span></div><div class="line">&#123;</div><div class="line">    ngx_http_handler_pt               *h;</div><div class="line"></div><div class="line">    <span class="keyword">ngx_http_core_main_conf_t</span>         *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);</div><div class="line"></div><div class="line">    h = ngx_array_push(&amp;cmcf-&gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);</div><div class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">return</span> NGX_ERROR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *h = ngx_http_foo_handler;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> NGX_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>然后同样是在foo目录下新建一个配置文件config
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">ngx_addon_name</span>=ngx_http_foo_module</div><div class="line"><span class="attr">HTTP_MODULES</span>=<span class="string">"$HTTP_MODULES ngx_http_foo_module"</span></div><div class="line"><span class="attr">NGX_ADDON_SRCS</span>=<span class="string">"$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_foo_module.c"</span></div></pre></td></tr></table></figure></p>
<p>这样，一个最简单的第三方模块就编写完成，上述两个函数很好理解，一个是初始化函数，将这个模块的handler注册到某个阶段中，这个例子是在阶段NGX_HTTP_CONTENT_PHASE，然后当程序执行到上述阶段时，即可执行foo模块；最后重新编译生成可执行文件即可。</p>
<p>接下来，利用gdb来看下http执行过程，把定点设置在
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(gdb) b ngx_http_foo_handler</div><div class="line">Breakpoint <span class="number">1</span> <span class="meta">at</span> <span class="number">0x47617e</span>: file ./thm/foo/ngx_http_foo_module.c, line <span class="number">41</span>.</div><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line"></div><div class="line">Breakpoint <span class="number">1</span>, ngx_http_foo_handler (r=<span class="number">0x175bf70</span>) <span class="meta">at</span> ./thm/foo/ngx_http_foo_module.c:<span class="number">41</span></div><div class="line"><span class="number">41</span>	    ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, <span class="number">0</span>,</div><div class="line">(gdb) <span class="keyword">bt</span></div><div class="line">#<span class="number">0</span>  ngx_http_foo_handler (r=<span class="number">0x175bf70</span>) <span class="meta">at</span> ./thm/foo/ngx_http_foo_module.c:<span class="number">41</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x0000000000435f76</span> <span class="keyword">in</span> ngx_http_core_content_phase (r=<span class="number">0x175bf70</span>, ph=<span class="number">0x176f408</span>) <span class="meta">at</span> src/http/ngx_http_core_module.c:<span class="number">1377</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x0000000000430f43</span> <span class="keyword">in</span> ngx_http_core_run_phases (r=r@entry=<span class="number">0x175bf70</span>) <span class="meta">at</span> src/http/ngx_http_core_module.c:<span class="number">847</span></div><div class="line">#<span class="number">3</span>  <span class="number">0x000000000043105c</span> <span class="keyword">in</span> ngx_http_handler (r=r@entry=<span class="number">0x175bf70</span>) <span class="meta">at</span> src/http/ngx_http_core_module.c:<span class="number">830</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x0000000000438d66</span> <span class="keyword">in</span> ngx_http_process_request (r=r@entry=<span class="number">0x175bf70</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">1910</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x000000000043add5</span> <span class="keyword">in</span> ngx_http_process_request_headers (rev=rev@entry=<span class="number">0x1776590</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">1342</span></div><div class="line">#<span class="number">6</span>  <span class="number">0x000000000043b083</span> <span class="keyword">in</span> ngx_http_process_request_line (rev=rev@entry=<span class="number">0x1776590</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">1022</span></div><div class="line">#<span class="number">7</span>  <span class="number">0x000000000043b767</span> <span class="keyword">in</span> ngx_http_wait_request_handler (rev=<span class="number">0x1776590</span>) <span class="meta">at</span> src/http/ngx_http_request.c:<span class="number">499</span></div><div class="line">#<span class="number">8</span>  <span class="number">0x000000000042de5c</span> <span class="keyword">in</span> ngx_epoll_process_events (cycle=&lt;optimized <span class="keyword">out</span>&gt;, timer=&lt;optimized <span class="keyword">out</span>&gt;, flags=&lt;optimized <span class="keyword">out</span>&gt;)</div><div class="line">    <span class="meta">at</span> src/event/modules/ngx_epoll_module.c:<span class="number">822</span></div><div class="line">#<span class="number">9</span>  <span class="number">0x0000000000426225</span> <span class="keyword">in</span> ngx_process_events_and_timers (cycle=cycle@entry=<span class="number">0x1751110</span>) <span class="meta">at</span> src/event/ngx_event.c:<span class="number">242</span></div><div class="line">#<span class="number">10</span> <span class="number">0x000000000042c15a</span> <span class="keyword">in</span> ngx_worker_process_cycle (cycle=<span class="number">0x1751110</span>, data=&lt;optimized <span class="keyword">out</span>&gt;) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">753</span></div><div class="line">#<span class="number">11</span> <span class="number">0x000000000042ac46</span> <span class="keyword">in</span> ngx_spawn_process (cycle=cycle@entry=<span class="number">0x1751110</span>, proc=proc@entry=<span class="number">0x42c0d9</span> &lt;ngx_worker_process_cycle&gt;, data=data@entry=<span class="number">0x0</span>, </div><div class="line">    name=name@entry=<span class="number">0x47a4cf</span> <span class="string">"worker process"</span>, respawn=respawn@entry=-<span class="number">3</span>) <span class="meta">at</span> src/os/unix/ngx_process.c:<span class="number">198</span></div><div class="line">#<span class="number">12</span> <span class="number">0x000000000042c2b7</span> <span class="keyword">in</span> ngx_start_worker_processes (cycle=cycle@entry=<span class="number">0x1751110</span>, n=<span class="number">1</span>, type=type@entry=-<span class="number">3</span>) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">358</span></div><div class="line">#<span class="number">13</span> <span class="number">0x000000000042cb13</span> <span class="keyword">in</span> ngx_master_process_cycle (cycle=cycle@entry=<span class="number">0x1751110</span>) <span class="meta">at</span> src/os/unix/ngx_process_cycle.c:<span class="number">130</span></div><div class="line">#<span class="number">14</span> <span class="number">0x000000000040c83d</span> <span class="keyword">in</span> main (argc=&lt;optimized <span class="keyword">out</span>&gt;, argv=&lt;optimized <span class="keyword">out</span>&gt;) <span class="meta">at</span> src/core/nginx.c:<span class="number">367</span></div></pre></td></tr></table></figure></p>
<p>简要说明下上述函数，我阅读的版本和运行版本不一样，因此上述仅供参考:</p>
<ol>
<li>当有客户端发送tcp连接请求时，ngx_epoll_process_events返回listenfd可读事件，调用ngx_event_accept函数接收客户端请求，然后将请求封装成ngx_connection_t结构体，最后调用ngx_http_init_connection函数进入http处理；</li>
<li>在新版nginx中，并没有看到ngx_http_wait_request_handler,而是改成了ngx_http_init_connection(ngx_connection_t *c)函数，然后在这个函数内部调用ngx_http_init_request函数初始化请求结构体ngx_http_request_t以及调用ngx_http_process_request_line函数；</li>
<li>ngx_http_process_request_line函数内部先是调用ngx_http_read_request_header函数将请求行读取到缓存中，然后调用ngx_http_parse_request_line函数解析出请求行信息，最后调用ngx_http_process_request_header处理请求头；</li>
<li>在函数ngx_http_process_request_header内部先是调用函数ngx_http_read_request_header读取请求头，然后调用ngx_http_parse_header_line函数解析出请求头，接着调用ngx_http_process_request_header函数对请求头进行必要的验证，最后调用ngx_http_process_request函数处理请求；</li>
<li>在ngx_http_process_request函数内部调用ngx_http_handler(ngx_http_request_t *r)函数，而在ngx_http_handler(ngx_http_request_t *r)函数内部调用
函数ngx_http_core_run_phases进行多阶段处理；</li>
<li>我们来看下多阶段处理函数ngx_http_core_run_phases
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">ngx_http_core_run_phases</span><span class="params">(<span class="keyword">ngx_http_request_t</span> *r)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">ngx_int_t</span>                   rc;</div><div class="line">    <span class="keyword">ngx_http_phase_handler_t</span>   *ph;</div><div class="line">    <span class="keyword">ngx_http_core_main_conf_t</span>  *cmcf;</div><div class="line"></div><div class="line">    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);</div><div class="line"></div><div class="line">    ph = cmcf-&gt;phase_engine.handlers;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (ph[r-&gt;phase_handler].checker) &#123;</div><div class="line"></div><div class="line">        rc = ph[r-&gt;phase_handler].checker(r, &amp;ph[r-&gt;phase_handler]);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (rc == NGX_OK) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>http多阶段处理，每个阶段可能对应一个handler，也可能对应多个handler，而每个阶段对应同一个checker，因此上述while循环中，迭代所有http模块handler，然后在handler函数中根据请求结构体ngx_http_request_t做出相应的处理；上述gdb调试结果，可以看出NGX_HTTP_CONTENT_PHASE阶段的checker函数为ngx_http_core_content_phase，然后再在这个checker函数内部执行foo模块的handler（ngx_http_foo_handler）。</p>
<p>等到多阶段处理结束之后，最后再将response返回给客户端。</p>
<h1>4. 总结</h1>
<p>这篇文章主要就是宏观分析下nginx整体运行流程，因为第一次看nginx时，有很多看不懂的地方，所以这篇文章也算是做笔记吧。后续还需认真看多阶段处理，因为第三方开发模块也是注册在多阶段过程，以及熟悉ngx+lua模块开发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前就有看nginx的冲动，但是一直被一些事耽搁着，最近在繁忙之中，抽出点时间，看了下nginx代码，发现整体上并不是很难看懂，而且刚好想学习nginx+lua开发，因此，决定在今后一段时间内，对技术的时间投入都放在nginx+lua了。nginx在互联网公司使用很广，
    
    </summary>
    
      <category term="nginx" scheme="http://luodw.cc/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://luodw.cc/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>《人类简史》和《未来简史》--赫拉利</title>
    <link href="http://luodw.cc/2017/02/18/mankind/"/>
    <id>http://luodw.cc/2017/02/18/mankind/</id>
    <published>2017-02-18T06:24:21.000Z</published>
    <updated>2017-03-16T08:51:34.129Z</updated>
    
    <content type="html"><![CDATA[<p>最近在业余时间，看了以色列历史学家赫拉利两本著作《人类简史》和《未来简史》，这两本书也是受到各大科技大佬，作家以及报社推荐，全球20多个国家争相购得版权热销；我在看完《人类简史》之后，真心佩服赫拉利的学识渊博以及脑洞大；后来，《未来简史》一出版，我也是第一时间购买，并且大概花一个星期就看完了，完全可以说是情不自禁；</p>
<p>这两本书分别叙述了我们人类是如何从动物一步一步走向万物之灵，地球主宰；以及我们人类在未来将会面对可能的未来；通过这两本书，我也更加认清我们生活的这个世界，什么是人文主义教条，什么是资本主义教条等等；《人类简史》和《未来简史》可以说是历史哲学书籍，因为赫拉利在书中并不仅仅是叙述事实，而且辩证地阐述了事实的由来；</p>
<p>再看这两本书之前，我自己的感受是最好对世界史有个认识，可以看看“二混子”历史系列以及《大国崛起》记录片；对于《未来简史》我觉得有大数据思维会更好理解数据主义，可以看看《大数据时代》或者《智能时代》；</p>
<p>下面就跟着赫拉利介绍下这两本书的观点；</p>
<ol>
<li>《人类简史》</li>
<li>《未来简史》</li>
<li>感悟</li>
</ol>
<h1>《人类简史》</h1>
<hr>
<p>《人类简史》这本书的副标题为“从动物到上帝”，我觉得很切合书本提到的观点；我们人类最原始其实和普通的动物一样，过着采集狩猎的生活；后面经历了认知革命，农业革命以及科学革命才一步一步主宰地球，过着现在的生活；下面，分别从上述三大革命来阐述赫拉利观点；</p>
<h2>认知革命</h2>
<p>认知革命可以说是智人(人类祖先)从普通动物到万物之灵最为重要的一次革命，因为这次革命，智人绕过基因组演变的宿命，从动物到人类的演变；下面先给出一些重要时间：</p>
<ul>
<li>135亿年 宇宙大爆炸</li>
<li>38亿年 形成有机生物，生物学开始</li>
<li>250 万年 非洲人属开始演化，出现最早的石器</li>
<li>200万年 人类由非洲传播到欧亚大陆，演化为不同的人种</li>
<li>30万年 开始日常用火</li>
<li>20万年 智人在东非演化</li>
<li>7万年 认知革命 出现能描述故事的语言</li>
<li>1.2万年 农业革命 驯化动植物，出现永久聚落</li>
<li>500年 科学革命 人类承认自己的无知，开始取得前所未有的能力；欧洲人开始在政府美洲和各大洋，整个地球形成单一历史场域，资本主义兴起</li>
<li>200年 工业革命生产力大幅度提高，动植物大规模灭绝</li>
</ul>
<p>从这个时间，我们可以知道人这个物种其实大概存活了250万年，我们智人存活的历史有20万年；在智人出现的时候，其实智人和其他动物一样，过着采集狩猎的生活；在个人能力上，不如尼安德特人或者一些大型的动物；因此那时智人也是弱势群体，经常只能在远处看着大型动物吃猎物，然后再吃剩下的肉；当时的智人，也和动物一样，四海为家，哪有食物，就在哪定居；而且由于每天可能吃到的食物不一样，因此智人能获取的必需的营养成分；智人就上述生活到了距今7万年，智人开始了第一次革命：认知革命。</p>
<p>在认知革命之前，智人的认知和其他动物一样，只能叙述某个事实，例如，河边有头狮子；而在认知革命之后，智人产生了可以叙述故事的语言，这些故事也可以说是想象的实体，例如上帝，国家，企业等等，而正是这些想象的实体，智人才打败其他人种和动物，登上食物链顶端；因为就算是大批互相不认识的人，只要同样相信某个故事，就能共同协作；</p>
<p>原来动物或其他人种可能只有几个人的小团伙协作，但是认知革命之后，智人通过故事可以让大批的人聚集在一起协作；因此如果是单打独斗，智人肯定是打不过狮子或者尼安德特人，但是智人可以聚集大量的智人一起协作对抗其他人种和动物，可以说这时的智人已经在地球上再也没有对手了，主宰折地球；</p>
<p>在距今7万年到1万年期间，智人开始从非洲开始走向世界，每到一个地方，靠着团队协作，打败了各种人种以及动物，甚至导致大量物种灭绝；就这样，智人成为地球上唯一的人种，智人主宰地球每个角落；</p>
<p>也有学者提出，认知革命是怎么产生的？书本提到说是基因突变，纯粹的偶然，毕竟历史就是由偶然的事件串起来的；正是因为这次基因突变，智人就绕开了基因演化的宿命，踏上文化演化的快车道；我们现在的人类的基因和认知革命前的基因相差不是很大，但是现在人类的生活已经和认知革命前智人的生活可以说完全不同；</p>
<h2>农业革命</h2>
<p>大约在距今1.2万年，此时的智人已经在地球的每个角落，并且靠着采集狩猎生活；在这之后，智人进行了第二次革命：农业革命；农业革命一直延续到距今500年前，也就是说公元前1万年到公园1500年，我们祖先开始过上了农民的生活，种植农作物和饲养动物；</p>
<p>农业革命之后，因为人类开始饲养动植物，所以人类也就没有过着四海为家采集狩猎的生活，而是在某个地方定居下来，过着日出而作，日落而息的生活；随着人类的聚集以及认知革命产生叙述故事的能力，开始出现城镇，王国，宗教，帝国等大型的想象的实体；后面的历史进入了人类文明史，智人开始生活在客观和主观，以及人类社会三个现实中，而动物还是生活在主观和客观现实中；</p>
<p>也有人说，农业革命是最大的骗局；对于智人整体而言，农业革命是历史的进步；但是对于智人个体而言却是退步；</p>
<ol>
<li>因为人类的定居，因此人类更容易遭受洪涝灾害的影响；而采集狩猎时期的智人，因为四海为家，这边没食物，可以到其他地方觅食；</li>
<li>其次智人的食物单一，营养还不如采集狩猎时期的营养丰富，采集狩猎时期，智人食物多样化；</li>
<li>其次是疾病的传播；因为人类聚居在一起，使得疾病更加容易传播；</li>
</ol>
<p>农业革命还有一个重大的成就，就是文字的发明；当时的帝国要记录交易和税收，军用物资和商品的库存量，但是人的大脑存储有限，而且人类总难免一死以及人类的大脑只存储特定类型的信息；因此就导致了文字的产生；公元前3000年左右，苏美尔人产生了最早的文字；</p>
<p>正是想象构建的秩序和文字的发明，弥补了我们基因的不足，人类社会就这样继续前行着；</p>
<h2>人类融合</h2>
<p>农业革命后，人类从一开始各个独立生活在自己的小区域慢慢走向了融合；赫拉利提到，促成人类走向融合的有三大因素：金钱，帝国和宗教；</p>
<p>在原始社会，人与人之间的交换主要是物物交换；例如，10个苹果换区一双鞋；但是有些时候，鞋匠不一定需要10个苹果，因此这时买鞋的人就无法与鞋匠进行交换；后来演化为用一个特定的以物易物系统，分别从不同专业农夫和制造商取得物品，然后再分配到需要人手里；后来又发明了金钱的概念，不一定是硬币或钞票，因为金钱也是人的想象出来，只要大家相信，任何东西都可以代表其他物品交换；一开始用贝壳，后来用银金属，最后才到纸币电子货币；</p>
<p>帝国主要有两个因素，一个是多民族，一个是领土可以灵活调整；历史上出现较大的帝国有古希腊帝国，古罗马帝国，奥斯特土耳其帝国等等；帝国将不同的民族收为统一管理，使各个民族的生活习惯，语言，文化等等趋于统一，人类更加融合；</p>
<p>一开始，采集狩猎时期，学者普遍认可泛神论；后来演进成了多神论，二元论，一神论以及现在的人文主义宗教；在科学革命之前，人类信仰上帝，而科学革命之后，人文主义兴起，人类相信自己的感觉；</p>
<h2>科学革命</h2>
<p>在距今500面前，智人进行了第三次革命：科学革命；科学革命最主要的成就可以说有两方面，一个是人文主义的兴起，一个是工业革命；人文主义的兴起，人类从信仰上帝转变为相信自己的感觉；人类的生活的意义不再是为了上帝某个计划而活，而是凭着自己的感觉而活；而工业革命大大提高了人类的力量，促进人类经济，政治各方面的极大提高；</p>
<p>对于科学革命，赫拉利在书本中提到，促成科学革命的两股力量主要是帝国和资本；</p>
<p>《大国崛起》讲述的就是16世纪以来，也就是科学革命以来9个世界大国的崛起；最开始，葡萄牙由于领土的狭小，资源短缺，当时国力也不是西班牙的对手，因此为了经济的发展，只能往航海新航线探索，这也开始了欧洲帝国殖民全球的历史；在殖民的过程中，列强往往会带着各行业的人才，生物学，地质学，地理学等等，在殖民地进行考察收集数据；这也是当时科学能快速发展的一方面原因；</p>
<p>另一个原因就是资本主义的兴起；帝国在殖民过程中，需要消耗大量的金钱，如果每次都是向国民收税，国民早就民不聊生，暴乱四起；荷兰最早兴起资本主义；当荷兰在殖民东南亚时，除了向国民征税外，还建立了东印度公司；东印度公司向社会筹集战争资金，然后通过殖民获取财富，再反馈给股东，这样就建立一个正向反馈；也正是相信战争能获取财富，因此欧洲国家才投资发展热兵器，如枪，大炮以及各种技术的研究；</p>
<p>资本主义也是主要依赖于人的信任，信赖未来会获得财富，所以才会有人投资；这个概念现在也适用；当今，风投公司将资本投向创业公司，也是因为相信所投创业公司可以上市盈利，而所投创业公司最后上市之后，风投公司就可以分红或者股票套现，获取财富；</p>
<p>科学革命最后一部分还提到，人文主义为现代社会提供了意义，而科学为现代社会提供力量；人们就这样快乐的生活着了吗？然而随机生命科学与信息技术的发展，人类社会遭遇了第二次认知革命，这些将会在《未来简史》中介绍；</p>
<h1>《未来简史》</h1>
<hr>
<p>如果看过《人类简史》，《未来简史》会比较好看懂，因为《未来简史》大部分还是在说历史，为未来做铺垫，只有最后一部分，预测未来的发展方向；</p>
<p>《未来简史》最主要的论断就是生物也是算法，碳基或者叫做有机算法，而计算机属于硅基算法或者叫做无机算法；既然二者同属算法，那么生物和计算是可以相互交流，通过基因改造技术或者植入芯片的方式，使智人上升为超人类；或者通过人工智能方式，产生比人类更智能的物种，新物种接管人类；这也导致产生新的宗教：科技人文主义和数据主义；</p>
<h2>人类的新议题</h2>
<p>这一章节，赫拉利通过大量的例子证明了自科学革命以来，人类战胜了饥荒，瘟疫和战争；而在第三个千年之际，人类开始了追求新的三个议题：长生不死，快乐和神性；</p>
<p>这三个方面可以很好理解，人类在战胜了饥荒，瘟疫和战争之后，在人文主义宗教之下，因为没了突如其来的死亡，但是终将寿终正寝，因此人类就开始了永生的追求；而人类永生，漫漫人生，肯定不想充满痛苦，因此开始对快乐的追求；而人类的贪然，希望把生活的大部分甚至是外太空纳到自己的控制之下，必定追求更高的力量；</p>
<p>这一章节还通过绿色草坪的例子，说明研究历史的意义：不是为了预测未来，而是要将会自己从过去中释放出来，想象是否有另一种可能；而这本书的标题《未来简史》主要是基于过去300的未来，因此赫拉利提到，为了题解未来，我们需要再回头，了解智人是怎样的生物，人文主义如何成为主导世界的宗教以及为什么实现人文主义的梦想反而导致人文主义的崩塌；</p>
<h2>智人征服世界</h2>
<p>这部分主要讲了三点：</p>
<ol>
<li>人类与其他动物有什么不同？</li>
<li>人类如何征服世界？</li>
<li>智人究竟是以高等的生命形式，还是欺凌其他物种的地痞流氓？</li>
</ol>
<p>生物也是算法，人类99%的决定，包括关于配偶，事业和住处的选择，都是由各种进化而成的算法来处理，我们把这些算法称为感觉，情感和欲望；</p>
<p>现代科学和工业的兴起，带来了人和动物关系的第二次革命；农业革命中，人类让泛灵论只剩下人类和神的对话；而到了科学革命，连神也去掉了，人类成了整个世界的独角兽；</p>
<p>人类与其他动物到底有什么不同？其实人类和其他物种并没有特别之处，人类的情感欲望动物也有，真正让人类统治地球，就是虚构故事的能力，人类洒下的意义之网；</p>
<h2>智人为世界赋予意义</h2>
<p>这一章节还是在说明人类的为世界赋予的意义，包括神，城市，国家，文字，公司以及各种品牌等；</p>
<p>同时提到现代科学和宗教的关系；在科学革命之前，人类有意义(宗教)，却没力量；而科学革命之后，人类有了科技，力量得到大幅度提升，而人类也不相信上帝的存在，为什么人类社会没有崩塌(宗教的意义就在于维护人类秩序)？原因就在于新的宗教－人文主义的兴起；科学提供力量，人文主义提供意义和秩序；</p>
<p>人文主义就是说人类生活意义不在是某个超人类的计划，而是相信自己的感觉，自由意志才是最高的权威；书上提到以下小点人文主义：</p>
<ol>
<li>人文主义政治：选民能做出最好的选择</li>
<li>人文主义经济：顾客永远是对的</li>
<li>人文主义美学：看的人觉得美，就是美</li>
<li>人文主义伦理：感觉对了，就去做吧(同性恋)</li>
<li>人文主义教育：为自己想</li>
</ol>
<p>人文主义兴起之后，更加注重人的感觉；在科学革命之前，书上对战争的描述主要描述战争这件事实；而人文主义兴起之后，书上对战争的描述主要是考虑士兵个体的感受；</p>
<p>人文主义在发展过程中，产生了三个分支：进化人文主义，自由人文主义，社会人文主义；</p>
<ul>
<li>进化人文主义　最为代表就是德国纳粹激进民族主义；觉得自己民族是最优民族，灭绝把次等民族，防止次等民族污染优等民族的基因；</li>
<li>自由人文主义　认为每个人都是独特的个体，拥有独一无二的内在声音；</li>
<li>社会人文主义　考虑更多的集体的感受，而不是个人的利益；
目前，世界上的国家主要是自由人文主义和社会主义，例如俄罗斯和中国就是社会主义，发展社会主义经济；而美国和欧洲国家就是自由人文主义，发展资本主义经济；</li>
</ul>
<h2>智人失去控制权</h2>
<p>这章节才是开始预测未来可能发生的趋势；首先提出生命科学的发展，戳破了人文主义的想法，自由个人也是一个虚构的故事，人只是生化算法的组合；既然人是生化算法的组合，那么有机算法和无机算法都有智能，有机算法只是比无机算法多了一个意识，但是无机算法会比人类更加智能；但是在大多数情况下下，人们只需要智能而不要意识，例如谷歌和特斯拉的无人驾驶汽车，如果同是把人运输到目的地，那么这需要智能即可，对于意识可有可无；因此未来很多职业会被算法代替，会产生很多无用阶级；</p>
<p>由《智能时代》我们知道，当数据量大到一定程度时，算法可能会比我们自己更加了解自己；而且生物也是算法，那么由于无机算法比有机算法更加智能，权威将会从个人转移到算法；人将被无机算法淘汰，就向其他动物被人类淘汰一样；人将更加信赖算法，这就导致人文主义的崩塌；</p>
<p>科技人文主义：通过基因工程，纳米技术和脑机界面升级智人，智人将上升为神人，拥有超人类的力量，例如更强大的记忆力，更加智慧的大脑，更加庞大的心理频谱等；</p>
<p>数据主义：人类和人类社会就是一个数据处理系统，当数据量大到人类大脑不能处理时，就需要借助于更加强大电子算法；而且电子算法比我们自己将更加了解自己；</p>
<p>最后把《未来简史》提出三项未来发展列出：</p>
<ol>
<li>生命科学指出所有生物都是算法，而生命是进行数据处理；</li>
<li>智能正在和意识脱钩；</li>
<li>无意识但具备高度智能的算法，可能很快就会比我们更了解自己；</li>
</ol>
<h1>感悟</h1>
<hr>
<p>《人类简史》和《未来简史》是我读到书里面，使我世界观大为改变的两本书(当然，我读书不多，哈哈)，强烈推荐阅读；从人类诞生之初到现代社会，由从现代社会预测未来的可能性，而且这种预测是完全有可能实现，对我们做好未来的准备也很有参考意义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在业余时间，看了以色列历史学家赫拉利两本著作《人类简史》和《未来简史》，这两本书也是受到各大科技大佬，作家以及报社推荐，全球20多个国家争相购得版权热销；我在看完《人类简史》之后，真心佩服赫拉利的学识渊博以及脑洞大；后来，《未来简史》一出版，我也是第一时间购买，并且大概
    
    </summary>
    
      <category term="reading" scheme="http://luodw.cc/categories/reading/"/>
    
    
      <category term="reading" scheme="http://luodw.cc/tags/reading/"/>
    
  </entry>
  
  <entry>
    <title>SeaweedFS概述</title>
    <link href="http://luodw.cc/2017/01/05/weedfs/"/>
    <id>http://luodw.cc/2017/01/05/weedfs/</id>
    <published>2017-01-05T06:46:43.000Z</published>
    <updated>2017-03-16T08:51:34.133Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统在后端开发中，是非常重要的组件，当有存储图片或者视频的时候，文件系统就派上用场了；例如阿里为淘宝上的大量图片存储开发了分布式文件系统TFS和FastDFS，有些直播软件上视频也是存储在文件系统上等等；因此如果是从事后端开发或者分布式存储开发，也必须好好学习研究下文件系统；seaweedfs文件系统实现了Facebook's Haystack文件系统设计论文，它并不支持Linux操作系统中POSIX文件系统语义，而是选择实现了key-&gt;file存储形式，类似于NoSQL，我们也可以称呼为NoFS；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-a123.JPG" alt="100篇博客，上本人照片"></p>
<p>这篇博客，不会深入分析seaweedfs文件系统原理，这里只是简单的介绍，作为之前一段时间的总结；所以这篇文章包括下面３小点:</p>
<ol>
<li>seaweedfs文件系统架构;</li>
<li>seaweedfs操作例子;</li>
<li>总结;</li>
</ol>
<h1>SeaweedFS文件系统架构</h1>
<hr>
<p>分布式文件系统的拓扑结构大体都类似，分为NameNode和DataNode，NameNode负责管理数据节点拓扑结构以及元数据，DataNode负责真实数据存储；在seaweedfs文件系统中，NameNode称为Master，DataNode称为VolumeServer；我们先来看下seaweedfs文件系统整体的拓扑结构:</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_07861.JPG" alt="seaweedfs文件系统拓扑结构"></p>
<p>由架构图可以看出，</p>
<ul>
<li>Master负责管理集群的拓扑结构，分为主从结构，并采用raft实现主从复制和高可用，以此消除单点问题；TFS中的NameNode为了消除单点问题，采取的是虚拟IP配上lvs；</li>
<li>DataNode负责存储具体数据，并与M-Master保持心跳，上报自己的存储信息；</li>
</ul>
<p>当客户端需要存储数据时，</p>
<ol>
<li>需要先给M-Master发送请求，获取该文件存储的DataNode地址，文件存储的VolumeID以及文件fid;</li>
<li>然后客户端接着将文件发送至从Master获取到的DataNode，DataNode会根据VolumeID找到相应的Volume，并将文件存储到该Volume;</li>
</ol>
<blockquote>
<p>分布式文件系统数据节点存储数据时，会创建出若干个大文件(可以想象为磁盘)，用于存储小文件，例如文件，短视频等等；在seaweedfs中，大文件就称为Volume；</p>
</blockquote>
<p>ok，上述是正常情况下seaweedfs运行时的整体架构图，但是机器的东西，说不准哪天就挂了，特别是Master，因为Master挂了，整个文件系统就不可用了；在seaweedfs是通过raft实现高可用，即使M-Master挂了，会通过选举算法，在S-Master选举出新的M-Master，然后所有DataNode则将自己的信息上报给新的M-Master；结构图如下:</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_07871.JPG" alt="选举新M-Master"></p>
<p>图中可以看出，当M-Master挂了之后，剩余两个S-Master会进行选举，产生新的M-Master，此时所有的DataNode将会连接到新的M-Master，并上报自己的存储信息；而客户端下次需要存储文件时，会先到选举产生的新M-Master获取DataNode信息，然后再将文件存储到具体DataNode；</p>
<p>这里，client是如何连接到新的M-Master的，我不是很清楚，因此没有在实际生产环境中部署使用过，但是我觉得可以通过客户端轮询来实现;</p>
<p>接下来，我们来看下Master拓扑结构，如下图:</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_07881.JPG" alt="Master拓扑结构"></p>
<p>seaweedfs拓扑结构主要有三个概念，数据中心(DataCenter)，机架(Rack)，数据节点(DataNode)；这样可以很灵活配置不同数据中心，同一个数据中心下不同机架，同一机架下不同的数据节点；数据都是存储在DataNode中；</p>
<p>最后再来看下DataNode存储节点Volumn布局；如下:
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="code">+-------------+</span></div><div class="line"><span class="section">| SuperBlock  |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle1     |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle2     |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle3     |</span></div><div class="line">+-------------+</div><div class="line"><span class="section">| Needle...   |</span></div><div class="line">+-------------+</div></pre></td></tr></table></figure></p>
<p>一般情况下，一个DataNode会配置多个Volume，这样可以避免多个客户端对同一个Volume读写争抢；每个Volume由一个SuperBlock和若干个Needle组成；每个Needle则代表一个小文件，例如图片和短视频；</p>
<h1>SeaweedFS操作例子</h1>
<hr>
<p>客户端访问seaweedfs，主要是通过http协议，我们通过以下例子来说明；首先开启一个Master以及两个DataNode
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./weed master</div><div class="line">./weed <span class="keyword">volume</span><span class="bash"> -dir=<span class="string">"/tmp/1"</span> -max=5  -mserver=<span class="string">"localhost:9333"</span> -port=8080</span></div><div class="line">./weed <span class="keyword">volume</span><span class="bash"> -dir=<span class="string">"/tmp/2"</span> -max=5  -mserver=<span class="string">"localhost:9333"</span> -port=8081</span></div></pre></td></tr></table></figure></p>
<p>-dir表示该DataNode数据存储的目录，-max表示volume个数最大值，-mserver表示Master地址，-port该DataNode监听的端口；</p>
<p>首先从Master获取一个fid:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; curl -X POST http://localhost:9333/dir/assign</div><div class="line">&#123;<span class="string">"fid"</span>:<span class="string">"3,017ebf0b02"</span>,<span class="string">"url"</span>:<span class="string">"127.0.0.1:8081"</span>,<span class="string">"publicUrl"</span>:<span class="string">"127.0.0.1:8081"</span>,<span class="string">"count"</span>:1&#125;</div></pre></td></tr></table></figure></p>
<p>这里fid中，3表示volumeid，01表示文件的序号，7ebf0b02表示cookie</p>
<p>然后，我们访问127.0.0.1:8081，并传入fid以及文件存储，如下:
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; curl -X PUT -F <span class="keyword">file</span>=@<span class="regexp">/home/</span>charles<span class="regexp">/myphoto.jpg http:/</span><span class="regexp">/127.0.0.1:8081/</span><span class="number">3</span>,<span class="number">017</span>ebf0b02</div><div class="line">&#123;<span class="string">"name"</span>:<span class="string">"myphoto.jpg"</span>,<span class="string">"size"</span>:<span class="number">61188</span>&#125;</div></pre></td></tr></table></figure></p>
<p>这样，图片就已经存储到127.0.0.1:8081DataNode上第3个volume上了；我们可以在浏览器通过链接http://127.0.0.1:8081/3,017ebf0b02访问到刚才存储的图片；</p>
<h1>总结</h1>
<hr>
<p>这篇文章只是简单的介绍seaweedfs的架构以及原理，同时通过简单的上传图片展示如何使用seaweedfs，算是学习记录，也希望给看者入门材料；之前在实习时，看了TFS，了解文件系统大体架构，因此看快就熟悉了seaweedfs的架构；但是seaweedfs使用的是http协议，而TFS使用的是自己设置的协议并且是C++编写，seaweedfs会比TFS简单易懂，而且自带系统后台，方便查看集群信息；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件系统在后端开发中，是非常重要的组件，当有存储图片或者视频的时候，文件系统就派上用场了；例如阿里为淘宝上的大量图片存储开发了分布式文件系统TFS和FastDFS，有些直播软件上视频也是存储在文件系统上等等；因此如果是从事后端开发或者分布式存储开发，也必须好好学习研究下文件
    
    </summary>
    
      <category term="weedfs" scheme="http://luodw.cc/categories/weedfs/"/>
    
    
      <category term="weedfs" scheme="http://luodw.cc/tags/weedfs/"/>
    
  </entry>
  
  <entry>
    <title>NSQ源码分析之nsqlookupd</title>
    <link href="http://luodw.cc/2016/12/13/nsqlookupd/"/>
    <id>http://luodw.cc/2016/12/13/nsqlookupd/</id>
    <published>2016-12-13T02:58:30.000Z</published>
    <updated>2017-03-16T08:51:34.133Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了NSQ整体概述以及拓扑结构；这篇文章开始分析下NSQ源码；NSQ主要由三个部分nsqd,nsqlookupd,nsqadmin以及一些工具组成，我们从简单的nsqlookupd开始分析源码；nsqlookupd是nsq管理集群拓扑信息以及用于注册和发现nsqd服务；所以，也可以把nsqlookupd理解为注册发现服务；当nsq集群中有多个nsqlookupd服务时，因为每个nsqd都会向所有的nsqlookupd上报本地信息，因此nsqlookupd具有最终一致性；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-IMG_0718.JPG" alt="厦门狮山"></p>
<p>这篇文章主要从以下几个方面来分析下nsqlookupd源码：</p>
<ol>
<li>nsqlookupd运行过程；</li>
<li>nsqlookupd优秀设计；</li>
<li>总结；</li>
</ol>
<h1>nsqlookupd运行过程</h1>
<hr>
<h2>NSQ目录结构</h2>
<p>在看nsqlookupd源码之前，先来看下NSQ的目录结构；NSQ目录结构设计也很清晰，从目录就可以看出各个模块什么意思；</p>
<ol>
<li>apps　目录存放了nsqd, nsqlookupd, nsqadmin和一些工具的main函数文件；</li>
<li>internal　目录存放了NSQ内部使用的一些函数，例如三大组件通用函数；</li>
<li>nsqadmin　目录存放了关于nsqadmin源码；</li>
<li>nsqd　目录存放了关于nsqd源码；</li>
<li>nsqlookupd　目录存放了　nsqlookupd的源码；</li>
</ol>
<p>因此如果看nsqlookupd源码的话，我们首先需要看apps/nsqlookupd目录下的nsqlookupd.go文件；</p>
<h2>nsqlookupd启动函数</h2>
<p>NSQ的nsqd和nsqlookupd组件都使用了开源组件</p>
<blockquote>
<p>&quot;github.com/judwhite/go-svc/svc&quot;</p>
</blockquote>
<p>来管理进程的初始化，启动和关闭；我们先来看下main函数
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> program <span class="keyword">struct</span> &#123;</div><div class="line">	nsqlookupd *nsqlookupd.NSQLookupd</div><div class="line">&#125;<span class="comment">//nsqlookupd启动服务实例</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	prg := &amp;program&#123;&#125;</div><div class="line">	<span class="keyword">if</span> err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatal(err)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>svc.run方法接收一个实现了init,start和stop方法的服务实例，以及若干信号；信号用于控制该服务的优雅终止，而服务实例用于开启nsqlookupd服务；</p>
<p>我们来看下program的start方法；
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *program)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	flagSet.Parse(os.Args[<span class="number">1</span>:])</div><div class="line"></div><div class="line">	<span class="keyword">if</span> *showVersion &#123;</div><div class="line">		fmt.Println(version.String(<span class="string">"nsqlookupd"</span>))</div><div class="line">		os.Exit(<span class="number">0</span>)</div><div class="line">	&#125;<span class="comment">//如果只是查看版本号，则显示版本号并退出</span></div><div class="line"></div><div class="line">	<span class="keyword">var</span> cfg <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</div><div class="line">	<span class="keyword">if</span> *config != <span class="string">""</span> &#123;</div><div class="line">		_, err := toml.DecodeFile(*config, &amp;cfg)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Fatalf(<span class="string">"ERROR: failed to load config file %s - %s"</span>, *config, err.Error())</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="comment">//从配置文件解析配置信息</span></div><div class="line"></div><div class="line">	opts := nsqlookupd.NewOptions()</div><div class="line">	options.Resolve(opts, flagSet, cfg)</div><div class="line">	<span class="comment">//实例化一个nsqlookupd实例</span></div><div class="line">	daemon := nsqlookupd.New(opts)</div><div class="line">	<span class="comment">//调用nsqlookupd的Main方法</span></div><div class="line">	daemon.Main()</div><div class="line">	p.nsqlookupd = daemon</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数用于调用nsqlookupd的Main函数，而Main函数才是nsqlookupd模块启动的主体函数；当这个Start函数返回之后，整个程序阻塞在svc.Run方法内部的信号channel上；当我们向这个程序发送SIGINT和SIGTERM信号时，svc.Run函数调用program.Stop方法终止nsqlookupd进程。</p>
<h2>nsqlookupd模块之Main函数</h2>
<p>之前的分析都还是在apps/nsqlookupd目录下，通过之前调用nsqlookupd.Main方法，将代码切换到了nsqlookupd目录下；ok，我们直接找到nsqlookupd/nsqlookupd.Main方法；
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *NSQLookupd)</span> <span class="title">Main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">//整个nsqlookupd模块上下文</span></div><div class="line">	ctx := &amp;Context&#123;l&#125;</div><div class="line"></div><div class="line">	tcpListener, err := net.Listen(<span class="string">"tcp"</span>, l.opts.TCPAddress)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		l.logf(<span class="string">"FATAL: listen (%s) failed - %s"</span>, l.opts.TCPAddress, err)</div><div class="line">		os.Exit(<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">	l.Lock()</div><div class="line">	l.tcpListener = tcpListener</div><div class="line">	l.Unlock()</div><div class="line">	tcpServer := &amp;tcpServer&#123;ctx: ctx&#125;</div><div class="line">	<span class="comment">//开启nsqlookupd的tcp服务</span></div><div class="line">	l.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		protocol.TCPServer(tcpListener, tcpServer, l.opts.Logger)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">	httpListener, err := net.Listen(<span class="string">"tcp"</span>, l.opts.HTTPAddress)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		l.logf(<span class="string">"FATAL: listen (%s) failed - %s"</span>, l.opts.HTTPAddress, err)</div><div class="line">		os.Exit(<span class="number">1</span>)</div><div class="line">	&#125;</div><div class="line">	l.Lock()</div><div class="line">	l.httpListener = httpListener</div><div class="line">	l.Unlock()</div><div class="line">	httpServer := newHTTPServer(ctx)</div><div class="line">	<span class="comment">//开启nsqlookupd的http服务</span></div><div class="line">	l.waitGroup.Wrap(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		http_api.Serve(httpListener, httpServer, <span class="string">"HTTP"</span>, l.opts.Logger)</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，l.waitGroup是sync.WaitGroup的子类，该类的Wrap方法用于在新的goroutine调用参数func函数；因此在执行Main方法之后，此时nsqlookupd进程就另外开启了两个goroutine，一个用于执行tcp服务，一个用于执行http服务；我们分别来看下；</p>
<h2>nsqlookupd之tcp服务；</h2>
<p>上篇文章有说道，nsqlookupd的tcp服务是用于处理nsqd上报信息的；我们顺着之前的Main方法，找到开启tcp服务的代码internal/protocol/tcp_server.go，如下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> TCPHandler <span class="keyword">interface</span> &#123;</div><div class="line">	Handle(net.Conn)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TCPServer</span><span class="params">(listener net.Listener, handler TCPHandler, l app.Logger)</span></span> &#123;</div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"TCP: listening on %s"</span>, listener.Addr()))</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		clientConn, err := listener.Accept()</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</div><div class="line">				l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"NOTICE: temporary Accept() failure - %s"</span>, err))</div><div class="line">				runtime.Gosched()</div><div class="line">				<span class="keyword">continue</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// theres no direct way to detect this error because it is not exposed</span></div><div class="line">			<span class="keyword">if</span> !strings.Contains(err.Error(), <span class="string">"use of closed network connection"</span>) &#123;</div><div class="line">				l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"ERROR: listener.Accept() - %s"</span>, err))</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">go</span> handler.Handle(clientConn)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"TCP: closing %s"</span>, listener.Addr()))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个TCPServer函数是公共函数部分，因此这个函数也用于nsqd的tcp服务；这个函数和平时见到的golang网络编程模型一样，在一个for循环中，接收一个客户端，并开启一个新的goroutine来处理这个客户端；</p>
<p>接下来，看下这个TCPHandler，这是个接口，这个接口包含Handle(net.Conn)方法，从Main方法可以看出，传入的TCPHandler是类tcpServer；我们接下来看下，在文件nsqlookupd/tcp.go:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> tcpServer <span class="keyword">struct</span> &#123;</div><div class="line">	ctx *context</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *tcpServer)</span> <span class="title">Handle</span><span class="params">(clientConn net.Conn)</span></span> &#123;</div><div class="line">	......</div><div class="line">	<span class="keyword">var</span> prot protocol.Protocol</div><div class="line">	<span class="keyword">switch</span> protocolMagic &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"  V1"</span>:</div><div class="line">		prot = &amp;LookupProtocolV1&#123;ctx: p.ctx&#125;</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		protocol.SendResponse(clientConn, []<span class="keyword">byte</span>(<span class="string">"E_BAD_PROTOCOL"</span>))</div><div class="line">		clientConn.Close()</div><div class="line">		p.ctx.nsqlookupd.logf(<span class="string">"ERROR: client(%s) bad protocol magic '%s'"</span>,</div><div class="line">			clientConn.RemoteAddr(), protocolMagic)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	err = prot.IOLoop(clientConn)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		p.ctx.nsqlookupd.logf(<span class="string">"ERROR: client(%s) - %s"</span>, clientConn.RemoteAddr(), err)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	......</div></pre></td></tr></table></figure></p>
<p>这个tcpServer只有一个成员ctx，之前在Main函数有看到，这个context只有一个成员，即这个nsqlookupd实例的地址；这个context其实主要作用就是在各模块间传递nsqlookupd这个实例，便于访问nsqlookupd地址；nsq协议有默认(其实就是v0)和v1，因此代码有根据协议的版本执行不同的代码；我们以协议v1为例；这个Handle方法最后调用了LookupProtocolV1.IOLoop方法；由名字可以看出这个IOLoop函数是一个循环，我们来看下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">...........<span class="comment">//省去一些代码</span></div><div class="line">client := NewClientV1(conn)</div><div class="line">reader := bufio.NewReader(client)</div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">	<span class="comment">//读取用户的请求命令</span></div><div class="line">	line, err = reader.ReadString(<span class="string">'\n'</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">break</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	line = strings.TrimSpace(line)</div><div class="line">	<span class="comment">//按空格切割用户请求，params存储的就是用户请求命令以及参数</span></div><div class="line">	params := strings.Split(line, <span class="string">" "</span>)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> response []<span class="keyword">byte</span></div><div class="line">	<span class="comment">//执行请求并返回结果</span></div><div class="line">	response, err = p.Exec(client, reader, params)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		ctx := <span class="string">""</span></div><div class="line">		<span class="keyword">if</span> parentErr := err.(protocol.ChildErr).Parent(); parentErr != <span class="literal">nil</span> &#123;</div><div class="line">			ctx = <span class="string">" - "</span> + parentErr.Error()</div><div class="line">		&#125;</div><div class="line">		p.ctx.nsqlookupd.logf(<span class="string">"ERROR: [%s] - %s%s"</span>, client, err, ctx)</div><div class="line"></div><div class="line">		_, sendErr := protocol.SendResponse(client, []<span class="keyword">byte</span>(err.Error()))</div><div class="line">		<span class="keyword">if</span> sendErr != <span class="literal">nil</span> &#123;</div><div class="line">			p.ctx.nsqlookupd.logf(<span class="string">"ERROR: [%s] - %s%s"</span>, client, sendErr, ctx)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// errors of type FatalClientErr should forceably close the connection</span></div><div class="line">		<span class="keyword">if</span> _, ok := err.(*protocol.FatalClientErr); ok &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">continue</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> response != <span class="literal">nil</span> &#123;</div><div class="line">		_, err = protocol.SendResponse(client, response)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后这个客户端的goroutine就在这个循环中不断执行用户(其实就是nsqd服务)请求；过程如下:</p>
<ol>
<li>读取用户请求；</li>
<li>将用户请求字符串按空格切割成字符串数组；</li>
<li>调用LookupProtocolV1.Exec方法，执行具体请求；</li>
</ol>
<p>最后来看下LookupProtocolV1.Exec方法;
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *LookupProtocolV1)</span> <span class="title">Exec</span><span class="params">(client *ClientV1, reader *bufio.Reader, params []<span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">switch</span> params[<span class="number">0</span>] &#123;</div><div class="line">	<span class="keyword">case</span> <span class="string">"PING"</span>:</div><div class="line">		<span class="keyword">return</span> p.PING(client, params)</div><div class="line">	<span class="keyword">case</span> <span class="string">"IDENTIFY"</span>:</div><div class="line">		<span class="keyword">return</span> p.IDENTIFY(client, reader, params[<span class="number">1</span>:])</div><div class="line">	<span class="keyword">case</span> <span class="string">"REGISTER"</span>:</div><div class="line">		<span class="keyword">return</span> p.REGISTER(client, reader, params[<span class="number">1</span>:])</div><div class="line">	<span class="keyword">case</span> <span class="string">"UNREGISTER"</span>:</div><div class="line">		<span class="keyword">return</span> p.UNREGISTER(client, reader, params[<span class="number">1</span>:])</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, protocol.NewFatalClientErr(<span class="literal">nil</span>, <span class="string">"E_INVALID"</span>, fmt.Sprintf(<span class="string">"invalid command %s"</span>, params[<span class="number">0</span>]))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个函数可以看出，nsqd向nsqlookupd发送的信息只有上述四个命令，我分别说明下:</p>
<ol>
<li>PING nsqd每隔一段时间都会向nsqlookupd发送心跳，表明自己还活着；</li>
<li>IDENTITY 当nsqd第一次连接nsqlookupd时，发送IDENTITY，验证自己身份；</li>
<li>REGISTER 当nsqd创建一个topic或者channel时，向nsqlookupd发送REGISTER请求，在nsqlookupd上更新当前nsqd的topic或者channel信息；</li>
<li>UNREGISTER 当nsqd删除一个topic或者channel时，向nsqlookupd发送UNREGISTER请求，在nsqlookupd上更新当前nsqd的topic或者channel信息；
具体各个命令怎么执行，这里就不去分析了；需要提一点是，nsqd的信息是保存在registration_db这样的实例里面的；</li>
</ol>
<p>我们来总结下nsqlookupd的tcp执行流程:</p>
<ol>
<li>首先在Main函数开启一个goroutine来开启一个tcp循环，接收nsqd连接请求；</li>
<li>当接收到一个nsqd接请求时，开启一个goroutine来处理这个nsqd；</li>
<li>这个nsqd先是经历tcpServer.Handle函数，然后到LookupProtocolV1.IOLoop函数，并阻塞在此函数中；</li>
<li>当nsqd发送请求时，LookupProtocolV1.IOLoop函数先是读取该请求，并调用LookupProtocolV1.Exec函数执行具体请求；</li>
</ol>
<h2>nsqlookupd之http服务</h2>
<p>nsqlookupd的http服务是用于向nsqadmin提供查询接口的，本质上，就是一个web服务器，提供http查询接口；我们顺着Main函数，来看下http是怎么运行的，在文件internel/http_api/http_server.go中
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(listener net.Listener, handler http.Handler, proto <span class="keyword">string</span>, l app.Logger)</span></span> &#123;</div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"%s: listening on %s"</span>, proto, listener.Addr()))</div><div class="line"></div><div class="line">	server := &amp;http.Server&#123;</div><div class="line">		Handler:  handler,</div><div class="line">		ErrorLog: log.New(logWriter&#123;l&#125;, <span class="string">""</span>, <span class="number">0</span>),</div><div class="line">	&#125;</div><div class="line">	err := server.Serve(listener)</div><div class="line">	<span class="comment">// theres no direct way to detect this error because it is not exposed</span></div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !strings.Contains(err.Error(), <span class="string">"use of closed network connection"</span>) &#123;</div><div class="line">		l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"ERROR: http.Serve() - %s"</span>, err))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	l.Output(<span class="number">2</span>, fmt.Sprintf(<span class="string">"%s: closing %s"</span>, proto, listener.Addr()))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数也很简单，实例化http.Server模块，然后调用server.Server(listner)函数开启http服务；如果之前有看过golang的http模块，应该知道http模块最重要的就是http.Handler，因为http.Handler提供了路由查询，视图函数执行功能；在Main函数看到传入的http.Handler是newHTTPServer这个类，我们来看下:
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> httpServer <span class="keyword">struct</span> &#123;</div><div class="line">	ctx    *Context</div><div class="line">	router http.Handler</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newHTTPServer</span><span class="params">(ctx *Context)</span> *<span class="title">httpServer</span></span> &#123;</div><div class="line">	log := http_api.Log(ctx.nsqlookupd.opts.Logger)</div><div class="line">	<span class="comment">//实例化一个httprouter</span></div><div class="line">	router := httprouter.New()</div><div class="line">	router.HandleMethodNotAllowed = <span class="literal">true</span></div><div class="line">	<span class="comment">//设置panic时的处理函数</span></div><div class="line">	router.PanicHandler = http_api.LogPanicHandler(ctx.nsqlookupd.opts.Logger)</div><div class="line">	<span class="comment">//设置not found处理函数</span></div><div class="line">	router.NotFound = http_api.LogNotFoundHandler(ctx.nsqlookupd.opts.Logger)</div><div class="line">	<span class="comment">//当请求方法不支持时的处理函数</span></div><div class="line">	router.MethodNotAllowed = http_api.LogMethodNotAllowedHandler(ctx.nsqlookupd.opts.Logger)</div><div class="line">	s := &amp;httpServer&#123;</div><div class="line">		ctx:    ctx,</div><div class="line">		router: router,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	router.Handle(<span class="string">"GET"</span>, <span class="string">"/ping"</span>, http_api.Decorate(s.pingHandler, log, http_api.PlainText))</div><div class="line">	<span class="comment">//省略后续路由定义</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *httpServer)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">	s.router.ServeHTTP(w, req)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>nsqlookupd的http服务路由使用的是开源框架httprouter；httprouter路由使用radix树来存储路由信息，路由查找上效率高，同时提供一些其他优秀特性，因此很受欢迎，gin web框架使用的就是httprouter路由；</p>
<p>这个httpServer有两个成员属性，一个是context，用于传递nsqlookupd地址，一个是httprouter实例，用于定义路由以及提供路由查找入口；这个httpServer.ServerHTTP函数内部调用httprouter.ServerHTTP来处理http请求；</p>
<p>针对这个函数，我们最后再来看下路由定义中的http_api.Decorate函数，在文件internal/http_api/api_response.go
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decorate</span><span class="params">(f APIHandler, ds ...Decorator)</span> <span class="title">httprouter</span>.<span class="title">Handle</span></span> &#123;</div><div class="line">	decorated := f</div><div class="line">	<span class="keyword">for</span> _, decorate := <span class="keyword">range</span> ds &#123;</div><div class="line">		decorated = decorate(decorated)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request, ps httprouter.Params)</span></span> &#123;</div><div class="line">		decorated(w, req, ps)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数其实就是一个装饰器，第一个参数为需要被装饰的视图函数，从第二参数开始，都是装饰函数，最后返回装饰好的视图函数；http模块比较简单，和其他的web服务一样，很容易看懂；每个路由以及对应的视图函数比较多，这里就不一一解释了；</p>
<h1>nsqlookupd优秀设计</h1>
<hr>
<p>上部分主要分析了nsqlookupd执行过程，主要有两个方面，一个是tcp，另一个是http；这部分，我将根据自己的理解，写下我认为nsqlookupd优秀设计；学习开源框架，除了使用和了解原理外，我觉得学习开源框架优秀设计以及代码技巧也是非常有意义的一件事；</p>
<h2>优雅的代码启动方式和退出方式</h2>
<p>nsqlookupd模块使用开源框架svc来开启进程以及控制进程的退出；本人也一直很喜欢使用信号的方式来退出进程，这样可以在进程收到信号时，可以做一些扫尾操作；虽然svc也是用信号来控制进程退出，但是使用svc，使代码看起来更简介优雅；</p>
<h2>context的使用</h2>
<p>nsqlookupd服务使用context来保存上下文(nsqlookupd实例地址)，这样在每个模块就可以很方便地访问nsqdlookupd实例；这有点类似与golang1.7正式引入的context；</p>
<h2>代码复用</h2>
<p>接口的使用，使代码复用更加容易；而且golang的继承是非浸入式的，即不需要显示声明某结构体继承自某个接口，只要该结构体实现了接口定义的函数即可；例如internal/protocol/tcp_server.go
<figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> <span class="type">TCPHandler</span> interface &#123;</div><div class="line">	<span class="type">Handle</span>(net.<span class="type">Conn</span>)</div><div class="line">&#125;</div><div class="line"><span class="title">func</span> <span class="type">TCPServer</span>(listener net.<span class="type">Listener</span>, handler <span class="type">TCPHandler</span>, l app.<span class="type">Logger</span>)</div></pre></td></tr></table></figure></p>
<p>这个函数是用于开启tcp服务，nsqd和nsqlookupd都有使用，这里的TCPHandler就是一个接口，nsqd和nsqlookupd服务分别有相应的结构体实现了TCPHandler，然后传入这个函数中；</p>
<h2>视图函数封装</h2>
<p>在web开发过程中，每个路由都有对应的视图函数，当我们在执行一个视图函数时，我们有打印日志(例如请求执行时间)或者判断权限等需求；如果在写每个视图函数时，都手动添加日志打印，第一是麻烦，第二是代码冗余；如果用装饰器模式将会非常方便；nsqlookupd的http服务针对每个视图函数都进行了装饰；如果所有视图函数的装饰函数是一样，那么我们可以直接装饰在http.handler上，这样可以简化代码；python的bottle也提供了类似功能，但是bottle是以插件的形式引入装饰器；</p>
<h1>总结</h1>
<p>这篇文章分析了nsqlookupd服务执行过程以及分享了我自认为一些好的代码设计；nsqlookupd对golang主要特性channel使用比较少，我们将会在nsqd中看到NSQ是如何优雅使用goroutine和channel.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章介绍了NSQ整体概述以及拓扑结构；这篇文章开始分析下NSQ源码；NSQ主要由三个部分nsqd,nsqlookupd,nsqadmin以及一些工具组成，我们从简单的nsqlookupd开始分析源码；nsqlookupd是nsq管理集群拓扑信息以及用于注册和发现nsqd
    
    </summary>
    
      <category term="nsq" scheme="http://luodw.cc/categories/nsq/"/>
    
    
      <category term="nsq" scheme="http://luodw.cc/tags/nsq/"/>
    
      <category term="nsqlookupd" scheme="http://luodw.cc/tags/nsqlookupd/"/>
    
  </entry>
  
  <entry>
    <title>NSQ源码分析之概述</title>
    <link href="http://luodw.cc/2016/12/08/nsq01/"/>
    <id>http://luodw.cc/2016/12/08/nsq01/</id>
    <published>2016-12-08T07:03:29.000Z</published>
    <updated>2017-03-16T08:51:34.129Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列在互联网公司使用非常普遍，因此也促使我去学习研究消息队列的原理以及细节问题；之前也有接触过消息队列，最主要就是在异步处理方面，当然消息队列还解耦，流量削峰等功能；目前消息队列产品也比较多，例如kafka，ActiveMQ，RabbitMQ，NSQ等等；之前原本打算看kafka，但是处于学习成本(kafka是scala编写，之前scala接触的比较少)，所以就先不看kafka，选择了NSQ；NSQ主要是golang编写，本人刚好非常喜欢golang这门语言，因此在学习NSQ的同时，也可以学习NSQ是如何优雅地使用golang;</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1802933924.jpg" alt="厦门飞机场"></p>
<p>目前，看了nsqlookupd的代码，写的真的很精美，我觉得代码可以和redis相媲美，这等后续分析代码时再详说；关于NSQ的特性，可以查看<a href="http://nsq.io/overview/features_and_guarantees.html" target="_blank" rel="external">NSQ官网</a>；这篇文章主要分析以下几点:</p>
<ol>
<li>NSQ概述;</li>
<li>python操作NSQ;</li>
<li>总结;</li>
</ol>
<h1>NSQ概述</h1>
<hr>
<p>NSQ提供了三大组件以及一些工具，三大组件为:</p>
<ol>
<li>nqsd NSQ主要组件，用于存储消息以及分发消息；</li>
<li>nsqlookupd 用于管理nsqd集群拓扑，提供查询nsqd主机地址的服务以及服务最终一致性；</li>
<li>nsqadmin 用于管理以及查看集群中的topic,channel,node等等；</li>
</ol>
<p>对于单机版，只需要用到nsqd就够了，但是单机会出现单点问题以及没有监控，因此如果是线上环境，都会部署nsqlookupd,nsqadmin以及nsqd集群；这里先给出我手绘的NSQ拓扑图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-3139862022.jpg" alt="NSQ拓扑"></p>
<p>NSQ的拓扑结构和文件系统的拓扑结构类似，有一个中心节点来管理集群节点；我们从图中可以看出:</p>
<ol>
<li>nsqlookupd服务同时开启tcp和http两个监听服务，nsqd会作为客户端，连上nsqlookupd的tcp服务，并上报自己的topic和channel信息，以及通过心跳机制判断nsqd状态；还有个http服务提供给nsqadmin获取集群信息；</li>
<li>nsqadmin只开启http服务，其实就是一个web服务，提供给客户端查询集群信息；</li>
<li>nsqd也会同时开启tcp和http服务，两个服务都可以提供给生产者和消费者，http服务还提供给nsqadmin获取该nsqd本地topic和channel信息；</li>
</ol>
<p>以上就是NSQ集群服务整体拓扑信息，下面来看下客户端方面；NSQ提供了多种语言的支持，比如go-nsq for golang，pynsq for python等；上述拓扑信息，我也是看了pynsq才弄懂了客户端是如何和nsq集群连接的；我们来看下:</p>
<ol>
<li>生产者会同时连上NSQ集群中所有nsqd节点，当然这些节点的地址是在Writer初始化时，通过外界传递进去；当发布消息时，writer会随机选择一个nsqd节点发布某个topic的消息；</li>
<li>消费者也会同时连上NSQ集群中所有nsqd节点，reader首先会连上nsqlookupd，获取集群中topic的所有producer，然后通过tcp连上所有producer节点，并在本地用tornado轮询每个连接，当某个连接有可读事件时，即有消息达到，处理即可；</li>
</ol>
<p>根据我自己的理解，说说NSQ优点:</p>
<ul>
<li>高可用(无单点问题) writer和reader是直接连上各个nsqd节点，因此即使nsqlookupd挂了，也不影响线上正常使用；即使某个nsqd节点挂了，writer发布消息时，发现节点挂了，可以选择其他节点(当然，这是客户端负责的)，单个节点挂了对reader无影响；</li>
<li>高性能 writer在发布消息时，是随机发布到集群中nsqd节点，因此在一定程序上达到负载均衡；reader同时监听着集群中所有nsqd节点，无论哪个节点有消息，都会投递到reader上；</li>
<li>高可扩展 当向集群中添加节点时，首先reader会通过nsqlookupd发现新的节点加入，并i自动连接；因为writer连接的nsqd节点的地址是初始化时设置的，因此增加节点时，只需要在初始化writer时，添加新节点的地址即可；</li>
</ul>
<p>ok，分析了NSQ集群整体的拓扑结构之后，我们来看下单个nsqd节点是如何处理消息的，下面给出官网提供的动图:
<img src="https://f.cloud.github.com/assets/187441/1700696/f1434dc8-6029-11e3-8a66-18ca4ea10aca.gif" alt="nsqd消息处理"></p>
<p>当向某个topic发布一个消息时，该消息会被复制到所有的channel，如果channel只有一个客户端，那么channel就将消息投递给这个客户端；如果channel的客户端不止一个，那么channel将把消息随机投递给任何一个客户端，这也可以看做是客户端的负载均衡；</p>
<h1>python操作nsq</h1>
<hr>
<p>NSQ官网上已经有NSQ快速入门操作，这里就不去讲述了，我们来看下python是如何操作nsq；首先要下载pynsq包，可以用
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install pynsq</div></pre></td></tr></table></figure></p>
<p>然后需要在三个终端分别开启nsqd，nsqlookupd和nsqadmin服务
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./nsqlookupd</div><div class="line">./nsqd --lookupd-tcp-address=127.0.0.1:4160</div><div class="line">./nsqadmin --lookupd-http-address=127.0.0.1:4161</div></pre></td></tr></table></figure></p>
<p>三个服务开启之后，我们就可以编写生产者和消费者；生产者代码如下：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> nsq</div><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub_message</span><span class="params">()</span>:</span></div><div class="line">    writer.pub(<span class="string">'test'</span>, time.strftime(<span class="string">'%H:%M:%S'</span>).encode(<span class="string">'utf-8'</span>), finish_pub)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish_pub</span><span class="params">(conn, data)</span>:</span></div><div class="line">    print(data)</div><div class="line"></div><div class="line">writer = nsq.Writer([<span class="string">'127.0.0.1:4150'</span>])</div><div class="line">tornado.ioloop.PeriodicCallback(pub_message, <span class="number">5000</span>).start()</div><div class="line">nsq.run()</div></pre></td></tr></table></figure></p>
<p>消费者代码如下：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> nsq</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(message)</span>:</span></div><div class="line">    print(message.body)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line">r = nsq.Reader(message_handler=handler,</div><div class="line">        nsqd_tcp_addresses=[<span class="string">'127.0.0.1:4150'</span>],</div><div class="line">        topic=<span class="string">'test'</span>, channel=<span class="string">'test'</span>, lookupd_poll_interval=<span class="number">15</span>)</div><div class="line">nsq.run()</div></pre></td></tr></table></figure></p>
<p>这里消费者，暂时连接到具体的nsqd实例，因为连接到nsqlookupd会报错，根据出错提示，应该是pynsq包对nsqlookupd返回的结果处理出错；</p>
<p>这里的生产者每隔5秒向'test' topic发送时间字符串，消费者可以得到这个时间字符串，我们可以看下上述生产者和消费的输出；
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生产者输出，返回ok，表示消息投递成功</span></div><div class="line">charles@charles-Aspire<span class="number">-4741</span>:~/mydir/pydir$ python3 nsq_producer.py </div><div class="line">b<span class="string">'OK'</span></div><div class="line">b<span class="string">'OK'</span></div><div class="line">b<span class="string">'OK'</span></div><div class="line">b<span class="string">'OK'</span></div><div class="line">.....</div><div class="line"><span class="comment">//消费者输出</span></div><div class="line">charles@charles-Aspire<span class="number">-4741</span>:~/mydir/pydir$ python3 nsq_consume.py </div><div class="line">b<span class="string">'19:36:11'</span></div><div class="line">b<span class="string">'19:36:16'</span></div><div class="line">b<span class="string">'19:36:21'</span></div><div class="line">b<span class="string">'19:36:26'</span></div><div class="line">b<span class="string">'19:36:31'</span></div><div class="line">.....</div></pre></td></tr></table></figure></p>
<p>上述就是python操作nsq最简单的示例程序；</p>
<h2>总结</h2>
<hr>
<p>这篇文章分析了nsq的架构设计，并通过一个简单的例子说明了nsq如何使用；当然nsq还有很多配置参数，例如每隔消息队列的长度，以及内存使用上限等等；后续文章，将继续分析nsqlookupd和nsqd的源码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列在互联网公司使用非常普遍，因此也促使我去学习研究消息队列的原理以及细节问题；之前也有接触过消息队列，最主要就是在异步处理方面，当然消息队列还解耦，流量削峰等功能；目前消息队列产品也比较多，例如kafka，ActiveMQ，RabbitMQ，NSQ等等；之前原本打算看
    
    </summary>
    
      <category term="nsq" scheme="http://luodw.cc/categories/nsq/"/>
    
    
      <category term="nsq" scheme="http://luodw.cc/tags/nsq/"/>
    
  </entry>
  
  <entry>
    <title>python之wsgiref模块</title>
    <link href="http://luodw.cc/2016/11/12/python-wsgi/"/>
    <id>http://luodw.cc/2016/11/12/python-wsgi/</id>
    <published>2016-11-12T11:34:43.000Z</published>
    <updated>2017-03-16T08:51:34.133Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了python的http原生模块，分析了原生http模块的实现原理以及不足;而实际使用过程中，用的比较多的是python的wsgi server和wsgi application; 关于什么是wsgi协议，简单的来说，就是wsgi server调用wsgi application接口的约定，即当有个请求到达wsgi server时，wsgi server通过调用wsgi application提供的接口来处理这个请求;其实，看过python wsgiref模块，也就能理解什么是wsgi模块。</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1970767937.jpg" alt="圆明园遗址(时光相册制作)"></p>
<p>现在比较流行的wsgi application有bottle, flask,django等，比较流行的wsgi server有werkzeug,gunicorn,gevent等;今天这篇文章主要分析下python自带的wsgiref模块，以这个为模板，可以理解下wsgi协议；</p>
<p>这篇文章主要有以下两部分：</p>
<ol>
<li>wsgiref简单示例</li>
<li>wsgiref实现原理</li>
<li>原理解释示例程序</li>
<li>总结</li>
</ol>
<h2>wsgiref简单示例</h2>
<hr>
<p>这里先给出wsgiref模块的简单示例，有个感性的认识，后续在分析实现原理；代码如下:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</div><div class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    httpd = make_server(<span class="string">''</span>, <span class="number">9999</span>, application)</div><div class="line">    print(<span class="string">"Serving HTTP on port 9999..."</span>)</div><div class="line">    httpd.serve_forever()</div></pre></td></tr></table></figure></p>
<p>这个示例程序很简单，创建一个httpd服务器，并监听9999端口，当有客户端请求时，在浏览器显示Hello, web字符串；</p>
<p>上述例子中的application就是wsgiref application，当然也可以一个类，平时常见的也是类，例如flask,bottle等，这些类实现__call__方法，并且该方法参数为environ, start_response即可，environ为一个字典，保存系统变量以及请求相关属性，例如请求路径，请求参数，请求方法等等；start_response为函数，设置response的状态码和header，然后application函数的返回值为response的body；因此上述例子程序，设置response状态码为200，表示请求成功，在headers添加返回数据类型为text/html，以及返回的response body为[b'&lt;h1&gt;Hello, web!&lt;/h1&gt;']</p>
<h2>wsgiref实现原理</h2>
<hr>
<p>wsgiref模块也是由server和handler组成，server用于监听端口，接收请求；handler用于处理请求；先来看下server
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIServer</span><span class="params">(HTTPServer)</span>:</span></div><div class="line"></div><div class="line">    <span class="string">"""BaseHTTPServer that implements the Python WSGI protocol"""</span></div><div class="line"></div><div class="line">    application = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_bind</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Override server_bind to store the server name."""</span></div><div class="line">        HTTPServer.server_bind(self)</div><div class="line">        self.setup_environ()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_environ</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Set up base environment</span></div><div class="line">        env = self.base_environ = &#123;&#125;</div><div class="line">        env[<span class="string">'SERVER_NAME'</span>] = self.server_name</div><div class="line">        env[<span class="string">'GATEWAY_INTERFACE'</span>] = <span class="string">'CGI/1.1'</span></div><div class="line">        env[<span class="string">'SERVER_PORT'</span>] = str(self.server_port)</div><div class="line">        env[<span class="string">'REMOTE_HOST'</span>]=<span class="string">''</span></div><div class="line">        env[<span class="string">'CONTENT_LENGTH'</span>]=<span class="string">''</span></div><div class="line">        env[<span class="string">'SCRIPT_NAME'</span>] = <span class="string">''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_app</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.application</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_app</span><span class="params">(self,application)</span>:</span></div><div class="line">        self.application = application</div></pre></td></tr></table></figure></p>
<p>WSGIServer继承自HTTPServer，并重载来server_bind方法，同时提供注册和获取server application的接口；其中set_environ函数设置了该web应用程序的环境变量，例如服务器名称，服务器端口等等；</p>
<p>ok，了解来WSGIServer之后，来看下handler是如何实现；WSGIRequestHandler类继承自BaseHTTPRequestHandler，并且重载handle方法，即处理请求的方法；</p>
<p>我们来看下WSGIRequestHandler的handle方法：
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="string">""</span><span class="string">"Handle a single HTTP request"</span><span class="string">""</span></div><div class="line">	<span class="comment"># 读取客户端发送的请求行</span></div><div class="line">        <span class="keyword">self</span>.raw_requestline = <span class="keyword">self</span>.rfile.readline(<span class="number">65537</span>)</div><div class="line">        <span class="keyword">if</span> len(<span class="keyword">self</span>.raw_requestline) &gt; <span class="number">65536</span>:</div><div class="line">            <span class="keyword">self</span>.requestline = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.request_version = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.command = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.send_error(<span class="number">414</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">	<span class="comment"># 解析客户端的请求行和请求头</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.parse_request(): <span class="comment"># An error code has been sent, just exit</span></div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="comment"># Avoid passing the raw file object wfile, which can do partial</span></div><div class="line">        <span class="comment"># writes (Issue 24291)</span></div><div class="line">        stdout = BufferedWriter(<span class="keyword">self</span>.wfile)</div><div class="line">        <span class="symbol">try:</span></div><div class="line">	　　<span class="comment"># 用于调用wsgi application的handler</span></div><div class="line">            handler = ServerHandler(</div><div class="line">                <span class="keyword">self</span>.rfile, stdout, <span class="keyword">self</span>.get_stderr(), <span class="keyword">self</span>.get_environ()</div><div class="line">            )</div><div class="line">            handler.request_handler = <span class="keyword">self</span>      <span class="comment"># backpointer for logging</span></div><div class="line">            handler.run(<span class="keyword">self</span>.server.get_app())</div><div class="line">        <span class="symbol">finally:</span></div><div class="line">            stdout.detach()</div></pre></td></tr></table></figure></p>
<p>handle函数首先解析请求行和请求头，然后实例化ServerHandler类，用该类来调用wsgi application；</p>
<p>ServerHandler类接受参数为socket读端，输出端，错误输出端以及一个包含请求信息的字典；self.get_environ()函数返回包含web应用程序的环境变量和请求的环境变量的字典；</p>
<p>最后再来看下ServerHandler;ServerHandler继承自SimpleHandler,SimpleHandler继承自BaseHandler；我们直接看下ServerHandler的run方法；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>, application)</span></span>:</div><div class="line">	<span class="symbol">try:</span></div><div class="line">            <span class="keyword">self</span>.setup_environ()</div><div class="line">            <span class="keyword">self</span>.result = application(<span class="keyword">self</span>.environ, <span class="keyword">self</span>.start_response)</div><div class="line">            <span class="keyword">self</span>.finish_response()</div><div class="line">        <span class="symbol">except:</span></div><div class="line">            <span class="symbol">try:</span></div><div class="line">                <span class="keyword">self</span>.handle_error()</div><div class="line">            <span class="symbol">except:</span></div><div class="line">                <span class="comment"># If we get an error handling an error, just give up already!</span></div><div class="line">                <span class="keyword">self</span>.close()</div><div class="line">                raise   <span class="comment"># ...and let the actual server figure it out.</span></div></pre></td></tr></table></figure></p>
<ol>
<li>self.setup_environ函数用于建立每次请求的相关信息，并存储在self.environ；</li>
<li>self.start_response为该handler函数，用于设置response的状态码和header；</li>
<li>self.result为response body；</li>
<li>self.finish_response用于将response返回给客户端；</li>
</ol>
<p>这个handler类就不一一分析了，详情可以看wsgiref/handlers.py模块；</p>
<h2>原理解释示例程序</h2>
<hr>
<p>了解了wsgiref模块之后．从原理层面来解释上述例子程序；再次粘帖程序代码如下:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</div><div class="line">    <span class="keyword">return</span> [<span class="string">b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    httpd = make_server(<span class="string">''</span>, <span class="number">9999</span>, application)</div><div class="line">    print(<span class="string">"Serving HTTP on port 9999..."</span>)</div><div class="line">    httpd.serve_forever()</div></pre></td></tr></table></figure></p>
<p>示例程序先是调用wsgiref模块的make_server方法，可以看下该方法如下：
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def make<span class="number">_</span>server(</div><div class="line">    host, port, app, server<span class="number">_</span><span class="keyword">class</span>=WSGIServer, handler<span class="number">_</span><span class="keyword">class</span>=WSGIRequestHandler</div><div class="line">):</div><div class="line">    <span class="string">"""Create a new WSGI server listening on `host` and `port` for `app`"""</span></div><div class="line">    server = server<span class="number">_</span><span class="keyword">class</span>((host, port), handler<span class="number">_</span><span class="keyword">class</span>)</div><div class="line">    server.set<span class="number">_</span>app(app)</div><div class="line">    <span class="keyword">return</span> server</div></pre></td></tr></table></figure></p>
<p>可以看到wsgiref默认的server_class为WSGIServer，handler_class为WSGIRequestHandler；先是实例化一个WSGIServer，然后注册application，最后返回该server实例；</p>
<p>在示例程序中，最后调用httpd.server_forever()方法开启事件监听循环；</p>
<p>当某个请求到来之后，先是实例化一个WSGIRequestHandler，并在该WSGIRequestHandler的handle方法内部解析请求参数，以及实例化一个ServerHandler，以及调用ServerHandler的run方法来处理请求；</p>
<p>在ServerHandler的run方法内部先是建立环境变量字典environ，然后调用wsgi application设置resopnse的状态码和headers，以及返回response body；最后调用finish_response()方法将response返回给客户端；</p>
<p>上述即为一次请求全过程；</p>
<h2>总结</h2>
<hr>
<p>这篇文章分析了python的wsgiref模块，解释了wsgiref模块一次请求的过程；当然实际应用中，wsgi application可不是示例程序中那么简单的返回一个字符串，因为一个web应用程序需要根据路由来调用相应的view函数以及一些其他特性，这等到分析bottle时再来分析；</p>
<p>wsgi server和wsgi application分离的设计，使python web的开发非常灵活，在部署python web应用程序时，可以根据性能的需求，选择合适的wsgi server；例如flask自带的wsgi server不适合在正式工业环境中使用，因此flask经常的搭配是nginx+gunicorn+flask，而不是用自带的werkzeug；</p>
<p>不同的wsgi server，区别主要是在并发模型的选择上，有单线程，多进程，多线程，协程；而wsgi application主要功能相近，无非就是根据请求路由，执行相应的view函数，当然有一些特性上的不同；</p>
<p>今天就先写到这，下篇文章分析bottle的实现；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写了python的http原生模块，分析了原生http模块的实现原理以及不足;而实际使用过程中，用的比较多的是python的wsgi server和wsgi application; 关于什么是wsgi协议，简单的来说，就是wsgi server调用wsgi appli
    
    </summary>
    
      <category term="python" scheme="http://luodw.cc/categories/python/"/>
    
    
      <category term="python" scheme="http://luodw.cc/tags/python/"/>
    
      <category term="wsgiref" scheme="http://luodw.cc/tags/wsgiref/"/>
    
      <category term="wsgi" scheme="http://luodw.cc/tags/wsgi/"/>
    
  </entry>
  
  <entry>
    <title>python之HTTP模块</title>
    <link href="http://luodw.cc/2016/11/05/python-http/"/>
    <id>http://luodw.cc/2016/11/05/python-http/</id>
    <published>2016-11-05T13:56:48.000Z</published>
    <updated>2017-03-16T08:51:34.133Z</updated>
    
    <content type="html"><![CDATA[<p>挺久没写博客了，因为博主开始了今年另一段美好的实习经历，学习加做项目，时间已排满；很感谢今年这两段经历，让我接触了golang和python，学习不同语言，可以跳出之前学习c/c++思维的限制，学习golang和python的优秀特性以及了解在不同的场景，适用不同的语言；而之前学习linux和c/c++，也使我很快就上手golang和python;</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/IMG_0361.JPG" alt="杭州清河坊"></p>
<p>我学习的习惯，除了学习如何使用，还喜欢研究源码，学习运行机制，这样用起来才会得心应手或者说，使用这些语言或框架，就和平时吃饭睡觉一样，非常自然；因为最近有接触到bottle和flask  web框架，所以想看下这两个的源码，但是这两个框架是基于python自带的http，因此就有了这篇文章；</p>
<p>这篇主要从以下几个方面来解析python之http模块:</p>
<ol>
<li>一个python http简单的例子</li>
<li>http之server;</li>
<li>http之handler;</li>
</ol>
<h1>python http简单例子</h1>
<hr>
<p>python http框架主要有server和handler组成，server主要是用于建立网络模型，例如利用epoll监听socket；handler用于处理各个就绪的socket；先来看下python http简单的使用：
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line">from http.server import HTTPServer,SimpleHTTPRequestHandler</div><div class="line"></div><div class="line">ServerClass = HTTPServer</div><div class="line">HandlerClass = SimpleHTTPRequestHandler</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    port = <span class="keyword">int</span>(sys.<span class="built_in">argv</span>[<span class="number">2</span>])</div><div class="line">    server_address = (sys.<span class="built_in">argv</span>[<span class="number">1</span>],port)</div><div class="line">    httpd = ServerClass(server_address,HandlerClass)</div><div class="line"></div><div class="line">    <span class="keyword">sa</span>=httpd.socket.getsockname()</div><div class="line">    <span class="keyword">print</span>(<span class="string">"Serving HTTP on"</span>, <span class="keyword">sa</span>[<span class="number">0</span>], <span class="string">"port"</span>, <span class="keyword">sa</span>[<span class="number">1</span>], <span class="string">"..."</span>)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        httpd.serve_forever()</div><div class="line">    except KeyboardInterrup<span class="variable">t:</span></div><div class="line">        <span class="keyword">print</span>(<span class="string">"\nKeyboard interrupt received, exiting."</span>)</div><div class="line">        httpd.server_close()</div><div class="line">        sys.<span class="keyword">exit</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>运行上述例子，可以得到如下：</p>
<blockquote>
<p>python3 myhttp.py 127.0.0.1 9999</p>
</blockquote>
<p>此时如果在当前文件夹新建一个index.html文件，就可以通过<a href="http://127.0.0.1:9999/index.html" target="_blank" rel="external">http://127.0.0.1:9999/index.html</a>访问了index.html页面了。</p>
<p>这个例子的server类用的是HTTPServer，handler类是SimpleHTTPRequestHandler，因此当HTTPServer监听到有request到来时，就把这个request丢给SimpleHTTPRequestHandler类求处理；ok，了解这些之后，我们开始分别分析下server和handler.</p>
<h1>http之server</h1>
<hr>
<p>http模块的设计充分利用了面向对象的继承多态，因为之前有看了会tfs文件系统的代码，所以再看python http时，没那么大的压力；先给出server的继承关系
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="code">                       +------------------+</span></div><div class="line"><span class="code">+------------+</span>         | tcpserver基类    |</div><div class="line">| BaseServer +--------&gt;| 开启事件循环监听 |</div><div class="line"><span class="code">+-----+</span>------+         | 处理客户端请求   |</div><div class="line"><span class="code">      |                +------------------+</span></div><div class="line"><span class="code">      v                +-----------------+</span></div><div class="line"><span class="code">+------------+</span>         | httpserver基类  |</div><div class="line">| TCPServer  <span class="code">+--------&gt;+</span>  设置监听socket |</div><div class="line"><span class="code">+-----+</span>------+         | 开启监听        |</div><div class="line"><span class="code">      |                +-----------------+</span></div><div class="line"><span class="section">      v</span></div><div class="line">+------------+</div><div class="line"><span class="section">| HTTPServer |           </span></div><div class="line">+------------+</div></pre></td></tr></table></figure></p>
<p>继承关系如上图所示，其中BaseServer和TCPServer在文件socketserver.py，HTTPServer在http/server.py；我们先看下来BaseServer；</p>
<h2>BaseServer</h2>
<hr>
<p>因为BaseServer是所有server的基类，因此BaseServer尽可能抽象出所有server的共性，例如开启事件监听循环，这就是每个server的共性，因此这也是BaseServer主要做的使;我们来看下BaseServer主要代码部分
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def serve_forever(<span class="keyword">self</span>, poll_interval=<span class="number">0.5</span>):</div><div class="line">        <span class="keyword">self</span>.__is_shut_down.clear()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">with</span> _ServerSelector() <span class="keyword">as</span> <span class="keyword">selector</span>:</div><div class="line">                <span class="keyword">selector</span>.register(<span class="keyword">self</span>, selectors.EVENT_READ)</div><div class="line"></div><div class="line">                <span class="keyword">while</span> <span class="keyword">not</span> <span class="keyword">self</span>.__shutdown_request:</div><div class="line">                    ready = <span class="keyword">selector</span>.select(poll_interval)</div><div class="line">                    <span class="keyword">if</span> ready:</div><div class="line">                        <span class="keyword">self</span>._handle_request_noblock()</div><div class="line"></div><div class="line">                    <span class="keyword">self</span>.service_actions()</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            <span class="keyword">self</span>.__shutdown_request = <span class="keyword">False</span></div><div class="line">            <span class="keyword">self</span>.__is_shut_down.set()</div></pre></td></tr></table></figure></p>
<p>代码中的selector其实就是封装了select,poll,epoll等的io多路复用，然后将服务自身监听的socket注册到io多路复用，开启事件监听，当有客户端连接时，此时会调用self._handle_request_noblock()来处理请求；接下来看下这个处理函数做了啥；
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def _handle_request_noblock(<span class="keyword">self</span>):</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            request, client_address = <span class="keyword">self</span>.get_request()</div><div class="line">        <span class="keyword">except</span> OSError:</div><div class="line">            return</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.verify_request(request, client_address):</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="keyword">self</span>.process_request(request, client_address)</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">self</span>.handle_error(request, client_address)</div><div class="line">                <span class="keyword">self</span>.shutdown_request(request)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">self</span>.shutdown_request(request)</div></pre></td></tr></table></figure></p>
<p>_handle_request_noblock函数是一个内部函数，首先是接收客户端连接请求，底层其实是封装了系统调用accept函数，然后验证请求，最后调用process_request来处理请求；其中get_request是属于子类的方法，因为tcp和udp接收客户端请求是不一样的(tcp有连接，udp无连接)</p>
<p>我们接下来再看下process_request具体做了什么；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(<span class="keyword">self</span>, request, client_address)</span></span>:</div><div class="line">       <span class="keyword">self</span>.finish_request(request, client_address)</div><div class="line">       <span class="keyword">self</span>.shutdown_request(request)</div><div class="line"><span class="comment"># -------------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish_request</span><span class="params">(<span class="keyword">self</span>, request, client_address)</span></span>:</div><div class="line">        <span class="keyword">self</span>.RequestHandlerClass(request, client_address, <span class="keyword">self</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown_request</span><span class="params">(<span class="keyword">self</span>, request)</span></span>:</div><div class="line">    <span class="keyword">self</span>.close_request(request)</div></pre></td></tr></table></figure></p>
<p>process_request函数先是调用了finish_request来处理一个连接，处理结束之后，调用shutdown_request函数来关闭这个连接；而finish_request函数内部实例化了一个handler类，并把客户端的socket和地址传了进去，说明，handler类在初始化结束的时候，就完成了请求处理，这个等后续分析handler时再细看；</p>
<p>以上就是BaseServer所做的事，这个BaseServer不能直接使用，因为有些函数还没实现，只是作为tcp/udp的抽象层；总结下：</p>
<ol>
<li>先是调用serve_forever开启事件监听；</li>
<li>然后当有客户端请求到来时，将请求交给handler处理；</li>
</ol>
<h2>TCPServer</h2>
<hr>
<p>由上述BaseServer抽象出的功能，我们可以知道TCPServer或UDPServer应该完成的功能有，初始化监听套接字，并绑定监听，最后当有客户端请求时，接收这个客户端；我们来看下代码
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">BaseServer==&gt;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, server_address, RequestHandlerClass)</span></span>:</div><div class="line">        <span class="string">""</span><span class="string">"Constructor.  May be extended, do not override."</span><span class="string">""</span></div><div class="line">        <span class="keyword">self</span>.server_address = server_address</div><div class="line">        <span class="keyword">self</span>.RequestHandlerClass = RequestHandlerClass</div><div class="line">        <span class="keyword">self</span>.__is_shut_down = threading.Event()</div><div class="line">        <span class="keyword">self</span>.__shutdown_request = False</div><div class="line"><span class="comment">#--------------------------------------------------------------------------------</span></div><div class="line">TCPServer==&gt;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, server_address, RequestHandlerClass, bind_and_activate=True)</span></span>:</div><div class="line">       BaseServer.__init_<span class="number">_</span>(<span class="keyword">self</span>, server_address, RequestHandlerClass)</div><div class="line">       <span class="keyword">self</span>.socket = socket.socket(<span class="keyword">self</span>.address_family,</div><div class="line">                                   <span class="keyword">self</span>.socket_type)</div><div class="line">       <span class="keyword">if</span> <span class="symbol">bind_and_activate:</span></div><div class="line">           <span class="symbol">try:</span></div><div class="line">               <span class="keyword">self</span>.server_bind()</div><div class="line">               <span class="keyword">self</span>.server_activate()</div><div class="line">           <span class="symbol">except:</span></div><div class="line">               <span class="keyword">self</span>.server_close()</div><div class="line">               raise</div></pre></td></tr></table></figure></p>
<p>TCPServer初始化时先是调用基类BaseServer的初始化函数，初始化服务器地址，handler类等，然后初始化自身的监听套接字，最后调用server_bind绑定套接字，server_activate监听套接字
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_bind</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">allow_reuse_address:</span></div><div class="line">        <span class="keyword">self</span>.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">    <span class="keyword">self</span>.socket.bind(<span class="keyword">self</span>.server_address)</div><div class="line">    <span class="keyword">self</span>.server_address = <span class="keyword">self</span>.socket.getsockname()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_activate</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">    <span class="keyword">self</span>.socket.listen(<span class="keyword">self</span>.request_queue_size)</div></pre></td></tr></table></figure></p>
<p>TCPServer还实现了另一个函数，那就是接收客户端请求，
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.socket.accept()</div></pre></td></tr></table></figure></p>
<p>之前如果有学过linux编程，那么看这些代码应该会觉得很熟悉，因为函数名和Linux提供的系统调用名一模一样，这里也不多说了；</p>
<p>TCPServer其实已经把基于tcp的服务器主体框架搭起来了，因此HTTPServer在继承TCPServer基础上，只是重载了server_bind函数，设置reuse_address等；</p>
<p>ok，这里分析下上述例子程序的开启过程；</p>
<ol>
<li>httpd = ServerClass(server_address,HandlerClass)这行代码在初始化HTTPServer时，主要是调用基类TCPServer的初始化方法，初始化了监听的套接字，并绑定和监听；</li>
<li>httpd.serve_forever()这行代码调用的是基类BaseServer的serve_forever方法，开启监听循环，等待客户端的连接；</li>
</ol>
<p>如果有看过redis或者一些后台组件的源码，对这种并发模型应该很熟悉；ok，分析了server之后，接下来看下handler是如何处理客户端请求的。</p>
<h1>http之handler</h1>
<hr>
<p>handler类主要分析tcp层的handler和http应用层的handler,tcp层的handler是不能使用的，因为tcp层只负责传输字节，但是并不知对于接收到的字节要如何解析，如何处理等；因此应用层协议如该要使用TCP协议，必须继承TCP handler，然后实现handle函数即可;例如，http层的handler实现handle函数，解析http协议，处理业务请求以及结果返回给客户端；先来看下tcp层的handler</p>
<h2>tcp层handler</h2>
<hr>
<p>tcp层handler主要有BaseRequestHandler和StreamRequestHandler(都在socketserver.py文件)，先看下BaseRequestHandler代码，
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequestHandler</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, request, client_address, server)</span></span>:</div><div class="line">        <span class="keyword">self</span>.request = request</div><div class="line">        <span class="keyword">self</span>.client_address = client_address</div><div class="line">        <span class="keyword">self</span>.server = server</div><div class="line">        <span class="keyword">self</span>.setup()</div><div class="line">        <span class="symbol">try:</span></div><div class="line">            <span class="keyword">self</span>.handle()</div><div class="line">        <span class="symbol">finally:</span></div><div class="line">            <span class="keyword">self</span>.finish()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        pass</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        pass</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        pass</div></pre></td></tr></table></figure></p>
<p>之前在看server时，知道处理客户端请求就是在handler类的初始化函数中完成；由这个基类初始化函数，我们知道处理请求大概经历三个过程：</p>
<ol>
<li>setup对客户端的socket做一些设置；</li>
<li>handle真正处理请求的函数；</li>
<li>finish关闭socket读写请求；</li>
</ol>
<p>这个BaseRequestHandler是handler top level 基类，只是抽象出handler整体框架，并没有实际的处理；我们看下tcp handler，
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamRequestHandler</span>(<span class="title">BaseRequestHandler</span>):</span></div><div class="line">    timeout = None</div><div class="line">    disable_nagle_algorithm = False</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">self</span>.connection = <span class="keyword">self</span>.request</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.timeout is <span class="keyword">not</span> <span class="symbol">None:</span></div><div class="line">            <span class="keyword">self</span>.connection.settimeout(<span class="keyword">self</span>.timeout)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">disable_nagle_algorithm:</span></div><div class="line">            <span class="keyword">self</span>.connection.setsockopt(socket.IPPROTO_TCP,</div><div class="line">                                       socket.TCP_NODELAY, True)</div><div class="line">        <span class="keyword">self</span>.rfile = <span class="keyword">self</span>.connection.makefile(<span class="string">'rb'</span>, <span class="keyword">self</span>.rbufsize)</div><div class="line">        <span class="keyword">self</span>.wfile = <span class="keyword">self</span>.connection.makefile(<span class="string">'wb'</span>, <span class="keyword">self</span>.wbufsize)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.wfile.<span class="symbol">closed:</span></div><div class="line">            <span class="symbol">try:</span></div><div class="line">                <span class="keyword">self</span>.wfile.flush()</div><div class="line">            except socket.<span class="symbol">error:</span></div><div class="line">                pass</div><div class="line">        <span class="keyword">self</span>.wfile.close()</div><div class="line">        <span class="keyword">self</span>.rfile.close()</div></pre></td></tr></table></figure></p>
<p>tcp handler实现了setup和finish函数，setup函数设置超时时间，开启nagle算法以及设置socket读写缓存；finish函数关闭socket读写；</p>
<p>由上述两个tcp层的handler可知，要实现一个基于http的服务器handler，只需要继承StreamRequestHandler类，并实现handle函数即可；因此这也是http层handler主要做的事；</p>
<h2>http层handler</h2>
<hr>
<p>由之前tcp层handler的介绍，我们知道http层handler在继承tcp层handler基础上，主要是实现了handle函数处理客户端的请求；还是直接看代码吧；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">        <span class="keyword">self</span>.close_connection = True</div><div class="line"></div><div class="line">        <span class="keyword">self</span>.handle_one_request()</div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">close_connection:</span></div><div class="line">            <span class="keyword">self</span>.handle_one_request()</div></pre></td></tr></table></figure></p>
<p>这就是BaseHTTPRequestHandler的handle函数，在handle函数会调用handle_one_request函数处理一次请求；默认情况下是短链接，因此在执行了一次请求之后，就不会进入while循环在同一个连接上处理下一个请求，但是在handle_one_request函数内部会进行判断，如果请求头中的connection为keep_alive或者http版本大于等于1.1，则可以保持长链接；接下来看下handle_one_request函数是如何处理；
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_one_request</span><span class="params">(<span class="keyword">self</span>)</span></span>:</div><div class="line">    <span class="symbol">try:</span></div><div class="line">        <span class="keyword">self</span>.raw_requestline = <span class="keyword">self</span>.rfile.readline(<span class="number">65537</span>)</div><div class="line">        <span class="keyword">if</span> len(<span class="keyword">self</span>.raw_requestline) &gt; <span class="number">65536</span>:</div><div class="line">            <span class="keyword">self</span>.requestline = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.request_version = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.command = <span class="string">''</span></div><div class="line">            <span class="keyword">self</span>.send_error(HTTPStatus.REQUEST_URI_TOO_LONG)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">raw_requestline:</span></div><div class="line">            <span class="keyword">self</span>.close_connection = True</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.parse_request():</div><div class="line">            <span class="keyword">return</span></div><div class="line">        mname = <span class="string">'do_'</span> + <span class="keyword">self</span>.command</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(<span class="keyword">self</span>, mname):</div><div class="line">            <span class="keyword">self</span>.send_error(</div><div class="line">                HTTPStatus.NOT_IMPLEMENTED,</div><div class="line">                <span class="string">"Unsupported method (%r)"</span> % <span class="keyword">self</span>.command)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        method = getattr(<span class="keyword">self</span>, mname)</div><div class="line">        method()</div><div class="line">        <span class="keyword">self</span>.wfile.flush()</div><div class="line">    except socket.timeout as <span class="symbol">e:</span></div><div class="line">        <span class="keyword">self</span>.log_error(<span class="string">"Request timed out: %r"</span>, e)</div><div class="line">        <span class="keyword">self</span>.close_connection = True</div><div class="line">        <span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>这个handle_one_request执行过程如下：</p>
<ol>
<li>先是调用parse_request解析客户端http请求内容</li>
<li>通过&quot;do_&quot;+command构造出请求所对于的函数method</li>
<li>调用method函数，处理业务并将response返回给客户端</li>
</ol>
<p>这个BaseHTTPRequestHandler是http handler基类，因此也是无法直接使用，因为它没有定义请求处理函数，即method函数；好在python为我们提供了一个简单的SimpleHTTPRequestHandler，该类继承了BaseHTTPRequestHandler，并实现了请求函数；我们看下get函数：
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># SimpleHTTPRequestHandler</span></div><div class="line"><span class="comment"># ---------------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="string">"""Serve a GET request."""</span></div><div class="line">      f = self.send_head()</div><div class="line">      <span class="keyword">if</span> f:</div><div class="line">          <span class="keyword">try</span>:</div><div class="line">              self.copyfile(f, self.wfile)</div><div class="line">          <span class="keyword">finally</span>:</div><div class="line">              f.close()</div></pre></td></tr></table></figure></p>
<p>这个get函数先是调用do_GET函数给客户端返回response头部，并返回请求的文件，最后调用copyfile函数将请求文件通过连接返回给客户端；</p>
<p>以上就是http模块最基础的内容，最后，总结下例子程序handler部分：</p>
<ol>
<li>server把请求传给SimpleHTTPRequestHandler初始化函数；</li>
<li>SimpleHTTPRequestHandler在初始化部分，对这个客户端connection进行一些设置；</li>
<li>接着调用handle函数处理请求；</li>
<li>在handle函数接着调用handle_one_request处理请求；</li>
<li>在handle_one_request函数内部，解析请求，找到请求处理函数；</li>
<li>我之前的访问属于get访问，因此直接调用do_GET函数将index.html文件返回给客户端；</li>
</ol>
<p>python http模块到此已经分析结束；不知道大家有没发现，python自带的http模块使用起来不是很方便，因为它是通过请求方法来调用请求函数，这样当同一方法调用次数非常多时，例如get和post方法，会导致这个请求函数异常庞大，代码不好编写，各种情况判断；当然SimpleHTTPRequestHandler只是python提供的一个简单例子而已；</p>
<p>当然，python官方提供了针对http更好用的框架，即wsgi server和wsgi application；接下来文章先分析python自带的wsgiref模块以及bottle，后面再分析flask;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;挺久没写博客了，因为博主开始了今年另一段美好的实习经历，学习加做项目，时间已排满；很感谢今年这两段经历，让我接触了golang和python，学习不同语言，可以跳出之前学习c/c++思维的限制，学习golang和python的优秀特性以及了解在不同的场景，适用不同的语言；而
    
    </summary>
    
      <category term="python" scheme="http://luodw.cc/categories/python/"/>
    
    
      <category term="python" scheme="http://luodw.cc/tags/python/"/>
    
      <category term="http" scheme="http://luodw.cc/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>从汇编角度理解golang多值返回和闭包</title>
    <link href="http://luodw.cc/2016/09/04/golang03/"/>
    <id>http://luodw.cc/2016/09/04/golang03/</id>
    <published>2016-09-04T07:48:16.000Z</published>
    <updated>2017-03-16T08:51:34.125Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊两个轻松的话题，golang相比与之前学习的C/C++，有很多新颖的特性，不知道大家的使用的时候，有没想过，这些特性是如何实现的？当然你可能会说，不了解这些特性好像也不影响自己使用golang；对，你说的也有道理；但是，多了解底层的实现原理，对于在使用golang时的眼界是完全不一样的，就类似于看过http的实现之后，再来使用http框架，和未看过http框架时的眼界是不一样的，当然，你如果是一名it爱好者，求知欲自然会引导你去学习；知其然而不知其所以然，是很可怕的；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-0033033999475765_b.jpg" alt="厦门世贸中心"></p>
<p>相对于C/C++，golang有很多新颖的特性，例如goroutine,channel,defer,reflect,interface{}等等；这些特性其实从golang源码是可以理解其实现的原理；今天这篇文章主要来分析下golang多值返回以及闭包的实现，因为这两个实现golang源码中并不存在，我们必须从汇编的角度来窥探二者的实现；</p>
<p>这篇文章主要就分析两点:</p>
<ol>
<li>golang多值返回的实现;</li>
<li>golang闭包的实现;</li>
<li>总结;</li>
</ol>
<h1>golang多值返回的实现</h1>
<hr>
<p>我们在学C/C++时，很多人应该有了解过C/C++函数调用过程，参数是通过寄存器di和si(假设就两个参数)传递给被调用的函数，被调用函数的返回结果只能是通过eax寄存器返回给调用函数，因此C/C++函数只能返回一个值，那么我们是不是可以想象，golang的多值返回是否可以通过多个寄存器来实现的，正如用多个寄存器来传参一样？</p>
<p>这也是一种办法，但是golang并没有采用；我的理解是引入多个寄存器来存储返回值，会引起多个寄存器用途的重新约定，这无疑增加了复杂度；可以这么说，golang的ABI与C/C++非常不一样；</p>
<p>在从汇编角度分析golang多值返回之前，需要先熟悉golang汇编代码的一些约定，<a href="https://golang.org/doc/asm" target="_blank" rel="external">golang官网</a>有说明，这里重点说明四个symbols，需要注意的是这里的寄存器是伪寄存器：</p>
<ol>
<li>FP　栈底寄存器，指向一个函数栈的顶部；</li>
<li>PC  程序计数器，指向下一条执行指令;</li>
<li>SB　指向静态数据的基指针，全局符号;</li>
<li>SP　栈顶寄存器;</li>
</ol>
<p>这里面最重要的就是FP和SP，FP寄存器主要用于取参数以及存返回值，golang函数调用的实现很大程度上都是依赖这两个寄存器，这里先给出结果，</p>
<p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">                </div><div class="line">+-----------+---\</div><div class="line">|<span class="string">  返回值2  </span>|<span class="string">    \</span></div><div class="line">+-----------+     \</div><div class="line">|<span class="string">  返回值1  </span>|<span class="string">      \</span></div><div class="line">+---------+-+      </div><div class="line">|<span class="string">  参数2    </span>|<span class="string">      这些在调用函数中</span></div><div class="line">+-----------+       </div><div class="line">|<span class="string">  参数1    </span>|<span class="string">   　 /</span></div><div class="line">+-----------+     /</div><div class="line">|<span class="string">  返回地址 </span>|<span class="string">    /</span></div><div class="line">+-----------+--\/-----fp值</div><div class="line">|<span class="string">  局部变量 </span>|<span class="string">   \</span></div><div class="line">|<span class="string">    ...    </span>|<span class="string">   被调用数栈祯</span></div><div class="line">|<span class="string">           </span>|<span class="string">   /</span></div><div class="line">+-----------+--/+---sp值</div></pre></td></tr></table></figure></p>
<p>这个就是golang的一个函数栈，也是说函数传参是通过fp+offset来实现的，而多个返回值也是通过fp+offset存储在调用函数的栈帧中；下面通过一个例子来分析
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import <span class="string">"fmt"</span></div><div class="line"></div><div class="line">func test(<span class="selector-tag">i</span>, j int) (int, int) &#123;</div><div class="line">	<span class="selector-tag">a</span> := <span class="selector-tag">i</span> + j</div><div class="line">	<span class="selector-tag">b</span> := <span class="selector-tag">i</span> - j</div><div class="line">	return <span class="selector-tag">a</span>, <span class="selector-tag">b</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	<span class="selector-tag">a</span>, <span class="selector-tag">b</span> := test(<span class="number">2</span>, <span class="number">1</span>)</div><div class="line">	fmt.Println(<span class="selector-tag">a</span>, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子很简单，主要是为了说明golang多值返回的过程；我们通过下面命令编译该程序</p>
<blockquote>
<p>go tool compile -S test.go &gt; test.s</p>
</blockquote>
<p>然后，就可以打开test.s，来看下这个小程序的汇编代码。首先来看下test函数的汇编代码</p>
<p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span>.test t=<span class="number">1</span> size=<span class="number">32</span> value=<span class="number">0</span> args=<span class="number">0x20</span> locals=<span class="number">0x0</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        TEXT    <span class="string">""</span>.test(SB), <span class="number">$0</span>-<span class="number">32</span>//栈大小为<span class="number">32</span>字节</div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">NOP</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">NOP</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.i+<span class="number">8</span>(FP), <span class="built_in">CX</span>//取第一个参数i</div><div class="line">        <span class="number">0x0005</span> <span class="number">00005</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.j+<span class="number">16</span>(FP), <span class="built_in">AX</span>//取第二个参数j</div><div class="line">        <span class="number">0x000a</span> <span class="number">00010</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$0</span>, gclocals·a8eabfc4a4514ed6b3b0c61e9680e440(SB)</div><div class="line">        <span class="number">0x000a</span> <span class="number">00010</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</div><div class="line">        <span class="number">0x000a</span> <span class="number">00010</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="built_in">BX</span>//将i放入<span class="built_in">bx</span></div><div class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        ADDQ    <span class="built_in">AX</span>, <span class="built_in">CX</span>//i+j放入<span class="built_in">cx</span></div><div class="line">        <span class="number">0x0010</span> <span class="number">00016</span> (<span class="keyword">test</span>.go:<span class="number">7</span>)        SUBQ    <span class="built_in">AX</span>, <span class="built_in">BX</span>//i-j放入<span class="built_in">bx</span></div><div class="line">						//将返回结果存入调用函数栈帧</div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">8</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">CX</span>, <span class="string">""</span>.~<span class="built_in">r2</span>+<span class="number">24</span>(FP)</div><div class="line">						//将返回结果存入调用函数栈帧</div><div class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (<span class="keyword">test</span>.go:<span class="number">8</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BX</span>, <span class="string">""</span>.~<span class="built_in">r3</span>+<span class="number">32</span>(FP)</div><div class="line">        <span class="number">0x001d</span> <span class="number">00029</span> (<span class="keyword">test</span>.go:<span class="number">8</span>)        <span class="keyword">RET</span></div></pre></td></tr></table></figure></p>
<p>由这个汇编代码可以看出来，在test函数内部，是通过fp+8取第一个参数，fp+16取第二个参数；然后将返回的第一个值存入fp+24,返回的第二个值存入fp+32，和我上述所说完全一致；golang函数调用过程，是通过fp+offset来实现传参和返回值，而不像C/C++都是通过寄存器实现传参和返回值；</p>
<p>但是，这里有个问题，我的变量都是int类型，为啥分配的都是8字节，这有待考证；</p>
<p>本来想通过查看main函数的栈帧来验证之前的结论，但是golang对小函数自动转为内联函数，因此你们可以自己编译出来看看，main函数内部是没有调用test函数的，而是将test函数的汇编代码直接拷贝进main函数执行了；</p>
<h1>golang闭包的实现</h1>
<hr>
<p>之前有去看了下C++11的lambda函数的实现，其实实现原理就是仿函数；编译器在编译lambda函数时，会生成一个匿名的仿函数类，然后执行这个lambda函数时，会调用编译生成的匿名仿函数类重载函数调用方法，这个方法也就是lambda函数中定义的方法；其实golang闭包的实现和这个类似，我们通过例子来说明
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">		a = a + i</div><div class="line">		<span class="keyword">return</span> a</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	f := test(<span class="number">1</span>)</div><div class="line">	a := f(<span class="number">2</span>)</div><div class="line">	fmt.Println(a)</div><div class="line">	b := f(<span class="number">3</span>)</div><div class="line">	fmt.Println(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子程序很简单，test函数传入一个整型参数a，返回一个函数类型；这个函数类型传入一个整型参数以及返回一个整型值；main函数调用test函数，返回一个闭包函数；ok，来看下test函数的汇编代码:</p>
<p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span>.test t=<span class="number">1</span> size=<span class="number">160</span> value=<span class="number">0</span> args=<span class="number">0x10</span> locals=<span class="number">0x20</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        TEXT    <span class="string">""</span>.test(SB), <span class="number">$32</span>-<span class="number">16</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    (TLS), <span class="built_in">CX</span></div><div class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        CMPQ    <span class="built_in">SP</span>, <span class="number">16</span>(<span class="built_in">CX</span>)</div><div class="line">        <span class="number">0x000d</span> <span class="number">00013</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        JLS     <span class="number">142</span></div><div class="line">        <span class="number">0x000f</span> <span class="number">00015</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        SUBQ    <span class="number">$32</span>, <span class="built_in">SP</span></div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$0</span>, gclocals·8edb5632446ada37b0a930d010725cc5(SB)</div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        FUNCDATA        <span class="number">$1</span>, gclocals·008e235a1392cc90d1ed9ad2f7e76d87(SB)</div><div class="line">        <span class="number">0x0013</span> <span class="number">00019</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        LEAQ    type.int(SB), <span class="built_in">BX</span></div><div class="line">        <span class="number">0x001a</span> <span class="number">00026</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BX</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x001e</span> <span class="number">00030</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        PCDATA  <span class="number">$0</span>, <span class="number">$0</span></div><div class="line">					//生成一个<span class="keyword">int</span>型对象，即a</div><div class="line">        <span class="number">0x001e</span> <span class="number">00030</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">CALL</span>    runtime.newobject(SB)</div><div class="line">					//<span class="number">8</span>(<span class="built_in">sp</span>)即生成的a的地址，放入<span class="built_in">AX</span></div><div class="line">        <span class="number">0x0023</span> <span class="number">00035</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></div><div class="line">					//将a的地址存入<span class="built_in">sp</span>+<span class="number">24</span>的位置</div><div class="line">        <span class="number">0x0028</span> <span class="number">00040</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.&amp;a+<span class="number">24</span>(<span class="built_in">SP</span>)</div><div class="line">					//取出main函数传入的第一个参数，即a</div><div class="line">        <span class="number">0x002d</span> <span class="number">00045</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.a+<span class="number">40</span>(FP), <span class="built_in">BP</span></div><div class="line">					//将a放入(<span class="built_in">AX</span>)指向的内存，即上述新生成的<span class="keyword">int</span>型对象</div><div class="line">        <span class="number">0x0032</span> <span class="number">00050</span> (<span class="keyword">test</span>.go:<span class="number">5</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BP</span>, (<span class="built_in">AX</span>)</div><div class="line">        <span class="number">0x0035</span> <span class="number">00053</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        LEAQ    type.struct &#123; F uintptr<span class="comment">; a *int &#125;(SB), BX</span></div><div class="line">        <span class="number">0x003c</span> <span class="number">00060</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BX</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0040</span> <span class="number">00064</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        PCDATA  <span class="number">$0</span>, <span class="number">$1</span></div><div class="line">        <span class="number">0x0040</span> <span class="number">00064</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">CALL</span>    runtime.newobject(SB)</div><div class="line">					//<span class="number">8</span>(<span class="built_in">sp</span>)这就是上述生成的struct对象地址</div><div class="line">        <span class="number">0x0045</span> <span class="number">00069</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></div><div class="line">        <span class="number">0x004a</span> <span class="number">00074</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">NOP</span></div><div class="line">					//<span class="keyword">test</span>内部匿名函数地址存入<span class="built_in">BP</span></div><div class="line">        <span class="number">0x004a</span> <span class="number">00074</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        LEAQ    <span class="string">""</span>.test.func1(SB), <span class="built_in">BP</span></div><div class="line">					//将匿名函数地址放入(<span class="built_in">AX</span>)指向的地址，即给上述</div><div class="line">					//F uintptr赋值</div><div class="line">        <span class="number">0x0051</span> <span class="number">00081</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BP</span>, (<span class="built_in">AX</span>)</div><div class="line">        <span class="number">0x0054</span> <span class="number">00084</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.autotmp_0001+<span class="number">16</span>(<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0059</span> <span class="number">00089</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">NOP</span>	</div><div class="line">					//将上述生成的整型对象a的地址存入<span class="built_in">BP</span></div><div class="line">        <span class="number">0x0059</span> <span class="number">00089</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="string">""</span>.&amp;a+<span class="number">24</span>(<span class="built_in">SP</span>), <span class="built_in">BP</span></div><div class="line">        <span class="number">0x005e</span> <span class="number">00094</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        CMPB    runtime.writeBarrier(SB), <span class="number">$0</span></div><div class="line">        <span class="number">0x0065</span> <span class="number">00101</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">JNE</span>     <span class="number">$0</span>, <span class="number">117</span></div><div class="line">					//将a地址存入<span class="built_in">AX</span>指向内存+<span class="number">8</span>，</div><div class="line">					//即为上述结构体a *<span class="keyword">int</span>赋值</div><div class="line">        <span class="number">0x0067</span> <span class="number">00103</span> (<span class="keyword">test</span>.go:<span class="number">6</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">BP</span>, <span class="number">8</span>(<span class="built_in">AX</span>)</div><div class="line">					//将上述结构体的地址存入main函数栈帧中；</div><div class="line">        <span class="number">0x006b</span> <span class="number">00107</span> (<span class="keyword">test</span>.go:<span class="number">9</span>)        <span class="keyword">MOVQ</span>    <span class="built_in">AX</span>, <span class="string">""</span>.~<span class="built_in">r1</span>+<span class="number">48</span>(FP)</div><div class="line">        <span class="number">0x0070</span> <span class="number">00112</span> (<span class="keyword">test</span>.go:<span class="number">9</span>)        ADDQ    <span class="number">$32</span>, <span class="built_in">SP</span></div><div class="line">        <span class="number">0x0074</span> <span class="number">00116</span> (<span class="keyword">test</span>.go:<span class="number">9</span>)        <span class="keyword">RET</span></div></pre></td></tr></table></figure></p>
<p>之前有看到一句话，很形象地描述了闭包</p>
<blockquote>
<p>类是有行为的数据，而闭包是有数据的行为；</p>
</blockquote>
<p>也就是说闭包是有上下文的，我们以测试例子为例，通过test函数生成的闭包函数，都有各自的a，这个a就是闭包的上下文数据，而且这个a一直伴随着他的闭包函数，每调用一次，a都会发生变化；</p>
<p>我们分析了上述汇编代码，来看下闭包实现原理；在这个测试例子中，由于a是闭包的上下文数据，因此a必须在堆上分配，如果在栈上分配，函数结束，a也被回收了；然后会定义出一个匿名结构体:</p>
<p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span>.<span class="keyword">struct</span> &#123; </div><div class="line">	F <span class="keyword">uintptr</span><span class="comment">//这个就是闭包调用的函数指针 </span></div><div class="line">	a *<span class="keyword">int</span> <span class="comment">//这就是闭包的上下文数据</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着生成一个该对象，并将之前在堆上分配的整型对象a的地址赋值给结构体中的a指针，接下来将闭包调用的func函数地址赋值给结构体中F指针；这样，每生成一个闭包函数，其实就是生成一个上述结构体对象，每个闭包对象也就有自己的数据a和调用函数F；最后将这个结构体的地址返回给main函数；</p>
<p>ok，来看下main函数获取闭包的过程；</p>
<p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span>.main t=<span class="number">1</span> size=<span class="number">528</span> value=<span class="number">0</span> args=<span class="number">0x0</span> locals=<span class="number">0x88</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       TEXT    <span class="string">""</span>.main(SB), <span class="number">$136</span>-<span class="number">0</span></div><div class="line">        <span class="number">0x0000</span> <span class="number">00000</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       <span class="keyword">MOVQ</span>    (TLS), <span class="built_in">CX</span></div><div class="line">        <span class="number">0x0009</span> <span class="number">00009</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       LEAQ    -<span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">AX</span></div><div class="line">        <span class="number">0x000e</span> <span class="number">00014</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       CMPQ    <span class="built_in">AX</span>, <span class="number">16</span>(<span class="built_in">CX</span>)</div><div class="line">        <span class="number">0x0012</span> <span class="number">00018</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       JLS     <span class="number">506</span></div><div class="line">        <span class="number">0x0018</span> <span class="number">00024</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       SUBQ    <span class="number">$136</span>, <span class="built_in">SP</span></div><div class="line">        <span class="number">0x001f</span> <span class="number">00031</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       FUNCDATA        <span class="number">$0</span>, gclocals·f5be5308b59e045b7c5b33ee8908cfb7(SB)</div><div class="line">        <span class="number">0x001f</span> <span class="number">00031</span> (<span class="keyword">test</span>.go:<span class="number">12</span>)       FUNCDATA        <span class="number">$1</span>, gclocals·9d868b227cedd8dd4b1bec8682560fff(SB)</div><div class="line">       					//将参数<span class="number">1</span>(f:=<span class="keyword">test</span>(<span class="number">1</span>))放入main函数栈顶</div><div class="line">	<span class="number">0x001f</span> <span class="number">00031</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       <span class="keyword">MOVQ</span>    <span class="number">$1</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0027</span> <span class="number">00039</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       PCDATA  <span class="number">$0</span>, <span class="number">$0</span></div><div class="line">					//调用main函数生成闭包对象</div><div class="line">        <span class="number">0x0027</span> <span class="number">00039</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       <span class="keyword">CALL</span>    <span class="string">""</span>.test(SB)</div><div class="line">					//将闭包对象的地址放入<span class="built_in">DX</span></div><div class="line">        <span class="number">0x002c</span> <span class="number">00044</span> (<span class="keyword">test</span>.go:<span class="number">13</span>)       <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">DX</span></div><div class="line">       					//将参数<span class="number">2</span>(a:=f(<span class="number">2</span>))放入栈顶</div><div class="line">	<span class="number">0x0031</span> <span class="number">00049</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    <span class="number">$2</span>, (<span class="built_in">SP</span>)</div><div class="line">        <span class="number">0x0039</span> <span class="number">00057</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    <span class="built_in">DX</span>, <span class="string">""</span>.f+<span class="number">56</span>(<span class="built_in">SP</span>)</div><div class="line">					//将闭包对象的函数指针赋值给<span class="built_in">BX</span></div><div class="line">        <span class="number">0x003e</span> <span class="number">00062</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    (<span class="built_in">DX</span>), <span class="built_in">BX</span></div><div class="line">        <span class="number">0x0041</span> <span class="number">00065</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       PCDATA  <span class="number">$0</span>, <span class="number">$1</span></div><div class="line">					//这里调用闭包函数，并且将闭包对象的地址也传进</div><div class="line">					//闭包函数，为了修改a嘛</div><div class="line">        <span class="number">0x0041</span> <span class="number">00065</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">CALL</span>    <span class="built_in">DX</span>, <span class="built_in">BX</span></div><div class="line">        <span class="number">0x0043</span> <span class="number">00067</span> (<span class="keyword">test</span>.go:<span class="number">14</span>)       <span class="keyword">MOVQ</span>    <span class="number">8</span>(<span class="built_in">SP</span>), <span class="built_in">BX</span></div></pre></td></tr></table></figure></p>
<p>很明显，main函数调用test函数获取的是闭包对象的地址，通过这个闭包对象地址找到闭包函数，然后执行这个闭包函数，并且把闭包对象的地址传进函数，这点和C++传this指针原理一样，为了修改成员变量a；</p>
<p>最后看下test内部的匿名函数(闭包函数实现):</p>
<p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="string">""</span><span class="selector-class">.test</span><span class="selector-class">.func1</span> t=<span class="number">1</span> size=<span class="number">32</span> value=<span class="number">0</span> args=<span class="number">0</span>x10 locals=<span class="number">0</span>x0</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        TEXT    <span class="string">""</span><span class="selector-class">.test</span><span class="selector-class">.func1</span>(SB), $<span class="number">0</span>-<span class="number">16</span></div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        NOP</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        NOP</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        FUNCDATA        $<span class="number">0</span>, gclocals·<span class="number">23</span>e8278e2b69a3a75fa59b23c49ed6ad(SB)</div><div class="line">        <span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        FUNCDATA        $<span class="number">1</span>, gclocals·<span class="number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)</div><div class="line">   					<span class="comment">//DX是闭包对象的地址，+8即a的地址</span></div><div class="line">	<span class="number">0</span>x0000 <span class="number">00000</span> (test<span class="selector-class">.go</span>:<span class="number">6</span>)        MOVQ    <span class="number">8</span>(DX), AX</div><div class="line">					<span class="comment">//AX为a的地址，(AX)即为a的值</span></div><div class="line">        <span class="number">0</span>x0004 <span class="number">00004</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        MOVQ    (AX), BP</div><div class="line">					<span class="comment">//将参数i存入R8</span></div><div class="line">        <span class="number">0</span>x0007 <span class="number">00007</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        MOVQ    <span class="string">""</span>.i+<span class="number">8</span>(FP), R8</div><div class="line">					<span class="comment">//a+i的值存入BP</span></div><div class="line">        <span class="number">0</span>x000c <span class="number">00012</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        ADDQ    R8, BP</div><div class="line">					<span class="comment">//将a+i存入a的地址</span></div><div class="line">        <span class="number">0</span>x000f <span class="number">00015</span> (test<span class="selector-class">.go</span>:<span class="number">7</span>)        MOVQ    BP, (AX)</div><div class="line">					<span class="comment">//将a地址最新数据存入BP</span></div><div class="line">        <span class="number">0</span>x0012 <span class="number">00018</span> (test<span class="selector-class">.go</span>:<span class="number">8</span>)        MOVQ    (AX), BP</div><div class="line">					<span class="comment">//将a最新值作为返回值放入main函数栈中</span></div><div class="line">        <span class="number">0</span>x0015 <span class="number">00021</span> (test<span class="selector-class">.go</span>:<span class="number">8</span>)        MOVQ    BP, <span class="string">""</span>.~r1+<span class="number">16</span>(FP)</div><div class="line">        <span class="number">0</span>x001a <span class="number">00026</span> (test<span class="selector-class">.go</span>:<span class="number">8</span>)        RET</div></pre></td></tr></table></figure></p>
<p>闭包函数的调用过程:</p>
<ol>
<li>通过闭包对象地址获取闭包上下文数据a的地址;</li>
<li>接着通过a的地址获取到a的值，并与参数i相加；</li>
<li>将a+i作为最新值存入a的地址；</li>
<li>将a最新值返回给main函数；</li>
</ol>
<h1>总结</h1>
<hr>
<p>这篇文章简单地从汇编角度分析了golang多值返回和闭包的实现；</p>
<ul>
<li>多值返回主要是通过fp寄存器+offset获取参数以及存入返回值实现；</li>
<li>闭包主要是通过在编译时生成包含闭包函数和闭包上下文数据的结构体实现；</li>
</ul>
<p>有什么不对的地方，希望各位能指出来，谢谢~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天聊两个轻松的话题，golang相比与之前学习的C/C++，有很多新颖的特性，不知道大家的使用的时候，有没想过，这些特性是如何实现的？当然你可能会说，不了解这些特性好像也不影响自己使用golang；对，你说的也有道理；但是，多了解底层的实现原理，对于在使用golang时的
    
    </summary>
    
      <category term="golang" scheme="http://luodw.cc/categories/golang/"/>
    
    
      <category term="golang" scheme="http://luodw.cc/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang之database/sql与go-sql-driver</title>
    <link href="http://luodw.cc/2016/08/28/golang02/"/>
    <id>http://luodw.cc/2016/08/28/golang02/</id>
    <published>2016-08-28T02:38:43.000Z</published>
    <updated>2017-03-16T08:51:34.125Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章也有说道，golang的http,rpc,以及第三方的redigo,go-sql-driver是开发一个服务常见的四大组件，因此我是很推荐有时间可以看下上述四大组件，而且golang自带的http和rpc框架本身就是http和rpc很好的教程，而且第三方框架miekg/dns也是采用http框架的形式，所以看懂http，对快速看懂miekg/dns是很有帮助的；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-1612992717.jpg" alt="厦大美景"></p>
<p>redigo相对较小，看起来比较容易，但是必须好好学习下redis的网络传输协议；http协议看懂整体流程相对较简单，但是要完全看懂，需要一定时日，毕竟内容较多；而golang的rpc框架可以基于tcp和http，也是比较好看懂，主要是反射比较多，rpc关键用了http自带的gob数解析格式，可以顺便学习下gob是如何使用的；而数据库操作之前用的就是挺迷糊的，明明有两个包database/sql和go-sql-driver为什么就只调用了database/sql里面的接口，因此在看了database/sql和go-sql-driver代码之后，就恍然大悟，也写篇博客记录下；</p>
<h1>前言</h1>
<hr>
<p>这里先给出简单例子，说明下如何使用database/sql；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	<span class="string">"database/sql"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line"></div><div class="line">	_ <span class="string">"github.com/go-sql-driver/mysql"</span></div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">	<span class="keyword">db</span>, <span class="keyword">err</span> := sql.<span class="keyword">Open</span>(<span class="string">"mysql"</span>, <span class="string">"root:root@/test"</span>)</div><div class="line">	checkErr(<span class="keyword">err</span>)</div><div class="line">	rows, <span class="keyword">err</span> := <span class="keyword">db</span>.<span class="keyword">Query</span>(<span class="string">"select * from test"</span>)</div><div class="line">	checkErr(<span class="keyword">err</span>)</div><div class="line">	<span class="keyword">var</span> (</div><div class="line">		id   uint64</div><div class="line">		name <span class="built_in">string</span></div><div class="line">	)</div><div class="line">	<span class="keyword">for</span> rows.Next() &#123;</div><div class="line">		<span class="keyword">err</span> = rows.Scan(&amp;id, &amp;name)</div><div class="line">		checkErr(<span class="keyword">err</span>)</div><div class="line">		fmt.Println(id, <span class="string">"-&gt;"</span>, name)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func checkErr(<span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		panic(<span class="keyword">err</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子很简单，先实例化一个数据库实例，然后通过db实例的query方法查询test数据库中的数据；大家可以看到，并没有用到go-sql-driver这个驱动程序，这是为什么了？</p>
<p>首先给出两个结论:</p>
<ol>
<li>database/sql是golang提供操作数据库的接口，但是有些内部方法需要调用驱动程序的接口；</li>
<li>go-sql-driver是符合database/sql接口的一套驱动程序，因此，真正进行数据库操作的接口是在go-sql-driver中实现的；</li>
</ol>
<p>好，接下来，我们看下database/sql是如何调用go-sql-driver的接口的；</p>
<h1>database/sql与go-sql-driver</h1>
<hr>
<p>我们先来看下，database/sql是如何注册驱动程序的，这个有点类似于linux虚拟文件系统，注册不同的文件系统，最后调用的就是相应文件系统的接口；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//database/sql/sql.go</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	driversMu sync.Mutex</div><div class="line">	drivers   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]driver.Driver)</div><div class="line">)</div><div class="line"><span class="comment">/*-------------------------------------------------*/</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Register</span><span class="params">(name <span class="keyword">string</span>, driver driver.Driver)</span></span> &#123;</div><div class="line">	driversMu.Lock()</div><div class="line">	<span class="keyword">defer</span> driversMu.Unlock()</div><div class="line">	<span class="keyword">if</span> driver == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sql: Register driver is nil"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> _, dup := drivers[name]; dup &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"sql: Register called twice for driver "</span> + name)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将驱动放入map中</span></div><div class="line">	drivers[name] = driver</div><div class="line">&#125;</div><div class="line"><span class="comment">/*--------------------------------------------------------*/</span></div><div class="line"><span class="comment">//go-sql-driver/mysql/driver.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	sql.Register(<span class="string">"mysql"</span>, &amp;MySQLDriver&#123;&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个代码可以看出，向database/sql注册驱动，其实就是将驱动程序存入database/sql内部定义的一个map中；而init()函数是在包引入时首先执行的函数，因此我们在使用go-sql-driver时，就不用显式注册驱动，因为包引入时，就已经注册好；我们接下来看下如何获得一个数据库；</p>
<h2>获取一个数据库</h2>
<p>由上述例子程序可以看出，要操作数据库，必须先获取一个数据库实例db，代码如下:
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//database/sql/sql.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span> &#123;</div><div class="line">	driversMu.Lock()</div><div class="line">	driveri, ok := drivers[driverName]</div><div class="line">	driversMu.Unlock()</div><div class="line">	<span class="keyword">if</span> !ok &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"sql: unknown driver %q (forgotten import?)"</span>, driverName)</div><div class="line">	&#125;</div><div class="line">	db := &amp;DB&#123;</div><div class="line">		driver:   driveri,</div><div class="line">		dsn:      dataSourceName,</div><div class="line">		openerCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, connectionRequestQueueSize),</div><div class="line">		lastPut:  <span class="built_in">make</span>(<span class="keyword">map</span>[*driverConn]<span class="keyword">string</span>),</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">go</span> db.connectionOpener()</div><div class="line">	<span class="keyword">return</span> db, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由这段代码，根据driverName获取驱动程序实例，然后封装成一个db实例返回，此时并没有一个连接存在；而是开启了一个goroutine来生产连接；我们来看下这个goroutine是怎么生产连接的；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) connectionOpener() &#123;</div><div class="line">	<span class="comment">//这个channel的缓冲区大小为1000000</span></div><div class="line">	<span class="keyword">for</span> <span class="keyword">range</span> <span class="keyword">db</span>.openerCh &#123;</div><div class="line">		<span class="keyword">db</span>.openNewConnection()</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Open one new connection</span></div><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) openNewConnection() &#123;</div><div class="line">	<span class="comment">//这是database/sql第一次调用驱动的接口，获取一个真实的连接</span></div><div class="line">	<span class="keyword">ci</span>, <span class="keyword">err</span> := <span class="keyword">db</span>.driver.<span class="keyword">Open</span>(<span class="keyword">db</span>.dsn)</div><div class="line">	<span class="keyword">db</span>.mu.Lock()</div><div class="line">	defer <span class="keyword">db</span>.mu.Unlock()</div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.closed &#123;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> == nil &#123;</div><div class="line">			<span class="keyword">ci</span>.<span class="keyword">Close</span>()</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">db</span>.pendingOpens--</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">db</span>.putConnDBLocked(nil, <span class="keyword">err</span>)</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将从驱动获取的连接封装成driverConn</span></div><div class="line">	dc := &amp;driverConn&#123;</div><div class="line">		<span class="keyword">db</span>: <span class="keyword">db</span>,</div><div class="line">		<span class="keyword">ci</span>: <span class="keyword">ci</span>,</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将新生成的driverConn放入空闲数组中</span></div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.putConnDBLocked(dc, <span class="keyword">err</span>) &#123;</div><div class="line">		<span class="keyword">db</span>.addDepLocked(dc, dc)</div><div class="line">		<span class="keyword">db</span>.numOpen++</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">ci</span>.<span class="keyword">Close</span>()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此，在获取一个db实例的时候，同时也生成了一个生产连接的goroutine，这个goroutine阻塞在channel中，当需要连接的时候，直接向这个channel发送数据即可；那么什么时候会产生连接了？有以下两种情况:</p>
<ol>
<li>第一次调用ping函数的时候，会产生一个连接；</li>
<li>当调用db.Exec或者db.Query等方法时，如果空闲数组中有连接，则直接获取，如果空闲数组中没有可用的连接，则会产生一个新的连接；</li>
</ol>
<h2>ping函数</h2>
<p>这里用ping函数来演示，如何通过向上述的goroutine发送数据，并产生一个连接，来，看下ping函数:
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Ping</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="comment">//获取一个连接</span></div><div class="line">	dc, err := db.conn(cachedOrNewConn)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将连接放入空闲数组中</span></div><div class="line">	db.putConn(dc, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ping这个函数很简单，调用db.conn获取一个连接，参数表示获取策略，可以是</p>
<ol>
<li>cachedOrNewConn从空闲数组获取或者新新生成一个连接</li>
<li>alwaysNewConn总是从新生成一个连接</li>
</ol>
<p>接下来，看下db.conn函数:
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">func (db *DB) conn(strategy connReuseStrategy) (*driverConn, error) &#123;</div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Lock</span>()</div><div class="line">	<span class="keyword">if</span> db<span class="selector-class">.closed</span> &#123;</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		return nil, errDBClosed</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果策略可以从空闲连接数组中获取，且空闲连接大于0,则直接从空闲数组获取连接返回；</span></div><div class="line">	numFree := len(db.freeConn)</div><div class="line">	<span class="keyword">if</span> strategy == cachedOrNewConn &amp;&amp; numFree &gt; <span class="number">0</span> &#123;</div><div class="line">		conn := db<span class="selector-class">.freeConn</span>[<span class="number">0</span>]</div><div class="line">		copy(db<span class="selector-class">.freeConn</span>, db<span class="selector-class">.freeConn</span>[<span class="number">1</span>:])</div><div class="line">		db<span class="selector-class">.freeConn</span> = db<span class="selector-class">.freeConn</span>[:numFree-<span class="number">1</span>]</div><div class="line">		conn<span class="selector-class">.inUse</span> = true</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		return conn, nil</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果当前打开的连接数大于设定的最大连接数，则阻塞在connQequest这个channel上，</span></div><div class="line">	<span class="comment">//下文再揭晓什么时候往这个channel写数据</span></div><div class="line">	<span class="keyword">if</span> db<span class="selector-class">.maxOpen</span> &gt; <span class="number">0</span> &amp;&amp; db<span class="selector-class">.numOpen</span> &gt;= db<span class="selector-class">.maxOpen</span> &#123;</div><div class="line">		req := make(chan connRequest, <span class="number">1</span>)</div><div class="line">		db<span class="selector-class">.connRequests</span> = append(db<span class="selector-class">.connRequests</span>, req)</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		ret := &lt;-req</div><div class="line">		return ret<span class="selector-class">.conn</span>, ret<span class="selector-class">.err</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果空闲连接数组中没有可用连接，且当前打开连接数还没达到最大值，则直接生成一个连接；</span></div><div class="line">	db.numOpen++ </div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">	ci, err := db<span class="selector-class">.driver</span><span class="selector-class">.Open</span>(db.dsn)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Lock</span>()</div><div class="line">		db<span class="selector-class">.numOpen--</span> <span class="comment">// 获取失败，则当前连接数减一</span></div><div class="line">		db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">		return nil, err</div><div class="line">	&#125;</div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Lock</span>()</div><div class="line">	<span class="comment">//封装成driverConn</span></div><div class="line">	dc := &amp;driverConn&#123;</div><div class="line">		db: db,</div><div class="line">		ci: ci,</div><div class="line">	&#125;</div><div class="line">	db.addDepLocked(dc, dc)</div><div class="line">	dc<span class="selector-class">.inUse</span> = true</div><div class="line">	db<span class="selector-class">.mu</span><span class="selector-class">.Unlock</span>()</div><div class="line">	return dc, nil</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这个函数可以看出，并不是所有连接都是从之前提到的那个goroutine产生，这个db.conn也会直接调用driver.Open函数产生连接；接下来看下ping函数内部是如何把连接放入空闲连接数组中的；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) putConn(dc *driverConn, <span class="keyword">err</span> <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">db</span>.mu.Lock()</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> == driver.ErrBadConn &#123;</div><div class="line">		<span class="keyword">db</span>.maybeOpenNewConnections()</div><div class="line">		<span class="keyword">db</span>.mu.Unlock()</div><div class="line">		dc.<span class="keyword">Close</span>()</div><div class="line">		<span class="built_in">return</span></div><div class="line">	&#125;</div><div class="line">	added := <span class="keyword">db</span>.putConnDBLocked(dc, nil)</div><div class="line">	<span class="keyword">db</span>.mu.Unlock()</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !added &#123;</div><div class="line">		dc.<span class="keyword">Close</span>()</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数内部，如果传进来的err为driver.ErrBadConn，那么之前在调用db.conn时获取的是一个无效的连接，因此这里需要调用db.maybeOpenNewConnections()来产生新连接；这个函数后面分析，先来看下added := db.putConnDBLocked(dc, nil)
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) putConnDBLocked(dc *driverConn, <span class="keyword">err</span> <span class="keyword">error</span>) bool &#123;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.maxOpen &gt; 0 &amp;&amp; <span class="keyword">db</span>.numOpen &gt; <span class="keyword">db</span>.maxOpen &#123;</div><div class="line">		<span class="keyword">return</span> false</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果有goroutine阻塞在获取连接上，则将这个本应该放回空闲连接数组的连接</span></div><div class="line">	<span class="comment">//返回给那个goroutine</span></div><div class="line">	<span class="keyword">if</span> c := len(<span class="keyword">db</span>.connRequests); c &gt; 0 &#123;</div><div class="line">		req := <span class="keyword">db</span>.connRequests[0]</div><div class="line">		<span class="keyword">copy</span>(<span class="keyword">db</span>.connRequests, <span class="keyword">db</span>.connRequests[1:])</div><div class="line">		<span class="keyword">db</span>.connRequests = <span class="keyword">db</span>.connRequests[:c-1]</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> == nil &#123;</div><div class="line">			dc.inUse = true</div><div class="line">		&#125;</div><div class="line">		req &lt;- connRequest&#123;</div><div class="line">			conn: dc,</div><div class="line">			<span class="keyword">err</span>:  <span class="keyword">err</span>,</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> true</div><div class="line">	<span class="comment">//否则将这个连接放入空闲数组中</span></div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">err</span> == nil &amp;&amp; !<span class="keyword">db</span>.closed &amp;&amp; <span class="keyword">db</span>.maxIdleConnsLocked() &gt; len(<span class="keyword">db</span>.freeConn) &#123;</div><div class="line">		<span class="keyword">db</span>.freeConn = <span class="keyword">append</span>(<span class="keyword">db</span>.freeConn, dc)</div><div class="line">		<span class="keyword">return</span> true</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ok，到这里，可以做个小结</p>
<ul>
<li>当某个goroutine需要一个连接的时候，首先查看空闲连接数组中是否有可用连接，如果有，则直接从空闲数组中获取；如果空闲数组中没有可用的连接，则需要判断当前打开的连接数是否超出设定的最大值，如果是，则当前goroutine阻塞；如果当前打开的连接数并没有大于设定的最大值，则直接生产一个连接返回；</li>
<li>当某个goroutine结束数据库操作时，将当前使用的连接放入空闲连接数组中，这时需要进行判断，是否有某个goroutine阻塞在获取连接上，如果有，则将当前的连接直接返回给阻塞的goroutine，如果没有goroutine阻塞在获取连接上，则可以直接放入空闲连接数组即可；</li>
</ul>
<p>之前还提到一个问题，就是当在putConn函数中，如果传入的是一个badConn，那么这时可能要生成新的连接；道理也很简单，因为如果某个goroutine阻塞在获取连接上，那么可能因为这个连接未及时调用putConn而阻塞更久；</p>
<p>我们来看下这个db.maybeOpenNewConnections()函数
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) maybeOpenNewConnections() &#123;</div><div class="line">	<span class="comment">//需要产生新的连接数量，db.pendingOpens是正在生成连接的数量</span></div><div class="line">	numRequests := len(<span class="keyword">db</span>.connRequests) - <span class="keyword">db</span>.pendingOpens</div><div class="line">	<span class="keyword">if</span> <span class="keyword">db</span>.maxOpen &gt; 0 &#123;</div><div class="line">		numCanOpen := <span class="keyword">db</span>.maxOpen - (<span class="keyword">db</span>.numOpen + <span class="keyword">db</span>.pendingOpens)</div><div class="line">		<span class="keyword">if</span> numRequests &gt; numCanOpen &#123;</div><div class="line">			numRequests = numCanOpen</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> numRequests &gt; 0 &#123;</div><div class="line">		<span class="keyword">db</span>.pendingOpens++</div><div class="line">		numRequests--</div><div class="line">		<span class="comment">//向db.openerCh发送数据，connectionOpener便会产生一个新连接</span></div><div class="line">		<span class="keyword">db</span>.openerCh &lt;- struct&#123;&#125;&#123;&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，才知道，原来一开始产生db的时候，新建的goroutine是在当连接出错时，用来生产连接的；</p>
<h2>db.Query方法</h2>
<p>之前已经知道如何获取一个连接，接着我们可以用db.Query是方法是如何实现的；
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) <span class="keyword">Query</span>(<span class="keyword">query</span> string, <span class="keyword">args</span> ...interface&#123;&#125;) (*Rows, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="keyword">var</span> rows *Rows</div><div class="line">	<span class="keyword">var</span> <span class="keyword">err</span> <span class="keyword">error</span></div><div class="line">	<span class="keyword">for</span> i := 0; i &lt; maxBadConnRetries; i++ &#123;</div><div class="line">		rows, <span class="keyword">err</span> = <span class="keyword">db</span>.<span class="keyword">query</span>(<span class="keyword">query</span>, <span class="keyword">args</span>, cachedOrNewConn)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != driver.ErrBadConn &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> == driver.ErrBadConn &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">db</span>.<span class="keyword">query</span>(<span class="keyword">query</span>, <span class="keyword">args</span>, alwaysNewConn)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> rows, <span class="keyword">err</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数，最终调用的是db.query()函数
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//database/sql/sql.go</span></div><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) <span class="keyword">query</span>(<span class="keyword">query</span> string, <span class="keyword">args</span> []interface&#123;&#125;, strategy connReuseStrategy) (*Rows, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="comment">//调用db.conn获取连接，如果出错，则回到Query方法的for循环中</span></div><div class="line">	<span class="keyword">ci</span>, <span class="keyword">err</span> := <span class="keyword">db</span>.conn(strategy)</div><div class="line">	<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">		<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">db</span>.queryConn(<span class="keyword">ci</span>, <span class="keyword">ci</span>.releaseConn, <span class="keyword">query</span>, <span class="keyword">args</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">/*-------------------------------------------------------------*/</span></div><div class="line">func (<span class="keyword">db</span> *<span class="keyword">DB</span>) queryConn(dc *driverConn, releaseConn func(<span class="keyword">error</span>), <span class="keyword">query</span> string, <span class="keyword">args</span> []interface&#123;&#125;) (*Rows, <span class="keyword">error</span>) &#123;</div><div class="line">	<span class="comment">//driver.Queryer是一个接口，只有query方法；从驱动中获取的</span></div><div class="line">	<span class="comment">//连接必须实现Query方法，</span></div><div class="line">	<span class="keyword">if</span> queryer, ok := dc.<span class="keyword">ci</span>.(driver.Queryer); ok &#123;</div><div class="line">		dargs, <span class="keyword">err</span> := driverArgs(nil, <span class="keyword">args</span>)</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">			releaseConn(<span class="keyword">err</span>)</div><div class="line">			<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">		&#125;</div><div class="line">		dc.Lock()</div><div class="line">		<span class="comment">//调用go-sql-driver中连接的Query方法</span></div><div class="line">		rowsi, <span class="keyword">err</span> := queryer.<span class="keyword">Query</span>(<span class="keyword">query</span>, dargs)</div><div class="line">		dc.Unlock()</div><div class="line">		<span class="keyword">if</span> <span class="keyword">err</span> != driver.ErrSkip &#123;</div><div class="line">			<span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</div><div class="line">				releaseConn(<span class="keyword">err</span>)</div><div class="line">				<span class="keyword">return</span> nil, <span class="keyword">err</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 将结果封装成Rows</span></div><div class="line">			rows := &amp;Rows&#123;</div><div class="line">				dc:          dc,</div><div class="line">				releaseConn: releaseConn,</div><div class="line">				rowsi:       rowsi,</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> rows, nil</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	...省去一些代码...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从queryConn函数可以看出，db.Query方法最终调用go-sql-driver驱动中mysqlConn.Query方法，最后将结果封装成Rows，返回给客户端；最后看下go-sql-driver的mysqlConn.Query方法
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *mysqlConn)</span> <span class="title">Query</span><span class="params">(query <span class="keyword">string</span>, args []driver.Value)</span> <span class="params">(driver.Rows, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> mc.netConn == <span class="literal">nil</span> &#123;</div><div class="line">		errLog.Print(ErrInvalidConn)</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, driver.ErrBadConn</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 发送sql语句请求，comQuery是查询类型</span></div><div class="line">	err := mc.writeCommandPacketStr(comQuery, query)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">// 读取结果</span></div><div class="line">		<span class="keyword">var</span> resLen <span class="keyword">int</span></div><div class="line">		resLen, err = mc.readResultSetHeaderPacket()</div><div class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">			rows := <span class="built_in">new</span>(textRows)</div><div class="line">			rows.mc = mc</div><div class="line"></div><div class="line">			<span class="keyword">if</span> resLen == <span class="number">0</span> &#123;</div><div class="line">				<span class="comment">// no columns, no more data</span></div><div class="line">				<span class="keyword">return</span> emptyRows&#123;&#125;, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			<span class="comment">// Columns</span></div><div class="line">			rows.columns, err = mc.readColumns(resLen)</div><div class="line">			<span class="keyword">return</span> rows, err</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，对于实现database/sql接口的驱动，操作的是真实的数据库，然后将结果返回给database/sql中的方法；其他方法类似，这里不一一分析；</p>
<h1>总结</h1>
<p>这篇文章主要分析了golang的database/sql模块是如何调用驱动中定义的方法；了解这些之后，对于使用database/sql将会更加得心应手，以及在驱动出现错误时，可以更快速的定位到错误；</p>
<p>之前看到很多地方都有用到protobuf，因此决定好好研究下这个框架，下次理解透之后，在发出来.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章也有说道，golang的http,rpc,以及第三方的redigo,go-sql-driver是开发一个服务常见的四大组件，因此我是很推荐有时间可以看下上述四大组件，而且golang自带的http和rpc框架本身就是http和rpc很好的教程，而且第三方框架miek
    
    </summary>
    
      <category term="golang" scheme="http://luodw.cc/categories/golang/"/>
    
    
      <category term="golang" scheme="http://luodw.cc/tags/golang/"/>
    
      <category term="database/sql" scheme="http://luodw.cc/tags/database-sql/"/>
    
      <category term="go-sql-driver" scheme="http://luodw.cc/tags/go-sql-driver/"/>
    
  </entry>
  
  <entry>
    <title>golang语言之groupcache</title>
    <link href="http://luodw.cc/2016/08/23/golang01/"/>
    <id>http://luodw.cc/2016/08/23/golang01/</id>
    <published>2016-08-23T12:53:55.000Z</published>
    <updated>2017-03-16T08:51:34.125Z</updated>
    
    <content type="html"><![CDATA[<p>实习期间一直在用golang，今天想写篇博客，聊聊我对golang的一些思考，以及分析下groupcache的实现；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/1356594941.jpg" alt="厦大美景"></p>
<p>在没接触golang之前，在我的印象里，服务器开发就是常见的nginx多进程，memcache多线程，redis单线程；后来，golang这种多协程，一个连接对应一个协程的模式深深吸引了我，相比进程，线程，协程粒度相对较小，协程切换代价与进程和线程相比是非常小的，因此一个连接对应一个协程才得以行得通；</p>
<p>golang很适合写服务，首先是语言层面支持高并发，其次是对http和rpc接口封装，用户在写c/s架构服务器时，既可以用基于http的rest api接口实现客户端和服务器端的通信，同时还可以用rpc实现客户端和服务器端的通信，而且支持多种数据格式传输，例如xml,json,gob等等；最后就是部署简单，生成可执行文件，直接运行；</p>
<p>学习golang，首先是学习基础语法，这个网上有很多教程，有一本《Go语言编程》很适合入门；其次就需要学习go语言层面底层的一些东西，例如协程切换，socket编程原理以及gc等等；这是非常有必要的，因为了解这些，对golang的使用会更加得心应手；例如golang网络编程，是怎么通知某个描述符有事件到达的?协程一开始阻塞在read调用中，当有数据达到之后，是怎么被唤醒的?等；我推荐两本gitbook，一个适合入门，一个适合深入:</p>
<ul>
<li><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/index.html" target="_blank" rel="external">深入理解Go</a></li>
<li><a href="https://tracymacding.gitbooks.io/implementation-of-golang/content/" target="_blank" rel="external">Implemention of golang</a></li>
</ul>
<p>在了解基础于语法以及一些底层原理之后，我觉得可以看看golang自带的框架，写的非常棒，很适合学习，特别是http和rpc，因为学习这两个框架可以了解到一次http请求是如何实现的，以及一次rpc过程是怎么实现的；当然还有一些第三方开源框架也写得很好；</p>
<p>ok，下面就来看看缓存库groupcache是怎么实现的。</p>
<h1>groupcache</h1>
<hr>
<p>groupcache存储的是kv结构，同是memcache作者出品，官方github上说明如下：</p>
<blockquote>
<p>groupcache is a caching and cache-filling library, intended as a replacement for memcached in many cases.</p>
</blockquote>
<p>也就是说groupcache是一个kv缓存，用于在某些方面替代memcache，但是我在学习了这个框架之后，我发现这个框架的适用场景并不多，因为groupcache只能get，不能update和delete，也不能设置过期时间，只能通过lru淘汰最近最少访问的数据；有些数据如果长时间不更改，那么可以用groupcache作为缓存；groupcache已经在dl.Google.com、Blogger、Google Code、Google Fiber、Google生产监视系统等项目中投入使用。</p>
<p>但是groupcache还是有它的优点的，groupcache既是服务器，也是客户端，当在本地groupcache缓存中没有查找的数据时，通过一致性哈希，查找到该key所对应的peer服务器，在通过http协议，从该peer服务器上获取所需要的数据；还有一点就是当多个客户端同时访问memcache中不存在的键时，会导致多个客户端从mysql获取数据并同时插入memcache中，而在相同情况下，groupcache只会有一个客户端从mysql获取数据，其他客户端阻塞，直到第一个客户端获取到数据之后，再返回给多个客户端；</p>
<p>groupcache是一个缓存库，也就是说不是一个完整的软件，需要自己实现main函数。可以自己写个测试程序，跑跑groupcache，我看了有些博客是直接引用<a href="http://capotej.com/blog/2013/07/28/playing-with-groupcache/" target="_blank" rel="external">Playing With Groupcache</a>这篇博客的测试程序，这个测试程序，客户端和groupcache通过rpc进行通信，而groupcache peer之间通过http协议进行通信；这是比较好的做法，因为如果客户端与服务器通信和groupcache之间通信采用的是同一个端口，那么在并发量上去的时候，会严重影响性能；下图是这个测试程序的架构图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-topology.png" alt="groupcache结构图"></p>
<p>这个原理就是如果客户端用的是set或get命令时，这时直接操作的是数据源(数据库或文件)，如果调用的是cget命令，则从groupcache中查找数据；</p>
<p>groupcache内部实现了lru和一致性哈希，我觉得大家可以看看，学习golang是如何实现lru和一致性哈希。下面简单分析groupcache Get函数的实现以及peer之间的通信；</p>
<h2>groupcache Get函数实现</h2>
<p>当客户端连上groupcache时，能做的只有get获取数据，如果本地有所需要的数据，则直接返回，如果没有，则通过一致性哈希函数判断这个key所对应的peer，然后通过http从这个peer上获取数据；如果这个peer上有需要的数据，则通过http回复给之前的那个groupcache；groupcache收到之后，保存在本地hotCache中，并返回给客户端；如果peer上也没有所需要的数据，则groupcache从数据源(数据库或者文件)获取数据，并将数据保存在本地mainCache，并返回给客户端；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Get</span><span class="params">(ctx Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="title">error</span></span> &#123;</div><div class="line">	g.peersOnce.Do(g.initPeers)</div><div class="line">	g.Stats.Gets.Add(<span class="number">1</span>)<span class="comment">//这是groupcache状态数据，即Get的次数+1</span></div><div class="line">	<span class="keyword">if</span> dest == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> errors.New(<span class="string">"groupcache: nil dest Sink"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//查找本地缓存，包括mainCache和hotCache</span></div><div class="line">	value, cacheHit := g.lookupCache(key)</div><div class="line"></div><div class="line">	<span class="keyword">if</span> cacheHit &#123;</div><div class="line">		<span class="comment">//如果命中，直接返回</span></div><div class="line">		g.Stats.CacheHits.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span> setSinkView(dest, value)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 如果本地没有命中，则从peer获取</span></div><div class="line">	destPopulated := <span class="literal">false</span></div><div class="line">	value, destPopulated, err := g.load(ctx, key, dest)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> destPopulated &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//将value赋值给dest返回</span></div><div class="line">	<span class="keyword">return</span> setSinkView(dest, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个Get函数很简单，先检查本地cache是否存在，存在即返回，不存在则向peer获取，接下来看下load函数是如何实现的；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">load</span><span class="params">(ctx Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="params">(value ByteView, destPopulated <span class="keyword">bool</span>, err error)</span></span> &#123;</div><div class="line">	g.Stats.Loads.Add(<span class="number">1</span>)</div><div class="line">	<span class="comment">//下面这个loadGroup是保证当数据不存在时，只有一个客户端从peer或者数据源获取数据，</span></div><div class="line">	<span class="comment">//其他客户端阻塞，直到第一个客户端数据之后，所有客户端再返回；这个主要是通过sync.WaitGroup实现</span></div><div class="line">	viewi, err := g.loadGroup.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> value, cacheHit := g.lookupCache(key); cacheHit &#123;</div><div class="line">			g.Stats.CacheHits.Add(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">		&#125;</div><div class="line">		g.Stats.LoadsDeduped.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">var</span> value ByteView</div><div class="line">		<span class="keyword">var</span> err error</div><div class="line">		<span class="keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</div><div class="line">			<span class="comment">//从peer获取数据</span></div><div class="line">			value, err = g.getFromPeer(ctx, peer, key)</div><div class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">				g.Stats.PeerLoads.Add(<span class="number">1</span>)</div><div class="line">				<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">			&#125;</div><div class="line">			g.Stats.PeerErrors.Add(<span class="number">1</span>)</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//从数据源获取数据</span></div><div class="line">		value, err = g.getLocally(ctx, key, dest)</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			g.Stats.LocalLoadErrs.Add(<span class="number">1</span>)</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">		&#125;</div><div class="line">		g.Stats.LocalLoads.Add(<span class="number">1</span>)</div><div class="line">		destPopulated = <span class="literal">true</span> </div><div class="line">		<span class="comment">//将数据源获取的数据存储在本地mainCache中</span></div><div class="line">		g.populateCache(key, value, &amp;g.mainCache)</div><div class="line">		<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">		value = viewi.(ByteView)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个load函数先是从peer获取数据，如果peer没有数据，则直接从数据源(数据库或文件)获取数据；ok，先看下groupcache是如何从数据源获取数据，然后再分析下如果从peer中获取数据；
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getLocally</span><span class="params">(ctx Context, key <span class="keyword">string</span>, dest Sink)</span> <span class="params">(ByteView, error)</span></span> &#123;</div><div class="line">	err := g.getter.Get(ctx, key, dest)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dest.view()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getLocallly函数主要是利用NewGroup创建Group时传进去的Getter，在调用这个Getter的Get函数从数据源获取数据。
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(name <span class="keyword">string</span>, cacheBytes <span class="keyword">int64</span>, getter Getter)</span> *<span class="title">Group</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> newGroup(name, cacheBytes, getter, <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说当groupcache以及peer不存在所需数据时，用户可以自己定义从哪获取数据以及如何获取数据，即定义Getter的实例即可；</p>
<h2>从peer获取数据</h2>
<p>当本地groupcache中不存在数据时，会先从peer处获取数据，我们来看下getFromPeer函数实现
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">getFromPeer</span><span class="params">(ctx Context, peer ProtoGetter, key <span class="keyword">string</span>)</span> <span class="params">(ByteView, error)</span></span> &#123;</div><div class="line">	<span class="comment">//为了减少传输数据量，在peer之间，通过pb来传输数据</span></div><div class="line">	req := &amp;pb.GetRequest&#123;</div><div class="line">		Group: &amp;g.name,</div><div class="line">		Key:   &amp;key,</div><div class="line">	&#125;</div><div class="line">	res := &amp;pb.GetResponse&#123;&#125;</div><div class="line">	err := peer.Get(ctx, req, res)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> ByteView&#123;&#125;, err</div><div class="line">	&#125;</div><div class="line">	value := ByteView&#123;b: res.Value&#125;</div><div class="line">	<span class="keyword">if</span> rand.Intn(<span class="number">10</span>) == <span class="number">0</span> &#123;<span class="comment">//10%的概率将从peer获取的数据存储在本地hotCache</span></div><div class="line">		g.populateCache(key, value, &amp;g.hotCache)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> value, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个ProtoGetter是个接口，httpGetter结构体实现了这个接口，而上述传进getFromPeer函数的peer就是httpGetter,因此，我们可以来看下httpGet这个结构体的Get函数
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">func (h *httpGetter) Get(context Context, <span class="keyword">in</span> *pb<span class="selector-class">.GetRequest</span>, out *pb.GetResponse) error &#123;</div><div class="line">	u := fmt.Sprintf(</div><div class="line">		<span class="string">"%v%v/%v"</span>,</div><div class="line">		h<span class="selector-class">.baseURL</span>,</div><div class="line">		url.QueryEscape(<span class="keyword">in</span>.GetGroup()),</div><div class="line">		url.QueryEscape(<span class="keyword">in</span>.GetKey()),</div><div class="line">	)</div><div class="line">	req, err := http.NewRequest(<span class="string">"GET"</span>, u, nil)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	<span class="selector-tag">tr</span> := http<span class="selector-class">.DefaultTransport</span></div><div class="line">	<span class="keyword">if</span> h<span class="selector-class">.transport</span> != nil &#123;</div><div class="line">		<span class="selector-tag">tr</span> = h.transport(context)</div><div class="line">	&#125;</div><div class="line">	res, err := <span class="selector-tag">tr</span>.RoundTrip(req)</div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return err</div><div class="line">	&#125;</div><div class="line">	defer res<span class="selector-class">.Body</span><span class="selector-class">.Close</span>()</div><div class="line">	<span class="keyword">if</span> res<span class="selector-class">.StatusCode</span> != http<span class="selector-class">.StatusOK</span> &#123;</div><div class="line">		return fmt.Errorf(<span class="string">"server returned: %v"</span>, res.Status)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//bufferPool是bytes.Buffer类型的对象池</span></div><div class="line">	<span class="selector-tag">b</span> := bufferPool.Get().(*bytes.Buffer)</div><div class="line">	<span class="selector-tag">b</span>.Reset()</div><div class="line">	defer bufferPool.Put(b)</div><div class="line">	_, err = io.Copy(<span class="selector-tag">b</span>, res.Body)<span class="comment">//将获取的数据copy给b</span></div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return fmt.Errorf(<span class="string">"reading response body: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	err = proto.Unmarshal(<span class="selector-tag">b</span>.Bytes(), out)<span class="comment">//将数据存在out中</span></div><div class="line">	<span class="keyword">if</span> err != nil &#123;</div><div class="line">		return fmt.Errorf(<span class="string">"decoding response body: %v"</span>, err)</div><div class="line">	&#125;</div><div class="line">	return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数首先向peer发起一个http请求，然后将请求得到的封装在out *pb.GetResponse，返回给getFromPeer,并最终返回给客户端；</p>
<h1>总结</h1>
<p>这篇文章主要是聊聊我对学习golang的一些看法，以及分析下groupcache的实现原理，分析的不是很细，主要是对这个框架进行了分析，对groupcache有了整体的认识之后，再去看细节部分，会简单很多。</p>
<p>这几天再看sqlmock开源框架，这个主要作用就是，在单元测试时用来模拟数据库操作；主要原理就是实现一个驱动程序。在看这个sqlmock过程中，首先必须把database/sql以及go-sql-driver看懂，知道这两个是如何一起运作的，这样才能了解sqlmock的实现；过几天再把database/sql以及go-sql-driver的实现原理发出来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习期间一直在用golang，今天想写篇博客，聊聊我对golang的一些思考，以及分析下groupcache的实现；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xjnip.com1.z0.glb.clouddn.com/1356594941.jpg&quot; alt=&quot;厦大
    
    </summary>
    
      <category term="golang" scheme="http://luodw.cc/categories/golang/"/>
    
    
      <category term="golang" scheme="http://luodw.cc/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>linux内存分配与回收</title>
    <link href="http://luodw.cc/2016/08/13/linux-cache/"/>
    <id>http://luodw.cc/2016/08/13/linux-cache/</id>
    <published>2016-08-13T11:32:11.000Z</published>
    <updated>2017-03-16T08:51:34.129Z</updated>
    
    <content type="html"><![CDATA[<p>之前在实习时，听了OOM的分享之后，就对linux内核内存管理充满兴趣；但是这块知识非常庞大，没有一定积累，不敢写下，担心误人子弟；所以经过一个一段时间的积累，对内核内存有一定了解之后，今天才写下这篇博客，记录以及分享；</p>
<p>之前也有写过linux内存管理，那篇文章主要是<a href="http://luodw.cc/2016/02/17/linux-memory/">linux内存管理</a>，这篇文章主要是分析了单个进程空间的内存布局与分配，今天这篇博客主要是从全局的视角分析下内核对内存的管理;
<img src="http://7xjnip.com1.z0.glb.clouddn.com/29381f30e924b899045823b46e061d950b7bf6d2.jpg" alt="厦大白城"></p>
<p>下面主要从以下方面介绍linux内存管理:</p>
<ul>
<li>进程的内存申请与分配</li>
<li>内存耗尽之后OOM</li>
<li>申请的内存都在哪？</li>
<li>系统回收内存</li>
</ul>
<h1>进程的内存申请与分配</h1>
<hr>
<p>之前有篇文章介绍hello world程序是如何载入内存以及是如何申请内存的；我在这，再次说明下；同样，还是先给出进程的地址空间，我觉得对于任何开发人员这张图是必须记住的，还有一张就是操作disk,memory以及cpu cache的时间图；
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_015.png" alt="进程的地址空间"></p>
<p>当我们在终端启动一个程序时，终端进程调用exec函数将可执行文件载入内存，此时代码段，数据段，bbs段，stack段都通过mmap函数映射到内存空间，堆则要根据是否有在堆上申请内存来决定是否映射；exec执行之后，此时并未真正开始执行进程，而是将cpu控制权交给了动态链接库装载器，由它来将该进程需要的动态链接库装载进内存；之后才开始进程的执行；这个过程可以通过strace命令跟踪进程调用的系统函数来分析，
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">charles@charles-Aspire-4741:~$ strace ./toUpper</div><div class="line">execve(<span class="string">"./toUpper"</span>, [<span class="string">"./toUpper"</span>], [/* 72 vars */]) = 0</div><div class="line">brk(NULL)                               = 0x1bef000</div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f30be5d8000</div><div class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = 3</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=116232, ...&#125;) = 0</div><div class="line">mmap(NULL, 116232, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f30be5bb000</div><div class="line">close(3)                                = 0</div><div class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</div><div class="line">open(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = 3</div><div class="line"><span class="built_in">read</span>(3, <span class="string">"\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0"</span>..., 832) = 832</div><div class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1864888, ...&#125;) =: 0</div><div class="line">mmap(NULL, 3967488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f30bdfec000</div><div class="line">mprotect(0x7f30be1ac000, 2093056, PROT_NONE) = 0</div><div class="line">mmap(0x7f30be3ab000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bf000) = 0x7f30be3ab000</div><div class="line">mmap(0x7f30be3b1000, 14848, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f30be3b1000</div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure></p>
<p>这是我上篇博客认识pipe中的程序，从这个输出过程，可以看出和我上述描述的一致；</p>
<p>当第一次调用malloc申请内存时，通过系统调用brk嵌入到内核，首先会进行一次判断，是否有关于堆的vma，如果没有，则通过mmap匿名映射一块内存给堆，并建立vma结构，挂到mm_struct描述符上的红黑树和链表上；然后回到用户态，通过内存分配器(ptmaloc,tcmalloc,jemalloc)算法将分配到的内存进行管理，返回给用户所需要的内存；</p>
<p>如果用户态申请大内存时，是直接调用mmap分配内存，此时返回给用户态的内存还是虚拟内存，直到第一次访问返回的内存时，才真正进行内存的分配；其实通过brk返回的也是虚拟内存，但是经过内存分配器进行切割分配之后(切割就必须访问内存)，全都分配到了物理内存</p>
<p>当进程在用户态通过调用free释放内存时，如果这块内存是通过mmap分配，则调用munmap直接返回给系统；否则内存是先返回给内存分配器，然后由内存分配器统一返还给系统，这就是为什么当我们调用free回收内存之后，再次访问这块内存时，可能不会报错的原因；</p>
<p>当然，当整个进程退出之后，这个进程占用的内存都会归还给系统；</p>
<h1>内存耗尽之后OOM</h1>
<hr>
<p>在实习期间，有一台测试机上的mysql实例经常被oom杀死；oom(out of memory)即为系统在内存耗尽时的自我拯救措施，他会选择一个进程，将其杀死，释放出内存；很明显，哪个进程占用的内存最多，即最可能被杀死，但事实是这样的吗？</p>
<p>今天早上去上班，刚好碰到了一起OOM，突然发现，oom一次，世界都安静下来了，哈哈；测试机上的redis被杀死了；
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Out of memory: <span class="keyword">Kill</span> process <span class="number">12312</span> (redis-<span class="keyword">server</span>) score <span class="number">9</span> <span class="keyword">or</span> sacrifice <span class="keyword">child</span></div><div class="line">Killed process <span class="number">12312</span>, UID <span class="number">501</span>, (redis-<span class="keyword">server</span>) total-vm:<span class="number">186660</span>kB, anon-rss:<span class="number">9388</span>kB, <span class="keyword">file</span>-rss:<span class="number">4</span>kB</div></pre></td></tr></table></figure></p>
<p>OOM关键文件oom_kill.c，里面介绍了当内存不够时，系统如何选择最应该被杀死的进程；选择因素有挺多的，除了进程占用的内存外，还有进程运行的时间，进程的优先级，是否为root用户进程，子进程个数和占用内存以及用户控制参数oom_adj都相关；</p>
<p>当产生oom之后，函数select_bad_process会遍历所有进程，通过之前提到的那些因素，每个进程都会得到一个oom_score分数，分数最高，则被选为杀死的进程；</p>
<p>我们可以通过设置/proc/&lt;pid&gt;/oom_adj分数来干预系统选择杀死的进程；
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * /proc/&lt;pid&gt;/oom_adj set to -17 protects from the oom killer for legacy</div><div class="line"> * purposes.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_DISABLE (-17)</span></div><div class="line"><span class="comment">/* inclusive */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_ADJUST_MIN (-16)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OOM_ADJUST_MAX 15</span></div></pre></td></tr></table></figure></p>
<p>这是内核关于这个oom_adj调整值的定义；最大可以调整为15,最小为-16，如果为-17，则该进程就像买了vip会员一样，不会被系统驱逐杀死了；因此，如果在一台机器上有跑很多服务器，且你不希望自己的服务被杀死的话，就可以设置自己服务的oom_adj为-17；</p>
<p>当然，说到这，就必须提到另一个参数/proc/sys/vm/overcommit_memory，man proc说明如下:
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0: heuristic overcommit (this is the default)</div><div class="line">1: always overcommit, never<span class="built_in"> check</span></div><div class="line">2: always check, never overcommit</div></pre></td></tr></table></figure></p>
<p>意思就是当overcommit_memory为0时，则为启发式oom，即当申请的虚拟内存不是很夸张的大于物理内存，则系统允许申请；但是当进程申请的虚拟内存很夸张的大于物理内存，则就会产生OOM，例如只有8g的物理内存，然后redis虚拟内存占用了24G，物理内存占用3g,如果这时执行bgsave，子进程和父进程共享物理内存，但是虚拟内存是自己的，即子进程会申请24g的虚拟内存，这很夸张大于物理内存，就会产生一次OOM；</p>
<p>当overcommit_memory为1时，则永远都允许overmemory内存申请；即不管你多大的虚拟内存申请都允许，但是当系统内存耗尽时，这时就会产生oom；即上述的redis例子，在overcommit_memory=1时，是不会产生oom的，因为物理内存足够；</p>
<p>当overcommit_memory为2时，永远都不能超出某个限定额的内存申请，这个限定额为swap+RAM*系数（/proc/sys/vm/overcmmit_ratio，默认50%，可以自己调整），如果这么多资源已经用光，那么后面任何尝试申请内存的行为都会返回错误，这通常意味着此时没法运行任何新程序</p>
<p>以上就是oom的内容，了解原理，以及如何根据自己的应用，合理的设置OOM；</p>
<h1>系统申请的内存都在哪？</h1>
<hr>
<p>我们了解了一个进程的地址空间之后，是否会好奇，申请到的物理内存都存在哪了？可能很多人觉得，不就是物理内存吗？我这里说申请的内存在哪，是因为物理内存有分为cache和普通物理内存，可以通过free命令查看；而且物理内存还有分DMA,NORMAL,HIGH三个区，这里主要分析cache和普通内存；</p>
<p>通过第一部分，我们知道一个进程的地址空间几乎都是mmap函数申请，有文件映射和匿名映射两种；</p>
<h2>共享文件映射</h2>
<p>我们先来看下代码段和动态链接库映射段，这两个都是属于共享文件映射，也就是说由同一个可执行文件启动的两个进程是共享这两个段，都是映射到同一块物理内存；那么这块内存在哪了？我写了个程序测试如下：
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">struct</span> stat sb;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">  	<span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;</div><div class="line">    	perror(<span class="string">"open"</span>);</div><div class="line">	&#125;  </div><div class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"fstat"</span>);  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,sb.st_size, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_SHARED , fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">    	perror(<span class="string">"mmap"</span>);  </div><div class="line">	 &#125;</div><div class="line">	<span class="comment">//必须执行下面memset函数，否则系统不会分配真实内存</span></div><div class="line">	<span class="built_in">memset</span>(p,<span class="string">'c'</span>,sb.st_size);</div><div class="line">	sleep(<span class="number">100</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先看下当前系统的内存使用情况:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           5828        1596        3612          47         620        3913</div><div class="line">Swap:          3904           4        3900</div></pre></td></tr></table></figure></p>
<p>当我在本地新建一个1G的文件</p>
<blockquote>
<p>dd if=/dev/zero of=fileblock bs=M count=1024</p>
</blockquote>
<p>然后调用上述程序，进行共享文件映射,此时内存使用情况为：
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> ./hello fileblock</div><div class="line">/*---------------------*/</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1679 </span>      <span class="number"> 2491 </span>        <span class="number"> 47 </span>      <span class="number"> 1656 </span>       3824</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div></pre></td></tr></table></figure></p>
<p>我们可以发现，buff/cache增长了大概1G，因此我们可以得出结论，代码段和动态链接库段是映射到内核cache中，也就是说当执行共享文件映射时，文件是先被读取到cache中，然后再映射到用户进程空间中；</p>
<h2>私有文件映射段</h2>
<p>对于进程空间中的数据段，其必须是私有文件映射；因为如果是共享文件映射，那么同一个可执行文件启动的两个进程，任何一个进程修改数据段，都将影响另一个进程了；我将上述测试程序改写成匿名文件映射：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">struct</span> stat sb;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">        <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        perror(<span class="string">"open"</span>);</div><div class="line">        &#125;  </div><div class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"fstat"</span>);  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,sb.st_size, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_PRIVATE , fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"mmap"</span>);  </div><div class="line">         &#125;</div><div class="line">        <span class="comment">//必须执行下面memset函数，否则系统不会分配真实内存</span></div><div class="line">        <span class="built_in">memset</span>(p,<span class="string">'c'</span>,sb.st_size);</div><div class="line">        sleep(<span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在执行程序执行，需要先将之前的cache释放掉，否则会影响结果</p>
<blockquote>
<p>echo 1 &gt;&gt; /proc/sys/vm/drop_caches</p>
</blockquote>
<p>接着执行程序，看下内存使用情况:
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//没执行程序之前的内存使用情况</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1679 </span>      <span class="number"> 3681 </span>        <span class="number"> 47 </span>       <span class="number"> 467 </span>       3840</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div><div class="line">/*------------------------------------------*/</div><div class="line">./hello fileblock</div><div class="line">/*-----------------------------------------*/</div><div class="line">//调用程序之后内存使用情况</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 2713 </span>      <span class="number"> 1584 </span>        <span class="number"> 47 </span>      <span class="number"> 1530 </span>       2806</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div></pre></td></tr></table></figure></p>
<p>从使用前和使用后对比，可以发现used和buff/cache分别增长了1G，说明当进行私有文件映射时，首先是将文件映射到cache中，然后如果某个文件对这个文件进行修改，则会从其他内存中分配一块内存先将文件数据拷贝至新分配的内存，然后再在新分配的内存上进行修改，这也就是写时复制；</p>
<p>这也很好理解，因为如果同一个可执行文件开启多个实例，那么内核先将这个可执行的数据段映射到cache，然后每个实例如果有修改数据段，则都将分配一个一块内存存储数据段，毕竟数据段也是一个进程私有的；</p>
<p>通过上述分析，可以得出结论，如果是文件映射，则都是将文件映射到cache中，然后根据共享还是私有进行不同的操作；</p>
<h2>私有匿名映射</h2>
<p>像bbs段，堆，栈这些都是匿名映射，因为可执行文件中没有相应的段；而且必须是私有映射，否则如果当前进程fork出一个子进程，那么父子进程将会共享这些段，一个修改都会影响到彼此，这是不合理的;</p>
<p>ok，现在我把上述测试程序改成私有匿名映射
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,SIZE, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">    	perror(<span class="string">"mmap"</span>);  </div><div class="line">	 &#125;</div><div class="line">	<span class="built_in">memset</span>(p,<span class="string">'c'</span>,SIZE);</div><div class="line">	sleep(<span class="number">100</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时再来看下内存的使用情况
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//程序执行前</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1698 </span>      <span class="number"> 3646 </span>        <span class="number"> 47 </span>       <span class="number"> 483 </span>       3821</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div><div class="line">/*------------------------------------------*/</div><div class="line">./hello</div><div class="line">/*------------------------------------------*/</div><div class="line">//测试程序执行之后</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 2749 </span>      <span class="number"> 2582 </span>        <span class="number"> 47 </span>       <span class="number"> 496 </span>       2771</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 4 </span>       3900</div></pre></td></tr></table></figure></p>
<p>我们可以看到，只有used增加了1G，而buff/cache并没有增长；说明，在进行匿名私有映射时，并没有占用cache，其实这也是有道理，因为就只有当前进程在使用这块这块内存，没有必要占用宝贵的cache;</p>
<h2>共享匿名映射</h2>
<p>当我们需要在父子进程共享内存时，就可以用到mmap共享匿名映射；那么共享匿名映射的内存是存放在哪了？我继续改写上述测试程序为共享匿名映射
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE  1024*1024*1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;  </div><div class="line">    <span class="keyword">char</span> *p;</div><div class="line">    <span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,SIZE, PROT_READ |   </div><div class="line">                PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </div><div class="line">        perror(<span class="string">"mmap"</span>);  </div><div class="line">         &#125;</div><div class="line">        <span class="built_in">memset</span>(p,<span class="string">'c'</span>,SIZE);</div><div class="line">        sleep(<span class="number">100</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时来看下内存的使用情况：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/测试程序执行前：</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           5828        1667        3661          47         499        3852</div><div class="line">Swap:          3904           4        3900</div><div class="line">/*-----------------------------------------*/</div><div class="line">./hello</div><div class="line">/*-----------------------------------------*/</div><div class="line">charles@charles-Aspire-4741:~$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:           5828        1694        2602        1071        1531        2801</div><div class="line">Swap:          3904           4        3900</div></pre></td></tr></table></figure></p>
<p>从上述结果，我们可以看出，只有buff/cache增长了1G，即当进行共享匿名映射时，这时是从cache中申请内存；道理也很明显，因为父子进程共享这块内存，共享匿名映射存在于cache，然后每个进程再映射到彼此的虚存空间，这样即可操作的是同一块内存，</p>
<h1>系统回收内存</h1>
<hr>
<p>当系统内存不足时，有两种方式进行内存释放，一种是手动的方式，另一种是系统自己触发的内存回收；先来看下手动触发方式；</p>
<h2>手动回收内存</h2>
<p>手动回收内存，之前也有演示过，即</p>
<blockquote>
<p>echo 1 &gt;&gt; /proc/sys/vm/drop_caches</p>
</blockquote>
<p>我们可以在man proc下面看到关于这个的简介
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">To free pagecache, use:</div><div class="line">	echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches<span class="title"></span></div><div class="line"></div><div class="line">To free<span class="title"> dentries</span> and<span class="title"> inodes,</span> use:<span class="title"></span></div><div class="line"></div><div class="line">	echo 2 &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches<span class="title"></span></div><div class="line"></div><div class="line">To free<span class="title"> pagecache,</span> dentries<span class="title"> and</span> inodes,<span class="title"> use:</span></div><div class="line"><span class="title"></span></div><div class="line">	echo 3 &gt; /<span class="keyword">proc</span>/sys/vm/drop_caches<span class="title"></span></div><div class="line"> Because writing<span class="title"> to</span> this<span class="title"> file</span> is<span class="title"> a</span> nondestructive<span class="title">  operation</span> <span class="title"> and</span> <span class="title"> </span></div><div class="line">dirty <span class="title"> objects</span> <span class="title"> are</span> <span class="title"> not</span> <span class="title"> freeable,</span> <span class="title"> the</span> user<span class="title"> should</span> run<span class="title"> sync(1)</span> first.</div></pre></td></tr></table></figure></p>
<p>从这个介绍可以看出，当drop_caches文件为1时，这时将释放pagecache中可释放的部分(有些cache是不能通过这个释放的)；当drop_caches为2时，这时将释放dentries和inodes缓存；当drop_caches为3时，这同时释放上述两项；</p>
<p>关键还有最后一句，意思是说如果pagecache中有脏数据时，操作drop_caches是不能释放的，必须通过sync命令将脏数据刷新到磁盘，才能通过操作drop_caches释放pagecache；</p>
<p>ok，之前有提到有些pagecache是不能通过drop_caches释放的，那么除了上述提文件映射和共享匿名映射外，还有有哪些东西是存在pagecache了？</p>
<h3>tmpfs</h3>
<p>我们先来看下tmpfs; tmpfs和procfs,sysfs以及ramfs一样，都是基于内存的文件系统；tmpfs和ramfs的区别就是ramfs的文件基于纯内存的，和tmpfs除了纯内存外，还会使用swap交换空间，以及ramfs可能会把内存耗尽，而tmpfs可以限定使用内存大小；可以用命令df -T -h查看系统一些文件系统，其中就有一些是tmpfs，比较出名的是目录/dev/shm</p>
<p>tmpfs文件系统源文件在内核源码mm/shmem.c，tmpfs实现很复杂，之前有介绍虚拟文件系统，基于tmpfs文件系统创建文件和其他基于磁盘的文件系统一样，也会有inode,super_block,identry,file等结构，区别主要是在读写上，因为读写才涉及到文件的载体是内存还是磁盘；</p>
<p>而tmpfs文件的读函数shmem_file_read，过程主要为通过inode结构找到address_space地址空间，其实就是磁盘文件的pagecache；然后通过读偏移定位cache页以及页内偏移，这时就可以直接从这个pagecache通过函数__copy_to_user将缓存页内数据拷贝到用户空间；当我们要读物的数据不pagecache中时，这时要判断是否在swap中，如果在则先将内存页swap in，再读取；</p>
<p>tmpfs文件的写函数shmem_file_write，过程主要为先判断要写的页是否在内存中，如果在，则直接将用户态数据通过函数__copy_from_user拷贝至内核pagecache中覆盖老数据，并标为dirty；如果要写的数据不再内存中，则判断是否在swap中，如果在，则先读取出来，用新数据覆盖老数据并标为脏；如果即不在内存也不在磁盘，则新生成一个pagecache存储用户数据；</p>
<p>由上面分析，我们知道基于tmpfs的文件也是使用cache的，我们可以在/dev/shm上创建一个文件来检测下:
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//没有创建文件前内存使用情况</span></div><div class="line">charles<span class="meta">@charles</span>-Aspire<span class="number">-4741</span>:<span class="regexp">/dev/</span>shm$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line"><span class="string">Mem:</span>           <span class="number">5828</span>        <span class="number">1401</span>        <span class="number">2223</span>          <span class="number">42</span>        <span class="number">2204</span>        <span class="number">4058</span></div><div class="line"><span class="string">Swap:</span>          <span class="number">3904</span>           <span class="number">0</span>        <span class="number">3904</span></div><div class="line"><span class="comment">/*-----------------------------------------*/</span></div><div class="line">dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>zero of=fileblock bs=<span class="number">1</span>G count=<span class="number">1</span></div><div class="line"><span class="comment">/*-----------------------------------------*/</span></div><div class="line"><span class="comment">//在/dev/shm上创建一个1G的文件</span></div><div class="line">charles<span class="meta">@charles</span>-Aspire<span class="number">-4741</span>:<span class="regexp">/dev/</span>shm$ free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line"><span class="string">Mem:</span>           <span class="number">5828</span>        <span class="number">1400</span>        <span class="number">1197</span>        <span class="number">1066</span>        <span class="number">3229</span>        <span class="number">3035</span></div><div class="line"><span class="string">Swap:</span>          <span class="number">3904</span>           <span class="number">0</span>        <span class="number">3904</span></div></pre></td></tr></table></figure></p>
<p>看到了吧，cache增长了1G，验证了tmpfs的确使用的cache内存；</p>
<p>其实mmap匿名映射原理也是用了tmpfs，在mm/mmap.c-&gt;do_mmap_pgoff函数内部，有判断如果file结构为空以及为SHARED映射，则调用shmem_zero_setup(vma)函数在tmpfs上用新建一个文件
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int shmem_zero_setup(<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span> *vma)</div><div class="line">&#123;</div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *file;</div><div class="line">	loff_t size = vma-&gt;vm_end - vma-&gt;vm_start;</div><div class="line"></div><div class="line">	file = shmem_file_setup(<span class="string">"dev/zero"</span>, size, vma-&gt;vm_flags);</div><div class="line">	<span class="keyword">if</span> (IS_ERR(file))</div><div class="line">		<span class="keyword">return</span> PTR_ERR(file);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (vma-&gt;vm_file)</div><div class="line">		fput(vma-&gt;vm_file);</div><div class="line">	vma-&gt;vm_file = file;</div><div class="line">	vma-&gt;vm_ops = &amp;shmem_vm_ops;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就解释了为什么共享匿名映射内存初始化为0了；但是我们知道用mmap分配的内存初始化为0，就是说mmap私有匿名映射也为0,那么体现在哪了？</p>
<p>这个在do_mmap_pgoff函数内部可没有体现出来，而是在缺页异常，然后分配一种特殊的初始化为0的页；</p>
<p>那么这个tmpfs占有的内存页可以回收吗？
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//创建文件前</div><div class="line">free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1240 </span>      <span class="number"> 4040 </span>        <span class="number"> 41 </span>       <span class="number"> 547 </span>       4245</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 0 </span>       3904</div><div class="line">//创建文件之后</div><div class="line">root@charles-Aspire-4741:/dev/shm<span class="comment"># free -m</span></div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1243 </span>      <span class="number"> 3011 </span>      <span class="number"> 1065 </span>      <span class="number"> 1573 </span>       3217</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 0 </span>       3904</div><div class="line">/*------------------------------------------*/</div><div class="line">root@charles-Aspire-4741:/dev/shm<span class="comment"># echo 1 &gt;&gt; /proc/sys/vm/drop_caches</span></div><div class="line">/*-------------------------------------------*/</div><div class="line"> free -m</div><div class="line">              total        used        free      shared  buff/cache   available</div><div class="line">Mem:          <span class="number"> 5828 </span>      <span class="number"> 1243 </span>      <span class="number"> 3012 </span>      <span class="number"> 1065 </span>      <span class="number"> 1572 </span>       3217</div><div class="line">Swap:         <span class="number"> 3904 </span>         <span class="number"> 0 </span>       3904</div></pre></td></tr></table></figure></p>
<p>也就是说tmpfs文件占有的pagecache是不能回收的；道理也很明显，因为有文件引用这些页，就不能回收；</p>
<h3>共享内存</h3>
<p>posix共享内存其实和mmap共享映射是同一个道理，都是利用在tmpfs文件系统上新建一个文件，然后再映射到用户态；最后两个进程操作同一个物理内存；那么System V共享内存是否也是利用tmpfs文件系统了？</p>
<p>我们可以跟踪到下述函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newseg</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_params *params)</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">//........</span></div><div class="line"><span class="built_in">sprintf</span>(name, <span class="string">"SYSV%08x"</span>, key);</div><div class="line"><span class="keyword">if</span>  ((shmflg &amp; SHM_NORESERVE) &amp;&amp;sysctl_overcommit_memory != OVERCOMMIT_NEVER)</div><div class="line">	acctflag = VM_NORESERVE;</div><div class="line">file = shmem_kernel_file_setup(name, size, acctflag);</div><div class="line"><span class="comment">//........</span></div></pre></td></tr></table></figure></p>
<p>这个函数就是新建一个共享内存段，其中函数</p>
<blockquote>
<p>shmem_kernel_file_setup</p>
</blockquote>
<p>就是在tmpfs文件系统上创建一个文件；然后通过这个内存文件实现进程通信；这我就不写测试程序了；而且这也是不能回收的，因为共享内存ipc机制生命周期是随内核的，也就是说你创建共享内存之后，如果不显示删除的话，进程退出之后，共享内存还是存在的；</p>
<p>之前看了一些技术博客，说到Poxic和System V两套ipc机制(消息队列，信号量以及共享内存)都是使用tmpfs文件系统，也就是说最终内存使用的都是pagecache，但是我在源码中看出了两个共享内存是基于tmpfs文件系统，其他信号量和消息队列还没看出来(有待后续考究)；</p>
<p>posix消息队列的实现有点类似与pipe的实现，也是自己一套mqueue文件系统，然后在inode上的i_private上挂上关于消息队列属性mqueue_inode_info，在这个属性上，内核2.6时，是用一个数组存储消息，而到了4.6则用红黑树了存储消息(我下载了这两个版本，具体什么时候开始用红黑树，没深究)；然后两个进程每次操作都是操作这个mqueue_inode_info中的消息数组或者红黑树，实现进程通信；和这个mqueue_inode_info类似的还有tmpfs文件系统属性shmem_inode_info和为epoll服务的文件系统eventloop,也有一个特殊属性struct eventpoll，这个是挂在file结构的private_data等等；</p>
<blockquote>
<p>说到这，可以小结下，进程空间中代码段，数据段，动态链接库(共享文件映射)，mmap共享匿名映射都存在于cache中，但是这些内存页都有被进程引用，所以是不能释放的；基于tmpfs的ipc进程间通信机制的生命周期是随内核，因此也是不能通过drop_caches释放；</p>
</blockquote>
<p>虽然上述提及的cache不能释放，但是后面有提到，当内存不足时，这些内存是可以swap out的；</p>
<p><strong>因此drop_caches能释放的就是当从磁盘读取文件时的缓存页以及某个进程将某个文件映射到内存之后，进程退出，这时映射文件的的缓存页如果没有被引用，也是可以被释放的;</strong></p>
<h2>内存自动释放方式</h2>
<p>当系统内存不够时，操作系统有一套自我整理内存，并尽可能的释放内存机制；如果这套机制不能释放足够多的内存，那么只能OOM了；</p>
<p>之前在提及oom时，说道redis因为oom被杀死，如下:
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Out of memory: <span class="keyword">Kill</span> process <span class="number">12312</span> (redis-<span class="keyword">server</span>) score <span class="number">9</span> <span class="keyword">or</span> sacrifice <span class="keyword">child</span></div><div class="line">Killed process <span class="number">12312</span>, UID <span class="number">501</span>, (redis-<span class="keyword">server</span>) total-vm:<span class="number">186660</span>kB, anon-rss:<span class="number">9388</span>kB, <span class="keyword">file</span>-rss:<span class="number">4</span>kB</div></pre></td></tr></table></figure></p>
<p>第二句后半部分，</p>
<blockquote>
<p>total-vm:186660kB, anon-rss:9388kB, file-rss:4kB</p>
</blockquote>
<p>把一个进程内存使用情况，用三个属性进行了说明，即所有虚拟内存，常驻内存匿名映射页以及常驻内存文件映射页；</p>
<p>其实从上述的分析，我们也可以知道一个进程其实就是文件映射和匿名映射；</p>
<ul>
<li>文件映射:代码段，数据段，动态链接库共享存储段以及用户程序的文件映射段；</li>
<li>匿名映射：bbs段，堆，以及当malloc用mmap分配的内存，还有mmap共享内存段；</li>
</ul>
<p>其实内核回收内存就是根据文件映射和匿名映射来进行的；在mmzone.h有如下定义:
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define LRU_BASE 0</span></div><div class="line"><span class="comment">#define LRU_ACTIVE 1</span></div><div class="line"><span class="comment">#define LRU_FILE 2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> &#123;</span></div><div class="line">	LRU_INACTIVE_ANON = LRU_BASE,<span class="regexp">//</span>不活跃匿名映射页lru</div><div class="line">	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,<span class="regexp">//</span>活跃匿名映射页lru</div><div class="line">	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,<span class="regexp">//</span>不活跃文件映射页lru</div><div class="line">	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,<span class="regexp">//</span>活跃文件映射页lru</div><div class="line">	LRU_UNEVICTABLE,</div><div class="line">	NR_LRU_LISTS</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>LRU_UNEVICTABLE即为不可驱逐页lru，我的理解就是当调用mlock锁住内存，不让系统swap out出去的页列表；</p>
<p>简单说下linux内核自动回收内存原理；内核有一个kswapd会周期性的检查内存使用情况，如果发现空闲内存定于pages_low，则kswapd会对lru_list前四个lru队列进行扫描，在活跃链表中查找不活跃的页，并添加不活跃链表；然后再遍历不活跃链表，逐个进行回收释放出32个页，知道free page数量达到pages_high；针对不同的页，回收方式也不一样；</p>
<p>当然，当内存水平低于某个极限阈值时，会直接发出内存回收，原理和kswapd一样，但是这次回收力度更大，需要回收更多的内存；</p>
<p>文件页：</p>
<ol>
<li>如果是脏页，则直接回写进磁盘，再回收内存；</li>
<li>如果不是脏页，则直接释放回收；因为如果是io读缓存，直接释放掉，下次读时，缺页异常，直接到磁盘读回来即可；如果是文件映射页，直接释放掉，下次访问时，也是产生两个缺页异常，一次将文件内容读取进磁盘，另一次与进程虚拟内存关联；</li>
</ol>
<p>匿名页：
因为匿名页没有回写的地方，如果释放掉，那么就找不到数据了，所以匿名页的回收是采取swap out到磁盘；并在页表项做个标记，下次缺页异常在从磁盘swap in进内存；</p>
<p>swap换进换出其实是很占用系统IO的，如果系统内存需求突然间迅速增长，那么cpu将被io占用，系统会卡死，导致不能对外提供服务；因此系统提供一个参数，用于设置当进行内存回收时，执行回收cache和swap匿名页的，这个参数为:
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/<span class="keyword">proc</span>/sys/vm/swappiness<span class="title"></span></div><div class="line">     The value<span class="title"> in</span> this<span class="title"> file</span> controls<span class="title"> how</span> aggressively<span class="title"> the</span> kernel<span class="title"> will</span></div><div class="line"><span class="title">     swap</span> memory<span class="title"> pages.</span> <span class="title"> Higher</span> values<span class="title"> increase</span> aggressiveness,<span class="title"> lower</span></div><div class="line"><span class="title">     values</span> decrease<span class="title"> aggressiveness.</span> <span class="title"> The</span> default<span class="title"> value</span> is 60.</div></pre></td></tr></table></figure></p>
<p>意思就是说这个值越高，越可能使用swap的方式回收内存；最大值为100；如果设为0，则尽可能使用回收cache的方式释放内存；</p>
<h1>总结</h1>
<p>这篇博客主要是写了linux内存管理相关的东西；首先是回顾了进程地址空间；其次当进程消耗大量内存而导致内存不足时，我们可以有两种方式，第一是手动回收cache；另一种是系统后台线程swapd执行内存回收工作；最后当申请的内存大于系统剩余的内存时，这时就只会产生oom，杀死进程，释放内存；从这个过程，可以看出系统为了腾出足够的内存，是多么的努力啊！！！</p>
<p>后记</p>
<blockquote>
<p>一开始决定在写最后一部分内存回收时，打算列出源码进行分析，但是发现linux内存回收比文件系统难看多了；所以暂时以分析原理为主，后面有时间，慢慢再看这块代码；</p>
</blockquote>
<blockquote>
<p>我一直很支持学计算机的朋友学习linux和c/c++，因为现在服务器几乎都是linux系统，而且经典高性能服务器软件大部分是c/c++(nginx,redis,mysql,redis,leveldb等等)写的，且跑在linux系统上；其次就是，linux暴露给外界进入的入口就是系统调用，其他语言如果想嵌入内核，就必须封装系统调用接口；而C++主要是锻炼oop思想还有泛型思想；因此，学好了linux和c/c++，再学其他软件或语言，都会轻松很多；<strong>这也就是我一直喜欢linux和c/c++的原因</strong></p>
</blockquote>
<blockquote>
<p>像这次实习接触golang语言；如果有c/c++基础，golang语法层面是很快熟悉的；然后如果了解linux系统系统调用以及内核原理，那么golang执行与系统相关的函数也会很好理解；像平时使用的网络编程，golang没有提供epoll接口，但是其实内部是有用这个epoll进行轮询的；后面要好好写写博客，聊聊golang</p>
</blockquote>
<p>还是那句话，如果有什么出错的地方，希望大家能指出来，感谢～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在实习时，听了OOM的分享之后，就对linux内核内存管理充满兴趣；但是这块知识非常庞大，没有一定积累，不敢写下，担心误人子弟；所以经过一个一段时间的积累，对内核内存有一定了解之后，今天才写下这篇博客，记录以及分享；&lt;/p&gt;
&lt;p&gt;之前也有写过linux内存管理，那篇文
    
    </summary>
    
      <category term="linux" scheme="http://luodw.cc/categories/linux/"/>
    
    
      <category term="linux" scheme="http://luodw.cc/tags/linux/"/>
    
      <category term="memory" scheme="http://luodw.cc/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>从内核源码聊聊pipe实现</title>
    <link href="http://luodw.cc/2016/08/01/pipeof/"/>
    <id>http://luodw.cc/2016/08/01/pipeof/</id>
    <published>2016-08-01T08:42:50.000Z</published>
    <updated>2017-03-16T08:51:34.133Z</updated>
    
    <content type="html"><![CDATA[<p>用linux也有两年多了，从命令，系统调用，到内核原理一路学过来，我发现我是深深喜欢上这个系统；使用起来就是一个字“爽”；当初在看linux内核原理时，对linux内核源码有种敬畏的心理，不敢涉入，主要是看不懂，直到最近实习的时候，在某次分享会上，某位老师分享了OOM机制，我很感兴趣，就去看内核代码，发现，原来我能看懂了；所以想写篇博客，分享下从内核代码分析pipe的实现；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-39310_2010129_676673.jpg" alt="厦大上弦场"></p>
<p>这部分内容说简单也很简单，说难也难，其实就是需要了解linux内核一些原理，例如系统调用嵌入内核，虚拟文件系统等等；</p>
<p>接下来，我会从以下小点介绍管道</p>
<ul>
<li>用户态管道的使用；</li>
<li>虚拟文件系统</li>
<li>内核态管道的实现原理；</li>
<li>fifo命名管道实现</li>
<li>总结；</li>
</ul>
<h1>管道的使用</h1>
<hr>
<p>一开始接触linux，相信很多人都是从命令开始；当一个命令的输出，需要作为另一个命令的输入时，我们就会使用管道来实现这个功能；例如，我们经常需要在某个文档中查找是否存在某个单词，我们就可以用如下方式:</p>
<blockquote>
<p>cat test.txt | grep 'hello'</p>
</blockquote>
<p>这行命令表示在test.txt文件中查找包含单词'hello'的句子。我们先解释下这行命令是怎么实现的；</p>
<p>我们知道终端也是一个进程，当我们输入一个命令执行时，其实是终端程序调用fork和exec产生一个子进程执行命令程序；当终端在执行这行命令时，会先解析输入的参数，当发现输入的命令行中有‘|’符号时，就会知道在命令行中包含了管道，因此，在终端程序中，</p>
<ul>
<li>会先fork出一个子进程，并执行exec将cat载入内存；</li>
<li>接着在cat程序中，用函数pipe定义出管道;</li>
<li>在定义出管道之后，再调用fork，生成一个子进程；</li>
<li>在父进程cat中关闭管道读端，将cat进程的标准输出重定向到管道的写端；</li>
<li>在子进程中将管道的写端关闭，将标准输入重定向到管道的读端，再调用exec将grep进程载入内存；</li>
<li>最后，cat的输出就可以最为grep的输入了；</li>
</ul>
<p>这里需要说明的是，父进程cat对管道的操作必须在fork之前，否则父进程cat对管道的操作会继承到子进程，这样会导致子进程无法读取父进程的数据；我们可以用一个简单的程序来模拟上述过程，为了简单起见，例子简单地将字符串从小写转为大写；程序如下:
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;stdio.h&gt;</span></div><div class="line"><span class="comment">#include&lt;stdlib.h&gt;</span></div><div class="line"><span class="comment">#include&lt;unistd.h&gt;</span></div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">  int fd[<span class="number">2</span>];</div><div class="line">  int ret=pipe(fd);<span class="regexp">//</span>创建管道</div><div class="line">  <span class="keyword">if</span> (ret==-<span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"pipe error!"</span>);</div><div class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  int pid=fork();</div><div class="line">  <span class="keyword">if</span> (pid&lt;<span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"fork error!"</span>);</div><div class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="regexp">//</span>在子进程中</div><div class="line">      close(fd[<span class="number">1</span>]);</div><div class="line">      dup2(fd[<span class="number">0</span>],STDIN_FILENO);<span class="regexp">//</span>将子进程的标准输入重定向到fd[<span class="number">0</span>]</div><div class="line">      ret=execl(<span class="string">"./toUpper"</span>,<span class="string">"toUpper"</span>, <span class="string">""</span>,NULL);<span class="regexp">//</span>执行子进程</div><div class="line">      <span class="keyword">if</span>(ret==-<span class="number">1</span>)&#123;</div><div class="line">        fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"execl error!"</span>);</div><div class="line">        <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="regexp">//</span> 以下是父进程</div><div class="line">  close(fd[<span class="number">0</span>]);</div><div class="line">  dup2(fd[<span class="number">1</span>],STDOUT_FILENO);<span class="regexp">//</span> 将父进程的标准输出重定向到fd[<span class="number">1</span>]</div><div class="line">  char buf[<span class="number">1024</span>];</div><div class="line">  int n=read(STDIN_FILENO,buf,<span class="number">1024</span>);<span class="regexp">//</span> 从标准输入读取数据</div><div class="line">  <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;</div><div class="line">    fprintf(stderr, <span class="string">"%s\n"</span>, <span class="string">"read error!"</span>);</div><div class="line">    <span class="keyword">exit</span>(-<span class="number">1</span>);</div><div class="line">  &#125;<span class="regexp">//</span> 将数据写入管道缓冲区中</div><div class="line">  write(STDOUT_FILENO, buf,n);</div><div class="line">  sleep(<span class="number">1</span>);</div><div class="line">  return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述为主程序；在主程序中通过fork函数创建出一个子进程；在父进程中关闭管道读端，将标准输出重定向到管道写端；当在父进程有数据输出到标准输出时，就可以输出到管道的缓冲区；在子进程中，关闭管道写端，将标准输入重定向到管道读端，这样子进程从标准输入读取时，就可以从管道缓冲区读取；
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">chartoUp</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (ch&gt;<span class="string">'a'</span> &amp;&amp; ch &lt;<span class="string">'z'</span>) &#123;</div><div class="line">    ch = ch - <span class="number">32</span>;</div><div class="line">  &#125;<span class="keyword">else</span> &#123;</div><div class="line">    ch = ch;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> buf[BUFSIZE];</div><div class="line">  <span class="comment">// 从标准输入读取数据，其实就是从管道缓冲区读取数据</span></div><div class="line">  <span class="keyword">int</span> n=read(STDIN_FILENO,buf,BUFSIZE);</div><div class="line">  <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, <span class="string">"read error!"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (;i&lt;n;i++)</div><div class="line">  &#123;</div><div class="line">      buf[i]=toUp(buf[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述程序为父进程调用的子程序，先从管道缓冲区读取数据，然后将每个字母转换为大写字母，最后输出到标准输出；例子很简单，当然，也可以使用C语言io库封装好的popen函数来实现上述功能;</p>
<h1>虚拟文件系统</h1>
<hr>
<p>在讲管道之前，必须先介绍下linux虚拟文件系统，否则很难说清楚在这里；虚拟文件系统是linux内核四大模块之一，我们知道linux下面everything is file。例如磁盘文件，管道，套接字，设备等等；我们都可以通过read和write函数来读取上述文件的数据；为了支持这一特性，linux引入虚拟文件系统，就是通过一层文件系统虚拟层，屏蔽不同文件系统的差异，实现相同的函数接口操作；linux支持非常多的文件系统，我们可以通过查看</p>
<blockquote>
<p>cat /proc/filesystems</p>
</blockquote>
<p>包括基于磁盘的文件ext4,ext3等，基于内存的文件系统proc,pipefs,sysfs,ramf以及tmpfs,和套接字文件系统sockfs;</p>
<p>当我们在用户态调用read函数读取一个文件描述符时，主要过程如下:</p>
<ol>
<li>首先通过软中断嵌入内核，调用系统相应服务例程sys_read,sys_read函数如下:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">asmlinkage ssize_t sys_read(unsigned int fd, <span class="keyword">char</span> __user * buf, size_t <span class="keyword">count</span>)</div><div class="line">&#123;</div><div class="line">    struct <span class="keyword">file</span> *<span class="keyword">file</span>;</div><div class="line">    ssize_t <span class="keyword">ret</span> = -EBADF;</div><div class="line">    int fput_needed;</div><div class="line">    <span class="comment">// fget_light函数从当前进程的文件描述符表中，通过文件描述符，</span></div><div class="line">    <span class="comment">//　获取file结构体</span></div><div class="line">    <span class="keyword">file</span> = fget_light(fd, &amp;fput_needed);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">file</span>) &#123;</div><div class="line">    	loff_t pos = file_pos_read(<span class="keyword">file</span>);<span class="comment">//获取读取文件的偏移量</span></div><div class="line">        <span class="keyword">ret</span> = vfs_read(<span class="keyword">file</span>, buf, <span class="keyword">count</span>, &amp;pos);<span class="comment">//调用虚拟文件系统调用层</span></div><div class="line">    	file_pos_write(<span class="keyword">file</span>, pos);<span class="comment">//　更新当前文件的偏移量</span></div><div class="line">    	fput_light(<span class="keyword">file</span>, fput_needed);<span class="comment">//　更新文件的引用计数</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">ret</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>我们可以看到sys_read服务例程的参数和系统调用read的参数是一样的，首先通过fd从当前的文件数组中获取file实例，接着获取当前的读偏移量，然后进入虚拟文件系统vfs_read调用;</p>
<ol start="2">
<li>接下来看看vf_read虚拟层调用的过程:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ssize_t vfs_read(struct <span class="keyword">file</span> *<span class="keyword">file</span>, <span class="keyword">char</span> __user *buf, size_t <span class="keyword">count</span>, loff_t *pos)</div><div class="line">&#123;</div><div class="line">	struct inode *inode = <span class="keyword">file</span>-&gt;f_dentry-&gt;d_inode;</div><div class="line">	ssize_t <span class="keyword">ret</span>;</div><div class="line"> 	<span class="keyword">if</span> (!(<span class="keyword">file</span>-&gt;f_mode &amp; FMODE_READ))</div><div class="line">    		<span class="keyword">return</span> -EBADF;</div><div class="line">  	<span class="keyword">if</span> (!<span class="keyword">file</span>-&gt;f_op || (!<span class="keyword">file</span>-&gt;f_op-&gt;<span class="keyword">read</span> &amp;&amp; !<span class="keyword">file</span>-&gt;f_op-&gt;aio_read))</div><div class="line">    		<span class="keyword">return</span> -EINVAL;</div><div class="line">  	<span class="keyword">ret</span> = locks_verify_area(FLOCK_VERIFY_READ, inode, <span class="keyword">file</span>, *pos, <span class="keyword">count</span>);</div><div class="line">  	<span class="keyword">if</span> (!<span class="keyword">ret</span>) &#123;</div><div class="line">    		<span class="keyword">ret</span> = security_file_permission (<span class="keyword">file</span>, MAY_READ);</div><div class="line">    	<span class="keyword">if</span> (!<span class="keyword">ret</span>) &#123;</div><div class="line">      		<span class="keyword">if</span> (<span class="keyword">file</span>-&gt;f_op-&gt;<span class="keyword">read</span>)</div><div class="line">        		<span class="comment">// 进入具体文件系统</span></div><div class="line">        		<span class="keyword">ret</span> = <span class="keyword">file</span>-&gt;f_op-&gt;<span class="keyword">read</span>(<span class="keyword">file</span>, buf, <span class="keyword">count</span>, pos);</div><div class="line">      		<span class="keyword">else</span></div><div class="line">        		<span class="keyword">ret</span> = do_sync_read(<span class="keyword">file</span>, buf, <span class="keyword">count</span>, pos);</div><div class="line">        	<span class="keyword">if</span> (<span class="keyword">ret</span> &gt; 0)</div><div class="line">			 dnotify_parent(<span class="keyword">file</span>-&gt;f_dentry, DN_ACCESS);</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">ret</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>在这个函数中，一开始先属性检查以及安全性检查，然后通过下面代码进入具体的文件系统</p>
<blockquote>
<p>ret = file-&gt;f_op-&gt;read(file, buf, count, pos);</p>
</blockquote>
<p>每种文件系统的file-&gt;f_op-&gt;read是不一样的，像基于磁盘的文件系统，file-&gt;f_op-&gt;read函数是先到缓存缓存获取数据，如果缓存没有数据，则到磁盘获取；基于内存的文件系统，file-&gt;f_op-&gt;read则是直接在内核缓存获取数据，而不会到磁盘获取数据;</p>
<p>所以虚拟文件系统类似于面向对象多态的实现，首先设计好接口，不同的文件系统分别实现这些接口，这样就可以调用相同的接口，实现不同的操作;</p>
<p>而这个file-&gt;f_op主要是从inode-&gt;i_fop中获得，因此对于不同的文件系统，inode也结构也是有区别的．当创建一个inode时，针对不同的文件系统需要设置不同的属性，最主要就是各种操作函数指针结构体，例如inode-&gt;i_op和inode-&gt;i_fop；这样不同的文件系统，就可以在f-&gt;f_op-&gt;read调用中，实现不同的操作.</p>
<h1>内核管道的实现</h1>
<hr>
<p>上面给出了管道简单的操作以及稍微介绍了虚拟文件系统，pipefs主要的系统调用就是pipe，read和write. 下面来分析内核是怎么实现管道的；linux下的进程的用户态地址空间都是相互独立的，因此两个进程在用户态是没法直接通信的，因为找不到彼此的存在；而内核是进程间共享的，因此进程间想通信只能通过内核作为中间人，来传达信息. 下图显示了两个进程间通过内核缓存进行通信的过程:</p>
<p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                写 |<span class="string"> 入         +-------+</span></div><div class="line">    +--------------+------------&lt;       |</div><div class="line">    |<span class="string">              </span>|<span class="string">            </span>|<span class="string"> 进程1 </span>|</div><div class="line">+---v----+         |<span class="string">            </span>|<span class="string">       </span>|</div><div class="line">|<span class="string">        </span>|<span class="string">         </span>|<span class="string">            +-------+</span></div><div class="line">|<span class="string"> 缓 存  </span>|<span class="string">     内  </span>|<span class="string">  用</span></div><div class="line">|<span class="string"> (page) </span>|<span class="string">     核  </span>|<span class="string">  户</span></div><div class="line">|<span class="string">        </span>|<span class="string">         </span>|<span class="string">  态</span></div><div class="line">+---v----+         |<span class="string">            +-------+</span></div><div class="line">    |<span class="string">              </span>|<span class="string">            </span>|<span class="string">       </span>|</div><div class="line">    |<span class="string">              </span>|<span class="string">            </span>|<span class="string"> 进程2 </span>|</div><div class="line">    +--------------+------------&gt;       |<span class="string"></span></div><div class="line">                读 |<span class="string"> 取         +-------+</span></div><div class="line">                   |</div></pre></td></tr></table></figure></p>
<p>pipe的实现就是和上述图示一样，在pipefs文件系统的inode中有一个属性</p>
<blockquote>
<p>struct pipe_inode_info	*i_pipe;</p>
</blockquote>
<p>这个结构体定义如下:</p>
<p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//pipe_fs_i.h</div><div class="line">struct pipe_inode_info &#123;</div><div class="line">    wait_queue_head_t wait<span class="comment">;</span></div><div class="line">    char *base<span class="comment">;//指向管道缓存首地址</span></div><div class="line">    unsignedint len<span class="comment">;//管道缓存使用的长度</span></div><div class="line">    unsignedint start<span class="comment">;//读缓存开始的位置</span></div><div class="line">    unsignedint readers<span class="comment">;</span></div><div class="line">    unsignedint writers<span class="comment">;</span></div><div class="line">    unsignedint waiting_writers<span class="comment">;</span></div><div class="line">    unsignedint r_counter<span class="comment">;</span></div><div class="line">    unsignedint w_counter<span class="comment">;</span></div><div class="line">    struct fasync_struct *fasync_readers<span class="comment">;</span></div><div class="line">    struct fasync_struct *fasync_writers<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个结构体定义了管道的缓存，由base指向，缓存大小为一个内存页，有如下定义</p>
<blockquote>
<p>#define PIPE_SIZE		PAGE_SIZE</p>
</blockquote>
<p>其实到现在我们大概可以猜得到管道的是实现原理，在一个进程中，向管道中写入数据时，其实就是写入这个缓存中；然后在另一个进程读取管道时，其实就是从这个缓存读取，实现进程的通信．</p>
<p>这个缓存也可以解释为什么管道是单通道的：</p>
<blockquote>
<p>因为只有一个缓存，如果是双通道，那么两个进程同时向这块缓存写数据时，这样会导致数据覆盖，即一个进程的数据被另一个进程的数据覆盖．而向套接字有读写缓存，因此套接字是双通道的．</p>
</blockquote>
<p>ok，接下来，从pipe函数开始，看看内核是如何创建管道的．pipe系统调用在内核对应的服务例程为sys_pipe，在sys_pipe函数中，接着调用do_pipe创建两个管道描述符，一个用于写，另一个用于读；我们来看下do_pipe都做了什么．</p>
<h2>do_pipe函数</h2>
<p>一开始先获得两个空file实例，一个对应管道读描述符，另一个对应管道写描述符</p>
<p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">error </span>= -ENFILE;</div><div class="line">f1 = get_empty_filp();</div><div class="line">if (!f1)</div><div class="line">	goto no_files;</div><div class="line">f2 = get_empty_filp();</div><div class="line">if (!f2)</div><div class="line">	goto close_f1;</div></pre></td></tr></table></figure></p>
<p>接着通过调用get_pipe_inode来实例化一个带有pipe属性的inode</p>
<p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">structinode* pipe_new(structinode* inode)</div><div class="line">&#123;</div><div class="line">	unsigned long <span class="built_in">page</span>;</div><div class="line">	<span class="comment">// 申请一个内存页，作为pipe的缓存</span></div><div class="line">	<span class="built_in">page</span> = __get_free_page(GFP_USER);</div><div class="line">	<span class="keyword">if</span> (!<span class="built_in">page</span>)</div><div class="line">		return NULL;</div><div class="line">	<span class="comment">// 为pipe_inode_info结构体分配内存</span></div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i\_pipe = kmalloc(sizeof(structpipe_inode\_info), GFP_KERNEL);</div><div class="line">	<span class="function"><span class="title">if</span> (!inode-&gt;</span>i_pipe)</div><div class="line">		goto fail_page;	</div><div class="line">	<span class="comment">// 初始化pipe_inode_info属性</span></div><div class="line">	init_waitqueue_head(PIPE_WAIT(*inode));</div><div class="line">	PIPE_BASE(*inode) = (char*) <span class="built_in">page</span>;</div><div class="line">	PIPE_START(*inode) = PIPE_LEN(*inode) = <span class="number">0</span>;</div><div class="line">	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = <span class="number">0</span>;</div><div class="line">	PIPE_WAITING_WRITERS(*inode) = <span class="number">0</span>;</div><div class="line">	PIPE_RCOUNTER(*inode) = PIPE_WCOUNTER(*inode) = <span class="number">1</span>;</div><div class="line">	*PIPE_FASYNC_READERS(*inode) = *PIPE_FASYNC_WRITERS(*inode) = NULL;</div><div class="line">	return inode;</div><div class="line">	fail_page:</div><div class="line">		free_page(<span class="built_in">page</span>);</div><div class="line">	return NULL;</div><div class="line">&#125;</div><div class="line"><span class="comment">//----------------------------------------------------------------</span></div><div class="line">static struct inode * get_pipe_inode(void)</div><div class="line">&#123;</div><div class="line">	<span class="comment">//　从pipefs超级块中分配一个inode</span></div><div class="line">	<span class="function"><span class="title">struct</span>	inode *inode = new_inode(pipe_mnt-&gt;</span>mnt_sb);</div><div class="line">	<span class="keyword">if</span> (!inode)</div><div class="line">		goto fail_inode;</div><div class="line">	<span class="comment">// pipe_new函数主要用来为这个inode初始化pipe属性，就是pipe_inode_info结构体</span></div><div class="line">	<span class="keyword">if</span>(!pipe_new(inode))</div><div class="line">		goto fail_iput;</div><div class="line">	PIPE_READERS(*inode) = PIPE_WRITERS(*inode) = <span class="number">1</span>;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_fop = &amp;rdwr_pipe_fops;<span class="comment">//设置pipefs的inode操作函数集合，rdwr_pipe_fops</span></div><div class="line">	<span class="comment">// 为结构体，包含读写管道所有操作</span></div><div class="line"></div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_state = I_DIRTY;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_mode = S_IFIFO | S_IRUSR | S_IWUSR;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span><span class="function"><span class="title">i_uid</span> = current-&gt;</span>fsuid;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span><span class="function"><span class="title">i_gid</span> = current-&gt;</span>fsgid;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span><span class="function"><span class="title">i_atime</span> = inode-&gt;</span><span class="function"><span class="title">i_mtime</span> = inode-&gt;</span>i_ctime = CURRENT_TIME;</div><div class="line">	<span class="function"><span class="title">inode</span>-&gt;</span>i_blksize = PAGE_SIZE</div><div class="line">	return inode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，在当前进程的files_struct结构中获取两个空的文件描述符，分别存储在i和j</p>
<p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">error </span>= get_unused_fd();</div><div class="line">if (error &lt; 0)</div><div class="line">	goto close_f12_inode;</div><div class="line">i = error;</div><div class="line"><span class="keyword">error </span>= get_unused_fd();</div><div class="line">if (error &lt; 0)</div><div class="line">	goto close_f12_inode_i;</div><div class="line">j = error;</div></pre></td></tr></table></figure></p>
<p>下一步就是为这个inode分配dentry目录项，dentry主要用于将file和inode连接起来,以及设置f1和f2的vfsmnt,dentry,mapping属性</p>
<p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">sprintf</span>(<span class="keyword">name</span>, "[%lu]", inode-&gt;</span>i_ino);</div><div class="line">this.<span class="keyword">name</span> = <span class="keyword">name</span>;</div><div class="line">this.len = strlen(<span class="keyword">name</span>);</div><div class="line"><span class="function"><span class="title">this</span>.hash = inode-&gt;</span>i_ino; <span class="comment">/* will go */</span></div><div class="line"><span class="function"><span class="title">dentry</span> = d_alloc(pipe_mnt-&gt;</span><span class="function"><span class="title">mnt_sb</span>-&gt;</span>s_root, &amp;this);</div><div class="line"><span class="keyword">if</span> (!dentry)</div><div class="line">	goto close_f12_inode_i_j;</div><div class="line"><span class="function"><span class="title">dentry</span>-&gt;</span>d\_op = &amp;pipefs_dentry_operations;</div><div class="line">d_add(dentry, inode);</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_vfsmnt = f2-&gt;</span>f\_vfsmnt = mntget(mntget(pipe_mnt));</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_dentry = f2-&gt;</span>f_dentry = dget(dentry);</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_mapping = f2-&gt;</span><span class="function"><span class="title">f</span>\_mapping = inode-&gt;</span>i_mapping;</div></pre></td></tr></table></figure></p>
<p>最后，针对读写file实例设置不同的属性，并且将两个fd和两个file实例关联起来</p>
<p><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* read file */</span></div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span><span class="function"><span class="title">f</span>\_pos = f2-&gt;</span>f_pos = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f\_flags = O_RDONLY;<span class="comment">//f1这个file实例只可读</span></div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f\_op = &amp;read_pipe_fops;<span class="comment">//这是这个可读file的操作函数集合结构体</span></div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f\_mode = FMODE_READ;</div><div class="line"><span class="function"><span class="title">f1</span>-&gt;</span>f_version = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/* write file */</span></div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_flags = O_WRONLY;<span class="comment">//f2这个file实例只可写</span></div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_op = &amp;write_pipe_fops;<span class="comment">//这是这个只可写的file操作函数集合结构体</span></div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_mode = FMODE_WRITE;</div><div class="line"><span class="function"><span class="title">f2</span>-&gt;</span>f_version = <span class="number">0</span>;</div><div class="line"></div><div class="line">fd_install(i, f1);<span class="comment">//将i(fd)和f1(file)关联起来</span></div><div class="line">fd_install(j, f2);<span class="comment">// 将j(fd)和f2(file)关联起来</span></div><div class="line">fd[<span class="number">0</span>] = i;</div><div class="line">fd[<span class="number">1</span>] = j;</div><div class="line">return <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>到这里，do_pipe函数就算结束了，并且用i和j文件描述符填充了fd[2]数组，最后在sys_pipe函数中通过copy_to_user将fd[2]数组返回给用户程序；</p>
<p>总结下do_pipe函数的执行过程:</p>
<ol>
<li>实例化两个空file结构体；</li>
<li>创建带有pipe属性的inode结构；</li>
<li>在当前进程文件描述符表中找出两个未使用的文件描述符;</li>
<li>为这个inode分配dentry结构体，关联file和inode;</li>
<li>针对可读和可写file结构，分别设置相应属性，主要是操作函数集合属性；</li>
<li>关联文件描述符和file结构</li>
<li>将两个文件描述符返回给用户;</li>
</ol>
<h2>pipe读操作</h2>
<p>当通过pipe函数获取到两个文件描述符，即可使用read和write函数分别对这两个描述符进行读写;我们先来看下read操作;</p>
<p>有之前虚拟文件系统知道，当用户态调用read函数时，对应于内核态sys_read，然后在sys_read函数中调用vfs_read函数，在vfs_read函数中调用file-&gt;f_op-&gt;read，由上述do_pipe函数可以知道，pipefs的read(file)实例对应的file-&gt;f_op为read_pipe_fpos，这个read_pipe_fpos结构体定义如下:</p>
<p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct file_operations read_pipe_fops = &#123;</div><div class="line">	<span class="selector-class">.llseek</span>		= no_llseek,</div><div class="line">	<span class="selector-class">.read</span>		= pipe_read,</div><div class="line">	<span class="selector-class">.readv</span>		= pipe_readv,</div><div class="line">	<span class="selector-class">.write</span>		= bad_pipe_w,</div><div class="line">	<span class="selector-class">.poll</span>		= pipe_poll,</div><div class="line">	<span class="selector-class">.ioctl</span>		= pipe_ioctl,</div><div class="line">	<span class="selector-class">.open</span>		= pipe_read_open,</div><div class="line">	<span class="selector-class">.release</span>	= pipe_read_release,</div><div class="line">	<span class="selector-class">.fasync</span>		= pipe_read_fasync,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此，在vfs_read函数中调用的(pipe)file-&gt;f_op-&gt;read即为pipe_read函数，这个函数定义在fs/pipe.c文件中,</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t</span></div><div class="line"><span class="title">pipe_read</span><span class="params">(structfile *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></div><div class="line">&#123;</div><div class="line">  structiovec iov = &amp;#<span class="number">123</span>; .iov\_base = buf, .iov_len = count &amp;#<span class="number">125</span>;;</div><div class="line">  <span class="keyword">return</span> pipe_readv(filp, &amp;iov, <span class="number">1</span>, ppos);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>pipe_read函数将用户程序的接收数据缓冲区和大小转换为iovec结构，然后调用pipe_readv函数从缓冲区获取数据;在pipe_readv函数中，最主要部分如下:</p>
<p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">intsize = PIPE_LEN(*inode);</div><div class="line"><span class="built_in">if</span> (<span class="built_in">size</span>) &#123;</div><div class="line">  <span class="comment">// 获取管道缓冲区读首地址</span></div><div class="line">  <span class="keyword">char</span> *pipebuf = PIPE_BASE(*inode) + PIPE_START(*inode);</div><div class="line">  <span class="comment">// 缓冲区可读最大值=PIPE\_SIZE - PIPE\_START(inode)</span></div><div class="line">  ssize_t chars = PIPE_MAX_RCHUNK(*inode);</div><div class="line"></div><div class="line">  <span class="comment">// 下面两个if语句用于比较缓冲区可读最大值，缓冲区数据长度以及</span></div><div class="line">  <span class="comment">// 用户态缓冲区的长度，取最小值</span></div><div class="line">  <span class="built_in">if</span> (chars &gt; total_len)</div><div class="line">  	chars = total_len;</div><div class="line">  <span class="built_in">if</span> (chars &gt; <span class="built_in">size</span>)</div><div class="line">  	chars = <span class="built_in">size</span>;</div><div class="line">  <span class="comment">// 调用如下函数把数据拷贝到用户态</span></div><div class="line">  <span class="built_in">if</span> (pipe_iov_copy_to_user(iov, pipebuf, chars)) &#123;</div><div class="line">    <span class="built_in">if</span> (!ret) ret = -EFAULT;</div><div class="line">      <span class="built_in">break</span>;</div><div class="line">  &#125;</div><div class="line">  ret += chars;</div><div class="line">  <span class="comment">// 更新缓冲区读首地址</span></div><div class="line">  PIPE_START(*inode) += chars;</div><div class="line">  <span class="comment">// 对缓冲区长度取模</span></div><div class="line">  PIPE_START(*inode) &amp;= (PIPE_SIZE - <span class="number">1</span>);</div><div class="line">  <span class="comment">// 更新缓冲区数据长度</span></div><div class="line">  PIPE_LEN(*inode) -= chars;</div><div class="line">  <span class="comment">// 更新用户态缓冲区长度</span></div><div class="line">  total_len -= chars;</div><div class="line">  do_wakeup = <span class="number">1</span>;</div><div class="line">  <span class="built_in">if</span> (!total_len)</div><div class="line">    <span class="built_in">break</span>;	<span class="comment">/* 如果用户态缓冲区已满，则读取成功 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码是在一个循环中，直到用户态缓冲区已满，或者管道缓冲区全部数据读取完毕；当然这还涉及到如果缓冲区为空，则当前进程阻塞(切换到其他进程)等等；我们来看下pipe_iov_copy_to_user函数</p>
<p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static inline int</div><div class="line">pipe_iov_copy_to_user(struct iovec *iov, constvoid *<span class="keyword">from</span>, unsignedlong len)</div><div class="line">&#123;</div><div class="line">    unsignedlongcopy;</div><div class="line"></div><div class="line">    while (len &gt; <span class="number">0</span>) &#123;</div><div class="line">      while (!iov-&gt;iov_len)</div><div class="line">      	iov++;</div><div class="line">      <span class="keyword">copy</span><span class="bash"> = min_t(unsignedlong, len, iov-&gt;iov_len);</span></div><div class="line"></div><div class="line">      if (copy_to_user(iov-&gt;iov_base, <span class="keyword">from</span>, <span class="keyword">copy</span><span class="bash">))</span></div><div class="line">          return -EFAULT;</div><div class="line">      <span class="keyword">from</span> += <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">      len -= <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">      iov-&gt;iov_base += <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">      iov-&gt;iov_len -= <span class="keyword">copy</span><span class="bash">;</span></div><div class="line">    &#125;</div><div class="line">    return0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数很简单，其实就是在一个循环中，将缓冲区中数据通过copy_to_user函数写到用户态空间缓冲区中。最后在用户态read函数返回之后，即可在缓冲区中读取到管道中数据。</p>
<p>pipe的写过程其实就是和read的过程相反，首先也是通过系统调用嵌入内核write-&gt;sys_write-&gt;vfs_write,在vfs_write函数中调用file-&gt;f_op-&gt;write函数，而这个函数对应管道写file实例的pipe_write函数。后面的过程就是将用户态缓冲区的数据拷贝到内核管道缓冲区，不再叙述；</p>
<h1>fifo命名管道的实现</h1>
<hr>
<p>因为pipe只能用在两个有亲缘关系的进程上，例如父子进程；如果要在两个没有关系的进程上用管道通信时，这时pipe就派不上用场了。我们可以思考一个问题，如何让两个不相干的进程找到带有pipe属性的inode了？我们自然就想到利用磁盘文件。因为linux下两个进程访问同一个文件时，虽然各自的file是不一样的，但是都是指向同一个inode节点。所以将pipe和磁盘文件结合，就产生了fifo命名管道；</p>
<p>fifo的实现原理和pipe一样，我们可以看下fifo和pipe的read函数操作集合:</p>
<p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//read_fifo_fpos</span></div><div class="line">struct file_operations read_fifo_fops = &#123;</div><div class="line">	<span class="selector-class">.read</span>		= pipe_read,</div><div class="line">	<span class="selector-class">.readv</span>		= pipe_readv,</div><div class="line">	<span class="selector-class">.write</span>		= bad_pipe_w,</div><div class="line">	<span class="selector-class">.poll</span>		= fifo_poll,</div><div class="line">	<span class="selector-class">.ioctl</span>		= pipe_ioctl,</div><div class="line">	<span class="selector-class">.open</span>		= pipe_read_open,</div><div class="line">	<span class="selector-class">.release</span>	= pipe_read_release,</div><div class="line">	<span class="selector-class">.fasync</span>		= pipe_read_fasync,</div><div class="line">&#125;</div><div class="line"><span class="comment">// read_pipe_fops</span></div><div class="line">struct file_operations read_pipe_fops = &#123;</div><div class="line">	<span class="selector-class">.llseek</span>		= no_llseek,</div><div class="line">	<span class="selector-class">.read</span>		= pipe_read,</div><div class="line">	<span class="selector-class">.readv</span>		= pipe_readv,</div><div class="line">	<span class="selector-class">.write</span>		= bad_pipe_w,</div><div class="line">	<span class="selector-class">.poll</span>		= pipe_poll,</div><div class="line">	<span class="selector-class">.ioctl</span>		= pipe_ioctl,</div><div class="line">	<span class="selector-class">.open</span>		= pipe_read_open,</div><div class="line">	<span class="selector-class">.release</span>	= pipe_read_release,</div><div class="line">	<span class="selector-class">.fasync</span>		= pipe_read_fasync,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出来，二者操作函数一样，说明对fifo的读写操作也是对管道缓冲区进行读写；唯一不同点是轮询函数，其实fifo_poll和pipe_poll也是一样的</p>
<blockquote>
<p>#define fifo_poll pipe_poll</p>
</blockquote>
<p>而fifo创建的文件只是让读写进程能找到相同的inode，进而操作相同的pipe缓冲区。</p>
<h1>总结</h1>
<hr>
<p>这篇文章，主要从内核代码介绍了pipe的实现，总结一点就是两个进程对同一块内存的操作，和进程内部多个线程操作同一个块内存类似。我这只是简单的说明pipe的实现原理，当然，实际上还有许多内容，例如管道阻塞和非阻塞，管道轮询等等。此外还介绍了fifo命名管道的实现原理。</p>
<p>在准备写这篇文章时，我也看了些关于文件系统的资料以及内核其他文件系统的代码，我加深了对linux虚拟文件系统的实现机理。</p>
<p>接下来文章，要开始分析了golang的底层实现了，因为在使用过程中，发现golang是一门非常好用的系统级语言，越来越多的公司引入了golang语言进行项目开发，知其然而不知所以然是一件很痛苦的事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用linux也有两年多了，从命令，系统调用，到内核原理一路学过来，我发现我是深深喜欢上这个系统；使用起来就是一个字“爽”；当初在看linux内核原理时，对linux内核源码有种敬畏的心理，不敢涉入，主要是看不懂，直到最近实习的时候，在某次分享会上，某位老师分享了OOM机制，
    
    </summary>
    
      <category term="pipe" scheme="http://luodw.cc/categories/pipe/"/>
    
    
      <category term="pipe" scheme="http://luodw.cc/tags/pipe/"/>
    
  </entry>
  
  <entry>
    <title>不忘初心，重新认识hello world</title>
    <link href="http://luodw.cc/2016/07/02/helloworld/"/>
    <id>http://luodw.cc/2016/07/02/helloworld/</id>
    <published>2016-07-02T01:38:49.000Z</published>
    <updated>2017-03-16T08:51:34.125Z</updated>
    
    <content type="html"><![CDATA[<p>对于程序员来说，hello world的含义，可能并不只是一句简单的打招呼，更多的是学习一门编程语言的第一个示例．和编程接触了这么多年，如果要学习一门编程语言，我也会情不自禁地敲下hello world程序，看下程序的的输出．如今回过头的来重新看hello world，就会发现hello world背后隐藏的许多秘密；</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-fpic1574.jpg" alt="首页显示"></p>
<p>路走的远了，就需要不断回头审视自己来时的路，以及眺望未来之路，不忘初心，重新(心)出发．所以才有了这篇文章，好好窥探hello world的秘密；</p>
<p>这篇文章主要分为以下几块，</p>
<ol>
<li>什么是程序？</li>
<li>代码如何转换为二进制?</li>
<li>程序是怎么装载进内存？</li>
<li>进程是怎么执行的?</li>
<li>进程怎么退出?</li>
</ol>
<p>其实就是hello world的一生；都是我自己的理解，有误的地方，希望看者能提出来，互相进步；这里就是做个引子，介绍下，希望可以帮助大家更好的理解进程的运行,如果想深入学习，需要看相关书籍；</p>
<h1>什么是程序</h1>
<hr>
<p>很多时候，人们会把程序和进程的概念弄混了，其实可以这么理解，程序是一堆无生命的二进制代码，而这些二进制代码被读取进内存，跑起来之后，就是进程了；也就是说，程序是躺在磁盘里无生命活力的二进制代码，而进程是在内存中有生命活力的二进制代码；ok，我写个hello world程序hello.c，作为例子:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这剪短的代码，有没很熟悉？如果有种很熟悉的感觉，那恭喜你，你肯定也是个程序员(不用回头，没错，就是你!!!)． 这段代码很简单，就是简单的输出一句&quot;hello world&quot;就退出了．按我的理解，这其实还不能算是程序，可以称呼为代码；我理解的是程序应该是能被操作系统认识理解，运行的代码．而操作系统只能认识二进制的东西，所以像我们编写的C/C++,JAVA,GO等等代码，最后都要被转换为二进制的代码，才能够执行；</p>
<h1>代码如何转换为二进制</h1>
<hr>
<p>紧接着上述的话题，当我们写好一段代码之后，如果将其转换为二进制了?这就是我们默默无闻的编译器了．为什么说默默无闻了?因为编译器做着非常重要的工作，但是又有多少人真正打开编译器的心扉，好好认识编译器？(当然包括我，羞愧低下了头!!!)．编译C代码分为几个步奏，有技术背景应该听过，预处理，编译，汇编，链接；</p>
<p>预处理阶段为:</p>
<blockquote>
<p>gcc -E hello.c -o hello.i</p>
</blockquote>
<p>我们可以打开hello.i看看，里面的头文件stdio.h已经被展开了，包括一些类型定义函数定义等等，截取片段如下:
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __socklen_t;</div><div class="line"><span class="meta"># 36 <span class="meta-string">"/usr/include/stdio.h"</span> 2 3 4</span></div><div class="line"><span class="meta"># 44 <span class="meta-string">"/usr/include/stdio.h"</span> 3 4</span></div><div class="line"><span class="keyword">struct</span> _IO_FILE;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IO_FILE FILE;</div></pre></td></tr></table></figure></p>
<p>从这个片段，我们可以看出来了，我们平时引用的stdio.h文件存在与/usr/include/stdio.h，所以想研究stdio.h的朋友，可以打开看看；这个代码片段很重要的还有FILE的定义，这就是我们用c语言打开一个文件返回的句柄结构，所以想理解C语言中缓冲流是怎么实现的，可以先看看_IO_FILE结构体中io流缓冲区的定义，再结合代码即可理解；</p>
<p>预处理之后，接下来，就需要将这些代码编译成汇编代码:</p>
<blockquote>
<p>gcc -S hello.i -o hello.s</p>
</blockquote>
<p>这个过程，就是将上述的代码转换为汇编代码，其实就是一条条汇编指令，这个过程是c代码转换为二进制最为重要的过程，也是最复杂的过程；我们可以打开hello.s看看内部的东东
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line"><span class="symbol">.LFB0:</span></div><div class="line"><span class="meta">        .cfi_startproc</span></div><div class="line">        pushq   %rbp</div><div class="line"><span class="meta">        .cfi_def_cfa_offset</span> <span class="number">16</span></div><div class="line"><span class="meta">        .cfi_offset</span> <span class="number">6</span>, -<span class="number">16</span></div><div class="line">        <span class="keyword">movq</span>    %rsp, %rbp</div><div class="line"><span class="meta">        .cfi_def_cfa_register</span> <span class="number">6</span></div><div class="line">        movl    $.LC0, %edi</div><div class="line">        <span class="keyword">call</span>    puts</div></pre></td></tr></table></figure></p>
<p>这就是汇编指令，但是直接打开hello.s看，显示不是很友好，我们可以用objdump或者gdb的反汇编指令打开obj文件，如下:
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~$ objdump -d hello.o</div><div class="line"></div><div class="line">hello.o：     文件格式 elf64-x86-<span class="number">64</span></div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</div><div class="line">   <span class="number">0</span>:	<span class="number">55</span>                   	<span class="keyword">push</span>   %rbp</div><div class="line">   <span class="number">1</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</div><div class="line">   <span class="number">4</span>:	bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $0<span class="keyword">x</span><span class="number">0</span>,%edi</div><div class="line">   <span class="number">9</span>:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  e &lt;main+<span class="number">0xe</span>&gt;</div><div class="line">   e:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $0<span class="keyword">x</span><span class="number">0</span>,%eax</div><div class="line">  <span class="number">13</span>:	<span class="number">5</span>d                   	<span class="keyword">pop</span>    %rbp</div><div class="line">  <span class="number">14</span>:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>这样看是不是好很多了．学习汇编，重要的不是说还让你去写汇编代码(当然有些C代码是有嵌入汇编的，例如内存屏障),而是让我们能看懂汇编代码．那有人又会问，看懂汇编代码有什么用？我最深的体会就是可以从汇编代码看懂函数栈的调用过程，我很早也有写过<a href="http://luodw.cc/2015/10/07/gdb/">用gdb反汇编理解c函数栈调用过程</a>，还有就是理解底层ABI的一些东西，例如系统调用嵌入内核时，参数是存在哪些寄存器，然后从内核内核返回用户态时，返回值是存在哪个寄存器(rax)等等；如果你还有问知道这些有什么用，我只能问你，为什么来学计算机？</p>
<p>ok，编译结束之后，接下来就是将汇编代码转换为目标文件：</p>
<blockquote>
<p>gcc -c hello.s -o hello.o</p>
</blockquote>
<p>目标文件已经是二进制代码了，这个hello.o也是之前用objdump打开查看汇编代码的文件；二进制代码是不能用文本编辑器打开查看的，可以试着用vim打开hello.o，可以看到一对乱码，可能会有几个看得懂的字符；我们可以用od -c　hello.o命令看二进制所对应的每个字符．
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~$ od -c hello.o</div><div class="line"><span class="number">0000000</span> <span class="number">177</span>   E   L   F <span class="number">002</span> <span class="number">001</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000020</span> <span class="number">001</span>  <span class="string">\0</span>   &gt;  <span class="string">\0</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000040</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   <span class="number">0</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000060</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   @  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   @  <span class="string">\0</span>  <span class="string">\r</span>  <span class="string">\0</span>  <span class="string">\n</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000100</span>   U   H <span class="number">211</span> <span class="number">345</span> <span class="number">277</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">350</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">270</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000120</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>   ] <span class="number">303</span>   h   e   l   l   o       w   o   r   l   d</div><div class="line"><span class="number">0000140</span>   !  <span class="string">\0</span>  <span class="string">\0</span>   G   C   C   :       (   U   b   u   n   t   u    </div><div class="line"><span class="number">0000160</span>   <span class="number">4</span>   .   <span class="number">8</span>   .   <span class="number">4</span>   -   <span class="number">2</span>   u   b   u   n   t   u   <span class="number">1</span>   ~   <span class="number">1</span></div><div class="line"><span class="number">0000200</span>   <span class="number">4</span>   .   <span class="number">0</span>   <span class="number">4</span>   .   <span class="number">3</span>   )       <span class="number">4</span>   .   <span class="number">8</span>   .   <span class="number">4</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div><div class="line"><span class="number">0000220</span> <span class="number">024</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">001</span>   z   R  <span class="string">\0</span> <span class="number">001</span>   x <span class="number">020</span> <span class="number">001</span></div><div class="line"><span class="number">0000240</span> <span class="number">033</span>  <span class="string">\f</span>  <span class="string">\a</span>  <span class="string">\b</span> <span class="number">220</span> <span class="number">001</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">034</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span> <span class="number">034</span>  <span class="string">\0</span>  <span class="string">\0</span>  <span class="string">\0</span></div></pre></td></tr></table></figure></p>
<p>编译成目标文件之后，最后一步就是链接，生成可执行的目标文件．二进制代码文件有分为可重定向文件，可执行文件和可共享文件．一般情况下，hello.o是可重定向文件，多个.o文件链接在一起，就可以生成可执行文件；静态链接库和动态链接库为可共享的二进制代码．</p>
<p>在这个例子中，只有一个文件，所以就直接生成可执行文件就好了</p>
<blockquote>
<p>gcc hello.o -o hello</p>
</blockquote>
<p>此时就生成了可执行的程序；在linux下，可执行的程序属于ELF文件，可以使用file命令查看文件类型．这时还没有进程，还只是程序而已；之前看到有些问题，如&quot;进程的的静态区是什么时候分配的，有些回答是编译时&quot;．我当时就醉了，编译的时候还没进程，哪来的内存；正确是编译时决定内存的如何分配，但是真正分配还是在进程跑起来之后．</p>
<h1>程序是如何装载进内存</h1>
<hr>
<p>ok，到这为止，一个程序就已经准备好了，我们很习惯就会输出以下命令执行程序</p>
<blockquote>
<p>./hello</p>
</blockquote>
<p>就这么简短的一个运行命令，里面就有非常多的学问，涉及到程序的装载，操作系统内存分配，进程调度；在接下去讲进程装载时，有必要介绍下hello这个可执行文件的布局；很多人应该有听过进程的代码段，数据段，bbs，堆，栈等；相应的，在可执行文件中，也有代码段，数据段，bbs；而堆和栈在elf文件中没有相应的项，他俩属于匿名映射；当然elf文件不止之前说的三个段，还有很多，我们可以用readelf命令来查看elf文件中含有的sections:
<figure class="highlight tap"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">charles@charles-Lenovo:~$ readelf -S hello</div><div class="line">共有<span class="number"> 30 </span>个节头，从偏移量 0x1178 开始：</div><div class="line"></div><div class="line">节头：</div><div class="line">  [Nr] Name              Type             Address           Offset</div><div class="line">       Size              EntSize          Flags  Link  Info  Align</div><div class="line">  [ 0]                   NULL            <span class="number"> 0000000000000000 </span> 00000000</div><div class="line">      <span class="number"> 0000000000000000 </span><span class="number"> 0000000000000000 </span>         <span class="number"> 0 </span>   <span class="number"> 0 </span>    0</div><div class="line">  [ 1] .interp           PROGBITS        <span class="number"> 0000000000400238 </span> 00000238</div><div class="line">       000000000000001c <span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    1</div><div class="line">  [ 2] .note.ABI-tag     NOTE            <span class="number"> 0000000000400254 </span> 00000254</div><div class="line">      <span class="number"> 0000000000000020 </span><span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    4</div><div class="line">  [ 3] .note.gnu.build-i NOTE            <span class="number"> 0000000000400274 </span> 00000274</div><div class="line">      <span class="number"> 0000000000000024 </span><span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    4</div><div class="line">  [ 4] .gnu.hash         GNU_HASH        <span class="number"> 0000000000400298 </span> 00000298</div><div class="line">       000000000000001c <span class="number"> 0000000000000000 </span>  A      <span class="number"> 5 </span>   <span class="number"> 0 </span>    8</div><div class="line">  [ 5] .dynsym           DYNSYM           00000000004002b8  000002b8</div><div class="line">      <span class="number"> 0000000000000060 </span><span class="number"> 0000000000000018 </span>  A      <span class="number"> 6 </span>   <span class="number"> 1 </span>    8</div><div class="line">  [ 6] .dynstr           STRTAB          <span class="number"> 0000000000400318 </span> 00000318</div><div class="line">       000000000000003d <span class="number"> 0000000000000000 </span>  A      <span class="number"> 0 </span>   <span class="number"> 0 </span>    1</div><div class="line">  [ 7] .gnu.version      VERSYM          <span class="number"> 0000000000400356 </span> 00000356</div><div class="line">      <span class="number"> 0000000000000008 </span><span class="number"> 0000000000000002 </span>  A      <span class="number"> 5 </span>   <span class="number"> 0 </span>    2</div><div class="line">  [ 8] .gnu.version_r    VERNEED         <span class="number"> 0000000000400360 </span> 00000360</div><div class="line">      <span class="number"> 0000000000000020 </span><span class="number"> 0000000000000000 </span>  A      <span class="number"> 6 </span>   <span class="number"> 1 </span>    8</div></pre></td></tr></table></figure></p>
<p>太长了，我就截取这部分sections．在这么多sections，很多我们并不知道他们有什么用，但是有几个setcion我们是必须了解的，因为在理解静态链接库和动态链接库时，需要他们；例如header,.symtab,.rel.text,.rel.data,.dynamic等等；rela.txt和rela.data一般是在可重定向文件才会有，链接生成的可执行文件一般是没有的；但是因为很多section的读写权限是一样的，所以在装载进内存时，这些sections会合并成一个segment，例如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-linux_process_address_space_03.png" alt="进程地址空间和elf文件的映射"></p>
<p>图片取自,<strong>程序员的自我修养</strong>从这幅图可以看出，进程的地址空间的一个段，就相当于elf文件中多个sections；所以我们看到的代码段，并不只是代码，还有可能是字符串常量或者一些常量，因为这些都是可读不可写的，所以可以合并在代码段中．</p>
<p>ok，理解上面所说之后，接着可以说说进程是如何被载入内存了．因为终端也是一个程序，所以当我们在终端输入</p>
<blockquote>
<p>./hello</p>
</blockquote>
<p>这时，终端会调用fork创建一个子进程，fork函数是一个系统调用，这时会嵌入内核，调用的是clone函数，这个clone函数接着会调用do_fork函数，这个函数做了大部分创建工作，例如创建task_struct，内核栈，thread_info等结构，因为fork函数是采用写时复制技术，因此此时子进程task_struct大部分的属性还是和父进程task_struct一样，主要就是没有为子进程开辟内存空间；当子进程内核结构创建好之后，这时进程调度系统会优先调度子进程，因为一般情况下，子进程会直接调用exec函数避免写时拷贝开销．</p>
<blockquote>
<p>这里提下，一次fork调用为什么会返回两个值；因为当fork在内核调用成功，要返回用户态时，如果此时调度子进程执行，那么会把0放入rax寄存器中，等fork返回用户态执行子进程时，从rax得到的就是0；当内核调度的是父进程时，这时会把子进程的id号放入rax寄存器中，等返回到用户态执行父进程时，此时从rax获得的就是子进程的id号；</p>
</blockquote>
<p>到这里，还是只是创建了子进程内核的一些结构，接下来，在终端fork的子进程中，会调用exec系列函数</p>
<blockquote>
<p>execl(&quot;./hello&quot;,&quot;hello&quot;,&quot;&quot;,NULL);</p>
</blockquote>
<p>这个函数会会为子进程hello单独开辟一块内存(之前是和父进程共用内存空间)，其实最主要就是为mm_struct结构以及页表重新赋值；具体怎么做了，最主要是调用mmap函数；我们可以把上述图的左边看成是躺在磁盘中的可执行文件，右边对应的是进程在内存中布局；当内核要将可执行文件的代码段映射到进程空间时，内核会先把code segment读取进内核的cache中，然后给hello进程的code段分配一块vma虚拟内存，并把这块虚拟内存映射到在cache中code segment，并把这块vma放入mm_struct的红黑树和链表中．链表适合当需要遍历所有vma内存区域时，而红黑树适合快速获取某个特定内存区域；我们经常查看/proc/&lt;pid&gt;/maps某个进程的内存布局，其实就是便利这个进程的vma链表即可．</p>
<p>数据段也是采用同样的方式载入．但是堆和栈不是采用这种方式，因为他俩在elf文件中没有相应的栈，所以他俩是通过mmap匿名映射的方式分配内存，同时也加入到mm_struct中vma链表和红黑树结构中．</p>
<p>下面这张图更好说明了用户进程空间:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_015.png" alt="进程用户态控空间"></p>
<p>到目前为止，内核已经为hello这个子进程创建了内核task_struct结构，内核栈，thread_info以及用户空间内存结构．按理说应该开始执行程序了吧，但是并没有；在真正执行hello程序之前，首先会把权限交给动态链接器，也就是我们在输出/proc/&lt;pid&gt;/maps的时候，看到的</p>
<blockquote>
<p>/lib/x86_64-linux-gnu/ld-2.19.so</p>
</blockquote>
<p>这个链接器会把hello这个程序中用到的动态链接库载入用户空间的共享存储区，采用的方法也是内存映射，也会为这些动态链接库生成一个vma结构，放入mm_struct中vma链表和红黑树中．hello这个进程用的最主要就是C运行时库，</p>
<blockquote>
<p>/lib/x86_64-linux-gnu/libc-2.19.so</p>
</blockquote>
<p>我还是输出hello这个进程的内存结构吧
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">root@charles-<span class="symbol">Lenovo:</span>/home/charles<span class="comment"># cat /proc/1658/maps</span></div><div class="line"><span class="number">00400000</span>-<span class="number">00401000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">09</span> <span class="number">130893</span>                             /home/charles/hello</div><div class="line"><span class="number">00600000</span>-<span class="number">00601000</span> r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">09</span> <span class="number">130893</span>                             /home/charles/hello</div><div class="line"><span class="number">00601000</span>-<span class="number">00602000</span> rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">09</span> <span class="number">130893</span>                             /home/charles/hello</div><div class="line"><span class="number">7</span>f1a47bc6000-<span class="number">7</span>f1a47d80000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47d80000-<span class="number">7</span>f1a47f80000 ---p <span class="number">001</span>ba000 <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47f80000-<span class="number">7</span>f1a47f84000 r--p <span class="number">001</span>ba000 <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47f84000-<span class="number">7</span>f1a47f86000 rw-p <span class="number">001</span>be000 <span class="number">08</span>:<span class="number">06</span> <span class="number">28902</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">libc</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a47f86000-<span class="number">7</span>f1a47f8b000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>f1a47f8b000-<span class="number">7</span>f1a47fae000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28893</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">ld</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a4818d000-<span class="number">7</span>f1a48190000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>f1a481aa000-<span class="number">7</span>f1a481ad000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>f1a481ad000-<span class="number">7</span>f1a481ae000 r--p <span class="number">00022000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28893</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">ld</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a481ae000-<span class="number">7</span>f1a481af000 rw-p <span class="number">00023000</span> <span class="number">08</span>:<span class="number">06</span> <span class="number">28893</span>                      /<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span>/<span class="title">ld</span>-2.19.<span class="title">so</span></span></div><div class="line"><span class="number">7</span>f1a481af000-<span class="number">7</span>f1a481b0000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line"><span class="number">7</span>fff82079000-<span class="number">7</span>fff8209a000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [stack]</div><div class="line"><span class="number">7</span>fff820ed000-<span class="number">7</span>fff820ef000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</div><div class="line"><span class="number">7</span>fff820ef000-<span class="number">7</span>fff820f1000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vvar]</div><div class="line">ffffffffff600000-ffffffffff601000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</div></pre></td></tr></table></figure></p>
<p>这些vma段和上述图片是一样的，图片看得更形象；hello这个进程没有堆结构，因为进程运行过程中，并没有申请堆内存．ok，当动态链接库也转载进内存之后，就把控制权交给hello进程执行．</p>
<h1>进程是如何执行的?</h1>
<hr>
<p>进程的执行其实就是cpu获取指令以及数据，并进行计算，这里cpu各个寄存器的使用和虚拟内存与物理内存转换等等；而hello这个进程非常简单，就是调用C库函数printf输出一句话．但是其中涉及的过程还是相当复杂的．</p>
<p>首先当执行到printf时，因为hello.c中没有定义这个函数，所以进程会去C库的动态链接库查找，当找到printf之后，进程会跳转到printf函数执行；在printf函数内部，会执行系统调用</p>
<blockquote>
<p>write(1, &quot;hello world!\n&quot;, 13)</p>
</blockquote>
<p>其中1是STDOUT_FILENO表示标准输，对应的就是输出到显示器；到这里，我们可以聊聊系统调用；当执行这个write函数时，因为write是个系统调用，在执行这个write之前，会将参数放入寄存器中，例如1放在rdi,＂hello world!\n&quot;字符串指针放入rsi,13放入rdx寄存器中．linux在执行系统调用时，会触发一次int80软中断，并把系统调用号放入rax寄存器中；这时cpu切换到内核软中断处理函数中，怎么找到这个软中断函数？这个说起来，话又很多了(IDTR寄存器和中断描述符表)．在中断函数中，找到rax寄存器对应的系统调用，write对应的是sys_write函数，开始执行sys_write函数．在sys_write函数中，会通过fd找到file结构，inode结构等等，最后输出到显示器．</p>
<h1>进程是如何退出的</h1>
<hr>
<p>当进程执行结束之后，会调用exit函数，而这个函数调用的系统调用函数_exit()会嵌入内核，进行清除工作．例如释放进程打开的文件，释放进程mm_struct对应的内存(如果没有共享内存)等等，最后只剩下task_struct,内核栈和thread_info三个结构．子进程会给父进程发送一个SIGCHLD信号，表示进程退出；父进程在收到这个信号之后，会调用wait或waitpid函数回收子进程的资源，task_struct,内核栈以及thread_info．到这里，hello进程的生命就算走完了．</p>
<h1>总结</h1>
<hr>
<p>这篇文章主要就是介绍linux下面，一个进程的生命过程，从诞生到终结．涉及到非常多的知识，也希望能给大家对进程的一个比较清晰的认识；我并没有写得很深入，因为那样的话，会非常长，大部分人会看不懂．我自己发现有些知识点还需要好好巩固，因为有时候，我并不能非常熟练的表达出来，还需要多研究．</p>
<p>还是那句话，如果有什么出错的地方，还希望各位能够指出来，共同进步．</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于程序员来说，hello world的含义，可能并不只是一句简单的打招呼，更多的是学习一门编程语言的第一个示例．和编程接触了这么多年，如果要学习一门编程语言，我也会情不自禁地敲下hello world程序，看下程序的的输出．如今回过头的来重新看hello world，就会
    
    </summary>
    
      <category term="hello world" scheme="http://luodw.cc/categories/hello-world/"/>
    
    
      <category term="helloworld" scheme="http://luodw.cc/tags/helloworld/"/>
    
  </entry>
  
  <entry>
    <title>libtask之channel实现机制</title>
    <link href="http://luodw.cc/2016/06/26/libtask01/"/>
    <id>http://luodw.cc/2016/06/26/libtask01/</id>
    <published>2016-06-26T09:19:33.000Z</published>
    <updated>2017-03-16T08:51:34.129Z</updated>
    
    <content type="html"><![CDATA[<p>用过golang语言，都知道golang最吸引人的特性就是goroutine和channel．goroutine可以称呼为go程，其实就是go语言协程；channel即为通道，用于goroutine之间进行通信；比较直观的理解，channel实现可以认为生产者和消费者模型，即一个goroutine写入消息，另一个协程读取消息；当然，具体如何实现，可以看libtask的channel实现，即可略知一二．</p>
<p>libtask的channel模块，理解起来没有task模块轻松，逻辑比较复杂，我在计划写这篇博客时，还是很担心不能够写明白libtask的channel是如何运行的；这篇博客主要是以例子以及解析源码的形式来分析channel的实现；</p>
<p>go  channel分为有有缓存和无缓存，对应于libtask也是如此，我们先来看下无缓存是如何实现的；</p>
<h2>无缓存channel实现</h2>
<hr>
<p>下面是一个简单的例子，用于说明libtask中channel的实现
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;task.h&gt;</span></span></div><div class="line"></div><div class="line">Channel *c=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">counttask1</span><span class="params">(<span class="keyword">void</span> *arg)</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test3-----\n"</span> );</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> x = chanrecvul(c);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>,x );</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test4-----\n"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">    c = chancreate(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>),<span class="number">0</span>);</div><div class="line">    taskcreate(counttask1, <span class="literal">NULL</span>, <span class="number">32768</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test1-----\n"</span> );</div><div class="line">    chansendul(c, <span class="number">1</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"test2-----\n"</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译程序</p>
<blockquote>
<p>gcc -g mytest.c -o mytest -ltask</p>
</blockquote>
<p>最后得到结果如下:
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">test1<span class="comment">-----</span></div><div class="line">test3<span class="comment">-----</span></div><div class="line"><span class="number">1</span></div><div class="line">test4<span class="comment">-----</span></div><div class="line">test2<span class="comment">-----</span></div></pre></td></tr></table></figure></p>
<p>先来分析下结果，当然如果你熟悉golang，这结果是很明显的．</p>
<ol>
<li>一开始任务队列中只有taskmain任务，所以调度器直接调度taskmain任务；</li>
<li>在taskmain任务中，创建了counttask1任务，然后输出&quot;test1------&quot;，接着向管道中写入一个无符号长整形1，由于是无缓存的channel，所以taskmain任务阻塞并切换到调度器;</li>
<li>此时任务队列只有counttask1，调度器调度counttask1任务执行;</li>
<li>在counttask1任务中，从channel中读取一个元素，因为channel中已经有一个元素，所以直接返回channel中的数值，最后输出&quot;test4----&quot;;</li>
<li>调度器切回taskmain执行，最后结束任务队列为空，退出整个程序；</li>
</ol>
<h2>源码实现</h2>
<hr>
<p>libtask中关于channel的源码实现主要是在文件channel.c中，我在初次看channel的实现时，就三个字＂看不懂＂；主要逻辑在chanalt和altexec函数中，这两个函数最晦涩难懂；最后只能祭出上古神器gdb；跟着gdb，设断点，一步一步跟踪程序，最后终于把channel搞懂了；所以建议从代码字面看不懂的同学，可以和我一样，利用gdb；</p>
<p>好了，不多说，来开始代码之旅；</p>
<h3>向channel发送数据代码逻辑</h3>
<p>测试例子程序中，我们先看下创建channel的代码逻辑
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function">Channel*</span></div><div class="line"><span class="title">chancreate</span><span class="params">(<span class="keyword">int</span> elemsize, <span class="keyword">int</span> bufsize)</span></div><div class="line">&#123;</div><div class="line">	Channel *c;</div><div class="line">	<span class="comment">// 为channel分配内存</span></div><div class="line">	c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *c+bufsize*elemsize);</div><div class="line">	<span class="keyword">if</span>(c == nil)&#123;</div><div class="line">		fprint(<span class="number">2</span>, <span class="string">"chancreate malloc: %r"</span>);</div><div class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> *c);</div><div class="line">	c-&gt;elemsize = elemsize;<span class="comment">// channel中每个元素的大小</span></div><div class="line">	c-&gt;bufsize = bufsize;</div><div class="line">	c-&gt;nbuf = <span class="number">0</span>;<span class="comment">//缓存已使用量</span></div><div class="line">	c-&gt;buf = (uchar*)(c+<span class="number">1</span>);<span class="comment">//指向缓存首地址</span></div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"><span class="comment">//--------------------------------------------------------</span></div><div class="line"><span class="keyword">struct</span> Channel</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	bufsize;<span class="comment">//缓存大小，即缓存元素个数</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	elemsize;<span class="comment">//channel每个元素的大小</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	*buf;<span class="comment">//指向缓存的指针</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	nbuf;<span class="comment">//缓存已使用量</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	off;<span class="comment">//当前读取的元素个数</span></div><div class="line">	Altarray	asend;<span class="comment">//发送队列</span></div><div class="line">	Altarray	arecv;<span class="comment">//接收队列</span></div><div class="line">	<span class="keyword">char</span>		*name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>从这段代码，我们可以看出来参数elemsize表示channel中每个元素的大小，bufsize表示缓存可以容纳多少个元素，即缓存的size；因此有无缓存，主要是看bufsize的值，如果为0，则无缓存，如果不为0，则有缓存；</p>
<p>创建好channel之后，接下来看下chansendul(c, 1)函数的代码逻辑，这个函数直接调用_chanop函数
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span></div><div class="line">_chanop(Channel *c, <span class="keyword">int</span> op, <span class="keyword">void</span> *p, <span class="keyword">int</span> canblock)</div><div class="line">&#123;</div><div class="line">	Alt a[<span class="number">2</span>];</div><div class="line"></div><div class="line">	a[<span class="number">0</span>].c = c;</div><div class="line">	a[<span class="number">0</span>].op = op;</div><div class="line">	a[<span class="number">0</span>].v = p;</div><div class="line">	a[<span class="number">1</span>].op = canblock ? CHANEND : CHANNOBLK;</div><div class="line">	<span class="keyword">if</span>(chanalt(a) &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一次看代码的时候，会被这个alt数组给弄混淆了，代码中可以看出其实就是第一个alt存储数据，第二个并没有存储数据；看到后面之后，才会发现其实第二个alt就是用于一些条件的判断；</p>
<p>ok，接下来，到最重要的函数chanalt，省去一些无关紧要的代码,
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">chanalt(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">	<span class="comment">/* 省去一些代码 */</span></div><div class="line">	<span class="comment">/* 此时n=1 */</span></div><div class="line">	ncan = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">		<span class="built_in">c</span> = a[i].<span class="built_in">c</span>;</div><div class="line">		<span class="keyword">if</span>(altcanexec(&amp;a[i]))&#123;</div><div class="line">				ncan++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/* ......  */</span></div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">		<span class="keyword">if</span>(a[i].op != <span class="type">CHANNOP</span>)</div><div class="line">			altqueue(&amp;a[i]);</div><div class="line">	&#125;</div><div class="line">	taskswitch();</div><div class="line"><span class="comment">//------------------------------------------------</span></div><div class="line"><span class="keyword">static</span> int</div><div class="line">altcanexec(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">	<span class="type">Altarray</span> *ar;</div><div class="line">	<span class="type">Channel</span> *<span class="built_in">c</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(a-&gt;op == <span class="type">CHANNOP</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="built_in">c</span> = a-&gt;<span class="built_in">c</span>;</div><div class="line">	<span class="keyword">if</span>(<span class="built_in">c</span>-&gt;bufsize == <span class="number">0</span>)&#123;</div><div class="line">		ar = chanarray(<span class="built_in">c</span>, otherop(a-&gt;op));</div><div class="line">		<span class="keyword">return</span> ar &amp;&amp; ar-&gt;n;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		...............</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在chanalt函数中，首先是判断这个alt是否可执行；在判断函数altcanexec内部，因为此时是无缓存版本，因此代码逻辑就在if语句内部；</p>
<blockquote>
<p>otherop(a-&gt;op)函数返回当前操作的相反队列；例如如果此时是一个发送操作，那么这个otherop函数返回的是接收队列</p>
</blockquote>
<blockquote>
<p>chanarray函数返回通道c(channel)中，otherop(a-&gt;op)类型的队列，此时返回的是接收队列，因为ar-&gt;n为当前通道队列中元素的个数，此时接收队列为空，所以此时为ar-&gt;n为0</p>
</blockquote>
<p>因此这个判断函数altcanexec返回false，代码就直接来到了altqueue函数中，这个alt加入队列函数很简单，就是简单的将alt放入相应队列中，此时alt加入的是发送队列;</p>
<p>最后执行taskswitch函数，执行任务调度，切换到调度器；要注意的是，此时taskmain是没有放入任务队列的(调用taskyield函数才是让出当前CPU，并把自身放入任务队列末尾)，因此后面需要有个函数将这个taskmain放入队列中，等待调度，那这个函数是谁了?后面再揭晓</p>
<h3>从channel接收代码逻辑</h3>
<p>taskmain任务切换到调度器之后，此时任务队列中只有counttask1任务，因此调度器切换counttask1任务执行，我们直接看函数chanrecvul(c)逻辑，这个函数也是调用_chanop函数，最后到达chanalt函数;在chanalt函数中，代码逻辑主要是下面这些:
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">chanalt(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">	<span class="comment">/* ...... */</span></div><div class="line">	ncan = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">		<span class="built_in">c</span> = a[i].<span class="built_in">c</span>;</div><div class="line">		<span class="keyword">if</span>(altcanexec(&amp;a[i]))&#123;</div><div class="line">				ncan++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(ncan)&#123;</div><div class="line">		j = rand()%ncan;</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">			<span class="keyword">if</span>(altcanexec(&amp;a[i]))&#123;</div><div class="line">				<span class="keyword">if</span>(j-- == <span class="number">0</span>)&#123;</div><div class="line">					altexec(&amp;a[i]);</div><div class="line">					<span class="keyword">return</span> i;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/* ....... */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//------------------------------------------------</span></div><div class="line"><span class="keyword">static</span> int</div><div class="line">altcanexec(<span class="type">Alt</span> *a)</div><div class="line">&#123;</div><div class="line">        <span class="type">Altarray</span> *ar;</div><div class="line">        <span class="type">Channel</span> *<span class="built_in">c</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(a-&gt;op == <span class="type">CHANNOP</span>)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="built_in">c</span> = a-&gt;<span class="built_in">c</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">c</span>-&gt;bufsize == <span class="number">0</span>)&#123;</div><div class="line">                ar = chanarray(<span class="built_in">c</span>, otherop(a-&gt;op));</div><div class="line">                <span class="keyword">return</span> ar &amp;&amp; ar-&gt;n;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">                ...............</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在判断函数altcanexec函数内部，因为a-&gt;op为接收，所以ar为发送队列，因为之前已经存入一个元素，因此ar-&gt;n不为0，所以判断为真，此时ncan加1；转入执行下面if语句，最后执行altexec函数；
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void</div><div class="line">altexec(Alt *a)</div><div class="line">&#123;</div><div class="line">	int i;</div><div class="line">	Altarray *ar;</div><div class="line">	Alt *other;</div><div class="line">	Channel *c;</div><div class="line"></div><div class="line">	<span class="function"><span class="title">c</span> = a-&gt;</span>c;</div><div class="line">	<span class="function"><span class="title">ar</span> = chanarray(c, otherop(a-&gt;</span>op));<span class="comment">//取出channel中的发送队列</span></div><div class="line">	<span class="function"><span class="title">if</span>(ar &amp;&amp; ar-&gt;</span>n)&#123;</div><div class="line">		<span class="function"><span class="title">i</span> = rand()%ar-&gt;</span>n;<span class="comment">//i=0</span></div><div class="line">		<span class="function"><span class="title">other</span> = ar-&gt;</span>a[i];<span class="comment">//取出发送队列第一个alt</span></div><div class="line">		altcopy(a, other);<span class="comment">//将发送队列第一个alt中携带的数据拷贝到a</span></div><div class="line">		<span class="function"><span class="title">altalldequeue</span>(other-&gt;</span>xalt);<span class="comment">//删除发送队列第一个alt</span></div><div class="line">		<span class="function"><span class="title">other</span>-&gt;</span>xalt[<span class="number">0</span>].xalt = other;</div><div class="line">		<span class="function"><span class="title">taskready</span>(other-&gt;</span>task);<span class="comment">// 将other的宿主任务放入调度队列中</span></div><div class="line">	&#125;<span class="keyword">else</span></div><div class="line">		altcopy(a, <span class="literal">nil</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数很重要，可以说是理解channel接收逻辑的重点；解释如下</p>
<ol>
<li>一开始，取出发送队列第一个alt；</li>
<li>将发送队列第一个alt的数据拷贝至接收alt中；</li>
<li>删除发送队列中的第一个alt，因为已经被处理了;</li>
<li>调用taskready将taskmain任务放入任务队列中，等待调度；</li>
</ol>
<p>最后在chanrecvul函数中，将val，即接收alt-&gt;v中存储的值，返回给用户；</p>
<p>当counttask1任务结束时，调度器调度taskmain执行，taskmain输出一句&quot;test2----&quot;，也结束运行</p>
<p>最后，调度任务队列为空，调度循环退出，整个进程也就退出了</p>
<p>因此到目前为止，channel的发送接收逻辑已经很清楚了</p>
<blockquote>
<p>taskmain任务向channel发送数据时，将alt放入channel的发送队列；阻塞切换；然后counttask1任务从channel接收数据时，将发送队列第一个alt携带数据拷贝至接收队列的alt中，并将taskmain放入任务队列末尾，等待调度；在chanrecvul将数据返回给用户</p>
</blockquote>
<p>libtask无缓存的channel暂时分析到这；对于有缓存的的channel，代码逻辑和这下相似，只是用到了buf，我相信看懂无缓存channel的代码逻辑之后，再跟着gdb单步调试肯定也能看懂有缓存channel逻辑；</p>
<p>有时间在分析有缓存channel逻辑吧．</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过golang语言，都知道golang最吸引人的特性就是goroutine和channel．goroutine可以称呼为go程，其实就是go语言协程；channel即为通道，用于goroutine之间进行通信；比较直观的理解，channel实现可以认为生产者和消费者模型，
    
    </summary>
    
      <category term="libtask" scheme="http://luodw.cc/categories/libtask/"/>
    
    
      <category term="libtask" scheme="http://luodw.cc/tags/libtask/"/>
    
  </entry>
  
  <entry>
    <title>聊聊golang的前身libtask</title>
    <link href="http://luodw.cc/2016/06/21/libtask/"/>
    <id>http://luodw.cc/2016/06/21/libtask/</id>
    <published>2016-06-21T11:43:13.000Z</published>
    <updated>2017-03-16T08:51:34.129Z</updated>
    
    <content type="html"><![CDATA[<p>在实习期间，由于项目需要，接触了golang这门语言；经过一段时间的学习使用，我发现golang语言语法简单，有C/C++基础的同学，一个星期即可上手，当然要深入理解golang，还是要多使用，多学习底层机制；goroutine的引入，使得golang非常适合并发程序的开发；而我了，在学习一门语言或技术的时候，是一定要理解底层的实现原理，否则我会用的很盲目或者说难受．所以有了这篇文章．</p>
<p>之前，在没接触golang时，在我的认知范围内，服务器开发架构大体就是类似redis的单线程，memcache多线程，ngnix多进程；在接触golang之后，我认识了协程这么一个概念，可以说这是我知识体系非常大的补充，因为服务器开发还可以采用协程实现；接下来，先简要介绍下协程的概念，然后在介绍golang前身libtask的实现原理；</p>
<h1>协程是什么</h1>
<p>协程，其实就是轻量级线程，粒度比线程还小，通俗点说就是用户态的一个函数块；一个进程或线程如果内存够大，就可以创建足够多的协程，但是在在内核层面，还是只有一个进程描述符，也就是说内核并不知道协程的存在，所以协程的调度执行完全需要用户态调度器来调度执行；协程有也有自己的栈，也有自己的上下文，所以协程可以在执行到一半的时候让出cpu，同时保存上下文，切换到其他协程，待其他协程执行结束之后，再切回来继续执行；</p>
<p>对于Linux，</p>
<ol>
<li>进程切换是个耗时的工作，因为首先要程序要先嵌入到内核，保存当前进程的上下文到任务段，然后进程调度算法选择一个就绪进程，将这个就绪进程任务段保存的寄存器值恢复到CPU，切换页表，切换堆栈，刷新cpu中TLB和Cache缓存等；</li>
<li>线程就是轻量级的进程，因为线程在内核里面也有进程描述符，也有内核堆栈；所以线程的切换，也需要嵌入内核，执行上下文切换以及堆栈切换等，但是同个进程中的线程切换不需要切换页表，不要刷新TLB，所以在一定程度上，线程切换代价是小于进程切换；</li>
<li>协程的切换比进程，线程切换代价都小；linux下面，CPU调度最小的单位是线程(因为内核调度需要task_struct嘛)，所以对于一个进程或线程上的所有协程只能在同一个CPU上调度执行，而且只能一个协程执行结束之后再执行其他线程，除非某个协程显式让出CPU；因此，协程的调度不需要内核调度，而是由用户态调度器调度，而且只需要切换CPU硬件上下文，代价相对于进程线程是非常低的．</li>
</ol>
<p>当前，支持协程的语言越来越多，主流的有lua,golang,python,Erlang等；当然在远古时代，那时没有语言支持协程，有些大佬就用C语言自己封装实现用户态任务调度库，比较有代表性的就是golang的前身libtask，所以学习golang，libtask一定要看看，对于理解golang有很大的帮助．</p>
<h1>说说libtask</h1>
<p>libtask是一套用c语言编写的任务调度库，实现很简单，将创建的任务存入一个队列中，然后main函数主线程在一个for循环中，不断从队列头部开始调度任务，直到任务队列为空，直到所有任务调度完毕，进程退出；</p>
<h2>libtask简单例子程序</h2>
<p>这里先给个例子简单说明下libtask使用:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;task.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">counttask1</span><span class="params">(<span class="keyword">void</span> *arg)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"task1: %d\n"</span>, i);</div><div class="line">        taskyield();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">counttask2</span><span class="params">(<span class="keyword">void</span> *arg)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"task2: %d\n"</span>, i);</div><div class="line">        taskyield();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">    taskcreate(counttask1, <span class="literal">NULL</span>, <span class="number">32768</span>);</div><div class="line">    taskcreate(counttask2, <span class="literal">NULL</span>, <span class="number">32768</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译这段代码时，需要加入动态链接库</p>
<blockquote>
<p>gcc example.c -o example -ltask</p>
</blockquote>
<p>最后执行结果如下:
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">charles<span class="meta">@charles</span>-<span class="string">Lenovo:</span>~/libtask$ gcc example.c -o example -ltask</div><div class="line">charles<span class="meta">@charles</span>-<span class="string">Lenovo:</span><span class="regexp">~/libtask$ ./</span>example</div><div class="line"><span class="string">task1:</span> <span class="number">0</span></div><div class="line"><span class="string">task2:</span> <span class="number">5</span></div><div class="line"><span class="string">task1:</span> <span class="number">1</span></div><div class="line"><span class="string">task2:</span> <span class="number">6</span></div><div class="line"><span class="string">task1:</span> <span class="number">2</span></div><div class="line"><span class="string">task2:</span> <span class="number">7</span></div><div class="line"><span class="string">task1:</span> <span class="number">3</span></div><div class="line"><span class="string">task2:</span> <span class="number">8</span></div><div class="line"><span class="string">task1:</span> <span class="number">4</span></div><div class="line"><span class="string">task2:</span> <span class="number">9</span></div></pre></td></tr></table></figure></p>
<p>这个例子很简单，通过在taskmain函数中调用taskcreate创建两个任务，然后taskmain任务退出，开始执行counttask1和counttask2两个任务，并通过taskyield函数实现任务切换，主要就是让出CPU，实现交替执行，最终打印如上结果．</p>
<p>可能有小伙伴会有疑问，怎么这段小程序没有main函数？因为开始学编程的时候，老师就说main函数是程序入口．带着疑问，查看源码发现，main函数已经集成在libtask库，在task.c文件中；我刚开始看时，也有疑惑，为什么不把main函数交给用户？通过查看源码，我的理解是，因为在main函数中，需要实现任务调度功能，如果把main函数交个用户，那就需要再提供一个接口给用户注册调度模块，这就无疑增加代码难度以及暴露太多的内部细节，例如任务队列以及任务结构等等；所以libtask库干脆封装main函数，并在main函数中实现调度器，这样只需提供创建任务的接口即可，内部实现细节全都隐藏了．</p>
<h2>libtask实现原理</h2>
<p>这里先给出如下图示说明libtask的执行过程，我以上述example.c为例
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line">              <span class="comment">|</span>  <span class="comment">Scheduler</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">主线程</span></div><div class="line">              <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line">              <span class="comment">/</span>      <span class="comment">|</span>     <span class="comment">\</span></div><div class="line">             <span class="comment">/</span>       <span class="comment">|</span>      <span class="comment">\</span></div><div class="line">            <span class="comment">/</span>        <span class="comment">|</span>       <span class="comment">\</span></div><div class="line">           <span class="comment">/</span>         <span class="comment">|</span>        <span class="comment">\</span></div><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>     <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>    <span class="literal">+</span><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div><div class="line"><span class="comment">|</span> <span class="comment">taskmain</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">task1</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">|</span> <span class="comment">task2</span> <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span><span class="string">.</span></div><div class="line"><span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>     <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span>    <span class="literal">+</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">+</span></div></pre></td></tr></table></figure></p>
<ol>
<li>在task.c文件main函数中，首先会创建taskmain任务，并放入任务队列中；</li>
<li>接着mian函数主程序进入任务调度循环中，不断迭代并执行任务队列中的任务，直到任务队列为空；一开始只有taskmain任务，因此执行taskmain任务函数；</li>
<li>一般情况下，我们会在taskmain任务函数中创建其他任务，并放入任务中；此时tasmain任务结束退出；</li>
<li>此时任务队列中只有task1和task2，task1在队首，所以先执行，当遇到taskyield函数时，此时task1自愿放弃cpu，把自身放入任务队列末尾；执行任务切换，切换到调度器；</li>
<li>此时调度器取出位于队首的task2执行，同样，遇到taskyield，放弃cpu,自身存入任务队列末尾，切换到调度器；</li>
<li>调度器执行task1...</li>
</ol>
<p>以上就是例子example.c的执行过程，从中我们可以知道，libtask把真正的main函数隐藏了，也就是说调度器对用户是透明的，但是给用户提供了另一个main函数taskmain；因此我们在使用libtask时只需要把taskmain当做main函数即可，在libtask的真正main函数中会为这个taskmain创建一个任务并调度执行；所以除了调度器外，taskmain永远是第一个任务，后面的任务需要从taskmain任务创建衍生．</p>
<h2>libtask源码解析</h2>
<p>要实现任务切换，就必须能够保存当前任务的上下文，这样再次切回当前任务时，可以继续执行当前任务；在linux平台下面，主要用的就是ucontext.h，提供的getcontext,setcontext,swapcontext和makecontext函数，具体的上下文有结构体ucontext_t指定，包括任务的栈的大小，栈顶指针以及cpu内寄存器信息；简要介绍下四个函数，具体如何使用可以谷歌之．</p>
<ol>
<li>int getcontext(ucontext_t *ucp);函数用于获取当前任务的上下文，并存入ucp中；</li>
<li>int setcontext(const ucontext_t *ucp);用于实现任务切换，即设置当前执行的上下文；</li>
<li>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);用于创建一个上下文，存入ucp中，当执行这个上下文时，会跳转到func函数中执行；</li>
<li>int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);这个函数可以看成是setcontext好绕getcontext函数的合成，先保存当前上下文在oucp，然后跳转到ucp指定的上下文；当ucp任务执行结束之后，会回到swapcontext函数的下一行代码继续执行(实现可以思考uc_link)．</li>
</ol>
<p>接下来，从main函数开始，源码解析(省去一些不影响分析的代码)
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> taskargc;<span class="comment">//为了将用户输入的参数传进taskmain函数中</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> **taskargv<span class="comment">//所以设置了这两个变量</span></div><div class="line"><span class="keyword">int</span> mainstacksize;<span class="comment">// taskmain任务栈的大小</span></div><div class="line"></div><div class="line"><span class="comment">// taskmain主协程</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">taskmainstart</span><span class="params">(<span class="keyword">void</span> *v)</span></div><div class="line">&#123;</div><div class="line">	taskname(<span class="string">"taskmain"</span>);</div><div class="line">	taskmain(taskargc, taskargv);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	  省去对信号处理函数</div><div class="line">	*/</div><div class="line">	argv0 = argv[<span class="number">0</span>];</div><div class="line">	taskargc = argc;</div><div class="line">	taskargv = argv;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(mainstacksize == <span class="number">0</span>)</div><div class="line">		mainstacksize = <span class="number">256</span>*<span class="number">1024</span>;<span class="comment">//设置taskmain栈大小</span></div><div class="line"></div><div class="line">    　　<span class="comment">/* 创建taskmain协程 */</span></div><div class="line">	taskcreate(taskmainstart, nil, mainstacksize);</div><div class="line">        <span class="comment">/* 进入协程调度 */</span></div><div class="line">	taskscheduler();</div><div class="line">	fprint(<span class="number">2</span>, <span class="string">"taskscheduler returned in main!\n"</span>);</div><div class="line">	<span class="built_in">abort</span>();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>libtask代码写的很清晰，主程序主要是执行taskmain任务创建，接着进入任务调度模块；接下来先看下任务创建函数taskcreate
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">nt</div><div class="line">taskcreate(<span class="keyword">void</span> (*fn)(<span class="keyword">void</span>*), <span class="keyword">void</span> *arg, uint stack)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> <span class="keyword">id</span>;</div><div class="line">	Task *t;</div><div class="line">	<span class="comment">/*　taskalloc函数主要执行任务结构体Task内存分配以及创建，初始化</span></div><div class="line">	　　任务栈信息，创建任务上下文　*/</div><div class="line">	t = taskalloc(fn, arg, stack);</div><div class="line">	taskcount++;</div><div class="line">	<span class="keyword">id</span> = t-&gt;<span class="keyword">id</span>;</div><div class="line">	<span class="keyword">if</span>(nalltask%<span class="number">64</span> == <span class="number">0</span>)&#123;<span class="comment">//nalltask变量标识所有任务的个数，如果任务超出64个</span></div><div class="line">				<span class="comment">//则需要重新分配内存，把任务数组大小增加64</span></div><div class="line">		alltask = realloc(alltask, (nalltask+<span class="number">64</span>)*<span class="keyword">sizeof</span>(alltask[<span class="number">0</span>]));</div><div class="line">		<span class="keyword">if</span>(alltask == <span class="literal">nil</span>)&#123;</div><div class="line">			fprint(<span class="number">2</span>, <span class="string">"out of memory\n"</span>);</div><div class="line">			abort();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	t-&gt;alltaskslot = nalltask;</div><div class="line">	alltask[nalltask++] = t;</div><div class="line">	taskready(t);<span class="comment">//taskready将任务t标为就绪状态，并加入任务队列中</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">id</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//----------------------------------------------------------------------</span></div><div class="line"><span class="keyword">void</span></div><div class="line">taskready(Task *t)</div><div class="line">&#123;</div><div class="line">	t-&gt;ready = <span class="number">1</span>;</div><div class="line">	addtask(&amp;taskrunqueue, t);<span class="comment">//将任务t加入taskrunqueue队列中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经过taskcreate函数创建maintask任务，并且放入任务队列taskrunqueue队列中之后，接下来，程序进入taskscheduler()调度函数中，我们直接看任务调度循环部分
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(;;)&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(taskcount == <span class="number">0</span>)</div><div class="line">		<span class="keyword">exit</span>(taskexitval);</div><div class="line">	<span class="regexp">/* 取出队首的任务 */</span></div><div class="line">	t = taskrunqueue.head;</div><div class="line">	<span class="keyword">if</span>(t == nil)&#123;</div><div class="line">		fprint(<span class="number">2</span>, <span class="string">"no runnable tasks! %d tasks stalled\n"</span>, taskcount);</div><div class="line">		<span class="keyword">exit</span>(<span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="regexp">/* 从任务队列中删除该任务 */</span></div><div class="line">	deltask(&amp;taskrunqueue, t);</div><div class="line">	t-&gt;ready = <span class="number">0</span>;</div><div class="line">	taskrunning = t;<span class="regexp">/* 设置全局任务运行变量为当前执行任务t */</span></div><div class="line">	tasknswitch++; <span class="regexp">/* 任务切换次数+1 */</span></div><div class="line">	taskdebug(<span class="string">"run %d (%s)"</span>, t-&gt;id, t-&gt;name);</div><div class="line">	<span class="regexp">/* 执行任务切换 */</span></div><div class="line">	contextswitch(&amp;taskschedcontext, &amp;t-&gt;context);</div><div class="line">	taskrunning = nil;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(t-&gt;exiting)&#123;<span class="regexp">//</span>如果任务t执行完毕，即可在全局任务数组中删除</div><div class="line">		<span class="keyword">if</span>(!t-&gt;system)</div><div class="line">			taskcount--;</div><div class="line"></div><div class="line">		i = t-&gt;alltaskslot;</div><div class="line">		alltask[i] = alltask[--nalltask];</div><div class="line">		alltask[i]-&gt;alltaskslot = i;</div><div class="line">		free(t);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在contextswitch函数中，执行swapcontext函数进行任务切换；在上述example.c例子中，由于一开始任务队列中只有taskmain任务，因此执行contextswitch之后，切换到taskmain任务执行；在taskmain函数中，创建两个任务task1和task2，并加入到taskrunqueue队列中，taskmain即运行结束，在任务启动函数taskstart函数的结尾，有个退出函数taskexit(0)，这个函数执行如下操作:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskexit</span><span class="params">(<span class="keyword">int</span> val)</span></div><div class="line">&#123;</div><div class="line">	taskexitval = val;</div><div class="line">	taskrunning-&gt;exiting = <span class="number">1</span>;</div><div class="line">	taskswitch();</div><div class="line">&#125;</div><div class="line"><span class="comment">// -----------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">taskswitch</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">	needstack(<span class="number">0</span>);</div><div class="line">	contextswitch(&amp;taskrunning-&gt;context, &amp;taskschedcontext);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这两个函数，我们可以看出在某个任务退出之后，会进行任务切换，将控制权交给任务调度器，然后由调度器调度队列中的下一个任务；因此，到目前为止，libtask的架构更加清晰明了，</p>
<blockquote>
<p>由调度器调度队首任务，并从任务队列中删除队首任务；队首任务执行结束之后，会切回调度器，接着由调度器调度新的队首任务，直到任务队列为空．</p>
</blockquote>
<blockquote>
<p>当然有一种情况是遇到taskyield函数，这时当前任务会让出cpu，切换到调度器，并将自身放入任务队列末尾，等待调度器的再次调度．调度器即执行新的队首任务．</p>
</blockquote>
<p>这篇文章主要是分析了golang的前身libtask的实现原理，多多少少都有着golang的影子，当然听说golang改进了libtask任务调度机制，因为libtask每次某个任务执行结束都需要切换到调度器，再由调度器调度新的任务，显然，切换到调度器这过程是多余了；具体golang怎么实现，待我后续研究...</p>
<p>下篇文章分析下libtask的channel的实现．</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实习期间，由于项目需要，接触了golang这门语言；经过一段时间的学习使用，我发现golang语言语法简单，有C/C++基础的同学，一个星期即可上手，当然要深入理解golang，还是要多使用，多学习底层机制；goroutine的引入，使得golang非常适合并发程序的开发
    
    </summary>
    
      <category term="libtask" scheme="http://luodw.cc/categories/libtask/"/>
    
    
      <category term="libtask" scheme="http://luodw.cc/tags/libtask/"/>
    
  </entry>
  
  <entry>
    <title>TFS之DataServer启动执行过程</title>
    <link href="http://luodw.cc/2016/05/20/tfs01/"/>
    <id>http://luodw.cc/2016/05/20/tfs01/</id>
    <published>2016-05-20T12:20:01.000Z</published>
    <updated>2017-03-16T08:51:34.133Z</updated>
    
    <content type="html"><![CDATA[<p>最近在实习,接触了tfs文件系统,刚好之前有决定往数据存储方向发展,因此很认真的看了tfs安装部署,以及源码.不得不说,tfs源码真心不是很容易看懂的,因为用了C++很多继承多态,回调机制,地处底层封装等等,我也是花了大概好几天天的时间才把DataServer整体部分看懂了;因此必须写篇博客记录下...</p>
<h1>文件系统</h1>
<hr>
<p>学过计算机的朋友 ，都有听说过文件系统，简要地说，文件系统就是操作系统组织磁盘文件的一种方式，因为磁盘就是一个物理设备，只知道存储二进制的比特位，但是并不知道存储的是文件还是目录，因此操作系统要规划好如何将文件存入磁盘以及如何从磁盘取文件等等，这就是文件系统做的事；关于文件系统的介绍，《linux鸟哥的私房菜》前几章有很好的介绍。</p>
<p>当然对于linux来说，一切都是文件，因为在linux下面，文件系统的概念更广，有传统的基于磁盘的ext4,ext3...，有基于网络的sockfs，有基于内存的pipefs和procfs等等。通过一层虚拟文件系统vfs，屏蔽各个文件系统的差异，为用户提供统一的访问接口open,write,read,close等等；</p>
<p>分布式文件系统是属于用户态的文件系统，最终利用的还是操作系统内核的文件系统的存储功能；tfs将磁盘分成若干个块（其实就是大文件），一个块一般较大，可以存储较多的小文件；tfs就是将小文件存储在某个块中，也是从块中取小文件；我的理解就是操作系统文件系统单个文件为单位存储单个文件的数据，而分布式文件系统以块为单位存储各个小文件的数据。常见的分布式文件系统有GFS,HDFS,GridFS,TFS,FastFS等等；</p>
<h1>TFS简要概述</h1>
<hr>
<p>最近两个星期都在看TFS文件系统dataserver部分源码，感受最深的就是快吐了，由于是C++写的，代码里面充斥太多的继承多态，回调，以及各种底层封装，反正就是一个字“乱”，也可能正如林老湿所说，“是时候换个姿势了”。经过我的坚持和林老湿的指导，最终还是把整个dataserver的执行过程看懂了，因此今天写篇博客总结下。</p>
<p>TFS（Taobao !FileSystem）是一个高可扩展、高可用、高性能、面向互联网服务的分布式文件系统，主要针对海量的非结构化数据，它构筑在普通的Linux机器集群上，关于tfs的介绍可以看<a href="%22http://code.taobao.org/p/tfs/wiki/intro/%22">官方文档</a></p>
<p>先给出TFS整体框架图<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-tfs01.png" alt="TFS整体框架">
正如图所示，NameServer负责管理各个block和dataserver之间的对应关系，并不存储实际数据，而DataServer用于存储具体的数据，当应用程序要存储一个文件时，</p>
<ol>
<li>首先在客户端根据文件名解析出文件该文件所对应的block_id和file_id，接着访问NameServer，NameServer向客户端返回这个block_id对应块所在的dataserver地址链表（有一个是primary_ds,其他为了冗余存储），</li>
<li>客户端接着访问primary_ds，请求在block_id块存储file_id文件，把文件写入block_id对应块中；</li>
<li>primary_ds将数据写入块之后，再给其他slave数据服务器发送在block_id块存储file_id的消息，实现同步；slave服务器成功写入返回之后，primary_ds通过心跳机制给ns报告块的使用情况；</li>
<li>primary_ds给客户端回复数据成功写入；</li>
</ol>
<p>当客户端需要读取文件时，</p>
<ol>
<li>首先在客户端根据文件名解析出文件所对应的block_id和file_id，然后访问NameServer获取这个block所对应的dataserver地址链表；</li>
<li>接着客户端访问primary_ds读取数据；</li>
</ol>
<p>以上就客户端存储和读取数据的简要过程，之后会深入介绍文件存储和读取，本篇文章主要是介绍DataServer执行过程；</p>
<h1>DataServer启动过程</h1>
<hr>
<p>首先来看下DataServer启动过程，稍后再分析DataServer处理业务过程。</p>
<ol>
<li>服务器要开启，首先要找到main函数，DataServer的main函数在/dataserver/service.cpp下面
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">  tfs::dataserver::DataService service;</div><div class="line">  <span class="keyword">return</span> service.main(argc, argv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>从代码可以看出先是实例化一个DataService类，然后调用DataService这个类的main函数，接着我们自然而然的会去DataService中查找main函数，接着会发现并没有！这里要先介绍类的继承关系：
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">DataService</span>继承自/<span class="meta">common</span>/<span class="keyword">BaseService</span></div><div class="line"><span class="keyword">BaseService继承自/common/BaseMain</span></div></pre></td></tr></table></figure></p>
<p>因此我们向上查找，在BaseMain类中找到了main方法，在main方法中，主要处理的是运行程序时，跟在程序后面的参数，最后在main方法中调用start方法
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">iret</span> = start(argc , argv, daemonize);</div></pre></td></tr></table></figure></p>
<p>start方法也是在/common/base_main.cpp文件中，主要做的任务就是处理服务器配置文件以及初始化工作目录，pid目录以及日志目录，最后调用run函数
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iret = <span class="keyword">run</span><span class="bash">(argc, argv);</span></div></pre></td></tr></table></figure></p>
<ol start="2">
<li>而这个run函数在/common/base_service.cpp的BaseService类中，run函数主要任务就是首先通过调用函数
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int32_t iret = initialize_network(<span class="name">argv</span>[<span class="number">0</span>])<span class="comment">;</span></div></pre></td></tr></table></figure></li>
</ol>
<p>开启网络模块tbnet两个线程，一个是eventloop线程，负责事件监听，另一个是timeoutLoop线程，负责监控各个客户端连接的情况。在run函数中，接着开启4工作线程，工作线程个数可配置,以及一个时间监控线程（我暂时不知道有啥用），最后调用initialize函数，到达具体服务的初始化操作；</p>
<ol start="3">
<li>之前是tfs为各个服务抽象出来的公共部分，通过initialize函数达到初始化具体服务的目的；在/dataserver/dataservice.cpp/DataService类中找到了initialize函数,这个函数主要就是初始化dataserver具体信息，比如初始化dataserver的私有目录，设置NameServer的地址，核对网络设备以及自身地址，同时再监听本dataserver端口+1的端口，也就是说一个dataserver监听着两个端口，假如第一个是8200，那么还有端口是8201。在initialize函数中，最后步骤就是开启了2个心跳线程，1个校对线程，1个压缩线程，1个复制线程（可配置）。</li>
</ol>
<p>至此，dataserver就启动完毕，等待客户端的连接，请求数据。</p>
<p>dataserver默认是有13个线程，我们可以通过pstack或者gdb info thread打印出来，而且除了main主线程，其他线程是根据开启时间，从上至下排列；
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">[root@meitu_6 luodw]# pstack <span class="number">3875</span></div><div class="line">Thread <span class="number">13</span> (Thread <span class="number">0x7f2ea1b96700</span> (LWP <span class="number">3876</span>)):<span class="comment">//tbnet的事件监听线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e96163</span> <span class="keyword">in</span> epoll_wait () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a61a9</span> <span class="keyword">in</span> tbnet::EPollSocketEvent::getEvents(int, tbnet::IOEvent*, int) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a2c29</span> <span class="keyword">in</span> tbnet::Transport::eventLoop(tbnet::SocketEvent*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">12</span> (Thread <span class="number">0x7f2ea1195700</span> (LWP <span class="number">3877</span>)):<span class="comment">// tbnet客户端监控超时监控事件</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e8ee54</span> <span class="keyword">in</span> usleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a396a</span> <span class="keyword">in</span> tbnet::Transport::timeoutLoop() ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">11</span> (Thread <span class="number">0x7f2e9bfff700</span> (LWP <span class="number">3881</span>)):<span class="comment">// 工作线程1</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">10</span> (Thread <span class="number">0x7f2e9b5fe700</span> (LWP <span class="number">3883</span>)):<span class="comment">// 工作线程2</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">9</span> (Thread <span class="number">0x7f2e9abfd700</span> (LWP <span class="number">3885</span>)):<span class="comment">// 工作线程3</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">8</span> (Thread <span class="number">0x7f2e9a1fc700</span> (LWP <span class="number">3886</span>)):<span class="comment">// 工作线程4</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004a0267</span> <span class="keyword">in</span> tbnet::PacketQueueThread::run(tbsys::CThread*, void*) ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004a3c49</span> <span class="keyword">in</span> tbsys::CThread::hook(void*) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">7</span> (Thread <span class="number">0x7f2e997fb700</span> (LWP <span class="number">3887</span>)):<span class="comment">//这就是我暂时不是很清楚的那个时间线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da98e</span> <span class="keyword">in</span> pthread_cond_timedwait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00000000004baf04</span> <span class="keyword">in</span> bool tbutil::Cond::timedWaitImpl&lt;tbutil::Mutex&gt;(tbutil::Mutex const&amp;, tbutil::Time const&amp;) const ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004ba145</span> <span class="keyword">in</span> tbutil::Monitor&lt;tbutil::Mutex&gt;::timedWait(tbutil::Time const&amp;) const ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b9459</span> <span class="keyword">in</span> tbutil::Timer::run() ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">6</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">6</span> (Thread <span class="number">0x7f2e98dfa700</span> (LWP <span class="number">3892</span>)):<span class="comment">// 心跳线程1</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e8ee54</span> <span class="keyword">in</span> usleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000043c53a</span> <span class="keyword">in</span> tfs::dataserver::DataService::run_heart(int) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">5</span> (Thread <span class="number">0x7f2e983f9700</span> (LWP <span class="number">3894</span>)):<span class="comment">// 心跳线程2</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e8ee54</span> <span class="keyword">in</span> usleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000043c476</span> <span class="keyword">in</span> tfs::dataserver::DataService::run_heart(int) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">4</span> (Thread <span class="number">0x7f2e979f8700</span> (LWP <span class="number">3896</span>)):<span class="comment">// 校对线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea1e59cdd</span> <span class="keyword">in</span> nanosleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007f2ea1e59b50</span> <span class="keyword">in</span> sleep () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x0000000000438633</span> <span class="keyword">in</span> tfs::dataserver::DataService::run_check() ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">3</span> (Thread <span class="number">0x7f2e96ff7700</span> (LWP <span class="number">3897</span>)):<span class="comment">// 压缩线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x000000000042f3a9</span> <span class="keyword">in</span> tfs::dataserver::CompactBlock::run_compact_block() ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">2</span> (Thread <span class="number">0x7f2e8ffff700</span> (LWP <span class="number">3899</span>)):<span class="comment">// 复制线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da98e</span> <span class="keyword">in</span> pthread_cond_timedwait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x000000000042b7ff</span> <span class="keyword">in</span> tfs::dataserver::ReplicateBlock::run_replicate_block() ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004b5069</span> <span class="keyword">in</span> startHook ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x00007f2ea28d69d1</span> <span class="keyword">in</span> start_thread () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x00007f2ea1e95b6d</span> <span class="keyword">in</span> clone () <span class="keyword">from</span> /lib64/libc.so<span class="number">.6</span></div><div class="line">Thread <span class="number">1</span> (Thread <span class="number">0x7f2ea2f02720</span> (LWP <span class="number">3875</span>)):<span class="comment">// 主线程</span></div><div class="line">#<span class="number">0</span>  <span class="number">0x00007f2ea28da5bc</span> <span class="keyword">in</span> pthread_cond_wait@@GLIBC_2<span class="number">.3</span><span class="number">.2</span> () <span class="keyword">from</span> /lib64/libpthread.so<span class="number">.0</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x000000000048c4dc</span> <span class="keyword">in</span> tfs::common::BaseMain::wait_for_shutdown() ()</div><div class="line">#<span class="number">2</span>  <span class="number">0x000000000048d632</span> <span class="keyword">in</span> tfs::common::BaseMain::start(int, char**, bool) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x000000000048db2d</span> <span class="keyword">in</span> tfs::common::BaseMain::main(int, char**) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x000000000040f0c0</span> <span class="keyword">in</span> main ()</div></pre></td></tr></table></figure></p>
<p>因此，dataserver开启之后，总共有13个线程在跑着，最主要的线程是tbnet的事件监听线程和4个工作线程，因为这两个是处理客户端请求最主要的线程；</p>
<h1>dataserver处理请求过程</h1>
<hr>
<p>dataserver处理客户端的请求过程可比dataserver启动过程复杂的多，先简要说下过程;</p>
<blockquote>
<p>tbnet线程监听到客户端有数据可读，读取数据并将数据封装成packet，放入队列中；之前的四个工作线程一开始都阻塞在条件变量上，当有个packet放入队列并唤醒一个工作线程处理这个packet，处理结束之后，把回复客户端的内容放入链接缓冲区中，并在这个连接上注册一个可写事件，在可读事件结束之后,直接执行可写事件,把消息回复给客户端.</p>
</blockquote>
<p>ok，我开始分析吧!</p>
<p>这里就不分析网络模块的线程是怎么创建的，只分析处理过程，因为单独分析tbnet就可以写一篇文章。但是tfs如何创建线程估计就理解一小会，主要过程就是tbnet模块最主要类Transport通过调用start方法把自己传入CThread的start方法中，然后再回调Transport的run方法，实现创建线程的目的；</p>
<p>我们来看下eventLoop线程主要事件回调代码：
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bool rc = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span> (events[i]._readOccurred) &#123;</div><div class="line">    <span class="function"><span class="title">rc</span> = ioc-&gt;</span>handleReadEvent();</div><div class="line">    <span class="comment">//ioc为iocomponent,即将与网络io相关的部分封装在一起，一个f客户端对应一个iocomponent</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (rc &amp;&amp; events[i]._writeOccurred) &#123;</div><div class="line">    <span class="function"><span class="title">rc</span> = ioc-&gt;</span>handleWriteEvent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>listenfd和clientfd对应的iocomponent是不一样的，对于listenfd对应的iocomponent为tcpacceptor.cpp/TCPAcceptor这个类，这个类只有handleReadEvent方法，即将接收的客户端加入事件监听中，并注册可写事件。而clientfd对应的iocomponent为tcpconnnection.cpp/TCPConnection类，这个类的handleReadEvent处理客户端的请求，而handleWriteEvent处理回复客户端事件。</p>
<ol>
<li>我们从clientfd的iocomponent--&gt;handleReadEvent开始说起：
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bool</span> TCPComponent::handleReadEvent() &#123;</div><div class="line">    _lastUseTime = tbsys::CTimeUtil::getTime();</div><div class="line">    <span class="built_in">bool</span> rc = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (_state == TBNET_CONNECTED) &#123;</div><div class="line">        rc = _connection-&gt;readData();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>可以看到在TCPComponent::handleReadEvent方法中，只是简单的调用对应的_connection&gt;readData()方法。接下来，我们深入_connection-&gt;readData()方法。在readData方法中，</p>
<ul>
<li>首先调用socket的read方法将客户端的数据读取进_input缓冲区中；</li>
<li>接着调用方法_streamer-&gt;getPacketInfo，解析出包头;</li>
<li>最后调用handlePacket方法处理包；</li>
</ul>
<p>这个handlePacket方法在TCPConnection类中是找不到的，而是存在该类的父类Connection中，在handlePacket方法中，最重要的就是解析出包，然后调用
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">rc</span> = _serverAdapter-&gt;handlePacket(this, packet);</div></pre></td></tr></table></figure></p>
<p>来处理包；到这里，可能又要开始迷糊了，这个_serverAdapter是什么鬼？</p>
<blockquote>
<p>到这里需要先来介绍下tbnet模块的Transport类，为了tbnet模块接口的简单，tbnet就提供了Transport这类给其他模块调用，而这个类主要最主要就是listen方法和start方法；listen方法用于设置监听的套接字，start用于开启tbnet模块的两个线程；</p>
</blockquote>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IOComponent *Transport::listen(<span class="keyword">const</span> <span class="keyword">char</span> *spec, IPacketStreamer *streamer, IServerAdapter *serverAdapter)</div></pre></td></tr></table></figure></p>
<p>这个listen方法第一个参数为监听套接字，第二个参数为转码用的streamer，第三个参数为每个服务器处理包的适配器，因此tbnet模块所有的serverAdapter都是从这个listen接口传进去的。我们来看下dataserver调用listen接口：
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">tbnet:</span><span class="symbol">:IOComponent*</span> com = transport<span class="number">_</span>-&gt;listen(spec, streamer<span class="number">_</span>, this);</div></pre></td></tr></table></figure></p>
<p>在DataService类调用listen方法时，把自己作为serverAdapter传入tbnet模块，因为DataService继承自base_service,而base_service继承自IServerAdapter，因此DataService可以作为IServerAdapter的子类传入tbnet模块中；现在我们可以看下DataService-&gt;handlePacket方法做了什么？</p>
<ol start="2">
<li>在DataService-&gt;handlePacket方法中，最要就是调用push方法，而push方法主要就是将packet存入工作线程队列中
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool </span><span class="keyword">BaseService::push(BasePacket* </span>packet, <span class="keyword">bool </span><span class="keyword">block)</span></div><div class="line">    &#123;</div><div class="line">      return main_workers_.<span class="keyword">push(packet, </span>work_queue_size_, <span class="keyword">block);</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>在main_workers_为tbnet的PacketQueueThread类，我们定位到该类的push方法，在push方法中，最重要的就是</p>
<p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">_cond</span>.<span class="built_in">lock</span>();</div><div class="line">  <span class="variable">_queue</span>.push(packet);</div><div class="line">  <span class="variable">_cond</span>.unlock();</div><div class="line">  <span class="variable">_cond</span>.signal();</div></pre></td></tr></table></figure></p>
<p>将packet存入队列中，并且调用_cond.signal方法唤醒一个工作线程；到这时，tbnet的eventLoop线程即处理结束一个客户端的请求，接下来的处理就交给工作线程处理。</p>
<ol start="3">
<li>之前有提到，工作线程当初调用/PacketQueueThread/run方法，阻塞在条件变量中，因此可以和eventLoop线程共享packet队列。我们看下某个线程被唤醒后，做了什么？</li>
</ol>
<p>可以在run方法中，可以看到最重要的一行代码为:
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="variable">_handler</span>) &#123;</div><div class="line">           ret = <span class="variable">_handler</span>-&gt;handlePacketQueue(packet, <span class="variable">_args</span>);</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>即调用handler-&gt;handlePacketQueue方法，之前有提到过，这个_handler即为DataService类，可以定位到DataService-&gt;handlePacketQueue方法，在该方法中，根据packet的类型，执行不同的操作：</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> DataService::handlePacketQueue(tbnet::Packet* packet, <span class="keyword">void</span>* args)</div><div class="line">   &#123;</div><div class="line">     <span class="keyword">bool</span> bret = BaseService::handlePacketQueue(packet, args);</div><div class="line">     <span class="keyword">if</span> (bret)</div><div class="line">     &#123;</div><div class="line">       <span class="keyword">int32_t</span> pcode = packet-&gt;getPCode();</div><div class="line">       <span class="keyword">int32_t</span> ret = LOCAL_PACKET == pcode ? TFS_ERROR : TFS_SUCCESS;</div><div class="line">       <span class="keyword">if</span> (TFS_SUCCESS == ret)</div><div class="line">       &#123;</div><div class="line">         <span class="keyword">switch</span> (pcode)</div><div class="line">         &#123;</div><div class="line">           <span class="keyword">case</span> CREATE_FILENAME_MESSAGE:</div><div class="line">             ret = create_file_number(<span class="keyword">dynamic_cast</span>&lt;CreateFilenameMessage*&gt;(packet));</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> WRITE_DATA_MESSAGE:</div><div class="line">             ret = write_data(<span class="keyword">dynamic_cast</span>&lt;WriteDataMessage*&gt;(packet));</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> CLOSE_FILE_MESSAGE:</div><div class="line">             ret = close_write_file(<span class="keyword">dynamic_cast</span>&lt;CloseFileMessage*&gt;(packet));</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">    .........................</div></pre></td></tr></table></figure></p>
<p>我们以创建一个文件为例，此时执行的是create_file_number方法，在该方法中首先调用DataManagement-&gt;create_file方法，执行创建文件的操作；DataManagement专门负责DataServer文件存储各种方法调用，后面再写一篇文章，专门介绍DataServer如何存储文件。</p>
<p>在create_file_number方法中，接下来先定义一个回复给客户端的消息类，并且执行请求消息的reply方法将消息准备回复给客户端。
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RespCreateFilenameMessage* resp_cfn_msg = new RespCreateFilenameMessage()<span class="comment">;</span></div><div class="line">      resp_cfn_msg-&gt;set_block_id(<span class="name">block_id</span>)<span class="comment">;</span></div><div class="line">      resp_cfn_msg-&gt;set_file_id(<span class="name">file_id</span>)<span class="comment">;</span></div><div class="line">      resp_cfn_msg-&gt;set_file_number(<span class="name">file_number</span>)<span class="comment">;</span></div><div class="line">      message-&gt;reply(<span class="name">resp_cfn_msg</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时的message是一个BasePacket的子类，我们定位到BasePacket-&gt;reply方法。</p>
<p>在reply方法中，一开始是先设置回复消息类的一些属性，然后最重要的是调用_connection-&gt;postPacket方法:
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool </span><span class="keyword">bret= </span>connection_-&gt;postPacket(packet)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>在postPacket方法中，我们提取出最重要的两行代码
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将回复客户端的消息packet存入输出队列中</span></div><div class="line"> <span class="variable">_outputQueue</span>.push(packet);</div><div class="line"><span class="comment">// 注册当前连接的可写事件</span></div><div class="line"> <span class="variable">_iocomponent</span>-&gt;enableWrite(<span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<ol start="4">
<li>因为eventLoop的事件监听中，先执行可读事件，紧接着执行可写事件，因此上述注册可写事件之后，即可直接执行可写事件，把消息回复给客户端。</li>
</ol>
<p>可写事件的回调函数是</p>
<p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">rc</span> = ioc-&gt;handleWriteEvent()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>ok，我们定位到TCPComponent-&gt;handleWriteEvent方法，可以看到最主要还是执行TCPConnection-&gt;writedata方法</p>
<p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">rc</span> = _connection-&gt;writeData()<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>在TCPConnection-&gt;writeData方法中，去除输出队列的第一个消息包，然后调用</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ret = _socket-&gt;write(<span class="name">_output</span>.getData(), _output.getDataLen())<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>把消息回复给客户端。</p>
<p>上述就是客户端和DataServer一次完整的交互过程。</p>
<p>如果要按编程模型分类，DataServer属于多线程模型，这种多线程模型又区别于memcache，它是某个线程监听所有套接字，然后将客户端的请求封装成消息包，放入公共队列中；接着由4个工作线程同步地去除消息队列的第一个消息包，并执行；这种模式可缺点就是公共队列要加锁同步，有一定开销；优点就是eventLoop线程可以很快的返回，加快处理客户端的请求，然后把可能消耗大量时间的业务处理放在了工作线程，极大加快系统的响应速度，这点和linux内核中断上下文原理类似。</p>
<p>DataServer整体的执行过程就先分析到这，后续可能会分析tbnet模块和DataServer存储数据过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在实习,接触了tfs文件系统,刚好之前有决定往数据存储方向发展,因此很认真的看了tfs安装部署,以及源码.不得不说,tfs源码真心不是很容易看懂的,因为用了C++很多继承多态,回调机制,地处底层封装等等,我也是花了大概好几天天的时间才把DataServer整体部分看懂了
    
    </summary>
    
      <category term="tfs" scheme="http://luodw.cc/categories/tfs/"/>
    
    
      <category term="tfs" scheme="http://luodw.cc/tags/tfs/"/>
    
  </entry>
  
  <entry>
    <title>学习Linux高性能服务器编程的一些收获</title>
    <link href="http://luodw.cc/2016/04/29/HighLinux/"/>
    <id>http://luodw.cc/2016/04/29/HighLinux/</id>
    <published>2016-04-29T06:41:15.000Z</published>
    <updated>2017-03-16T08:51:34.121Z</updated>
    
    <content type="html"><![CDATA[<p>最近把 <strong>Linux高性能服务器编程</strong> 编程这本书给看了,之前在知乎上看好多人推荐这本书,于是乎在我看了这本书之后,我发现这本书真的很值得看,这本书适合有Linux基础的的人看,特别是看过一些成熟框架的人看,像redis,memcache,最好还有nginx,因为这本书介绍了服务器端开发的一些术语以及模式,如果没看过源码实现,这些理论我觉得会很空洞,即使书本提供了一些示例,看着也会比较吃力.</p>
<p>我这篇文章主要记录在这本书见到的新知识,虽然很多内容在之前有接触过,但是还是有一些内容让我眼前一亮.</p>
<p><img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-shuming.png" alt="Linux高性能服务器编程"></p>
<p>这本书篇章布局也很合理,第一篇介绍了网络的一些基础知识,tcp,ip,dns,arp等等,这些本科的网络课都有学过,但是我强烈推荐好好掌握下tcpdump这个命令(第一次见到这个命令是在unp网络编程),对网络上的的数据包进行截获的包分析工具,例如可以查看网络建立的三次握手数据包收发过程以及四次挥手过程,还可以查看icmp等等,非常方便.当然像route,netstat,ifconfig,ping,traceroute也是需要掌握的,还有和域名解析相关的三个命令dig,host,nslookup.</p>
<p>这本书的第二篇前半部分介绍了网络编程的一些函数调用;中间部分介绍了与网络相关的三种事件,文件io读写事件,定时事件,信号事件以及如何统一这三种事件源;最后一部分介绍了服务器编程中常用的多进程和多线程实现.</p>
<p>这本书的第三篇介绍了高性能服务器优化和检测,主要就是服务器调试,包括资源的调整,gdb调试和压力测试;还有一些和服务器性能相关的命令,例如stat系列,netstat,vmstat,ifstat,mpstat等等.</p>
<p>接下来,我就介绍下这本书中,给我眼前一亮的东西.</p>
<h1>sendfile,splice和tee函数</h1>
<hr>
<p>这三个函数在我没读这本书之前是没有遇到过的,unp网络编程我看了前半部分我也没见着,而且在redis和memcache我也没见着,关键是这三个函数效率很高,避免了用户态和内核态之间的数据拷贝.我经过一番思考之后,是因为服务器端程序都有业务逻辑,必须将数据拷贝至用户态,然后处理数据,最后再将数据拷贝进内核态发送出去,所以这三个函数在服务器上出场率不是很高;</p>
<h2>sendfile函数</h2>
<p>sendfile函数主要是用于在文件服务器上,在两个文件描述符之间直接传递数据(完全在内核中操作),从而避免了内核缓冲区和用户缓冲区之间的数据拷贝,效率很高,这种称为零拷贝.函数接口如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd,<span class="keyword">int</span> in_fd,<span class="keyword">off_t</span>* offset,<span class="keyword">size_t</span> count)</div></pre></td></tr></table></figure></p>
<p>outf_fd为待写入的文件描述符,一般是一个socket,in_fd是一个写入文件描述符,一般是一个磁盘文件描述符,offset是一个输入流的偏移量,如果为空,则从输入流的起始位置开始;count是文件描述符in_fd和out_fd之间传递的字节数.函数成功调用返回传递的字节数,失败返回-1,并设置error值.</p>
<p>sendfile函数使用场景最常见就是发送文件:</p>
<ul>
<li>从磁盘文件读取数据至内核缓冲区,用sendfile函数直接在内核将数据拷贝至socket输出缓冲区,发送出去;</li>
</ul>
<p>平时,我们如果要在网络上传输一个文件,要有以下步奏:</p>
<ol>
<li>打开一个文件fd,将文件的数据首先从磁盘拷贝至内核缓冲区;</li>
<li>然后将内核缓存区数据拷贝至用户态缓冲区;</li>
<li>将用户态缓冲区的数据拷贝至socket输出缓冲区;</li>
<li>将socket缓冲区数据发送出去;</li>
</ol>
<p>但是如果我们使用sendfile函数,则可以省去内核态拷贝至用户态这一过程:</p>
<ol>
<li>打开一个文件fd,将文件的数据首先从磁盘拷贝至内核缓冲区;</li>
<li>将内核哈缓冲区的数据拷贝至socket输出缓冲区;</li>
<li>将socket缓冲区数据发送出去;</li>
</ol>
<h2>splice函数</h2>
<p>这个函数主要是在两个文件描述符上移动数据,其中有一个必须是管道,主要是利用管道的在内核中缓冲区暂存数据,函数接口如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> splice(<span class="keyword">int</span> fd_in,<span class="keyword">loff_t</span>* off_in,in fd_out, <span class="keyword">loff_t</span>* off_out,</div><div class="line">  <span class="keyword">size_t</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</div></pre></td></tr></table></figure></p>
<p>splice用于在两个文件描述符之间移动数据， 也是零拷贝。fd_in参数是待输入描述符。如果它是一个管道文件描述符，则off_in必须设置为NULL；否则off_in表示从输入数据流的何处开读取，此时若为NULL，则从输入数据流的当前偏移位置读入。fd_out/off_out与上述相同，不过是用于输出。len参数指定移动数据的长度。flags参数则控制数据如何移动：</p>
<ul>
<li>SPLICE_F_NONBLOCK：splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞。</li>
<li>SPLICE_F_MORE：告知操作系统内核下一个 splice 系统调用将会有更多的数据传来。</li>
<li>SPLICE_F_MOVE：如果输出是文件，这个值则会使得操作系统内核尝试从输入管道缓冲区直接将数据读入到输出地址空间，这个数据传输过程没有任何数据拷贝操作发生。</li>
</ul>
<p>所以可以想象以下两个使用场景:</p>
<ol>
<li>回显服务器 从socket读入数据,并用splice函数输出到管道的写端;然后从管道的读端用splice函数输出到socket,实现回显服务器.</li>
<li>文件拷贝 从一个磁盘文件读取数据,用splice函数输出到管道的写端;然后从管道的读端用splice函数输出到另外一个磁盘文件.</li>
</ol>
<p>使用方法大概如下:
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这是测试示例主要部分</span></div><div class="line">  int pipefd[2];               </div><div class="line">  <span class="keyword">ret</span> = pipe(pipefd);  <span class="comment">//创建管道  </span></div><div class="line">  <span class="keyword">assert</span>(<span class="keyword">ret</span> != -1);  </div><div class="line">  <span class="comment">//将connfd上的客户端数据定向到管道中  </span></div><div class="line">  <span class="keyword">ret</span> = splice(connfd, NULL, pipefd[1], NULL,  </div><div class="line">                32768, SPLICE_F_MORE | SPLICE_F_MOVE);  </div><div class="line">  <span class="keyword">assert</span>(<span class="keyword">ret</span> != -1);  </div><div class="line">  <span class="comment">//将管道的输出定向到connfd上  </span></div><div class="line">  <span class="keyword">ret</span> = splice(pipefd[0], NULL, connfd, NULL,  </div><div class="line">                32768, SPLICE_F_MORE | SPLICE_F_MOVE);  </div><div class="line">  <span class="keyword">assert</span>(<span class="keyword">ret</span> != -1);</div></pre></td></tr></table></figure></p>
<p>从代码中可以看出没有使用到任何缓冲区,因为数据都是在内核实现了传递或者零传递,只是更改缓冲区的指针.</p>
<h2>tee函数</h2>
<p>tee函数是在两个管道文件描述符之间复制数据,也是零拷贝数据;因为只是从源管道复制到另外管道,所以原管道中保存的数据仍然可以用于后续操作,例如可以重定向到其他文件描述符;函数接口如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> tee(<span class="keyword">int</span> fdin, <span class="keyword">int</span> fdout, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</div></pre></td></tr></table></figure></p>
<p>fdin参数：待读取数据的文件描述符。fdout参数：待写入数据的文件描述符。len参数：表示复制的数据的长度。flags参数：同splice( )函数。fdin和fdout必须都是管道文件描述符。</p>
<p>返回值&gt;0：表示复制的字节数。返回0：表示没有复制任何数据。返回-1：表示失败，并设置errno。</p>
<p>这个函数的使用场景在我认知范围内,估计就是实现tee命令,可以实现将输入的数据输出到标准输出,同时输出到某个文件.基本使用方法如下:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int fd1 = open(<span class="string">"./1.txt"</span>, O_RDONLY);</div><div class="line">int fd2 = open(<span class="string">"./2.txt"</span>, O_RDWR| O_CREAT | O_TRUNC, <span class="number">0666</span>);</div><div class="line">int fd3 = open(<span class="string">"./3.txt"</span>, O_RDWR| O_CREAT | O_TRUNC, <span class="number">0666</span>);</div><div class="line"><span class="comment">/*用于向"./2.txt"输入数据*/</span></div><div class="line">int pipefd2[<span class="number">2</span>];</div><div class="line"><span class="comment">/*用于向"./3.txt"输入数据*/</span></div><div class="line">int pipefd3[<span class="number">2</span>];</div><div class="line">pipe(pipefd2);</div><div class="line">pipe(pipefd3);</div><div class="line"><span class="comment">/*将fd1文件的内容输入管道pipefd2中*/</span></div><div class="line">splice(fd1, NULL, pipefd2[<span class="number">1</span>], NULL, <span class="number">10086</span>, SPLICE_F_MORE);</div><div class="line"><span class="comment">/*将管道pipefd2的内容复制到管道pipefd3中，不消耗管道pipefd2上的数据，管道pipefd2上的数据可以用于后续操作*/</span></div><div class="line">tee(pipefd2[<span class="number">0</span>], pipefd3[<span class="number">1</span>], <span class="number">10086</span>, SPLICE_F_NONBLOCK);</div><div class="line"><span class="comment">/*将管道pipefd2的内容写入fd2文件中*/</span></div><div class="line">splice(pipefd2[<span class="number">0</span>], NULL, fd2, NULL, <span class="number">10086</span>, SPLICE_F_MORE);</div><div class="line"><span class="comment">/*将管道pipefd3的内容写入fd3文件中*/</span></div><div class="line">splice(pipefd3[<span class="number">0</span>], NULL, fd3, NULL, <span class="number">10086</span>, SPLICE_F_MORE);</div></pre></td></tr></table></figure></p>
<p>这个程序是将fd1中的数据重定向到两个磁盘文件,而tee命令是将fd1的数据重定向到fd2和标准输出,即最后一行代码的fd3替换为STDOUT_FILENO.</p>
<p>那有人可能会问,最后一行代码为什么不能pipefd3[0],也就是两次都从管道pipefd2[0]读取数据? 我试着修改pipefd3[0]该pipefd2[0],会造成输出阻塞. 因为splice函数将pipefd2[0]的缓冲区数据消耗了,所以第二次在pipefd2[0]调用splice会因为无数据读入而阻塞.而因为tee不会消耗数据,所以tee函数之后,还可以继续使用splice从相同pipefd2[0]读取数据.</p>
<h1>统一事件源</h1>
<hr>
<p>这个是我看这本书最喜欢的设计,因为它打通了我之前在libevent理解上的阻塞.之前在memcache时,有大概看了下libevent的实现原理,因为时间事件和io读写事件和redis的mainae模块一样,很好理解,但是信号事件我始终想不明白是如何加入到事件处理的?这里又不得不表扬管道了,具体实现后面在说明.</p>
<p>服务器常见的有三种事件类型,IO读写事件,信号事件和时间事件,如果分别去监听这三种事件,那么代码将会非常复杂,而将这三种事件整合在一个事件源中,代码将会更加简洁,而且逻辑非常清楚.libevent就是这么做的.所以这里借助libevent来分析如何将三种事件整合在一起,参考资料为张亮的 <strong>libevent 源码深度剖析</strong>,我上传到我的github,有需要可以下载看<a href="https://github.com/luodw/Material/blob/master/libevent%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90.pdf" target="_blank" rel="external">libevent源码剖析下载地址</a></p>
<p>libevent是一个轻量级的开源高性能网络库,底层支持多种I/O多路复用技术,epoll,poll,dev/poll,select和kqueue等,同时还支持定时器和信号事件;先看下libevent的整体框架
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0041.png" alt="libevent整体框架" title=" "></p>
<p>一开始,应用程序定义事件,可以是io读写事件,信号事件或者时间事件;定义好之后,接下来将事件放在各自的等待链表中;io读写事件和信号事件放在链表中,时间事件放在最小堆中.当io多路复用调用时间超时时,再检查每个事件,看是否就绪,例如可读可写事件是否可读可写,是否产生信号事件以及时间事件是否到期,并将所有就绪的事件放入就绪链表中,最后按优先级执行每个事件的事件处理函数.</p>
<p>了解了libevent执行过程之后,再来分析libevent是如何将三种事件整合在一起的.</p>
<ol>
<li>IO读写事件 因为libevent底层支持多种IO多路复用技术,以epoll为例,当我们定义个IO事件时,将IO事件的fd可读事件注册到epoll调用中;当客户端给服务器发送数据之后,触发服务器可读事件,服务器读取客户端的数据,并且经过业务逻辑处理之后,将数据放入输出缓冲区,并在fd上注册一个可写事件;在下一次事件循环中,检测到可写事件,最后执行可写事件的处理函数将数据发送给客户端.这就是libevent处理IO事件的过程.</li>
<li>时间事件 libevent用最小堆来管理时间事件,每次从堆中取出的时间事件是事件到期时间离当前最近的时间点. 如果epoll每次的超时时间都采用堆的根元素到期时间,那么epoll超时时间到期之后,最小堆的根元素事件肯定也到期了,在处理完IO事件之后,即可处理根元素时间事件,而且必须处理诺干个最小到期时间事件,直到到期时间在当前时间之后. 因为IO事件可能比较耗时,所以除了堆顶时间外,其他时间事件可能也到期了.这样就把时间事件和IO事件整合到一块了.</li>
<li>信号事件 libevent整合信号事件是最出彩的地方, 采用的方法如下:在主线程定义一对管道,然后将管道的读端注册到io多路复用的可读事件;当产生某个信号时,在信号处理函数中,往这对管道的写端写入这个信号的数值,这样即可触发管道读端的可读事件;然后在IO多路复用超时之后,根据不同的信号,执行不同的函数. 这样就可以把信号事件整合在IO事件中.</li>
</ol>
<p>一开始接触管道的时候,并没有发现管道是如此的神器; 我们在linux下遇到最多的就是磁盘文件描述符,socket描述符和管道描述符,而管道描述符属于最灵活,即可以作为其他两者的连接桥梁,如上述的splice函数,还可以作为进程间通信以及将信号事件整合IO事件中等等.</p>
<h1>多进程/多线程并发模式</h1>
<hr>
<p>服务器端编程三大模型,redis的单进程模型,memcache的单进程多线程模型和nginx的多进程模型.由于我看过redis,memcache源码,我对前两者模型很熟悉;而nginx源码我没看过,也没认真区研究nginx,所以对多进程模型也是一知半解; <strong>Linux服务器高性能编程</strong> 举出一个多进程通用模式,看完之后,我对这种模型有了一定的了解.</p>
<h2>多线程并发模式</h2>
<p>书本中列出多线程的两种模式,半同步半异步反应堆模式;下图是该模式的示意图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0042.png" alt="半同步半异步反应堆模式" title=" ">
该模式的主线程负责监听所有socket,包括listenfd和客户端fd.当客户端给服务器发送数据时,主线程将客户端的fd以及客户端的元数据打包成任务对象放入请求队列,然后工作线程同步的从请求队列中获取任务对象,并且处理任务对象逻辑.因为多个线程会从工作队列中争夺任务对象,所以工作队列必须加锁以保持同步.这种模式的客户端是无状态的,因为同一个连接上的不同请求可能会由不同的线程处理.</p>
<p>高性能半同步半异步模式,这也是memcache采用的多线程模式,下图是该模式的示意图:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0052.png" alt="高性能半同步半异步模式">
该模式的主线程主要负责监听listenfd,当有客户端连接到服务器时,主线程accept这个客户端socket,然后将这个socket放入工作线程的libevent的实例中,从此就由这个libevent实例来负责这个客户端socket的事件处理.</p>
<p>那么怎么通知工作线程什么时候去接收这个socket? 这时又是管道的功劳.每个工作线程都定义一对管道,工作线程监听管道的读端; 当有客户端连接时,主线程向管道的写端写入一个字符,触发工作线程的可写事件,这样工作线程就可以执行管道读端的事件处理函数,在函数中接收这个socket并为这个socket注册一个可读事件,从此以后,这个客户端就由这个工作线程监听处理.</p>
<h2>多进程模式</h2>
<p><strong>Linux服务器高性能编程</strong> 书中实现的多进程模型如下图所示:
<img src="http://7xjnip.com1.z0.glb.clouddn.com/ldw-%E9%80%89%E5%8C%BA_0062.png" alt="多进程编程模型">
主进程和工作进程利用管道来进行通信,工作进程注册管道的可读事件; 二者同时监听listanfd,也就是说如果有客户端连接的话,主进程和工作进程都能触发可读事件,也就是惊群现象. 但是主进程并不接收客户端socket,而是通过轮询的方式选择一个工作进程来接收这个客户端,并向这个工作进程管道的写端写入一个标志,触发工作进程的可读事件,在管道读事件的处理函数中,工作进程接收这个客户端. 之后这个客户端与服务器的通信就由这个工作进程负责监听. 所以这种模式的主进程主要起负载均衡作用,所有任务主要是由工作进程负责.</p>
<p>对多进程的理解,必须对fork系统调用以及copy on write机制有足够的理解,因为主进程和工作进程间有共享的部分listenfd也有各自独享部分.</p>
<h1>总结</h1>
<hr>
<p>如果想从事后台开发,了解常用的开发框架是很有必要的,因为对于理解后台软件web服务器或者数据库很有帮助.而且我发现多进程比较适合web服务器,多线程比较适合数据库.因为数据库需要在同一块内存中存储数据,由于多线程并发处理内存数据,而多进程的每个进程内存空间是隔离的,每个进程处理数据导致会导致多份数据;而web数据库主要是接收客户端请求并返回网页,每个客户端对网页的请求相互独立,所以适合多进程模型.</p>
<p>这本书对后台知识讲解归纳的很到位,可以对后台开发有个整体的认识,有linux基础之后,推荐读读...</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把 &lt;strong&gt;Linux高性能服务器编程&lt;/strong&gt; 编程这本书给看了,之前在知乎上看好多人推荐这本书,于是乎在我看了这本书之后,我发现这本书真的很值得看,这本书适合有Linux基础的的人看,特别是看过一些成熟框架的人看,像redis,memcache,最好
    
    </summary>
    
      <category term="linux" scheme="http://luodw.cc/categories/linux/"/>
    
    
      <category term="linux" scheme="http://luodw.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>写MyDB收获的经验和遇到的坑</title>
    <link href="http://luodw.cc/2016/04/09/mydb/"/>
    <id>http://luodw.cc/2016/04/09/mydb/</id>
    <published>2016-04-09T06:52:27.000Z</published>
    <updated>2017-03-16T08:51:34.129Z</updated>
    
    <content type="html"><![CDATA[<p>之前在用C++写NoSQL时,收获了一些经验也遇到了一些坑;今天想总结下这些经验和坑,避免以后重走弯路;mydb github地址为:<a href="https://github.com/luodw/MyDB" target="_blank" rel="external">https://github.com/luodw/MyDB</a></p>
<h1>为什么要写NoSQL?</h1>
<hr>
<p>首先说明下为什么要写这个NoSQL了.因为研一开始,我就给自己定下了三步走计划,操作系统+编程语言+开源软件;因为了所有软件都是用某种编程语言编写,运行在某个操作系统之上,所以先学好操作系统特别关键,我推荐的是linux系统;</p>
<p>操作系统要学哪些了?我当初是从基本的linxu命令开始,书本推荐的是<strong>Linux Shell脚本攻略</strong>和<strong>鸟哥的私房菜</strong>;然后看关于系统调用的书籍,如果是C++后台编程,系统调用是免不了的,入门级看,<strong>LINUX系统编程</strong>,然后才是apue和unp1,2.不推荐直接apue,过来人的忠告.最后看内核的东西,这是必须看的,否则对linux很多东西是理解不透彻.例如平时用的管道,了解管道是怎么实现的吗(pipefs)?fork子进程copy on write机制是什么?动态链接库是怎么实现的等等;理解这些原理,对实际的应用非常有帮助,可以说是得心应手;我推荐的书是<strong>Linux内核设计与实现</strong>,还有本厚的<strong>深入理解Linux内核</strong>,我看了部分.还有<a href="http://duartes.org/gustavo/blog/archives/" target="_blank" rel="external">Gustavo Duarte的博客</a>和<a href="https://pdos.csail.mit.edu/6.828/2008/readings/i386/toc.htm" target="_blank" rel="external">Intel 80386编程手册</a>,内核主要研究的就是文件系统,内存管理(虚拟地址和物理地址的映射非常重要,很多东西的理解都需要这块知识),进程调度,网络模块;</p>
<p>编程语言,我选择的是C/C++;主要是这两门语言接近底层,可以控制内存,可以给用户编程极大的灵活性;就像当初选择linux编程学习而不是window一样;<strong>C++primer</strong> ,<strong>深入理解C++对象模型</strong>和<strong>STL源码剖析</strong>没看完这三本书,真得不敢说自己会C++.我不多说这个,看了都说好.</p>
<p>还有开源软件,我目前有看源码的是leveldb,memcache和redis大部分;我推荐的就是这三个.leveldb整体的设计中包含了很多学习的亮点:内存池arena,缓存的设计,内存屏障,迭代器的设计等等;memcache学习的亮点最重要的就是多线程下的编程模型,当然还有slab内存池;redis这个真推荐,这是我觉得这三个框架里面,代码写的最优雅,思路最清晰,高度模块化；底层用C with class写，而且都是多态类型；事件驱动模块mainae(libevent针对不同平台的封装，代码量太长)，还有主从复制原理，心跳机制等等，看redis收获非常大．</p>
<p>之前在知乎上看到陈硕大哥说的一句话：单进程单线程编程模型的巅峰是redis；单进程多线程编程模型的巅峰是memcache；多进程编程模型的ngnix；说的还是有点道理的；</p>
<p>现在要说下为什么写NoSQL了．因为之前提到的都是看书得到，但是没有实战，很多东西理解的不够透彻；就像没有装个linux双系统来学习，命令很快就忘了．所以我必须将我所学的理论知识，通过实践转化为自己的能力；当然实践会遇到很多问题，这就需要记录下来，避免重蹈覆辙；</p>
<h1>一些经验</h1>
<hr>
<ol>
<li>使用C++11的function类来实现回调函数声明．一开始时，我在纳闷，C++怎么实现回调函数，用函数指针吧，感觉没脱离C的影子；用函数对象吧，感觉挺麻烦的，啥事都要写个类，所以最后选择了C++11function类；而且function类可以结合bind函数以及lambda函数非常灵活实用，我在给事件注册回调函数时，使用的就是lambda函数注册．</li>
<li>使用nocopyable类来实现避免函数复制，这在**Effective C++**中也有提及，就是定义一个类，将复制构造函数和赋值操作符声明为private，其他类继承nocopyable即可实现避免函数复制；在C++11中可以使用=delete来实现类避免复制．</li>
<li>使用C++ string而不是c字符数组．因为string使用的是copy on write机制，每次复制时，只是简单的复制成员变量，并没有重新开辟一块内存，而是当要更新字符串时，才重新分配内存，达到复制时间复杂度为常数时间．而且不用担心内存泄露(暂时没考虑return或者sigjmp造成的对象没有析构问题，即使有还可以使用智能指针)．相反，使用c字符数组时时都要想着内存有没释放，啥时释放；
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clients[connfd].outbuf=<span class="type">string</span>(<span class="string">"usage:del key\r<span class="subst">\n</span>"</span>);</div></pre></td></tr></table></figure></li>
</ol>
<p>单看这行代码，等号右边生成一个临时string对象，然后左边的字符串调用赋值操作符，用右边临时字符串给自己赋值．而output并没有为字符串重新开辟内存，而是接管了临时string对象的字符串指针，临时string在这句代码之后就被回收了．而且之后每次给clients[connfd].outbuf赋值时，会先析构原先的字符串，然后才是指向新的字符串，所以不存在内存泄露的问题．</p>
<ol start="4">
<li>避免vector类型复制(赋值)．当vector存储大量拥有nontrival构造函数对象时，如果vector进行复制或赋值，那么每个对象都要执行构造函数生成对象，将会是非常耗时．所以一般采取的办法是先生成一个新的空的vector，然后新的空的vector调用swap函数与旧的vector进行交换，这样就可以避免新的vector存储对象执行构造函数，也可避免旧的vector存储的对象执行析构函数．如果是情况一个vector，也很适合用swap函数；</li>
<li>在不需要排序的情况，尽量使用unordered_map，而不是map．因为unordered_map底层是用哈希表实现的，负载因子和哈希函数设计的好，则可实现查找操作在常数时间以内，而map底层是红黑树实现的，查找操作则需要O(logn)．</li>
<li>STL函数库和lambda函数二者的集合，代码更加简练；原先为了输出一个vector中所有的变量，需要写一个输出仿函数
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> output</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>&#125;;</div><div class="line">    for_each(v.begin(),v.end(),output());</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
<p>但是C++11引入lambda函数之后，代码如下:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>&#125;;</div><div class="line">    for_each(v.begin(),v.end(),[](<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有很多太细微的经验没列出来，而且我发现我在使用过程中，C++11真的带来了很多优秀的特性，给代码编写带来极大的便利．</p>
<h1>一些坑</h1>
<hr>
<p>说是一些坑，但是我映像最深的还是segmentation fault (core dumped)，太可怕了，因为其他很多系统调用返回的错误，可以通过函数的返回值判断错误的类型，但是出现段错误之后，就直接退出了，经常是不好看出到底是哪行出现问题；我在写MyDB过程中，出现最多的就是段错误，不外乎就是内存访问错误，包括没有给数组分配内存，就访问更新数组元素；访问越界数组元素等等；</p>
<p>数组没有分配内存，程序访问数组元素；例如原先我在定义Client这个结构时，没有给参数数组分配内存，因为后面在分解参数时，需要将每个参数赋给参数数组，就必须访问参数数组，这样就出现段错误了．
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Client</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> fd;<span class="comment">//这个客户端的fd</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> outbuf;<span class="comment">//存储回复客户端的数据</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;<span class="comment">//存储用户输入的命令</span></div><div class="line">    &#125;;<span class="comment">//客户端结构体</span></div></pre></td></tr></table></figure></p>
<p>因为目前暂时还不需要客户端对象执行函数，所以暂时使用了struct．结构体中的args只是调用默认构造函数，此时不含有任何对象；当解析出各个命令参数，使用索引下标存储时，则出现了段错误,如下：
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  mydb ./mydb</div><div class="line">2016-04-10 15:47:16 360 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=240 [TRACE] Ionet: mydb init successfully!</div><div class="line">2016-04-10 15:47:18 360 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=173 [TRACE] Ionet: Accept a clientfd=5</div><div class="line">[1]    360 segmentation fault (core dumped)  ./mydb</div></pre></td></tr></table></figure></p>
<p>而且错误提示很不友好，只是说明了出现了段错误，并没有具体指出哪出现问题了．所以调试代码也是一项能力，我原本对于小型的程序习惯用输出即可解决，但是对于大点的程序，逻辑稍微复杂点，输出调试就没那么简单了，所以这时就必须使用gdb了．</p>
<p>我用gdb运行程序，然后出现错误之后，输出如下:
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(gdb) r</div><div class="line">Starting <span class="string">program:</span> <span class="regexp">/home/</span>charles<span class="regexp">/mydir/</span>mywork<span class="regexp">/mydb/</span>mydb </div><div class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">59</span> <span class="number">2638</span> .<span class="regexp">/net/</span>Ionet.cc line=<span class="number">240</span> [TRACE] <span class="string">Ionet:</span> mydb init successfully!</div><div class="line"><span class="number">2016</span><span class="number">-04</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">05</span> <span class="number">2638</span> .<span class="regexp">/net/</span>Ionet.cc line=<span class="number">173</span> [TRACE] <span class="string">Ionet:</span> Accept a clientfd=<span class="number">5</span></div><div class="line"></div><div class="line">Program received signal SIGSEGV, Segmentation fault.</div><div class="line"><span class="number">0x00007ffff7b8f7e0</span> <span class="keyword">in</span> <span class="string">std:</span>:<span class="string">string:</span>:swap(<span class="string">std:</span>:string&amp;) () from <span class="regexp">/usr/</span>lib<span class="regexp">/x86_64-linux-gnu/</span>libstdc++.so<span class="number">.6</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>看吧，这样虽然看出来是什么段错误，调用std::string::swap(std::string&amp;)函数出现了错误，我们可以猜测是由于std::string对象在调用swap函数时，原对象没有分配内存，但是从gdb目前提示的错误还看不出问题具体出在哪．</p>
<p>所以这时就需要用到where或bt命令，输出调用的函数栈，可以看出问题出现在哪个函数调用上，如下:
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(gdb) bt</div><div class="line">#<span class="number">0</span>  <span class="number">0x00007ffff7b8f7e0</span> <span class="keyword">in</span> std::string::swap(std::string&amp;) () <span class="keyword">from</span> /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x00007ffff7b8f829</span> <span class="keyword">in</span> std::string::operator=(std::string&amp;&amp;) ()</div><div class="line">   <span class="keyword">from</span> /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x00000000004101a5</span> <span class="keyword">in</span> ionet::Parse::parseArgs(ionet::Client&amp;) ()</div><div class="line">#<span class="number">3</span>  <span class="number">0x0000000000408b13</span> <span class="keyword">in</span> ionet::Ionet::FdHandler(int) ()</div><div class="line">#<span class="number">4</span>  <span class="number">0x000000000040bcb1</span> <span class="keyword">in</span> ionet::Ionet::FdAccept(int)::$_2::operator()(int) const ()</div><div class="line">#<span class="number">5</span>  <span class="number">0x000000000040ba33</span> <span class="keyword">in</span> std::_Function_handler&lt;void (int), ionet::Ionet::FdAccept(int)::$_2&gt;::_M_invoke(std::_Any_data const&amp;, int) ()</div><div class="line">#<span class="number">6</span>  <span class="number">0x000000000040821c</span> <span class="keyword">in</span> std::function&lt;void (int)&gt;::operator()(int) const ()</div><div class="line">#<span class="number">7</span>  <span class="number">0x000000000040808a</span> <span class="keyword">in</span> ionet::Fdevent::handler(int) ()</div><div class="line">#<span class="number">8</span>  <span class="number">0x0000000000404751</span> <span class="keyword">in</span> ionet::EventLoop::startLoop() ()</div><div class="line">#<span class="number">9</span>  <span class="number">0x000000000040b53e</span> <span class="keyword">in</span> ionet::Ionet::run() ()</div><div class="line">#<span class="number">10</span> <span class="number">0x0000000000402670</span> <span class="keyword">in</span> main ()</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>这个输出从下到上是从最开始的main函数到出现问题的函数的函数栈．第0和第1个都是标准库string的成员函数，第2个才是我自己定义的函数，这样我就定位到错误出现的函数，我们定位到Parse::parseArgs这个函数
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void <span class="keyword">Parse</span>::parseArgs(Client &amp;client)</div><div class="line">    &#123;</div><div class="line">        int i=0; <span class="keyword">char</span> *q=<span class="keyword">query</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* delim=<span class="string">" "</span>;</div><div class="line">        <span class="keyword">char</span> *p=strtok(q,delim);</div><div class="line">        client.<span class="keyword">args</span>[i++]=<span class="built_in">string</span>(p);</div><div class="line">        <span class="comment">//strtok函数第二次调用时,必须传递NULL值,否则会无限迭代</span></div><div class="line">        <span class="keyword">while</span>((p=strtok(NULL,delim))!=NULL)</div><div class="line">        &#123;</div><div class="line">            client.<span class="keyword">args</span>[i++]=<span class="built_in">string</span>(p);</div><div class="line">        &#125;</div><div class="line">        i--;</div><div class="line">        size_t pos=client.<span class="keyword">args</span>[i].find(<span class="built_in">string</span>(<span class="string">"\r\n"</span>));</div><div class="line">        client.<span class="keyword">args</span>[i].<span class="keyword">erase</span>(pos);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>有之前的输出，我们知道错误是字符串的赋值错误，而在这个函数内部，就是给client.args参数数组赋值错误，所以我们可以把错误定位在这个client.args这个数组上，再结合段错误的一些原因，即可分析出错误的原因．</p>
<p>如果还是不知道错误，可以在这函数内部采用输出调试或者定点单步调试．</p>
<p>定点调试可以先定位到parse.cc这个文件
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.<span class="built_in">args</span>[i++]=<span class="built_in">string</span>(p);</div></pre></td></tr></table></figure></p>
<p>然后执行程序到此，可以输出client.args[i++]这个变量，看看得出什么结果．
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(gdb) b <span class="keyword">parse</span>.<span class="keyword">cc</span>:27 <span class="comment">//定位到赋值语句位置</span></div><div class="line">Breakpoint 1 at 0x40d9e1: <span class="keyword">file</span> ./util/<span class="keyword">parse</span>.<span class="keyword">cc</span>, <span class="keyword">line</span> 27.</div><div class="line">(gdb) <span class="built_in">r</span></div><div class="line">Starting <span class="keyword">program</span>: /home/charles/mydir/mywork/mydb/mydb </div><div class="line">2016-04-10 16:35:03 14443 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=240 [TRACE] Ionet: mydb init successfully!</div><div class="line">2016-04-10 16:35:07 14443 ./<span class="keyword">net</span>/Ionet.<span class="keyword">cc</span> <span class="keyword">line</span>=173 [TRACE] Ionet: Accept a clientfd=5</div><div class="line"></div><div class="line">Breakpoint 1, ionet::<span class="keyword">Parse</span>::parseArgs (this=0x7fffffffdd68, client=...) at ./util/<span class="keyword">parse</span>.<span class="keyword">cc</span>:27</div><div class="line">27	        client.<span class="keyword">args</span>[i++]=<span class="built_in">string</span>(p);</div><div class="line">(gdb)  p  client.<span class="keyword">args</span>[i++]</div><div class="line"><span class="variable">$1</span> = &lt;<span class="keyword">error</span> reading variable: Cannot access <span class="keyword">memory</span> at address 0x0&gt;</div><div class="line">(gdb) p client</div><div class="line"><span class="variable">$2</span> = (ionet::Client &amp;) @0x6183b0: &#123;fd = 5, outbuf = <span class="string">""</span>, <span class="keyword">args</span> = std::vector of length 0, capacity 0&#125;</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>当输出client.args[i++]时，输出的错误，没看过vector源码可能理解不是很清楚，我把源码黏贴如下:
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">const_reference</span> <span class="selector-tag">operator</span><span class="selector-attr">[]</span>(size_type n) <span class="selector-tag">const</span> &#123; <span class="selector-tag">return</span> *(begin() + n); &#125;</div><div class="line"><span class="comment">//========================================================================</span></div><div class="line"><span class="selector-tag">vector</span>() : <span class="selector-tag">start</span>(<span class="number">0</span>), <span class="selector-tag">finish</span>(<span class="number">0</span>), <span class="selector-tag">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>当调用clients.args[i++]时，会调用重载下标操作符函数，在重载下标函数内部，返回begin()迭代器向前移动n个位置元素的引用，而begin()返回是start迭代器，这个迭代器在没有参数的默认构造函数中初始为0，所以当输出client.args[i++]即输出start指向的值，就是位置0x0．</p>
<p>从输出client也可以看出args长度为0．</p>
<p>其他段错误也可以通过这种方法找出问题所在；如何调试段错误也是我写这篇文章最重要的原因，因为之前我对这不是很在行，所以需要记录下这过程，今后再出现段错误，可以快速解决问题．</p>
<h1>聊聊gdb原理</h1>
<hr>
<p>之前实习面试时，一位面试官问了我gdb设断点的原理，我一下懵了，因为我之前就是使用，没想过这个问题，这激发我极大的好奇心，我通过查找资料，发现gdb的实现主要是靠ptrace这个函数．简单的说gdb ./mydb时，会在gdb程序中fork和execl(./mydb)这个子进程，当我们设置断点时，其实是将原先设置断点处的指令替换为int 3指令，这样当进程运行到断点处时，会给gdb进程发送SIGTRAP信号，子进程则阻塞；父进程接收到此信号之后，则根据用户的输入，做出相应的回答．</p>
<p>ptrace这个系统调用还可以用来输出程序调用的系统调用，strace命令底层使用的就是这个系统调用．</p>
<p>ptrace还可以用来输出函数栈，pstack命令底层就是使用pstrace函数实现的，我之前还一直以为是backtrace函数实现的．但是回过头来想想，backtrace只是个函数，他必须嵌入到程序中才能输出函数栈，所以pstack底层不可能是backtrace函数实现．</p>
<p>理解了gdb的实现原理，再来使用gdb，会更加的得心应手...</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在用C++写NoSQL时,收获了一些经验也遇到了一些坑;今天想总结下这些经验和坑,避免以后重走弯路;mydb github地址为:&lt;a href=&quot;https://github.com/luodw/MyDB&quot; target=&quot;_blank&quot; rel=&quot;external&quot;
    
    </summary>
    
      <category term="mydb" scheme="http://luodw.cc/categories/mydb/"/>
    
    
      <category term="mydb" scheme="http://luodw.cc/tags/mydb/"/>
    
  </entry>
  
  <entry>
    <title>innodb_ruby工具使用</title>
    <link href="http://luodw.cc/2016/03/15/innodb03/"/>
    <id>http://luodw.cc/2016/03/15/innodb03/</id>
    <published>2016-03-15T11:28:28.000Z</published>
    <updated>2017-03-16T08:51:34.125Z</updated>
    
    <content type="html"><![CDATA[<p>之前跟着Jeremy Cole的博客分析了单表空间的文件布局,这篇文章分析下如何使用innodb_ruby这个工具来分析.ibd表空间文件.</p>
<p>这个工具,可以自行到Jeremy Cole的github下载,他的github也有教如何安装使用.</p>
<h1>分析一个最小空表格</h1>
<hr>
<p>我在MySQL5.7.11建立了一个只有一个主键的表,然后没有插入任何数据,也就是说是一个空表格.我们可以使用space-page-type-regions模式来查看这个表空间的初始页类型
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-page-type-regions</div><div class="line">start       end         count       type                </div><div class="line"><span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           FSP_HDR             </div><div class="line"><span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>           IBUF_BITMAP         </div><div class="line"><span class="number">2</span>           <span class="number">2</span>           <span class="number">1</span>           INODE               </div><div class="line"><span class="number">3</span>           <span class="number">3</span>           <span class="number">1</span>           INDEX               </div><div class="line"><span class="number">4</span>           <span class="number">5</span>           <span class="number">2</span>           FREE (ALLOCATED)</div></pre></td></tr></table></figure></p>
<p>由这个输出可以看出,这个表分配了ibd文件的标准页:FSP_HDR,IBUF_BITMAP,INODE和空的root索引页.还有两个没有被使用的free页.</p>
<p>space-lists模式可以用来输出extent描述符和inode链表信息
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">free_frag           <span class="number">1</span>           <span class="number">0</span>           <span class="number">158</span>         <span class="number">0</span>           <span class="number">158</span>         </div><div class="line">full_frag           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full_inodes         <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">free_inodes         <span class="number">1</span>           <span class="number">2</span>           <span class="number">38</span>          <span class="number">2</span>           <span class="number">38</span></div></pre></td></tr></table></figure></p>
<p>初始化时,只有free_frag有extent描述符项,而且只有一个,即第一个extent,此时第一个extent为fragment extent,即该extent内的页是单独分配的.而且也只有一个INODE页.</p>
<p>free_frag里的内容可以使用space-list-iterate模式输出('#'表示页已被使用,'.'表示页是free)
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -L free_frag space-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">0</span>           ####..</div></pre></td></tr></table></figure></p>
<p>所有索引段的内存信息可以使用space-indexes模式来输出;
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-indexes</div><div class="line">id          name                            root        fseg        used        allocated   fill_factor </div><div class="line"><span class="number">409</span>                                         <span class="number">3</span>           internal    <span class="number">1</span>           <span class="number">1</span>           <span class="number">100.00</span>%     </div><div class="line"><span class="number">409</span>                                         <span class="number">3</span>           leaf        <span class="number">0</span>           <span class="number">0</span>           <span class="number">0.00</span>%</div></pre></td></tr></table></figure></p>
<p>因为只有一个主键索引,所以只有两个段internal和leaf.又因为是空数据库,所以只有一个空的root页,没有叶子节点页.</p>
<p>接下来可以使用index-fseg-internal-lists模式来输出主键索引的内部节点extent信息以及使用index-fseg-leaf-lists模式来输出主键索引叶子节点extent信息.
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-leaf-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>因为是一个空表,所以任何链表都为空.那么有人可能会问,主键的root页在哪了?其实这root就是在frag page里面.因为每个段优先使用INODE entry优先使用32个frag page,这32个页全部使用之后,才会申请整个extent.</p>
<p>我们可以用index-fseg-internal-frag-pages模式来分析这个段零碎页的使用情况:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-frag-pages</div><div class="line">page        index   level   data    free    records </div><div class="line"><span class="number">3</span>           <span class="number">409</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">16252</span>   <span class="number">0</span>     </div><div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-leaf-frag-pages</div><div class="line">page        index   level   data    free    records</div></pre></td></tr></table></figure></p>
<p>由上述输出可以看出,内部索引段使用了一个零碎页,而叶子段没有使用任何一个页.</p>
<h1>拥有一百万条记录的表</h1>
<hr>
<p>接下来,我向之前的空表插入100万条记录,插入记录时必须用事务,而且等全部插入之后才commit,否则会很慢.</p>
<p>我们先来看下space-page-type-regions的输出
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-page-type-regions</div><div class="line">start       end         count       type                </div><div class="line"><span class="number">0</span>           <span class="number">0</span>           <span class="number">1</span>           FSP_HDR             </div><div class="line"><span class="number">1</span>           <span class="number">1</span>           <span class="number">1</span>           IBUF_BITMAP         </div><div class="line"><span class="number">2</span>           <span class="number">2</span>           <span class="number">1</span>           INODE               </div><div class="line"><span class="number">3</span>           <span class="number">37</span>          <span class="number">35</span>          INDEX               </div><div class="line"><span class="number">38</span>          <span class="number">63</span>          <span class="number">26</span>          FREE (ALLOCATED)    </div><div class="line"><span class="number">64</span>          <span class="number">1511</span>        <span class="number">1448</span>        INDEX               </div><div class="line"><span class="number">1512</span>        <span class="number">1663</span>        <span class="number">152</span>         FREE (ALLOCATED)</div></pre></td></tr></table></figure></p>
<p>我的这个输出和Jeremy Cole输出不一样,可能是5.7对底层页的使用进行了优化,没有那么多碎片.这100万条记录总共使用了35+1448个页;因为这个表的B+树有三层,一个root页,两个中间节点,其他都是叶子节点.所以对于内部节点段使用了3个零碎页,而叶子节点使用了32个零碎页,总共35个零碎页.剩下的26个页等需要时才会被使用.</p>
<p>我们再看下这个表空间的链表情况;
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">2</span>           <span class="number">0</span>           <span class="number">1118</span>        <span class="number">0</span>           <span class="number">1158</span>        </div><div class="line">free_frag           <span class="number">1</span>           <span class="number">0</span>           <span class="number">158</span>         <span class="number">0</span>           <span class="number">158</span>         </div><div class="line">full_frag           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full_inodes         <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">free_inodes         <span class="number">1</span>           <span class="number">2</span>           <span class="number">38</span>          <span class="number">2</span>           <span class="number">38</span></div></pre></td></tr></table></figure></p>
<p>可以看到还是只使用了一个fragment extent,以及分配了两个free extent.可以用space-list-iterate来显示是哪两个extents被分配free
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -L free space-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">1536</span>        ................................................................</div><div class="line"><span class="number">1600</span>        ................................................................</div></pre></td></tr></table></figure></p>
<p>我们可以看到最后之前space-page-type-regions最后输出的两个extent是free,完全没有被使用.同时可以使用space-list-iterate来输出free-frag信息
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -L free_frag space-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">0</span>           ######################################..........................</div></pre></td></tr></table></figure></p>
<p>接下来,在来看下这两个段各自使用页信息:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd space-indexes</div><div class="line">id          name                            root        fseg        used        allocated   fill_factor </div><div class="line"><span class="number">410</span>                                         <span class="number">3</span>           internal    <span class="number">3</span>           <span class="number">3</span>           <span class="number">100.00</span>%     </div><div class="line"><span class="number">410</span>                                         <span class="number">3</span>           leaf        <span class="number">1480</span>        <span class="number">1504</span>        <span class="number">98.40</span>%</div></pre></td></tr></table></figure></p>
<p>可以看出来,内部节点有三个,即root页以及两个中间页.最后叶子节点页分配了1504个页,使用了1480个页.</p>
<p>因为内部节点段只使用了3个页,所以并没有分配任何的extent,而是只使用了3个零碎页
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">full                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>      </div><div class="line"><span class="comment">//-----------------------------------------------------------------------------------------------------------</span></div><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-internal-frag-pages</div><div class="line">page        index   level   data    free    records </div><div class="line"><span class="number">3</span>           <span class="number">410</span>     <span class="number">2</span>       <span class="number">26</span>      <span class="number">16226</span>   <span class="number">2</span>       </div><div class="line"><span class="number">36</span>          <span class="number">410</span>     <span class="number">1</span>       <span class="number">7813</span>    <span class="number">8139</span>    <span class="number">601</span>     </div><div class="line"><span class="number">37</span>          <span class="number">410</span>     <span class="number">1</span>       <span class="number">11427</span>   <span class="number">4389</span>    <span class="number">879</span></div></pre></td></tr></table></figure></p>
<p>可以看出root页在page 3,中间两个页分别在page 36和page 37. 两个中间节点的子节点即为叶子节点的数量601+879=1480,等于上述space-indexes的输出.</p>
<p>而叶子节点不仅使用了32个零碎页,还使用了22个extents和一个未满的extent,如下:
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> index-fseg-leaf-lists</div><div class="line">name                length      f_page      f_offset    l_page      l_offset    </div><div class="line">free                <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           <span class="number">0</span>           </div><div class="line">not_full            <span class="number">1</span>           <span class="number">0</span>           <span class="number">1078</span>        <span class="number">0</span>           <span class="number">1078</span>        </div><div class="line">full                <span class="number">22</span>          <span class="number">0</span>           <span class="number">198</span>         <span class="number">0</span>           <span class="number">1038</span></div></pre></td></tr></table></figure></p>
<p>我们还可以迭代输出这三个链表的每一个,例如输出未满的链表:
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># innodb_space -f /var/lib/mysql/test/t.ibd -p <span class="number">3</span> -L not_full index-fseg-leaf-list-iterate</div><div class="line">start_page  page_used_bitmap                                                </div><div class="line"><span class="number">1472</span>        ########################################........................</div></pre></td></tr></table></figure></p>
<p>这里只是跟着Jeremy简单的使用innodb_ruby工具,还有一些使用方法,这里就没列出了,在我的github上也有一个简要的教程.自己亲自用innodb_ruby来输出ibd文件,可以加深对文件结构的理解记忆.</p>
<p>下篇文章将会分析ibd文件中,最重要的索引页结构,记着,在ibd文件中,存储索引和数据的页都是索引页.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前跟着Jeremy Cole的博客分析了单表空间的文件布局,这篇文章分析下如何使用innodb_ruby这个工具来分析.ibd表空间文件.&lt;/p&gt;
&lt;p&gt;这个工具,可以自行到Jeremy Cole的github下载,他的github也有教如何安装使用.&lt;/p&gt;
&lt;h1&gt;分
    
    </summary>
    
      <category term="innodb" scheme="http://luodw.cc/categories/innodb/"/>
    
    
      <category term="innodb" scheme="http://luodw.cc/tags/innodb/"/>
    
      <category term="innodb_ruby" scheme="http://luodw.cc/tags/innodb-ruby/"/>
    
  </entry>
  
</feed>
